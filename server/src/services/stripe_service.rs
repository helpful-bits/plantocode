//! Customer-facing payment notifications (receipts/invoices) are handled by Stripe.
//! Manual purchase emails are intentionally disabled to avoid duplicates and reduce operational dependencies.
// STRIPE API IDEMPOTENCY REQUIREMENTS:
//
// All mutating Stripe API operations (POST requests) MUST include an `Idempotency-Key` header
// to ensure safe retry behavior and prevent duplicate operations in case of network failures
// or application restarts.
//
// IDEMPOTENCY KEY REQUIREMENTS:
// 1. Each distinct operation MUST have a unique idempotency key
// 2. Keys should be UUIDs or similar unique identifiers
// 3. Keys MUST be reused for retries of the same logical operation
// 4. Keys should NOT be reused across different operations
// 5. Idempotency keys expire after 24 hours in Stripe's system
//
// CURRENT IMPLEMENTATION STATUS:
// - ✅ This service now implements idempotency key handling
// - ✅ All mutating methods accept an idempotency_key parameter
// - ✅ BillingService generates unique UUIDs for each operation
// - Note: PaymentMethod::detach may need library-specific idempotency handling
//
// RECOMMENDED IMPLEMENTATION:
// ```rust
// pub async fn create_customer_with_idempotency(
//     &self,
//     idempotency_key: &str,  // Add this parameter
//     user_id: &Uuid,
//     email: &str,
//     name: Option<&str>
// ) -> Result<Customer, StripeServiceError> {
//     // Set idempotency key in request headers
//     // self.client.set_idempotency_key(idempotency_key);
//     // ... rest of implementation
// }
// ```
//
// CRITICAL FOR BILLING OPERATIONS:
// - Payment processing operations MUST be idempotent to prevent double charges
// - Credit purchase operations MUST be idempotent to prevent duplicate billing
// - Usage record reporting MUST be idempotent to prevent double billing
//
use crate::stripe_types::{self, *};
use crate::utils::admin_alerting;
use reqwest::header::{HeaderMap, HeaderValue, AUTHORIZATION, CONTENT_TYPE};
use chrono::{DateTime, Utc};
use hmac::{Hmac, Mac};
use sha2::Sha256;
use std::collections::HashMap;
use uuid::Uuid;
use log::{debug, error, info, warn};
use hex;
use subtle::ConstantTimeEq;

#[derive(Debug, thiserror::Error)]
pub enum StripeServiceError {
    #[error("Stripe API error: {0}")]
    StripeApi(String),
    #[error("Webhook verification failed: {0}")]
    WebhookVerification(String),
    #[error("Invalid configuration: {0}")]
    Configuration(String),
    #[error("Payment processing error: {0}")]
    PaymentProcessing(String),
    #[error("Credit billing error: {0}")]
    CreditBilling(String),
}

type HmacSha256 = Hmac<Sha256>;


// Stripe Customer Portal Configuration Required:
// 1. Enable payment method management
// 2. Enable credit purchase and invoicing
// 3. Enable payment method updates
// 4. Enable invoice access
// 5. Set return URL to app billing page
// 6. Configure business branding

/// Stripe service for handling payment processing and credit-based billing
/// 
/// IMPORTANT: This service implements Stripe's idempotency requirements.
/// All mutating operations include idempotency keys to prevent:
/// - Duplicate payments
/// - Duplicate credit purchases  
/// - Duplicate usage records
/// - Data inconsistencies during retries
/// 
/// Idempotency keys are generated by the calling service (BillingService) as UUIDs.
#[derive(Clone)]
pub struct StripeService {
    webhook_secret: String,
    publishable_key: String,
    secret_key: String,
    http_client: reqwest::Client,
}

impl std::fmt::Debug for StripeService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("StripeService")
            .field("webhook_secret", &"<redacted>")
            .field("publishable_key", &self.publishable_key)
            .finish()
    }
}

impl StripeService {
    pub fn new(secret_key: String, webhook_secret: String, publishable_key: String) -> Self {
        let http_client = reqwest::Client::new();
        
        Self {
            webhook_secret,
            publishable_key,
            secret_key,
            http_client,
        }
    }

    pub fn get_publishable_key(&self) -> &str {
        &self.publishable_key
    }

    /// Make a direct authenticated request to Stripe API with idempotency key
    async fn make_stripe_request_with_idempotency(
        &self,
        method: reqwest::Method,
        endpoint: &str,
        body: Option<serde_json::Value>,
        idempotency_key: Option<&str>,
    ) -> Result<serde_json::Value, StripeServiceError> {
        let url = format!("https://api.stripe.com/v1/{}", endpoint);
        
        let mut headers = HeaderMap::new();
        headers.insert(AUTHORIZATION, HeaderValue::from_str(&format!("Bearer {}", self.secret_key))
            .map_err(|_| StripeServiceError::Configuration("Invalid secret key format".to_string()))?);
        headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/x-www-form-urlencoded"));
        
        // Only add idempotency key for POST requests
        if method == reqwest::Method::POST {
            if let Some(key) = idempotency_key {
                headers.insert("Idempotency-Key", HeaderValue::from_str(key)
                    .map_err(|_| StripeServiceError::Configuration("Invalid idempotency key format".to_string()))?);
            }
        }
        
        // Use configurable Stripe API version with fallback to latest stable version
        let stripe_version = std::env::var("STRIPE_API_VERSION")
            .unwrap_or_else(|_| "2024-06-20".to_string());
        headers.insert("Stripe-Version", HeaderValue::from_str(&stripe_version)
            .map_err(|_| StripeServiceError::Configuration("Invalid Stripe version format".to_string()))?);
        
        let mut request = self.http_client.request(method, &url).headers(headers);
        
        if let Some(body_data) = body {
            // Convert JSON to form-encoded data for Stripe API
            let form_data = self.json_to_form_data(body_data)?;
            request = request.body(form_data);
        }
        
        let response = request.send().await
            .map_err(|e| StripeServiceError::Configuration(format!("HTTP request failed: {}", e)))?;
        
        if !response.status().is_success() {
            let status = response.status();
            let error_text = response.text().await
                .unwrap_or_else(|_| "Unknown error".to_string());
            
            // Try to parse Stripe error response for better error messages
            if let Ok(error_json) = serde_json::from_str::<serde_json::Value>(&error_text) {
                if let Some(error_obj) = error_json.get("error") {
                    let error_type = error_obj.get("type")
                        .and_then(|t| t.as_str())
                        .unwrap_or("unknown");
                    let error_message = error_obj.get("message")
                        .and_then(|m| m.as_str())
                        .unwrap_or(&error_text);
                    let error_code = error_obj.get("code")
                        .and_then(|c| c.as_str())
                        .unwrap_or("");
                    
                    error!("Stripe API error - Status: {}, Type: {}, Code: {}, Message: {}", 
                           status, error_type, error_code, error_message);
                    
                    // Return appropriate error type based on the error
                    return match error_type {
                        "card_error" | "payment_method_error" => {
                            Err(StripeServiceError::PaymentProcessing(error_message.to_string()))
                        }
                        "invalid_request_error" | "api_error" => {
                            Err(StripeServiceError::StripeApi(format!("{}: {}", error_code, error_message)))
                        }
                        _ => {
                            Err(StripeServiceError::Configuration(format!("Stripe API error: {}", error_message)))
                        }
                    };
                }
            }
            
            error!("Stripe API error - Status: {}, Response: {}", status, error_text);
            return Err(StripeServiceError::StripeApi(format!("HTTP {}: {}", status, error_text)));
        }
        
        let response_json: serde_json::Value = response.json().await
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse response: {}", e)))?;
        
        Ok(response_json)
    }
    
    /// Convert JSON object to form-encoded data for Stripe API
    fn json_to_form_data(&self, json: serde_json::Value) -> Result<String, StripeServiceError> {
        fn flatten_object(obj: &serde_json::Value, prefix: &str, params: &mut Vec<(String, String)>) {
            match obj {
                serde_json::Value::Object(map) => {
                    for (key, value) in map {
                        let new_key = if prefix.is_empty() {
                            key.clone()
                        } else {
                            format!("{}[{}]", prefix, key)
                        };
                        flatten_object(value, &new_key, params);
                    }
                }
                serde_json::Value::Array(arr) => {
                    for (index, value) in arr.iter().enumerate() {
                        let new_key = format!("{}[{}]", prefix, index);
                        flatten_object(value, &new_key, params);
                    }
                }
                value => {
                    let string_value = match value {
                        serde_json::Value::String(s) => s.clone(),
                        serde_json::Value::Number(n) => n.to_string(),
                        serde_json::Value::Bool(b) => b.to_string(),
                        serde_json::Value::Null => return,
                        _ => return,
                    };
                    params.push((prefix.to_string(), string_value));
                }
            }
        }
        
        let mut params = Vec::new();
        flatten_object(&json, "", &mut params);
        
        let form_string = params
            .into_iter()
            .map(|(k, v)| format!("{}={}", urlencoding::encode(&k), urlencoding::encode(&v)))
            .collect::<Vec<_>>()
            .join("&");
        
        Ok(form_string)
    }

    /// Verify webhook signature with timestamp validation
    pub fn verify_webhook_signature(
        &self,
        payload: &str,
        signature: &str,
    ) -> Result<(), StripeServiceError> {
        let elements: Vec<&str> = signature.split(',').collect();
        let mut timestamp = "";
        let mut signatures = Vec::new();

        for element in elements {
            if let Some(t) = element.strip_prefix("t=") {
                timestamp = t;
            } else if let Some(s) = element.strip_prefix("v1=") {
                signatures.push(s);
            }
        }

        if timestamp.is_empty() || signatures.is_empty() {
            return Err(StripeServiceError::WebhookVerification(
                "Invalid signature format".to_string(),
            ));
        }

        // Validate timestamp to prevent replay attacks - reject webhooks older than 5 minutes or from the future
        let timestamp_int: i64 = timestamp.parse()
            .map_err(|e| StripeServiceError::WebhookVerification(format!("Invalid timestamp format: {}", e)))?;
        let now = chrono::Utc::now().timestamp();
        let time_diff = now - timestamp_int;
        
        // Reject timestamps from the future or older than 5 minutes
        if time_diff < 0 {
            return Err(StripeServiceError::WebhookVerification(
                "Webhook timestamp is from the future".to_string()
            ));
        }
        if time_diff > 300 { // 5 minutes = 300 seconds
            return Err(StripeServiceError::WebhookVerification(
                format!("Webhook timestamp outside allowed window: webhook is {} seconds old (maximum 300 seconds allowed)", time_diff)
            ));
        }

        let signed_payload = format!("{}.{}", timestamp, payload);
        
        let mut mac = HmacSha256::new_from_slice(self.webhook_secret.as_bytes())
            .map_err(|e| StripeServiceError::WebhookVerification(format!("HMAC error: {}", e)))?;
        
        mac.update(signed_payload.as_bytes());
        let expected_signature = hex::encode(mac.finalize().into_bytes());

        for signature in signatures {
            let decoded = hex::decode(signature)
                .map_err(|e| StripeServiceError::WebhookVerification(format!("Invalid signature format: {}", e)))?;
            let expected_bytes = hex::decode(&expected_signature)
                .map_err(|e| StripeServiceError::WebhookVerification(format!("Invalid expected signature format: {}", e)))?;
            
            if decoded.len() == expected_bytes.len() && decoded.ct_eq(&expected_bytes).unwrap_u8() == 1 {
                return Ok(());
            }
        }

        Err(StripeServiceError::WebhookVerification(
            "Signature verification failed".to_string(),
        ))
    }

    /// Parse webhook event from payload
    pub fn parse_webhook_event(&self, payload: &str) -> Result<stripe_types::Event, StripeServiceError> {
        let event: stripe_types::Event = serde_json::from_str(payload)
            .map_err(|e| StripeServiceError::WebhookVerification(format!("Failed to parse event: {}", e)))?;
        Ok(event)
    }

    /// Construct and verify webhook event (combines signature verification and parsing)
    pub fn construct_event(
        &self,
        payload: &str,
        signature: &str,
    ) -> Result<stripe_types::Event, StripeServiceError> {
        self.verify_webhook_signature(payload, signature)?;
        self.parse_webhook_event(payload)
    }

    /// Process Stripe webhook event with idempotency key handling
    /// This method provides webhook event processing with built-in idempotency checks
    pub fn process_stripe_webhook_event(
        &self,
        event: &stripe_types::Event,
        idempotency_key: &str,
    ) -> Result<stripe_types::Event, StripeServiceError> {
        // Log the processing attempt with idempotency key
        info!("Processing Stripe webhook event {} (type: {}) with idempotency key: {}", 
              event.id, event.type_, idempotency_key);
        
        // The actual webhook processing is handled by the calling service
        // This method primarily serves as a validation and logging point
        // with idempotency key integration for future use
        
        // Validate event has required fields
        if event.id.is_empty() {
            return Err(StripeServiceError::WebhookVerification(
                "Event ID is missing".to_string(),
            ));
        }
        
        if event.type_.is_empty() {
            return Err(StripeServiceError::WebhookVerification(
                "Event type is missing".to_string(),
            ));
        }
        
        // Return the validated event for further processing
        Ok(event.clone())
    }

    /// Search for customers using Stripe's search API
    pub async fn search_customers(&self, query: &str) -> Result<SearchResult<Customer>, StripeServiceError> {
        let encoded_query = urlencoding::encode(query);
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("customers/search?query={}", encoded_query),
            None,
            None,
        ).await?;
        
        let search_result: SearchResult<Customer> = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse customer search response: {}", e)))?;
        
        info!("Customer search for query '{}' returned {} results", query, search_result.data.len());
        Ok(search_result)
    }

    /// Search for a customer by user_id metadata
    pub async fn search_customer_by_user_id(&self, user_id: &Uuid) -> Result<Option<Customer>, StripeServiceError> {
        // Use Stripe's Search Query Language exactly - no escaped quotes inside the value
        let query = format!("metadata['user_id']:'{}'", user_id);
        let search_result = self.search_customers(&query).await?;

        if search_result.data.len() > 1 {
            let subject = "CRITICAL: Multiple Stripe Customers Found for Single User".to_string();
            let message = format!(
                "Data integrity alert: Found {} Stripe customers for user_id: {}. This requires immediate manual investigation. Customer IDs: {:?}",
                search_result.data.len(),
                user_id,
                search_result.data.iter().map(|c| &c.id).collect::<Vec<_>>()
            );
            warn!("{}", &message);
            // Asynchronously send an alert to admins
            tokio::spawn(async move {
                let alerting_service = admin_alerting::AdminAlertingService::new();
                let alert = admin_alerting::AdminAlert::new(
                    admin_alerting::AlertSeverity::Critical,
                    admin_alerting::AlertType::DataIntegrityIssue,
                    subject,
                    message,
                );
                alerting_service.send_alert(alert).await;
            });
        }

        Ok(search_result.data.into_iter().next())
    }

    /// Create a new customer in Stripe
    pub async fn create_customer(
        &self,
        idempotency_key: &str,
        user_id: &Uuid,
        email: &str,
        name: Option<&str>,
    ) -> Result<stripe_types::Customer, StripeServiceError> {
        // Create new customer using direct API call with idempotency key
        let mut customer_data = serde_json::json!({
            "email": email
        });
        
        if let Some(name_value) = name {
            customer_data["name"] = serde_json::Value::String(name_value.to_string());
        }
        
        // Add metadata as nested object
        customer_data["metadata"] = serde_json::json!({
            "user_id": user_id.to_string(),
            "created_by": "vibe_manager"
        });
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "customers",
            Some(customer_data),
            Some(idempotency_key),
        ).await?;
        
        // Parse the response into a Customer struct
        let customer: stripe_types::Customer = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse customer response: {}", e)))?;
        
        info!("Created Stripe customer: {} for user: {}", customer.id, user_id);
        
        Ok(customer)
    }

    /// Retrieve a customer by ID
    pub async fn get_customer(&self, customer_id: &str) -> Result<stripe_types::Customer, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("customers/{}?expand[]=tax_ids", customer_id),
            None,
            None,
        ).await?;
        let customer: stripe_types::Customer = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse customer response: {}", e)))?;
        Ok(customer)
    }




    /// Create billing portal session for customer self-service
    /// This is the primary method for complex billing operations
    pub async fn create_billing_portal_session(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        return_url: &str,
    ) -> Result<stripe_types::BillingPortalSession, StripeServiceError> {
        // Create billing portal session using direct API call with idempotency key
        let session_data = serde_json::json!({
            "customer": customer_id,
            "return_url": return_url
        });
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "billing_portal/sessions",
            Some(session_data),
            Some(idempotency_key),
        ).await?;
        
        // Parse the response into a BillingPortalSession struct
        let session: stripe_types::BillingPortalSession = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse billing portal session response: {}", e)))?;
        
        info!("Created billing portal session for customer: {}", customer_id);
        Ok(session)
    }

    /// Retrieve a PaymentIntent by ID
    pub async fn get_payment_intent(&self, payment_intent_id: &str) -> Result<stripe_types::PaymentIntent, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("payment_intents/{}?expand[]=latest_charge.balance_transaction", payment_intent_id),
            None,
            None,
        ).await?;
        let payment_intent: stripe_types::PaymentIntent = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse payment intent response: {}", e)))?;
        Ok(payment_intent)
    }

    /// Retrieve a Charge by ID with expanded balance transaction
    pub async fn get_charge(&self, charge_id: &str) -> Result<stripe_types::Charge, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("charges/{}?expand[]=balance_transaction", charge_id),
            None,
            None,
        ).await?;
        let charge: stripe_types::Charge = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse charge response: {}", e)))?;
        Ok(charge)
    }



    

    /// List payment methods for a customer from Stripe
    pub async fn list_payment_methods(&self, customer_id: &str) -> Result<Vec<stripe_types::PaymentMethod>, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("payment_methods?customer={}", customer_id),
            None,
            None,
        ).await?;
        
        let payment_methods_list: stripe_types::PaymentMethodList = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse payment methods response: {}", e)))?;
        
        info!("Retrieved {} payment methods for customer: {}", payment_methods_list.data.len(), customer_id);
        
        Ok(payment_methods_list.data)
    }


    /// Detach/delete a payment method in Stripe
    pub async fn detach_payment_method(&self, idempotency_key: &str, payment_method_id: &str) -> Result<stripe_types::PaymentMethod, StripeServiceError> {
        // Detach payment method using direct API call with idempotency key
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            &format!("payment_methods/{}/detach", payment_method_id),
            None, // POST /v1/payment_methods/:id/detach doesn't require body data
            Some(idempotency_key),
        ).await?;
        
        // Parse the response into a PaymentMethod struct
        let payment_method: stripe_types::PaymentMethod = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse payment method response: {}", e)))?;
        
        info!("Detached payment method: {}", payment_method_id);
        Ok(payment_method)
    }

    /// Set default payment method for a customer in Stripe
    pub async fn set_default_payment_method(&self, idempotency_key: &str, customer_id: &str, payment_method_id: &str) -> Result<stripe_types::Customer, StripeServiceError> {
        // Set default payment method using direct API call with idempotency key
        let update_data = serde_json::json!({
            "invoice_settings[default_payment_method]": payment_method_id
        });
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            &format!("customers/{}", customer_id),
            Some(update_data),
            Some(idempotency_key),
        ).await?;
        
        // Parse the response into a Customer struct
        let customer: stripe_types::Customer = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse customer response: {}", e)))?;
        info!("Set default payment method {} for customer: {}", payment_method_id, customer_id);
        
        Ok(customer)
    }

    /// Create a product and price (for credit purchases and one-time payments)
    pub async fn create_product_and_price(
        &self,
        idempotency_key: &str,
        product_name: &str,
        price_amount: i64,
        currency: &str,
        interval: Option<&str>,
    ) -> Result<(stripe_types::Product, stripe_types::Price), StripeServiceError> {
        // Create product using direct API call with idempotency key
        // Note: 'type' field is deprecated in current Stripe API
        let product_data = serde_json::json!({
            "name": product_name,
            "tax_code": "txcd_10103001"  // Tax code for SaaS/API credits
        });
        
        let product_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "products",
            Some(product_data),
            Some(&format!("{}_product", idempotency_key)),
        ).await?;
        
        let product: stripe_types::Product = serde_json::from_value(product_response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse product response: {}", e)))?;
        
        // Create price using direct API call with idempotency key
        let mut price_data = serde_json::json!({
            "currency": currency.to_lowercase(),
            "product": product.id,
            "unit_amount": price_amount,
            "tax_behavior": "exclusive"  // Taxes calculated on top of price
        });
        
        // Add recurring information only if interval is provided (recurring credit plans)
        if let Some(recurring_interval) = interval {
            price_data["recurring[interval]"] = serde_json::Value::String(recurring_interval.to_string());
        }
        
        let price_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "prices",
            Some(price_data),
            Some(&format!("{}_price", idempotency_key)),
        ).await?;
        
        let price: stripe_types::Price = serde_json::from_value(price_response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse price response: {}", e)))?;
        
        info!("Created product {} and price {} for {}", product.id, price.id, product_name);
        Ok((product, price))
    }


    /// Create a SetupIntent for saving payment method without charging (required by handlers)
    pub async fn create_setup_intent(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        metadata: HashMap<String, String>,
    ) -> Result<stripe_types::SetupIntent, StripeServiceError> {
        
        // Create setup intent using direct API call with idempotency key
        let mut setup_data = serde_json::json!({
            "customer": customer_id
        });
        
        // Add metadata
        for (key, value) in metadata {
            setup_data[format!("metadata[{}]", key)] = serde_json::Value::String(value);
        }
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "setup_intents",
            Some(setup_data),
            Some(idempotency_key),
        ).await?;
        
        let setup_intent: stripe_types::SetupIntent = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse setup intent response: {}", e)))?;
        
        info!("Created SetupIntent for customer: {}", customer_id);
        Ok(setup_intent)
    }

    /// Retrieve a SetupIntent by ID
    pub async fn get_setup_intent(&self, setup_intent_id: &str) -> Result<stripe_types::SetupIntent, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("setup_intents/{}", setup_intent_id),
            None,
            None,
        ).await?;
        let setup_intent: stripe_types::SetupIntent = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse setup intent response: {}", e)))?;
        Ok(setup_intent)
    }

    /// List invoices for a customer with pagination
    pub async fn list_invoices(&self, customer_id: &str, limit: Option<u64>, starting_after: Option<&str>) -> Result<serde_json::Value, StripeServiceError> {
        let mut query_params = vec![
            ("customer".to_string(), customer_id.to_string()),
        ];
        
        if let Some(limit_val) = limit {
            query_params.push(("limit".to_string(), limit_val.to_string()));
        }
        
        if let Some(starting_after_value) = starting_after {
            query_params.push(("starting_after".to_string(), starting_after_value.to_string()));
        }
        
        let query_string = query_params
            .into_iter()
            .map(|(k, v)| format!("{}={}", k, v))
            .collect::<Vec<_>>()
            .join("&");
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("invoices?{}", query_string),
            None,
            None,
        ).await?;
        
        Ok(response)
    }

    /// Create a Stripe Checkout Session (generic for payment and setup modes)
    // TODO(legal-compliance): Store consent timestamps from checkout (immediate performance + 
    // withdrawal acknowledgement). Send durable medium confirmation email immediately after 
    // successful payment with consent details. Implement pro-rata refund calculation based 
    // on credits consumed for withdrawal cases. Expose consent data for audit trail.
    pub async fn create_checkout_session(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        user_id: &uuid::Uuid,
        mode: &str,
        line_items: Option<Vec<stripe_types::CreateCheckoutSessionLineItems>>,
        success_url: &str,
        cancel_url: &str,
        metadata: HashMap<String, String>,
        billing_address_collection: Option<bool>,
        automatic_tax: Option<bool>,
        invoice_creation_enabled: Option<bool>,
        tax_id_collection_enabled: Option<bool>,
        customer_update_address: Option<bool>,
    ) -> Result<stripe_types::CheckoutSession, StripeServiceError> {
        // Create checkout session using direct API call with idempotency key
        let mode_str = mode;
        
        // Ensure success_url includes the session ID placeholder for payment verification
        let success_url_with_session = if success_url.contains("{CHECKOUT_SESSION_ID}") {
            success_url.to_string()
        } else {
            // Add session ID placeholder if not present
            let separator = if success_url.contains('?') { "&" } else { "?" };
            format!("{}{}", success_url, separator) + "session_id={CHECKOUT_SESSION_ID}"
        };
        
        let mut session_data = serde_json::json!({
            "customer": customer_id,
            "client_reference_id": user_id.to_string(),
            "mode": mode_str,
            "success_url": success_url_with_session,
            "cancel_url": cancel_url
        });
        
        // Only set line_items for non-Setup modes
        // Setup mode is for saving payment methods and doesn't require line_items
        if mode_str != "setup" {
            if let Some(items) = line_items {
                let mut line_items_array = Vec::new();
                for item in items.iter() {
                    let mut line_item = serde_json::Map::new();
                    if let Some(price) = &item.price {
                        line_item.insert("price".to_string(), serde_json::Value::String(price.clone()));
                    }
                    if let Some(price_data) = &item.price_data {
                        line_item.insert("price_data".to_string(), price_data.clone());
                    }
                    if let Some(quantity) = item.quantity {
                        line_item.insert("quantity".to_string(), serde_json::Value::Number(serde_json::Number::from(quantity)));
                    }
                    line_items_array.push(serde_json::Value::Object(line_item));
                }
                session_data["line_items"] = serde_json::Value::Array(line_items_array);
            }
        }
        
        match mode_str {
            "payment" => {
                let mut payment_intent_data = serde_json::Map::new();
                
                // Add capture_method for automatic payment capture
                payment_intent_data.insert("capture_method".to_string(), serde_json::Value::String("automatic".to_string()));
                
                // Save the payment method for future use (off-session charges, auto top-off, etc.)
                payment_intent_data.insert("setup_future_usage".to_string(), serde_json::Value::String("off_session".to_string()));
                
                // Add metadata to payment_intent_data
                if !metadata.is_empty() {
                    let mut metadata_obj = serde_json::Map::new();
                    for (key, value) in &metadata {
                        metadata_obj.insert(key.clone(), serde_json::Value::String(value.clone()));
                    }
                    payment_intent_data.insert("metadata".to_string(), serde_json::Value::Object(metadata_obj));
                }
                
                
                if !payment_intent_data.is_empty() {
                    session_data["payment_intent_data"] = serde_json::Value::Object(payment_intent_data);
                }
            }
            "setup" => {
                if !metadata.is_empty() {
                    let mut setup_intent_data = serde_json::Map::new();
                    let mut metadata_obj = serde_json::Map::new();
                    for (key, value) in &metadata {
                        metadata_obj.insert(key.clone(), serde_json::Value::String(value.clone()));
                    }
                    setup_intent_data.insert("metadata".to_string(), serde_json::Value::Object(metadata_obj));
                    session_data["setup_intent_data"] = serde_json::Value::Object(setup_intent_data);
                }
            }
            _ => {}
        }
        
        // Add billing address collection (default to required for tax compliance)
        let collect_billing = billing_address_collection.unwrap_or(true);
        if collect_billing {
            session_data["billing_address_collection"] = serde_json::Value::String("required".to_string());
        }
        
        // Add tax ID collection for B2B customers (VAT/GST numbers)
        let collect_tax_ids = tax_id_collection_enabled.unwrap_or(true);
        if collect_tax_ids && mode_str == "payment" {
            session_data["tax_id_collection"] = serde_json::json!({
                "enabled": true
            });
        }
        
        // Enable customer updates to persist billing addresses and business names (required for tax ID collection)
        let update_address = customer_update_address.unwrap_or(true);
        if update_address && mode_str == "payment" {
            session_data["customer_update"] = serde_json::json!({
                "address": "auto",
                "name": "auto"  // Required when tax_id_collection is enabled
            });
        }
        
        // Add automatic tax (default to enabled for compliance)
        let auto_tax = automatic_tax.unwrap_or(true);
        if auto_tax && mode_str == "payment" {
            let mut automatic_tax_obj = serde_json::Map::new();
            automatic_tax_obj.insert("enabled".to_string(), serde_json::Value::Bool(true));
            session_data["automatic_tax"] = serde_json::Value::Object(automatic_tax_obj);
        }
        
        // Add invoice creation if enabled for payment mode
        if mode_str == "payment" {
            if let Some(true) = invoice_creation_enabled {
                let mut invoice_creation = serde_json::Map::new();
                invoice_creation.insert("enabled".to_string(), serde_json::Value::Bool(true));
                session_data["invoice_creation"] = serde_json::Value::Object(invoice_creation);
            }
        }
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "checkout/sessions",
            Some(session_data),
            Some(idempotency_key),
        ).await?;
        
        // Parse the response into a CheckoutSession struct
        let session: stripe_types::CheckoutSession = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse checkout session response: {}", e)))?;
        
        info!("Created Checkout Session: {} for customer: {}", session.id, customer_id);
        Ok(session)
    }

    /// Get a checkout session by ID
    pub async fn get_checkout_session(&self, session_id: &str) -> Result<stripe_types::CheckoutSession, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("checkout/sessions/{}", session_id),
            None,
            None,
        ).await?;
        let session: stripe_types::CheckoutSession = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse checkout session response: {}", e)))?;
        Ok(session)
    }


    /// Create an invoice for a customer with automatic payment collection
    pub async fn create_invoice_for_auto_topoff(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        net_amount_cents: i64,
        fee_amount_cents: i64,
        currency: &str,
        description: &str,
        metadata: Option<serde_json::Value>,
    ) -> Result<stripe_types::Invoice, StripeServiceError> {
        let total_amount_cents = net_amount_cents + fee_amount_cents;
        info!("Creating invoice for auto top-off - customer: {}, net: {} cents, fee: {} cents, total: {} {}", 
              customer_id, net_amount_cents, fee_amount_cents, total_amount_cents, currency);
        
        // Step 1: Create a draft invoice first (exclude pending items to avoid aggregation)
        let mut invoice_metadata = serde_json::json!({
            "type": "auto_topoff"
        });
        
        // Merge additional metadata if provided
        if let Some(additional_metadata) = metadata {
            if let serde_json::Value::Object(map) = additional_metadata {
                for (key, value) in map {
                    invoice_metadata[key] = value;
                }
            }
        }
        
        let invoice_data = serde_json::json!({
            "customer": customer_id,
            "currency": currency.to_lowercase(),
            "collection_method": "charge_automatically",
            "auto_advance": true,
            "pending_invoice_items_behavior": "exclude",
            "automatic_tax": {
                "enabled": true  // Enable automatic tax calculation for invoices
            },
            "metadata": invoice_metadata
        });
        
        let invoice_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "invoices",
            Some(invoice_data),
            Some(&format!("{}_invoice", idempotency_key)),
        ).await?;
        
        let mut invoice: stripe_types::Invoice = serde_json::from_value(invoice_response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse invoice response: {}", e)))?;
        
        info!("Created draft invoice: {}", invoice.id);
        
        // Step 2: Create TWO invoice items - one for credits, one for fee
        // First item: Credits (using price_data for proper tax handling)
        let credits_item_data = serde_json::json!({
            "customer": customer_id,
            "invoice": invoice.id,
            "price_data": {
                "currency": currency.to_lowercase(),
                "unit_amount": net_amount_cents,
                "tax_behavior": "exclusive",
                "product_data": {
                    "name": description,
                    "tax_code": "txcd_10103001"  // Tax code for SaaS/API credits
                }
            }
        });
        
        let credits_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "invoiceitems",
            Some(credits_item_data),
            Some(&format!("{}_credits_item", idempotency_key)),
        ).await?;
        
        let credits_item: serde_json::Value = credits_response;
        let credits_item_id = credits_item.get("id").and_then(|v| v.as_str()).unwrap_or("unknown");
        info!("Created credits invoice item: {} attached to invoice: {}", credits_item_id, invoice.id);
        
        // Second item: Processing fee (only if fee > 0)
        // Note: Processing fees are typically taxable; use appropriate tax code
        if fee_amount_cents > 0 {
            let fee_item_data = serde_json::json!({
                "customer": customer_id,
                "invoice": invoice.id,
                "price_data": {
                    "currency": currency.to_lowercase(),
                    "unit_amount": fee_amount_cents,
                    "tax_behavior": "exclusive",
                    "product_data": {
                        "name": "Processing fee",
                        "tax_code": "txcd_10103001"  // Same tax code as credits (taxable service)
                    }
                }
            });
            
            let fee_response = self.make_stripe_request_with_idempotency(
                reqwest::Method::POST,
                "invoiceitems",
                Some(fee_item_data),
                Some(&format!("{}_fee_item", idempotency_key)),
            ).await?;
            
            let fee_item: serde_json::Value = fee_response;
            let fee_item_id = fee_item.get("id").and_then(|v| v.as_str()).unwrap_or("unknown");
            info!("Created fee invoice item: {} attached to invoice: {}", fee_item_id, invoice.id);
        }
        
        // Step 3: Finalize the invoice (this creates the PaymentIntent and attempts payment)
        // Since auto_advance is true, Stripe should automatically attempt collection
        let finalized_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            &format!("invoices/{}/finalize", invoice.id),
            None, // No body needed for finalization
            Some(&format!("{}_finalize", idempotency_key)),
        ).await?;
        
        invoice = serde_json::from_value(finalized_response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse finalized invoice response: {}", e)))?;
        
        // Step 4: Attempt to pay the invoice if it's still open
        if invoice.status.as_ref().map(|s| s.as_str()) == Some("open") {
            info!("Invoice {} is still open, attempting to pay", invoice.id);
            
            let pay_response = self.make_stripe_request_with_idempotency(
                reqwest::Method::POST,
                &format!("invoices/{}/pay", invoice.id),
                None, // Let Stripe use the default payment method
                Some(&format!("{}_pay", idempotency_key)),
            ).await;
            
            match pay_response {
                Ok(paid_response) => {
                    invoice = serde_json::from_value(paid_response)
                        .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse paid invoice response: {}", e)))?;
                    info!("Successfully paid invoice: {}", invoice.id);
                },
                Err(e) => {
                    warn!("Failed to pay invoice {} automatically: {}", invoice.id, e);
                    // Don't fail the entire operation, just log the warning
                }
            }
        }
        
        info!("Successfully created and finalized invoice: {} with {} items for customer: {}", 
              invoice.id, if fee_amount_cents > 0 { "2" } else { "1" }, customer_id);
        Ok(invoice)
    }

    /// Clean up pending invoice items for a customer to prevent aggregation
    pub async fn cleanup_pending_invoice_items(&self, customer_id: &str) -> Result<(), StripeServiceError> {
        info!("Cleaning up pending invoice items for customer: {}", customer_id);
        
        // List all pending invoice items for the customer
        let list_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("invoiceitems?customer={}&pending=true&limit=100", customer_id),
            None,
            None,
        ).await?;
        
        let items_list: serde_json::Value = list_response;
        let items = items_list.get("data").and_then(|d| d.as_array()).cloned().unwrap_or_default();
        
        info!("Found {} pending invoice items for customer: {}", items.len(), customer_id);
        
        // Delete each pending invoice item
        for item in &items {
            if let Some(item_id) = item.get("id").and_then(|id| id.as_str()) {
                match self.make_stripe_request_with_idempotency(
                    reqwest::Method::DELETE,
                    &format!("invoiceitems/{}", item_id),
                    None,
                    None,
                ).await {
                    Ok(_) => info!("Deleted pending invoice item: {}", item_id),
                    Err(e) => warn!("Failed to delete pending invoice item {}: {}", item_id, e),
                }
            }
        }
        
        info!("Completed cleanup of pending invoice items for customer: {}", customer_id);
        Ok(())
    }
    
    /// Clean up pending invoice items that don't match the specified currency
    /// Returns the number of items deleted
    pub async fn cleanup_pending_invoice_items_except_currency(&self, customer_id: &str, keep_currency: &str) -> Result<usize, StripeServiceError> {
        info!("Cleaning up pending invoice items not in {} for customer: {}", keep_currency, customer_id);
        
        let mut total_deleted = 0;
        
        // List pending invoice items for the customer
        let list_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("invoiceitems?customer={}&pending=true&limit=100", customer_id),
            None,
            None,
        ).await?;
        
        let items_list: serde_json::Value = list_response;
        let items = items_list.get("data").and_then(|d| d.as_array()).cloned().unwrap_or_default();
        
        // Delete only items with mismatched currency
        for item in &items {
            if let Some(item_id) = item.get("id").and_then(|id| id.as_str()) {
                let currency = item.get("currency").and_then(|c| c.as_str()).unwrap_or("");
                let amount = item.get("amount").and_then(|a| a.as_i64()).unwrap_or(0);
                
                // Only delete if currency doesn't match
                if currency.to_lowercase() != keep_currency.to_lowercase() {
                    match self.make_stripe_request_with_idempotency(
                        reqwest::Method::DELETE,
                        &format!("invoiceitems/{}", item_id),
                        None,
                        None,
                    ).await {
                        Ok(_) => {
                            info!("Deleted mismatched currency invoice item: {} (was {} {}, keeping only {})", 
                                  item_id, amount, currency, keep_currency);
                            total_deleted += 1;
                        },
                        Err(e) => {
                            warn!("Failed to delete invoice item {} (amount: {} {}): {}", 
                                  item_id, amount, currency, e);
                        }
                    }
                } else {
                    debug!("Keeping invoice item {} in matching currency {}", item_id, currency);
                }
            }
        }
        
        if total_deleted > 0 {
            info!("Deleted {} invoice items with non-{} currencies for customer: {}", 
                  total_deleted, keep_currency, customer_id);
        }
        
        Ok(total_deleted)
    }
    
    /// Clean up ALL pending invoice items for a customer, regardless of currency
    /// Returns the number of items deleted
    pub async fn cleanup_all_pending_invoice_items(&self, customer_id: &str) -> Result<usize, StripeServiceError> {
        info!("Cleaning up ALL pending invoice items (all currencies) for customer: {}", customer_id);
        
        let mut total_deleted = 0;
        let mut has_more = true;
        
        // Keep fetching and deleting until no more items remain
        while has_more {
            // List pending invoice items for the customer
            let list_response = self.make_stripe_request_with_idempotency(
                reqwest::Method::GET,
                &format!("invoiceitems?customer={}&pending=true&limit=100", customer_id),
                None,
                None,
            ).await?;
            
            let items_list: serde_json::Value = list_response;
            let items = items_list.get("data").and_then(|d| d.as_array()).cloned().unwrap_or_default();
            
            if items.is_empty() {
                has_more = false;
                break;
            }
            
            info!("Found {} pending invoice items in this batch for customer: {}", items.len(), customer_id);
            
            // Delete each pending invoice item
            for item in &items {
                if let Some(item_id) = item.get("id").and_then(|id| id.as_str()) {
                    // Log the currency of the item being deleted for debugging
                    let currency = item.get("currency").and_then(|c| c.as_str()).unwrap_or("unknown");
                    let amount = item.get("amount").and_then(|a| a.as_i64()).unwrap_or(0);
                    
                    match self.make_stripe_request_with_idempotency(
                        reqwest::Method::DELETE,
                        &format!("invoiceitems/{}", item_id),
                        None,
                        None,
                    ).await {
                        Ok(_) => {
                            info!("Deleted pending invoice item: {} (amount: {} {})", item_id, amount, currency);
                            total_deleted += 1;
                        },
                        Err(e) => {
                            // Log but continue - some items might be attached to finalized invoices
                            warn!("Failed to delete pending invoice item {} (amount: {} {}): {}", 
                                  item_id, amount, currency, e);
                        }
                    }
                }
            }
            
            // Check if there are more items to fetch
            has_more = items_list.get("has_more")
                .and_then(|v| v.as_bool())
                .unwrap_or(false);
        }
        
        if total_deleted > 0 {
            info!("Successfully deleted {} pending invoice items for customer: {}", total_deleted, customer_id);
        }
        
        Ok(total_deleted)
    }



}

