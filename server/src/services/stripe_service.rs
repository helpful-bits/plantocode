// STRIPE API IDEMPOTENCY REQUIREMENTS:
//
// All mutating Stripe API operations (POST requests) MUST include an `Idempotency-Key` header
// to ensure safe retry behavior and prevent duplicate operations in case of network failures
// or application restarts.
//
// IDEMPOTENCY KEY REQUIREMENTS:
// 1. Each distinct operation MUST have a unique idempotency key
// 2. Keys should be UUIDs or similar unique identifiers
// 3. Keys MUST be reused for retries of the same logical operation
// 4. Keys should NOT be reused across different operations
// 5. Idempotency keys expire after 24 hours in Stripe's system
//
// CURRENT IMPLEMENTATION STATUS:
// - ✅ This service now implements idempotency key handling
// - ✅ All mutating methods accept an idempotency_key parameter
// - ✅ BillingService generates unique UUIDs for each operation
// - Note: PaymentMethod::detach may need library-specific idempotency handling
//
// RECOMMENDED IMPLEMENTATION:
// ```rust
// pub async fn create_customer_with_idempotency(
//     &self,
//     idempotency_key: &str,  // Add this parameter
//     user_id: &Uuid,
//     email: &str,
//     name: Option<&str>
// ) -> Result<Customer, StripeServiceError> {
//     // Set idempotency key in request headers
//     // self.client.set_idempotency_key(idempotency_key);
//     // ... rest of implementation
// }
// ```
//
// CRITICAL FOR BILLING OPERATIONS:
// - Payment processing operations MUST be idempotent to prevent double charges
// - Credit purchase operations MUST be idempotent to prevent duplicate billing
// - Usage record reporting MUST be idempotent to prevent double billing
//
use crate::stripe_types::{self, *};
use reqwest::header::{HeaderMap, HeaderValue, AUTHORIZATION, CONTENT_TYPE};
use chrono::{DateTime, Utc};
use hmac::{Hmac, Mac};
use sha2::Sha256;
use std::collections::HashMap;
use uuid::Uuid;
use log::{debug, error, info, warn};
use hex;
use subtle::ConstantTimeEq;

#[derive(Debug, thiserror::Error)]
pub enum StripeServiceError {
    #[error("Stripe API error: {0}")]
    StripeApi(String),
    #[error("Webhook verification failed: {0}")]
    WebhookVerification(String),
    #[error("Invalid configuration: {0}")]
    Configuration(String),
    #[error("Payment processing error: {0}")]
    PaymentProcessing(String),
    #[error("Credit billing error: {0}")]
    CreditBilling(String),
}

type HmacSha256 = Hmac<Sha256>;


// Stripe Customer Portal Configuration Required:
// 1. Enable payment method management
// 2. Enable credit purchase and invoicing
// 3. Enable payment method updates
// 4. Enable invoice access
// 5. Set return URL to app billing page
// 6. Configure business branding

/// Stripe service for handling payment processing and credit-based billing
/// 
/// IMPORTANT: This service implements Stripe's idempotency requirements.
/// All mutating operations include idempotency keys to prevent:
/// - Duplicate payments
/// - Duplicate credit purchases  
/// - Duplicate usage records
/// - Data inconsistencies during retries
/// 
/// Idempotency keys are generated by the calling service (BillingService) as UUIDs.
#[derive(Clone)]
pub struct StripeService {
    webhook_secret: String,
    publishable_key: String,
    secret_key: String,
    http_client: reqwest::Client,
}

impl std::fmt::Debug for StripeService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("StripeService")
            .field("webhook_secret", &"<redacted>")
            .field("publishable_key", &self.publishable_key)
            .finish()
    }
}

impl StripeService {
    pub fn new(secret_key: String, webhook_secret: String, publishable_key: String) -> Self {
        let http_client = reqwest::Client::new();
        
        Self {
            webhook_secret,
            publishable_key,
            secret_key,
            http_client,
        }
    }

    pub fn get_publishable_key(&self) -> &str {
        &self.publishable_key
    }

    /// Make a direct authenticated request to Stripe API with idempotency key
    async fn make_stripe_request_with_idempotency(
        &self,
        method: reqwest::Method,
        endpoint: &str,
        body: Option<serde_json::Value>,
        idempotency_key: Option<&str>,
    ) -> Result<serde_json::Value, StripeServiceError> {
        let url = format!("https://api.stripe.com/v1/{}", endpoint);
        
        let mut headers = HeaderMap::new();
        headers.insert(AUTHORIZATION, HeaderValue::from_str(&format!("Bearer {}", self.secret_key))
            .map_err(|_| StripeServiceError::Configuration("Invalid secret key format".to_string()))?);
        headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/x-www-form-urlencoded"));
        
        // Only add idempotency key for POST requests
        if method == reqwest::Method::POST {
            if let Some(key) = idempotency_key {
                headers.insert("Idempotency-Key", HeaderValue::from_str(key)
                    .map_err(|_| StripeServiceError::Configuration("Invalid idempotency key format".to_string()))?);
            }
        }
        
        // Use configurable Stripe API version with fallback to latest stable version
        let stripe_version = std::env::var("STRIPE_API_VERSION")
            .unwrap_or_else(|_| "2024-06-20".to_string());
        headers.insert("Stripe-Version", HeaderValue::from_str(&stripe_version)
            .map_err(|_| StripeServiceError::Configuration("Invalid Stripe version format".to_string()))?);
        
        let mut request = self.http_client.request(method, &url).headers(headers);
        
        if let Some(body_data) = body {
            // Convert JSON to form-encoded data for Stripe API
            let form_data = self.json_to_form_data(body_data)?;
            request = request.body(form_data);
        }
        
        let response = request.send().await
            .map_err(|e| StripeServiceError::Configuration(format!("HTTP request failed: {}", e)))?;
        
        if !response.status().is_success() {
            let status = response.status();
            let error_text = response.text().await
                .unwrap_or_else(|_| "Unknown error".to_string());
            
            // Try to parse Stripe error response for better error messages
            if let Ok(error_json) = serde_json::from_str::<serde_json::Value>(&error_text) {
                if let Some(error_obj) = error_json.get("error") {
                    let error_type = error_obj.get("type")
                        .and_then(|t| t.as_str())
                        .unwrap_or("unknown");
                    let error_message = error_obj.get("message")
                        .and_then(|m| m.as_str())
                        .unwrap_or(&error_text);
                    let error_code = error_obj.get("code")
                        .and_then(|c| c.as_str())
                        .unwrap_or("");
                    
                    error!("Stripe API error - Status: {}, Type: {}, Code: {}, Message: {}", 
                           status, error_type, error_code, error_message);
                    
                    // Return appropriate error type based on the error
                    return match error_type {
                        "card_error" | "payment_method_error" => {
                            Err(StripeServiceError::PaymentProcessing(error_message.to_string()))
                        }
                        "invalid_request_error" | "api_error" => {
                            Err(StripeServiceError::StripeApi(format!("{}: {}", error_code, error_message)))
                        }
                        _ => {
                            Err(StripeServiceError::Configuration(format!("Stripe API error: {}", error_message)))
                        }
                    };
                }
            }
            
            error!("Stripe API error - Status: {}, Response: {}", status, error_text);
            return Err(StripeServiceError::StripeApi(format!("HTTP {}: {}", status, error_text)));
        }
        
        let response_json: serde_json::Value = response.json().await
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse response: {}", e)))?;
        
        Ok(response_json)
    }
    
    /// Convert JSON object to form-encoded data for Stripe API
    fn json_to_form_data(&self, json: serde_json::Value) -> Result<String, StripeServiceError> {
        fn flatten_object(obj: &serde_json::Value, prefix: &str, params: &mut Vec<(String, String)>) {
            match obj {
                serde_json::Value::Object(map) => {
                    for (key, value) in map {
                        let new_key = if prefix.is_empty() {
                            key.clone()
                        } else {
                            format!("{}[{}]", prefix, key)
                        };
                        flatten_object(value, &new_key, params);
                    }
                }
                serde_json::Value::Array(arr) => {
                    for (index, value) in arr.iter().enumerate() {
                        let new_key = format!("{}[{}]", prefix, index);
                        flatten_object(value, &new_key, params);
                    }
                }
                value => {
                    let string_value = match value {
                        serde_json::Value::String(s) => s.clone(),
                        serde_json::Value::Number(n) => n.to_string(),
                        serde_json::Value::Bool(b) => b.to_string(),
                        serde_json::Value::Null => return,
                        _ => return,
                    };
                    params.push((prefix.to_string(), string_value));
                }
            }
        }
        
        let mut params = Vec::new();
        flatten_object(&json, "", &mut params);
        
        let form_string = params
            .into_iter()
            .map(|(k, v)| format!("{}={}", urlencoding::encode(&k), urlencoding::encode(&v)))
            .collect::<Vec<_>>()
            .join("&");
        
        Ok(form_string)
    }

    /// Verify webhook signature with timestamp validation
    pub fn verify_webhook_signature(
        &self,
        payload: &str,
        signature: &str,
    ) -> Result<(), StripeServiceError> {
        let elements: Vec<&str> = signature.split(',').collect();
        let mut timestamp = "";
        let mut signatures = Vec::new();

        for element in elements {
            if let Some(t) = element.strip_prefix("t=") {
                timestamp = t;
            } else if let Some(s) = element.strip_prefix("v1=") {
                signatures.push(s);
            }
        }

        if timestamp.is_empty() || signatures.is_empty() {
            return Err(StripeServiceError::WebhookVerification(
                "Invalid signature format".to_string(),
            ));
        }

        // Validate timestamp to prevent replay attacks - reject webhooks older than 5 minutes or from the future
        let timestamp_int: i64 = timestamp.parse()
            .map_err(|e| StripeServiceError::WebhookVerification(format!("Invalid timestamp format: {}", e)))?;
        let now = chrono::Utc::now().timestamp();
        let time_diff = now - timestamp_int;
        
        // Reject timestamps from the future or older than 5 minutes
        if time_diff < 0 {
            return Err(StripeServiceError::WebhookVerification(
                "Webhook timestamp is from the future".to_string()
            ));
        }
        if time_diff > 300 { // 5 minutes = 300 seconds
            return Err(StripeServiceError::WebhookVerification(
                format!("Webhook timestamp outside allowed window: webhook is {} seconds old (maximum 300 seconds allowed)", time_diff)
            ));
        }

        let signed_payload = format!("{}.{}", timestamp, payload);
        
        let mut mac = HmacSha256::new_from_slice(self.webhook_secret.as_bytes())
            .map_err(|e| StripeServiceError::WebhookVerification(format!("HMAC error: {}", e)))?;
        
        mac.update(signed_payload.as_bytes());
        let expected_signature = hex::encode(mac.finalize().into_bytes());

        for signature in signatures {
            let decoded = hex::decode(signature)
                .map_err(|e| StripeServiceError::WebhookVerification(format!("Invalid signature format: {}", e)))?;
            let expected_bytes = hex::decode(&expected_signature)
                .map_err(|e| StripeServiceError::WebhookVerification(format!("Invalid expected signature format: {}", e)))?;
            
            if decoded.len() == expected_bytes.len() && decoded.ct_eq(&expected_bytes).unwrap_u8() == 1 {
                return Ok(());
            }
        }

        Err(StripeServiceError::WebhookVerification(
            "Signature verification failed".to_string(),
        ))
    }

    /// Parse webhook event from payload
    pub fn parse_webhook_event(&self, payload: &str) -> Result<stripe_types::Event, StripeServiceError> {
        let event: stripe_types::Event = serde_json::from_str(payload)
            .map_err(|e| StripeServiceError::WebhookVerification(format!("Failed to parse event: {}", e)))?;
        Ok(event)
    }

    /// Construct and verify webhook event (combines signature verification and parsing)
    pub fn construct_event(
        &self,
        payload: &str,
        signature: &str,
    ) -> Result<stripe_types::Event, StripeServiceError> {
        self.verify_webhook_signature(payload, signature)?;
        self.parse_webhook_event(payload)
    }

    /// Process Stripe webhook event with idempotency key handling
    /// This method provides webhook event processing with built-in idempotency checks
    pub fn process_stripe_webhook_event(
        &self,
        event: &stripe_types::Event,
        idempotency_key: &str,
    ) -> Result<stripe_types::Event, StripeServiceError> {
        // Log the processing attempt with idempotency key
        info!("Processing Stripe webhook event {} (type: {}) with idempotency key: {}", 
              event.id, event.type_, idempotency_key);
        
        // The actual webhook processing is handled by the calling service
        // This method primarily serves as a validation and logging point
        // with idempotency key integration for future use
        
        // Validate event has required fields
        if event.id.is_empty() {
            return Err(StripeServiceError::WebhookVerification(
                "Event ID is missing".to_string(),
            ));
        }
        
        if event.type_.is_empty() {
            return Err(StripeServiceError::WebhookVerification(
                "Event type is missing".to_string(),
            ));
        }
        
        // Return the validated event for further processing
        Ok(event.clone())
    }

    /// Create or retrieve existing customer
    pub async fn create_or_get_customer(
        &self,
        idempotency_key: &str,
        user_id: &Uuid,
        email: &str,
        name: Option<&str>,
        existing_customer_id: Option<&str>,
    ) -> Result<stripe_types::Customer, StripeServiceError> {
        // If we have an existing customer ID, try to retrieve it first
        if let Some(customer_id) = existing_customer_id {
            match self.get_customer(customer_id).await {
                Ok(customer) => return Ok(customer),
                Err(e) => {
                    warn!("Failed to retrieve existing customer {}: {}", customer_id, e);
                }
            }
        }

        // Create new customer using direct API call with idempotency key
        let mut customer_data = serde_json::json!({
            "email": email
        });
        
        if let Some(name_value) = name {
            customer_data["name"] = serde_json::Value::String(name_value.to_string());
        }
        
        // Add metadata as nested object
        customer_data["metadata"] = serde_json::json!({
            "user_id": user_id.to_string(),
            "created_by": "vibe_manager"
        });
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "customers",
            Some(customer_data),
            Some(idempotency_key),
        ).await?;
        
        // Parse the response into a Customer struct
        let customer: stripe_types::Customer = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse customer response: {}", e)))?;
        
        info!("Created Stripe customer: {} for user: {}", customer.id, user_id);
        
        Ok(customer)
    }

    /// Retrieve a customer by ID
    pub async fn get_customer(&self, customer_id: &str) -> Result<stripe_types::Customer, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("customers/{}", customer_id),
            None,
            None,
        ).await?;
        let customer: stripe_types::Customer = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse customer response: {}", e)))?;
        Ok(customer)
    }

    /// Retrieve tax IDs for a customer
    pub async fn get_customer_tax_ids(&self, customer_id: &str) -> Result<Vec<stripe_types::TaxId>, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("customers/{}/tax_ids", customer_id),
            None,
            None,
        ).await?;
        let tax_id_list: stripe_types::TaxIdList = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse tax ID response: {}", e)))?;
        Ok(tax_id_list.data)
    }

    /// Create a payment intent for processing payments using latest Stripe patterns
    pub async fn create_payment_intent(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        amount_cents: i64,
        currency: &str,
        description: &str,
        metadata: HashMap<String, String>,
        save_payment_method: bool,
    ) -> Result<stripe_types::PaymentIntent, StripeServiceError> {
        // Validate amount
        if amount_cents <= 0 {
            return Err(StripeServiceError::PaymentProcessing(
                "Payment amount must be greater than 0".to_string()
            ));
        }
        
        // Create payment intent using direct API call with idempotency key
        let mut payment_data = serde_json::json!({
            "amount": amount_cents,
            "currency": currency.to_lowercase(),
            "customer": customer_id,
            "confirmation_method": "automatic",
            // Enable automatic payment method handling for better conversion
            "automatic_payment_methods": {
                "enabled": true
            }
        });
        
        if !description.is_empty() {
            payment_data["description"] = serde_json::Value::String(description.to_string());
        }
        
        // Add metadata
        for (key, value) in metadata {
            payment_data[format!("metadata[{}]", key)] = serde_json::Value::String(value);
        }
        
        if save_payment_method {
            payment_data["setup_future_usage"] = serde_json::Value::String("off_session".to_string());
        }
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "payment_intents",
            Some(payment_data),
            Some(idempotency_key),
        ).await.map_err(|e| {
            error!("Failed to create payment intent: {}", e);
            StripeServiceError::PaymentProcessing(format!("Failed to create payment intent: {}", e))
        })?;
        
        // Parse the response into a PaymentIntent struct
        let payment_intent: stripe_types::PaymentIntent = serde_json::from_value(response)
            .map_err(|e| {
                error!("Failed to parse payment intent response: {}", e);
                StripeServiceError::Configuration(format!("Failed to parse payment intent response: {}", e))
            })?;
        
        info!("Created PaymentIntent: {} for customer: {} with amount: {} {}", 
              payment_intent.id, customer_id, amount_cents, currency);
        Ok(payment_intent)
    }


    /// Create billing portal session for customer self-service
    /// This is the primary method for complex billing operations
    pub async fn create_billing_portal_session(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        return_url: &str,
    ) -> Result<stripe_types::BillingPortalSession, StripeServiceError> {
        // Create billing portal session using direct API call with idempotency key
        let session_data = serde_json::json!({
            "customer": customer_id,
            "return_url": return_url
        });
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "billing_portal/sessions",
            Some(session_data),
            Some(idempotency_key),
        ).await?;
        
        // Parse the response into a BillingPortalSession struct
        let session: stripe_types::BillingPortalSession = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse billing portal session response: {}", e)))?;
        
        info!("Created billing portal session for customer: {}", customer_id);
        Ok(session)
    }

    /// Retrieve a PaymentIntent by ID
    pub async fn get_payment_intent(&self, payment_intent_id: &str) -> Result<stripe_types::PaymentIntent, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("payment_intents/{}", payment_intent_id),
            None,
            None,
        ).await?;
        let payment_intent: stripe_types::PaymentIntent = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse payment intent response: {}", e)))?;
        Ok(payment_intent)
    }

    /// Retrieve a Charge by ID with expanded balance transaction
    pub async fn get_charge(&self, charge_id: &str) -> Result<stripe_types::Charge, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("charges/{}?expand[]=balance_transaction", charge_id),
            None,
            None,
        ).await?;
        let charge: stripe_types::Charge = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse charge response: {}", e)))?;
        Ok(charge)
    }



    

    /// List payment methods for a customer from Stripe
    pub async fn list_payment_methods(&self, customer_id: &str) -> Result<Vec<stripe_types::PaymentMethod>, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("payment_methods?customer={}&type=card", customer_id),
            None,
            None,
        ).await?;
        
        let payment_methods_list: stripe_types::PaymentMethodList = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse payment methods response: {}", e)))?;
        
        info!("Retrieved {} payment methods for customer: {}", payment_methods_list.data.len(), customer_id);
        
        Ok(payment_methods_list.data)
    }

    /// List invoices for a customer from Stripe
    pub async fn list_invoices(&self, customer_id: &str) -> Result<Vec<stripe_types::Invoice>, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("invoices?customer={}&limit=100", customer_id),
            None,
            None,
        ).await?;
        
        let invoices_list: stripe_types::InvoiceList = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse invoices response: {}", e)))?;
        
        info!("Retrieved {} invoices for customer: {}", invoices_list.data.len(), customer_id);
        
        Ok(invoices_list.data)
    }

    /// List invoices for a customer from Stripe with status filter and pagination
    pub async fn list_invoices_with_filter(&self, customer_id: &str, status: Option<&str>, limit: Option<u64>, starting_after: Option<&str>) -> Result<stripe_types::InvoiceList, StripeServiceError> {
        let mut query_params = vec![
            ("customer".to_string(), customer_id.to_string()),
        ];
        
        if let Some(limit_val) = limit {
            query_params.push(("limit".to_string(), limit_val.to_string()));
        }
        
        if let Some(starting_after_value) = starting_after {
            query_params.push(("starting_after".to_string(), starting_after_value.to_string()));
        }
        
        if let Some(status_str) = status {
            query_params.push(("status".to_string(), status_str.to_string()));
        }
        
        let query_string = query_params
            .into_iter()
            .map(|(k, v)| format!("{}={}", k, v))
            .collect::<Vec<_>>()
            .join("&");
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("invoices?{}", query_string),
            None,
            None,
        ).await?;
        
        let invoices_list: stripe_types::InvoiceList = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse invoices response: {}", e)))?;
        
        info!("Retrieved {} invoices for customer: {} with pagination (limit: {:?}, starting_after: {:?})", invoices_list.data.len(), customer_id, limit, starting_after);
        
        Ok(invoices_list)
    }

    /// Detach/delete a payment method in Stripe
    pub async fn detach_payment_method(&self, idempotency_key: &str, payment_method_id: &str) -> Result<stripe_types::PaymentMethod, StripeServiceError> {
        // Detach payment method using direct API call with idempotency key
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            &format!("payment_methods/{}/detach", payment_method_id),
            None, // POST /v1/payment_methods/:id/detach doesn't require body data
            Some(idempotency_key),
        ).await?;
        
        // Parse the response into a PaymentMethod struct
        let payment_method: stripe_types::PaymentMethod = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse payment method response: {}", e)))?;
        
        info!("Detached payment method: {}", payment_method_id);
        Ok(payment_method)
    }

    /// Set default payment method for a customer in Stripe
    pub async fn set_default_payment_method(&self, idempotency_key: &str, customer_id: &str, payment_method_id: &str) -> Result<stripe_types::Customer, StripeServiceError> {
        // Set default payment method using direct API call with idempotency key
        let update_data = serde_json::json!({
            "invoice_settings[default_payment_method]": payment_method_id
        });
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            &format!("customers/{}", customer_id),
            Some(update_data),
            Some(idempotency_key),
        ).await?;
        
        // Parse the response into a Customer struct
        let customer: stripe_types::Customer = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse customer response: {}", e)))?;
        info!("Set default payment method {} for customer: {}", payment_method_id, customer_id);
        
        Ok(customer)
    }

    /// Create a product and price (for credit purchases and one-time payments)
    pub async fn create_product_and_price(
        &self,
        idempotency_key: &str,
        product_name: &str,
        price_amount: i64,
        currency: &str,
        interval: Option<&str>,
    ) -> Result<(stripe_types::Product, stripe_types::Price), StripeServiceError> {
        // Create product using direct API call with idempotency key
        let product_data = serde_json::json!({
            "name": product_name,
            "type": "service"
        });
        
        let product_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "products",
            Some(product_data),
            Some(&format!("{}_product", idempotency_key)),
        ).await?;
        
        let product: stripe_types::Product = serde_json::from_value(product_response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse product response: {}", e)))?;
        
        // Create price using direct API call with idempotency key
        let mut price_data = serde_json::json!({
            "currency": currency.to_lowercase(),
            "product": product.id,
            "unit_amount": price_amount
        });
        
        // Add recurring information only if interval is provided (recurring credit plans)
        if let Some(recurring_interval) = interval {
            price_data["recurring[interval]"] = serde_json::Value::String(recurring_interval.to_string());
        }
        
        let price_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "prices",
            Some(price_data),
            Some(&format!("{}_price", idempotency_key)),
        ).await?;
        
        let price: stripe_types::Price = serde_json::from_value(price_response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse price response: {}", e)))?;
        
        info!("Created product {} and price {} for {}", product.id, price.id, product_name);
        Ok((product, price))
    }


    /// Create a SetupIntent for saving payment method without charging (required by handlers)
    pub async fn create_setup_intent(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        metadata: HashMap<String, String>,
    ) -> Result<stripe_types::SetupIntent, StripeServiceError> {
        
        // Create setup intent using direct API call with idempotency key
        let mut setup_data = serde_json::json!({
            "customer": customer_id
        });
        
        // Add metadata
        for (key, value) in metadata {
            setup_data[format!("metadata[{}]", key)] = serde_json::Value::String(value);
        }
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "setup_intents",
            Some(setup_data),
            Some(idempotency_key),
        ).await?;
        
        let setup_intent: stripe_types::SetupIntent = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse setup intent response: {}", e)))?;
        
        info!("Created SetupIntent for customer: {}", customer_id);
        Ok(setup_intent)
    }

    /// Retrieve a SetupIntent by ID
    pub async fn get_setup_intent(&self, setup_intent_id: &str) -> Result<stripe_types::SetupIntent, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("setup_intents/{}", setup_intent_id),
            None,
            None,
        ).await?;
        let setup_intent: stripe_types::SetupIntent = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse setup intent response: {}", e)))?;
        Ok(setup_intent)
    }

    /// Create a Stripe Checkout Session (generic for payment and setup modes)
    pub async fn create_checkout_session(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        user_id: &uuid::Uuid,
        mode: &str,
        line_items: Option<Vec<stripe_types::CreateCheckoutSessionLineItems>>,
        success_url: &str,
        cancel_url: &str,
        metadata: HashMap<String, String>,
        billing_address_collection: Option<bool>,
        automatic_tax: Option<bool>,
        invoice_creation_enabled: Option<bool>,
        price_data: Option<serde_json::Value>,
    ) -> Result<stripe_types::CheckoutSession, StripeServiceError> {
        // Create checkout session using direct API call with idempotency key
        let mode_str = mode;
        
        // Ensure success_url includes the session ID placeholder for payment verification
        let success_url_with_session = if success_url.contains("{CHECKOUT_SESSION_ID}") {
            success_url.to_string()
        } else {
            // Add session ID placeholder if not present
            let separator = if success_url.contains('?') { "&" } else { "?" };
            format!("{}{}", success_url, separator) + "session_id={CHECKOUT_SESSION_ID}"
        };
        
        let mut session_data = serde_json::json!({
            "customer": customer_id,
            "client_reference_id": user_id.to_string(),
            "mode": mode_str,
            "success_url": success_url_with_session,
            "cancel_url": cancel_url,
            "currency": "usd"
        });
        
        // Only set line_items for non-Setup modes
        // Setup mode is for saving payment methods and doesn't require line_items
        if mode_str != "setup" {
            if let Some(items) = line_items {
                let mut line_items_array = Vec::new();
                for item in items.iter() {
                    let mut line_item = serde_json::Map::new();
                    if let Some(price) = &item.price {
                        line_item.insert("price".to_string(), serde_json::Value::String(price.clone()));
                    }
                    if let Some(quantity) = item.quantity {
                        line_item.insert("quantity".to_string(), serde_json::Value::Number(serde_json::Number::from(quantity)));
                    }
                    line_items_array.push(serde_json::Value::Object(line_item));
                }
                session_data["line_items"] = serde_json::Value::Array(line_items_array);
            } else if let Some(price_data_value) = price_data {
                // Use price_data when provided instead of price ID
                let mut line_item = serde_json::Map::new();
                line_item.insert("price_data".to_string(), price_data_value);
                line_item.insert("quantity".to_string(), serde_json::Value::Number(serde_json::Number::from(1)));
                session_data["line_items"] = serde_json::Value::Array(vec![serde_json::Value::Object(line_item)]);
            }
        }
        
        match mode_str {
            "payment" => {
                let mut payment_intent_data = serde_json::Map::new();
                
                // Add capture_method for automatic payment capture
                payment_intent_data.insert("capture_method".to_string(), serde_json::Value::String("automatic".to_string()));
                
                // Add metadata to payment_intent_data
                if !metadata.is_empty() {
                    let mut metadata_obj = serde_json::Map::new();
                    for (key, value) in &metadata {
                        metadata_obj.insert(key.clone(), serde_json::Value::String(value.clone()));
                    }
                    payment_intent_data.insert("metadata".to_string(), serde_json::Value::Object(metadata_obj));
                }
                
                
                if !payment_intent_data.is_empty() {
                    session_data["payment_intent_data"] = serde_json::Value::Object(payment_intent_data);
                }
            }
            "setup" => {
                if !metadata.is_empty() {
                    let mut setup_intent_data = serde_json::Map::new();
                    let mut metadata_obj = serde_json::Map::new();
                    for (key, value) in &metadata {
                        metadata_obj.insert(key.clone(), serde_json::Value::String(value.clone()));
                    }
                    setup_intent_data.insert("metadata".to_string(), serde_json::Value::Object(metadata_obj));
                    session_data["setup_intent_data"] = serde_json::Value::Object(setup_intent_data);
                }
            }
            _ => {}
        }
        
        // Add billing address collection if specified
        if let Some(collect_billing) = billing_address_collection {
            if collect_billing {
                session_data["billing_address_collection"] = serde_json::Value::String("required".to_string());
            }
        }
        
        // Add automatic tax if specified
        if let Some(auto_tax) = automatic_tax {
            if auto_tax {
                let mut automatic_tax_obj = serde_json::Map::new();
                automatic_tax_obj.insert("enabled".to_string(), serde_json::Value::Bool(true));
                session_data["automatic_tax"] = serde_json::Value::Object(automatic_tax_obj);
            }
        }
        
        // Add invoice creation if enabled for payment mode
        if mode_str == "payment" {
            if let Some(true) = invoice_creation_enabled {
                let mut invoice_creation = serde_json::Map::new();
                invoice_creation.insert("enabled".to_string(), serde_json::Value::Bool(true));
                session_data["invoice_creation"] = serde_json::Value::Object(invoice_creation);
            }
        }
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "checkout/sessions",
            Some(session_data),
            Some(idempotency_key),
        ).await?;
        
        // Parse the response into a CheckoutSession struct
        let session: stripe_types::CheckoutSession = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse checkout session response: {}", e)))?;
        
        info!("Created Checkout Session: {} for customer: {}", session.id, customer_id);
        Ok(session)
    }

    /// Get a checkout session by ID
    pub async fn get_checkout_session(&self, session_id: &str) -> Result<stripe_types::CheckoutSession, StripeServiceError> {
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::GET,
            &format!("checkout/sessions/{}", session_id),
            None,
            None,
        ).await?;
        let session: stripe_types::CheckoutSession = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse checkout session response: {}", e)))?;
        Ok(session)
    }

    /// Create and automatically charge an invoice for auto top-off
    /// This method creates an invoice with auto_advance enabled, letting Stripe handle
    /// the payment automatically - fire-and-forget approach relying on webhooks
    pub async fn create_and_pay_invoice(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        amount_cents: i64,
        currency: &str,
        description: &str,
    ) -> Result<stripe_types::Invoice, StripeServiceError> {
        info!("Creating auto-charging invoice for customer: {} with amount: {} {}", customer_id, amount_cents, currency);
        
        // First, create an invoice item
        let invoice_item_data = serde_json::json!({
            "customer": customer_id,
            "amount": amount_cents,
            "currency": currency.to_lowercase(),
            "description": description,
        });

        let _invoice_item = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "invoiceitems",
            Some(invoice_item_data),
            Some(&format!("{}_item", idempotency_key)),
        ).await?;

        // Create the invoice with automatic payment collection
        // Setting auto_advance: true and collection_method: charge_automatically
        // makes Stripe automatically finalize and charge the invoice
        let invoice_data = serde_json::json!({
            "customer": customer_id,
            "auto_advance": true, // Automatically finalize and attempt payment
            "collection_method": "charge_automatically", // Charge the default payment method
            "description": description,
            "metadata": {
                "type": "auto_topoff",
                "created_by": "vibe_manager"
            }
        });

        let invoice_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "invoices",
            Some(invoice_data),
            Some(&format!("{}_invoice", idempotency_key)),
        ).await?;

        // Parse the invoice response and return immediately
        let invoice: stripe_types::Invoice = serde_json::from_value(invoice_response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse invoice response: {}", e)))?;

        info!("Successfully created auto-charging invoice: {} for customer: {} - relying on webhooks for fulfillment", invoice.id, customer_id);
        Ok(invoice)
    }

}

