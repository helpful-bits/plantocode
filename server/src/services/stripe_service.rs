// STRIPE API IDEMPOTENCY REQUIREMENTS:
//
// All mutating Stripe API operations (POST requests) MUST include an `Idempotency-Key` header
// to ensure safe retry behavior and prevent duplicate operations in case of network failures
// or application restarts.
//
// IDEMPOTENCY KEY REQUIREMENTS:
// 1. Each distinct operation MUST have a unique idempotency key
// 2. Keys should be UUIDs or similar unique identifiers
// 3. Keys MUST be reused for retries of the same logical operation
// 4. Keys should NOT be reused across different operations
// 5. Idempotency keys expire after 24 hours in Stripe's system
//
// CURRENT IMPLEMENTATION STATUS:
// - ✅ This service now implements idempotency key handling
// - ✅ All mutating methods accept an idempotency_key parameter
// - ✅ BillingService generates unique UUIDs for each operation
// - Note: PaymentMethod::detach may need library-specific idempotency handling
//
// RECOMMENDED IMPLEMENTATION:
// ```rust
// pub async fn create_customer_with_idempotency(
//     &self,
//     idempotency_key: &str,  // Add this parameter
//     user_id: &Uuid,
//     email: &str,
//     name: Option<&str>
// ) -> Result<Customer, StripeServiceError> {
//     // Set idempotency key in request headers
//     // self.client.set_idempotency_key(idempotency_key);
//     // ... rest of implementation
// }
// ```
//
// CRITICAL FOR BILLING OPERATIONS:
// - Payment processing operations MUST be idempotent to prevent double charges
// - Subscription creation/modification MUST be idempotent to prevent duplicate subscriptions
// - Usage record reporting MUST be idempotent to prevent double billing
//
use stripe::{
    Client, CreateCustomer, CreatePaymentIntent, CreateSetupIntent, CreateSubscription,
    CreateBillingPortalSession, PaymentIntent, SetupIntent, 
    Subscription, Customer, BillingPortalSession, Event, EventType,
    PaymentIntentStatus, SubscriptionStatus, Currency,
    PaymentIntentConfirmationMethod, SubscriptionItem,
    CreateSubscriptionItem, Price, Expandable, Invoice, PaymentMethod,
    ListPaymentMethods, CreatePrice, Product, CreateProduct, CreatePriceRecurringInterval, CreatePriceRecurring,
    ApiVersion,
    CreateInvoice, InvoiceStatus, ListInvoices, CreateInvoiceItem, InvoiceItem,
    CheckoutSession, CreateCheckoutSession, CheckoutSessionMode,
};
use reqwest::header::{HeaderMap, HeaderValue, AUTHORIZATION, CONTENT_TYPE};
use chrono::{DateTime, Utc};
use hmac::{Hmac, Mac};
use sha2::Sha256;
use std::collections::HashMap;
use uuid::Uuid;
use log::{debug, error, info, warn};
use hex;

#[derive(Debug, thiserror::Error)]
pub enum StripeServiceError {
    #[error("Stripe API error: {0}")]
    StripeApi(#[from] stripe::StripeError),
    #[error("Webhook verification failed: {0}")]
    WebhookVerification(String),
    #[error("Invalid configuration: {0}")]
    Configuration(String),
    #[error("Payment processing error: {0}")]
    PaymentProcessing(String),
    #[error("Subscription management error: {0}")]
    SubscriptionManagement(String),
}

type HmacSha256 = Hmac<Sha256>;


// Stripe Customer Portal Configuration Required:
// 1. Enable subscription cancellation
// 2. Enable plan changes with immediate/end-of-period options
// 3. Enable payment method updates
// 4. Enable invoice access
// 5. Set return URL to app billing page
// 6. Configure business branding

/// Stripe service for handling payment processing and subscription management
/// 
/// IMPORTANT: This service implements Stripe's idempotency requirements.
/// All mutating operations include idempotency keys to prevent:
/// - Duplicate payments
/// - Duplicate subscriptions  
/// - Duplicate usage records
/// - Data inconsistencies during retries
/// 
/// Idempotency keys are generated by the calling service (BillingService) as UUIDs.
#[derive(Clone)]
pub struct StripeService {
    client: Client,
    webhook_secret: String,
    publishable_key: String,
    secret_key: String,
    http_client: reqwest::Client,
}

impl std::fmt::Debug for StripeService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("StripeService")
            .field("client", &"<stripe::Client>")
            .field("webhook_secret", &"<redacted>")
            .field("publishable_key", &self.publishable_key)
            .finish()
    }
}

impl StripeService {
    pub fn new(secret_key: String, webhook_secret: String, publishable_key: String) -> Self {
        let client = Client::new(secret_key.clone());
        let http_client = reqwest::Client::new();
        
        // Note: API version is managed by the async-stripe library version
        // This library version corresponds to API version 2023-10-16
        
        Self {
            client,
            webhook_secret,
            publishable_key,
            secret_key,
            http_client,
        }
    }

    pub fn get_publishable_key(&self) -> &str {
        &self.publishable_key
    }

    /// Make a direct authenticated request to Stripe API with idempotency key
    async fn make_stripe_request_with_idempotency(
        &self,
        method: reqwest::Method,
        endpoint: &str,
        body: Option<serde_json::Value>,
        idempotency_key: &str,
    ) -> Result<serde_json::Value, StripeServiceError> {
        let url = format!("https://api.stripe.com/v1/{}", endpoint);
        
        let mut headers = HeaderMap::new();
        headers.insert(AUTHORIZATION, HeaderValue::from_str(&format!("Bearer {}", self.secret_key))
            .map_err(|_| StripeServiceError::Configuration("Invalid secret key format".to_string()))?);
        headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/x-www-form-urlencoded"));
        headers.insert("Idempotency-Key", HeaderValue::from_str(idempotency_key)
            .map_err(|_| StripeServiceError::Configuration("Invalid idempotency key format".to_string()))?);
        headers.insert("Stripe-Version", HeaderValue::from_static("2023-10-16"));
        
        let mut request = self.http_client.request(method, &url).headers(headers);
        
        if let Some(body_data) = body {
            // Convert JSON to form-encoded data for Stripe API
            let form_data = self.json_to_form_data(body_data)?;
            request = request.body(form_data);
        }
        
        let response = request.send().await
            .map_err(|e| StripeServiceError::Configuration(format!("HTTP request failed: {}", e)))?;
        
        if !response.status().is_success() {
            let error_text = response.text().await
                .unwrap_or_else(|_| "Unknown error".to_string());
            return Err(StripeServiceError::Configuration(format!("Stripe API error: {}", error_text)));
        }
        
        let response_json: serde_json::Value = response.json().await
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse response: {}", e)))?;
        
        Ok(response_json)
    }
    
    /// Convert JSON object to form-encoded data for Stripe API
    fn json_to_form_data(&self, json: serde_json::Value) -> Result<String, StripeServiceError> {
        fn flatten_object(obj: &serde_json::Value, prefix: &str, params: &mut Vec<(String, String)>) {
            match obj {
                serde_json::Value::Object(map) => {
                    for (key, value) in map {
                        let new_key = if prefix.is_empty() {
                            key.clone()
                        } else {
                            format!("{}[{}]", prefix, key)
                        };
                        flatten_object(value, &new_key, params);
                    }
                }
                serde_json::Value::Array(arr) => {
                    for (index, value) in arr.iter().enumerate() {
                        let new_key = format!("{}[{}]", prefix, index);
                        flatten_object(value, &new_key, params);
                    }
                }
                value => {
                    let string_value = match value {
                        serde_json::Value::String(s) => s.clone(),
                        serde_json::Value::Number(n) => n.to_string(),
                        serde_json::Value::Bool(b) => b.to_string(),
                        serde_json::Value::Null => return,
                        _ => return,
                    };
                    params.push((prefix.to_string(), string_value));
                }
            }
        }
        
        let mut params = Vec::new();
        flatten_object(&json, "", &mut params);
        
        let form_string = params
            .into_iter()
            .map(|(k, v)| format!("{}={}", urlencoding::encode(&k), urlencoding::encode(&v)))
            .collect::<Vec<_>>()
            .join("&");
        
        Ok(form_string)
    }

    /// Verify webhook signature
    pub fn verify_webhook_signature(
        &self,
        payload: &str,
        signature: &str,
    ) -> Result<(), StripeServiceError> {
        let elements: Vec<&str> = signature.split(',').collect();
        let mut timestamp = "";
        let mut signatures = Vec::new();

        for element in elements {
            if let Some(t) = element.strip_prefix("t=") {
                timestamp = t;
            } else if let Some(s) = element.strip_prefix("v1=") {
                signatures.push(s);
            }
        }

        if timestamp.is_empty() || signatures.is_empty() {
            return Err(StripeServiceError::WebhookVerification(
                "Invalid signature format".to_string(),
            ));
        }

        let signed_payload = format!("{}.{}", timestamp, payload);
        
        let mut mac = HmacSha256::new_from_slice(self.webhook_secret.as_bytes())
            .map_err(|e| StripeServiceError::WebhookVerification(format!("HMAC error: {}", e)))?;
        
        mac.update(signed_payload.as_bytes());
        let expected_signature = hex::encode(mac.finalize().into_bytes());

        for signature in signatures {
            if signature == expected_signature {
                return Ok(());
            }
        }

        Err(StripeServiceError::WebhookVerification(
            "Signature verification failed".to_string(),
        ))
    }

    /// Parse webhook event from payload
    pub fn parse_webhook_event(&self, payload: &str) -> Result<Event, StripeServiceError> {
        let event: Event = serde_json::from_str(payload)
            .map_err(|e| StripeServiceError::WebhookVerification(format!("Failed to parse event: {}", e)))?;
        Ok(event)
    }

    /// Create or retrieve existing customer
    pub async fn create_or_get_customer(
        &self,
        idempotency_key: &str,
        user_id: &Uuid,
        email: &str,
        name: Option<&str>,
        existing_customer_id: Option<&str>,
    ) -> Result<Customer, StripeServiceError> {
        // If we have an existing customer ID, try to retrieve it first
        if let Some(customer_id) = existing_customer_id {
            let parsed_customer_id = customer_id.parse()
                .map_err(|_| StripeServiceError::Configuration("Invalid Stripe customer ID format".to_string()))?;
            match Customer::retrieve(&self.client, &parsed_customer_id, &[]).await {
                Ok(customer) => return Ok(customer),
                Err(e) => {
                    warn!("Failed to retrieve existing customer {}: {}", customer_id, e);
                }
            }
        }

        // Create new customer using direct API call with idempotency key
        let mut customer_data = serde_json::json!({
            "email": email
        });
        
        if let Some(name_value) = name {
            customer_data["name"] = serde_json::Value::String(name_value.to_string());
        }
        
        // Add metadata
        customer_data["metadata[user_id]"] = serde_json::Value::String(user_id.to_string());
        customer_data["metadata[created_by]"] = serde_json::Value::String("vibe_manager".to_string());
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "customers",
            Some(customer_data),
            idempotency_key,
        ).await?;
        
        // Parse the response into a Customer struct using the stripe library's deserializer
        let customer: Customer = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse customer response: {}", e)))?;
        
        info!("Created Stripe customer: {} for user: {}", customer.id, user_id);
        
        Ok(customer)
    }

    /// Retrieve a customer by ID
    pub async fn get_customer(&self, customer_id: &str) -> Result<Customer, StripeServiceError> {
        let parsed_customer_id = customer_id.parse()
            .map_err(|_| StripeServiceError::Configuration("Invalid Stripe customer ID format".to_string()))?;
        let customer = Customer::retrieve(&self.client, &parsed_customer_id, &[]).await?;
        Ok(customer)
    }

    /// Create a payment intent for processing payments
    pub async fn create_payment_intent(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        amount_cents: i64,
        currency: &str,
        description: &str,
        metadata: HashMap<String, String>,
        save_payment_method: bool,
    ) -> Result<PaymentIntent, StripeServiceError> {
        // Create payment intent using direct API call with idempotency key
        let mut payment_data = serde_json::json!({
            "amount": amount_cents,
            "currency": currency.to_lowercase(),
            "customer": customer_id,
            "confirmation_method": "automatic"
        });
        
        if let Some(desc) = Option::from(description) {
            payment_data["description"] = serde_json::Value::String(desc.to_string());
        }
        
        // Add metadata
        for (key, value) in metadata {
            payment_data[format!("metadata[{}]", key)] = serde_json::Value::String(value);
        }
        
        if save_payment_method {
            payment_data["setup_future_usage"] = serde_json::Value::String("off_session".to_string());
        }
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "payment_intents",
            Some(payment_data),
            idempotency_key,
        ).await?;
        
        // Parse the response into a PaymentIntent struct
        let payment_intent: PaymentIntent = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse payment intent response: {}", e)))?;
        
        info!("Created PaymentIntent: {} for customer: {}", payment_intent.id, customer_id);
        Ok(payment_intent)
    }

    /// Create a subscription with trial period (simple version only)
    /// Complex subscription management should be done via Customer Portal
    pub async fn create_subscription_with_trial(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        price_id: &str,
        trial_days: Option<i64>,
        metadata: HashMap<String, String>,
    ) -> Result<Subscription, StripeServiceError> {
        // Create subscription using direct API call with idempotency key
        let mut subscription_data = serde_json::json!({
            "customer": customer_id,
            "items[0][price]": price_id,
            "items[0][quantity]": 1,
            "expand[]": "latest_invoice.payment_intent"
        });
        
        // Set trial period
        if let Some(days) = trial_days {
            let trial_end = Utc::now() + chrono::Duration::days(days);
            subscription_data["trial_end"] = serde_json::Value::Number(serde_json::Number::from(trial_end.timestamp()));
        }
        
        // Add metadata
        for (key, value) in metadata {
            subscription_data[format!("metadata[{}]", key)] = serde_json::Value::String(value);
        }
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "subscriptions",
            Some(subscription_data),
            idempotency_key,
        ).await?;
        
        // Parse the response into a Subscription struct
        let subscription: Subscription = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse subscription response: {}", e)))?;
        
        info!("Created subscription: {} for customer: {}", subscription.id, customer_id);
        Ok(subscription)
    }

    /// Create billing portal session for customer self-service
    /// This is the primary method for complex billing operations
    pub async fn create_billing_portal_session(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        return_url: &str,
    ) -> Result<BillingPortalSession, StripeServiceError> {
        // Create billing portal session using direct API call with idempotency key
        let session_data = serde_json::json!({
            "customer": customer_id,
            "return_url": return_url
        });
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "billing_portal/sessions",
            Some(session_data),
            idempotency_key,
        ).await?;
        
        // Parse the response into a BillingPortalSession struct
        let session: BillingPortalSession = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse billing portal session response: {}", e)))?;
        
        info!("Created billing portal session for customer: {}", customer_id);
        Ok(session)
    }

    /// Retrieve a PaymentIntent by ID
    pub async fn get_payment_intent(&self, payment_intent_id: &str) -> Result<PaymentIntent, StripeServiceError> {
        let parsed_payment_intent_id = payment_intent_id.parse()
            .map_err(|_| StripeServiceError::Configuration("Invalid Stripe payment intent ID format".to_string()))?;
        let payment_intent = PaymentIntent::retrieve(&self.client, &parsed_payment_intent_id, &[]).await?;
        Ok(payment_intent)
    }

    /// Retrieve a subscription by ID (basic info only)
    pub async fn get_subscription(&self, subscription_id: &str) -> Result<Subscription, StripeServiceError> {
        let parsed_subscription_id = subscription_id.parse()
            .map_err(|_| StripeServiceError::Configuration("Invalid Stripe subscription ID format".to_string()))?;
        let subscription = Subscription::retrieve(&self.client, &parsed_subscription_id, &[]).await?;
        Ok(subscription)
    }


    

    /// List payment methods for a customer from Stripe
    pub async fn list_payment_methods(&self, customer_id: &str) -> Result<Vec<PaymentMethod>, StripeServiceError> {
        let parsed_customer_id = customer_id.parse()
            .map_err(|_| StripeServiceError::Configuration("Invalid Stripe customer ID format".to_string()))?;
        
        let mut list_params = ListPaymentMethods::new();
        list_params.customer = Some(parsed_customer_id);
        list_params.type_ = Some(stripe::PaymentMethodTypeFilter::Card);

        let payment_methods = PaymentMethod::list(&self.client, &list_params).await?;
        info!("Retrieved {} payment methods for customer: {}", payment_methods.data.len(), customer_id);
        
        Ok(payment_methods.data)
    }

    /// List invoices for a customer from Stripe
    pub async fn list_invoices(&self, customer_id: &str) -> Result<Vec<Invoice>, StripeServiceError> {
        let parsed_customer_id = customer_id.parse()
            .map_err(|_| StripeServiceError::Configuration("Invalid Stripe customer ID format".to_string()))?;
        
        let mut list_params = ListInvoices::new();
        list_params.customer = Some(parsed_customer_id);
        list_params.limit = Some(100); // Reasonable limit

        let invoices = Invoice::list(&self.client, &list_params).await?;
        info!("Retrieved {} invoices for customer: {}", invoices.data.len(), customer_id);
        
        Ok(invoices.data)
    }

    /// List invoices for a customer from Stripe with status filter and pagination
    pub async fn list_invoices_with_filter(&self, customer_id: &str, status: Option<&str>, limit: Option<u64>, starting_after: Option<&str>) -> Result<Vec<Invoice>, StripeServiceError> {
        let parsed_customer_id = customer_id.parse()
            .map_err(|_| StripeServiceError::Configuration("Invalid Stripe customer ID format".to_string()))?;
        
        let mut list_params = ListInvoices::new();
        list_params.customer = Some(parsed_customer_id);
        
        // Pass pagination parameters directly to Stripe API
        list_params.limit = limit;
        if let Some(starting_after_value) = starting_after {
            list_params.starting_after = Some(starting_after_value.parse()
                .map_err(|_| StripeServiceError::Configuration("Invalid starting_after invoice ID format".to_string()))?);
        }
        
        // Set status filter if provided
        if let Some(status_str) = status {
            list_params.status = match status_str.to_lowercase().as_str() {
                "draft" => Some(InvoiceStatus::Draft),
                "open" => Some(InvoiceStatus::Open),
                "paid" => Some(InvoiceStatus::Paid),
                "uncollectible" => Some(InvoiceStatus::Uncollectible),
                "void" => Some(InvoiceStatus::Void),
                _ => None, // Unknown status, ignore filter
            };
        }

        let invoices = Invoice::list(&self.client, &list_params).await?;
        info!("Retrieved {} invoices for customer: {} with pagination (limit: {:?}, starting_after: {:?})", invoices.data.len(), customer_id, limit, starting_after);
        
        Ok(invoices.data)
    }

    /// Detach/delete a payment method in Stripe
    pub async fn detach_payment_method(&self, idempotency_key: &str, payment_method_id: &str) -> Result<PaymentMethod, StripeServiceError> {
        // Detach payment method using direct API call with idempotency key
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            &format!("payment_methods/{}/detach", payment_method_id),
            None, // POST /v1/payment_methods/:id/detach doesn't require body data
            idempotency_key,
        ).await?;
        
        // Parse the response into a PaymentMethod struct
        let payment_method: PaymentMethod = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse payment method response: {}", e)))?;
        
        info!("Detached payment method: {}", payment_method_id);
        Ok(payment_method)
    }

    /// Set default payment method for a customer in Stripe
    pub async fn set_default_payment_method(&self, idempotency_key: &str, customer_id: &str, payment_method_id: &str) -> Result<Customer, StripeServiceError> {
        // Set default payment method using direct API call with idempotency key
        let update_data = serde_json::json!({
            "invoice_settings[default_payment_method]": payment_method_id
        });
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            &format!("customers/{}", customer_id),
            Some(update_data),
            idempotency_key,
        ).await?;
        
        // Parse the response into a Customer struct
        let customer: Customer = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse customer response: {}", e)))?;
        info!("Set default payment method {} for customer: {}", payment_method_id, customer_id);
        
        Ok(customer)
    }

    /// Create a product and price (for both subscriptions and one-time payments)
    pub async fn create_product_and_price(
        &self,
        idempotency_key: &str,
        product_name: &str,
        price_amount: i64,
        currency: Currency,
        interval: Option<stripe::CreatePriceRecurringInterval>,
    ) -> Result<(Product, Price), StripeServiceError> {
        // Create product using direct API call with idempotency key
        let product_data = serde_json::json!({
            "name": product_name,
            "type": "service"
        });
        
        let product_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "products",
            Some(product_data),
            &format!("{}_product", idempotency_key),
        ).await?;
        
        let product: Product = serde_json::from_value(product_response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse product response: {}", e)))?;
        
        // Create price using direct API call with idempotency key
        let mut price_data = serde_json::json!({
            "currency": currency.to_string().to_lowercase(),
            "product": product.id.to_string(),
            "unit_amount": price_amount
        });
        
        // Add recurring information only if interval is provided (subscription)
        if let Some(recurring_interval) = interval {
            let interval_str = match recurring_interval {
                stripe::CreatePriceRecurringInterval::Day => "day",
                stripe::CreatePriceRecurringInterval::Week => "week",
                stripe::CreatePriceRecurringInterval::Month => "month",
                stripe::CreatePriceRecurringInterval::Year => "year",
            };
            price_data["recurring[interval]"] = serde_json::Value::String(interval_str.to_string());
        }
        
        let price_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "prices",
            Some(price_data),
            &format!("{}_price", idempotency_key),
        ).await?;
        
        let price: Price = serde_json::from_value(price_response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse price response: {}", e)))?;
        
        info!("Created product {} and price {} for {}", product.id, price.id, product_name);
        Ok((product, price))
    }


    /// Create a SetupIntent for saving payment method without charging (required by handlers)
    pub async fn create_setup_intent(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        metadata: HashMap<String, String>,
    ) -> Result<SetupIntent, StripeServiceError> {
        
        // Create setup intent using direct API call with idempotency key
        let mut setup_data = serde_json::json!({
            "customer": customer_id
        });
        
        // Add metadata
        for (key, value) in metadata {
            setup_data[format!("metadata[{}]", key)] = serde_json::Value::String(value);
        }
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "setup_intents",
            Some(setup_data),
            idempotency_key,
        ).await?;
        
        let setup_intent: SetupIntent = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse setup intent response: {}", e)))?;
        
        info!("Created SetupIntent for customer: {}", customer_id);
        Ok(setup_intent)
    }

    /// Create a Stripe Checkout Session (generic for payment and subscription modes)
    pub async fn create_checkout_session(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        mode: CheckoutSessionMode,
        line_items: Option<Vec<stripe::CreateCheckoutSessionLineItems>>,
        success_url: &str,
        cancel_url: &str,
        metadata: HashMap<String, String>,
        billing_address_collection: Option<bool>,
        automatic_tax: Option<bool>,
    ) -> Result<CheckoutSession, StripeServiceError> {
        // Create checkout session using direct API call with idempotency key
        let mode_str = match mode {
            CheckoutSessionMode::Payment => "payment",
            CheckoutSessionMode::Setup => "setup",
            CheckoutSessionMode::Subscription => "subscription",
        };
        
        let mut session_data = serde_json::json!({
            "customer": customer_id,
            "mode": mode_str,
            "success_url": success_url,
            "cancel_url": cancel_url
        });
        
        // Only set line_items for non-Setup modes
        // Setup mode is for saving payment methods and doesn't require line_items
        if !matches!(mode, CheckoutSessionMode::Setup) {
            if let Some(items) = line_items {
                for (index, item) in items.iter().enumerate() {
                    if let Some(price) = &item.price {
                        session_data[format!("line_items[{}][price]", index)] = serde_json::Value::String(price.to_string());
                    }
                    if let Some(quantity) = item.quantity {
                        session_data[format!("line_items[{}][quantity]", index)] = serde_json::Value::Number(serde_json::Number::from(quantity));
                    }
                }
            }
        }
        
        // Add metadata
        for (key, value) in metadata {
            session_data[format!("metadata[{}]", key)] = serde_json::Value::String(value);
        }
        
        // Add billing address collection if specified
        if let Some(collect_billing) = billing_address_collection {
            if collect_billing {
                session_data["billing_address_collection"] = serde_json::Value::String("required".to_string());
            }
        }
        
        // Add automatic tax if specified
        if let Some(auto_tax) = automatic_tax {
            if auto_tax {
                session_data["automatic_tax[enabled]"] = serde_json::Value::Bool(true);
            }
        }
        
        let response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "checkout/sessions",
            Some(session_data),
            idempotency_key,
        ).await?;
        
        // Parse the response into a CheckoutSession struct
        let session: CheckoutSession = serde_json::from_value(response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse checkout session response: {}", e)))?;
        
        info!("Created Checkout Session: {} for customer: {}", session.id, customer_id);
        Ok(session)
    }

    /// Get a checkout session by ID
    pub async fn get_checkout_session(&self, session_id: &str) -> Result<CheckoutSession, StripeServiceError> {
        let parsed_session_id = session_id.parse()
            .map_err(|_| StripeServiceError::Configuration("Invalid Stripe session ID format".to_string()))?;
        let session = CheckoutSession::retrieve(&self.client, &parsed_session_id, &[]).await?;
        Ok(session)
    }

    /// Create and immediately pay an invoice for auto top-off
    pub async fn create_and_pay_invoice(
        &self,
        idempotency_key: &str,
        customer_id: &str,
        amount_cents: i64,
        currency: &str,
        description: &str,
    ) -> Result<Invoice, StripeServiceError> {
        info!("Creating and paying invoice for customer: {} with amount: {} {}", customer_id, amount_cents, currency);
        
        // First, create an invoice item
        let invoice_item_data = serde_json::json!({
            "customer": customer_id,
            "amount": amount_cents,
            "currency": currency.to_lowercase(),
            "description": description,
        });

        let _invoice_item = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "invoiceitems",
            Some(invoice_item_data),
            &format!("{}_item", idempotency_key),
        ).await?;

        // Create the invoice
        let invoice_data = serde_json::json!({
            "customer": customer_id,
            "auto_advance": true, // Automatically finalize and attempt payment
            "collection_method": "charge_automatically",
            "description": description,
        });

        let invoice_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            "invoices",
            Some(invoice_data),
            &format!("{}_invoice", idempotency_key),
        ).await?;

        let invoice_id = invoice_response["id"].as_str()
            .ok_or_else(|| StripeServiceError::Configuration("Invalid invoice response".to_string()))?;

        // Finalize the invoice
        let finalize_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            &format!("invoices/{}/finalize", invoice_id),
            Some(serde_json::json!({})),
            &format!("{}_finalize", idempotency_key),
        ).await?;

        // Pay the invoice
        let pay_response = self.make_stripe_request_with_idempotency(
            reqwest::Method::POST,
            &format!("invoices/{}/pay", invoice_id),
            Some(serde_json::json!({})),
            &format!("{}_pay", idempotency_key),
        ).await?;

        // Parse the final invoice response
        let invoice: Invoice = serde_json::from_value(pay_response)
            .map_err(|e| StripeServiceError::Configuration(format!("Failed to parse invoice response: {}", e)))?;

        info!("Successfully created and paid invoice: {} for customer: {}", invoice.id, customer_id);
        Ok(invoice)
    }


}

/// Helper function to convert Currency enum from string
pub fn currency_from_str(s: &str) -> Result<Currency, StripeServiceError> {
    match s.to_lowercase().as_str() {
        "usd" => Ok(Currency::USD),
        "eur" => Ok(Currency::EUR),
        "gbp" => Ok(Currency::GBP),
        "cad" => Ok(Currency::CAD),
        "aud" => Ok(Currency::AUD),
        "jpy" => Ok(Currency::JPY),
        _ => Err(StripeServiceError::Configuration(format!("Unsupported currency: {}", s))),
    }
}