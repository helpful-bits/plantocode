#!/usr/bin/env node

/**
 * Generate TypeScript types from Tauri command definitions
 * 
 * This script uses tauri-bindgen to generate TypeScript definitions
 * from the Rust command function signatures in the Tauri backend.
 */

import { spawn } from 'child_process';
import fs from 'fs';
import path from 'path';

// Paths
const SRC_TAURI_DIR = path.resolve('./src-tauri/src');
const COMMANDS_DIR = path.resolve(SRC_TAURI_DIR, 'commands');
const OUTPUT_DIR = path.resolve('./src/types');
const OUTPUT_FILE = path.resolve(OUTPUT_DIR, 'tauri-commands.d.ts');

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// Header for generated file
const fileHeader = `/**
 * Generated TypeScript definitions for Tauri commands
 * DO NOT EDIT DIRECTLY - This file is generated by generate-tauri-types.mjs
 */

// Command interface definitions
`;

// Start by cleaning previous output
console.log('ðŸ§¹ Cleaning previous output...');
if (fs.existsSync(OUTPUT_FILE)) {
  fs.unlinkSync(OUTPUT_FILE);
}

// Initialize the output file with the header
fs.writeFileSync(OUTPUT_FILE, fileHeader, 'utf8');

console.log('ðŸ“¦ Analyzing Tauri commands...');

// Find all command modules
const commandFiles = fs.readdirSync(COMMANDS_DIR)
  .filter(file => file.endsWith('.rs'))
  .map(file => path.join(COMMANDS_DIR, file));

// Process each command file
commandFiles.forEach(filePath => {
  const fileName = path.basename(filePath);
  console.log(`  Processing ${fileName}...`);
  
  // Read the file content
  const content = fs.readFileSync(filePath, 'utf8');
  
  // Parse command definitions
  const commands = parseCommands(content, fileName);
  
  // Generate TypeScript definitions
  if (commands.length > 0) {
    const typeDefs = generateTypeDefs(commands);
    fs.appendFileSync(OUTPUT_FILE, typeDefs, 'utf8');
  }
});

// Generate the invoke type
generateInvokeType();

console.log('âœ… TypeScript definitions generated successfully!');
console.log(`   Output: ${OUTPUT_FILE}`);

/**
 * Parse Tauri commands from a Rust source file
 */
function parseCommands(content, fileName) {
  const commands = [];
  
  // Basic regex to find #[command] functions
  // Note: This is a simplified approach and might miss some edge cases
  const commandRegex = /#\[command\]\s+(?:pub\s+)?async\s+fn\s+([a-zA-Z0-9_]+)\s*\(([^)]*)\)/g;
  
  let match;
  while ((match = commandRegex.exec(content)) !== null) {
    const name = match[1];
    const params = match[2];
    
    // Parse parameters
    const parameters = parseParameters(params);
    
    commands.push({
      name,
      parameters,
      module: fileName.replace('.rs', '')
    });
  }
  
  return commands;
}

/**
 * Parse parameters from a Rust function signature
 */
function parseParameters(paramsStr) {
  if (!paramsStr.trim()) {
    return [];
  }
  
  const params = [];
  const paramList = paramsStr.split(',');
  
  for (const param of paramList) {
    const parts = param.trim().split(':');
    if (parts.length >= 2) {
      const name = parts[0].trim();
      const type = parts.slice(1).join(':').trim();
      
      // Skip certain parameter types (app_handle, state, etc.)
      if (type.includes('AppHandle') || type.includes('State')) {
        continue;
      }
      
      params.push({ name, type });
    }
  }
  
  return params;
}

/**
 * Generate TypeScript definitions for commands
 */
function generateTypeDefs(commands) {
  let output = `\n// Commands from ${commands[0].module}\n`;
  
  // Generate interface for each command
  for (const cmd of commands) {
    output += `export interface ${capitalize(cmd.name)}Args {\n`;
    
    for (const param of cmd.parameters) {
      const tsType = rustTypeToTypeScript(param.type);
      if (tsType) {
        output += `  ${param.name}: ${tsType};\n`;
      }
    }
    
    output += `}\n\n`;
  }
  
  return output;
}

/**
 * Generate the invoke type definition
 */
function generateInvokeType() {
  const invokeType = `
// Tauri invoke function type
export type TauriInvoke = {
${fs.readdirSync(COMMANDS_DIR)
  .filter(file => file.endsWith('.rs'))
  .map(file => {
    const content = fs.readFileSync(path.join(COMMANDS_DIR, file), 'utf8');
    const commands = parseCommands(content, file);
    
    return commands.map(cmd => {
      const hasParams = cmd.parameters.length > 0;
      return `  "${cmd.name}": ${hasParams ? `(args: ${capitalize(cmd.name)}Args) => Promise<any>` : '() => Promise<any>'};`;
    }).join('\n');
  })
  .filter(Boolean)
  .join('\n')}
};

// Strongly typed invoke function
export declare function invoke<T extends keyof TauriInvoke>(
  command: T,
  ...args: Parameters<TauriInvoke[T]>
): ReturnType<TauriInvoke[T]>;
`;

  fs.appendFileSync(OUTPUT_FILE, invokeType, 'utf8');
}

/**
 * Convert Rust types to TypeScript types
 */
function rustTypeToTypeScript(rustType) {
  // Handle Option types
  if (rustType.startsWith('Option<')) {
    const innerType = rustType.slice(7, -1);
    return `${rustTypeToTypeScript(innerType)} | null`;
  }
  
  // Handle basic types
  switch (rustType) {
    case 'String':
    case '&str':
    case 'str':
      return 'string';
    case 'i8':
    case 'i16':
    case 'i32':
    case 'i64':
    case 'u8':
    case 'u16':
    case 'u32':
    case 'u64':
    case 'f32':
    case 'f64':
    case 'isize':
    case 'usize':
      return 'number';
    case 'bool':
      return 'boolean';
    default:
      if (rustType.includes('HashMap')) {
        return 'Record<string, any>';
      } else if (rustType.includes('Vec<')) {
        const innerType = rustType.match(/Vec<(.+)>/)?.[1];
        if (innerType) {
          return `Array<${rustTypeToTypeScript(innerType)}>`;
        }
        return 'any[]';
      } else if (rustType.includes('serde_json::Value')) {
        return 'any';
      }
      return 'any';
  }
}

/**
 * Capitalize the first letter of a string
 */
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}