import { useState, useMemo, useContext } from "react";
import { Loader2, ChevronDown, ChevronUp, Copy, Eye, Check } from "lucide-react";
import { useNotification } from "@/contexts/notification-context";

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/ui/card";
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "@/ui/collapsible";
import { Progress } from "@/ui/progress";
import { useJobDetailsContext } from "../../_contexts/job-details-context";
import { Button } from "@/ui/button";
import { replacePlaceholders } from "@/utils/placeholder-utils";
import { type CopyButtonConfig } from "@/types/config-types";
import PlanContentModal from "../../../implementation-plans-panel/_components/PlanContentModal";
import { BackgroundJobsContext } from "@/contexts/background-jobs";
import { useLiveProgress } from "@/hooks/use-live-progress";

// Simple copy button component for non-implementation plan content
function SimpleCopyButton({ content }: { content: string }) {
  const [isCopied, setIsCopied] = useState(false);
  const { showNotification } = useNotification();

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(content);
      setIsCopied(true);
      setTimeout(() => setIsCopied(false), 2000);
      
      showNotification({
        title: "Copied to clipboard",
        message: "Response content copied successfully",
        type: "success",
        duration: 2000,
      });
    } catch (err) {
      console.error("Failed to copy to clipboard:", err);
      showNotification({
        title: "Copy failed", 
        message: "Failed to copy to clipboard",
        type: "error",
        duration: 3000,
      });
    }
  };

  return (
    <Button
      variant="outline"
      size="sm"
      className="text-xs h-7 px-2 py-1"
      onClick={handleCopy}
      title="Copy response content"
    >
      {isCopied ? (
        <>
          <Check className="mr-1 h-3 w-3" />
          Copied
        </>
      ) : (
        <>
          <Copy className="mr-1 h-3 w-3" />
          Copy
        </>
      )}
    </Button>
  );
}


export function JobDetailsResponseSection() {
  const { job, responseContent, parsedMetadata, copyButtons = [], formatStructuredResponse } = useJobDetailsContext();
  const [isResponseOpen, setIsResponseOpen] = useState(false);
  const [openedJobId, setOpenedJobId] = useState<string | null>(null);
  const { showNotification } = useNotification();
  
  // Get live jobs from context
  const { jobs } = useContext(BackgroundJobsContext);
  
  // Derive the live job from the context using the jobId
  const liveJobForModal = useMemo(() => {
    if (!openedJobId) return null;
    return jobs.find(j => j.id === openedJobId) || null;
  }, [openedJobId, jobs]);

  const isImplementationPlan = job.taskType === "implementation_plan" || job.taskType === "implementation_plan_merge";

  // Response content is now pre-formatted from context
  let displayContentForViewer = responseContent || "";

  const isJobStreaming = (job.status === "running" || job.status === "processingStream") && Boolean(parsedMetadata?.taskData?.isStreaming);
  
  // Use live progress hook
  const progress = useLiveProgress(job);


  // Copy handler for modal
  const handleCopy = async (button: CopyButtonConfig) => {
    try {
      const data = { IMPLEMENTATION_PLAN: responseContent || "", STEP_CONTENT: '' };
      const processedContent = replacePlaceholders(button.content, data);
      await navigator.clipboard.writeText(processedContent);
      
      showNotification({
        title: "Copied to clipboard",
        message: `${button.label} copied successfully`,
        type: "success",
        duration: 2000,
      });
    } catch (err) {
      console.error("Failed to copy to clipboard:", err);
      showNotification({
        title: "Copy failed", 
        message: "Failed to copy to clipboard",
        type: "error",
        duration: 3000,
      });
    }
  };

  return (
    <Card>
      {isImplementationPlan ? (
        // For implementation plans: header with copy buttons and modal trigger
        <CardHeader className="py-4 px-6">
          <div className="flex justify-between items-center">
            <div>
              <CardTitle className="text-sm font-semibold flex items-center gap-2 transition-colors">
                <span>Content</span>
                {isJobStreaming && (
                  <div className="flex items-center gap-1">
                    <Loader2 className="h-3 w-3 animate-spin" />
                    <span className="text-xs">Live Updates</span>
                  </div>
                )}
              </CardTitle>
              <CardDescription className="text-sm text-muted-foreground/80 mt-1">
                Output generated by the AI model
              </CardDescription>
            </div>
            <div className="flex items-center gap-2">
              {/* Copy Buttons */}
              {copyButtons.length > 0 && !isJobStreaming && (
                <div className="flex items-center gap-1">
                  {copyButtons.map((button) => (
                    <Button
                      key={button.id}
                      variant="outline"
                      size="sm"
                      className="text-xs h-7 px-2 py-1"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleCopy(button);
                      }}
                      title={`Copy: ${button.label}`}
                    >
                      <Copy className="mr-1 h-3 w-3" />
                      {button.label}
                    </Button>
                  ))}
                </div>
              )}
              {/* View Content Button */}
              <Button
                variant="outline"
                size="sm"
                className="text-xs h-7 px-2 py-1"
                onClick={() => setOpenedJobId(job.id)}
              >
                <Eye className="mr-1 h-3.5 w-3.5" />
                View Content
              </Button>
            </div>
          </div>
        </CardHeader>
      ) : (
        // For other job types: normal accordion behavior
        <Collapsible open={isResponseOpen} onOpenChange={setIsResponseOpen}>
          <CollapsibleTrigger asChild>
            <CardHeader className="py-4 px-6 cursor-pointer hover:bg-accent/30 transition-all duration-200 rounded-t-xl group">
              <div className="flex justify-between items-center">
                <div>
                  <CardTitle className="text-sm font-semibold flex items-center gap-2 group-hover:text-foreground/80 transition-colors">
                    <span>Response</span>
                  </CardTitle>
                  <CardDescription className="text-sm text-muted-foreground/80 mt-1">
                    Output generated by the AI model
                  </CardDescription>
                </div>
                <div className="flex items-center gap-2">
                  {isResponseOpen ? <ChevronUp className="h-5 w-5 text-muted-foreground group-hover:text-foreground transition-colors" /> : <ChevronDown className="h-5 w-5 text-muted-foreground group-hover:text-foreground transition-colors" />}
                </div>
              </div>
            </CardHeader>
          </CollapsibleTrigger>

          <CollapsibleContent>
            <CardContent className="pt-0">
              {(job.status === "running" || job.status === "processingStream") && parsedMetadata?.taskData?.isStreaming ? (
                <div className="mb-3">
                  <Progress
                    value={progress ?? 10}
                    className="h-1 mb-2"
                  />
                  <div className="flex justify-between items-center text-xs text-muted-foreground">
                    <div className="flex items-center gap-2">
                      <Loader2 className="h-3 w-3 animate-spin text-info" />
                      <span className="text-info font-medium">
                        Streaming in progress...
                      </span>
                    </div>
                    {progress !== undefined && (
                      <span>{Math.round(progress)}% complete</span>
                    )}
                  </div>
                </div>
              ) : null}

              {/* Check if there's a formatted response available */}
              {(() => {
                const formattedResponse = formatStructuredResponse?.(job);
                
                if (formattedResponse) {
                  return (
                    <div className="rounded-md bg-gray-50 dark:bg-gray-800 p-4">
                      {formattedResponse}
                    </div>
                  );
                }
                
                // Fall back to raw response display for other task types
                if (isJobStreaming) {
                  return (
                    <div className="flex items-center justify-center h-40 border border-border/60 bg-muted/20 rounded-md">
                      <div className="flex items-center gap-2">
                        <Loader2 className="h-4 w-4 animate-spin text-info" />
                        <span className="text-sm text-info">Streaming response...</span>
                      </div>
                    </div>
                  );
                }

                if (!displayContentForViewer) {
                  return (
                    <div className="flex items-center justify-center h-40 border border-border/60 bg-muted/20 rounded-md">
                      <span className="text-sm text-muted-foreground">No response content available</span>
                    </div>
                  );
                }

                return (
                  <div className="relative">
                    <div className="absolute top-2 right-2 z-10">
                      <SimpleCopyButton content={displayContentForViewer} />
                    </div>
                    <pre className="whitespace-pre-wrap font-mono text-xs text-balance w-full p-4 pr-20 bg-muted/20 rounded-md border border-border/60 text-foreground overflow-auto max-h-[70vh]">
                      {displayContentForViewer}
                    </pre>
                  </div>
                );
              })()}
            </CardContent>
          </CollapsibleContent>
        </Collapsible>
      )}

      {/* Content View Modal */}
      {liveJobForModal && (
        <PlanContentModal
          plan={liveJobForModal}
          open={openedJobId !== null}
          onOpenChange={(open: boolean) => {
            if (!open) {
              setOpenedJobId(null);
            }
          }}
          onRefreshContent={async () => {
            // No refresh needed in this context as job data comes from context
          }}
          copyButtons={copyButtons}
        />
      )}
    </Card>
  );
}
