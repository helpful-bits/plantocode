{
  "home": {
    "meta": {
      "title": "安全なコーディングのためのAI実装計画",
      "description": "大規模コードベース向けのAI実装計画ツール。実行前にすべての変更をレビューし、バグと重複ファイルを防止します。Cursor、GitHub Copilot、Claude Codeと完全統合。PlanToCodeは、AIコーディングエージェントを安全に採用するための包括的な開発計画プラットフォームです。インテリジェントなファイル検出により影響を受けるすべてのファイルを自動的に識別し、GPT-5.2、Claude Sonnet 4、Gemini 3 Proなどの複数のAIモデルからファイルごとの実装プランを生成します。Monaco Editorでプランをレビューおよび編集し、明示的な承認後にのみ実行します。永続的なターミナルセッション、音声文字起こし、完全な監査証跡により、企業チームに必要なガバナンスとコンプライアンスを提供します。レガシーコードのリファクタリング、大規模機能開発、複雑なバグ修正など、あらゆる複雑な開発タスクに対応。ヒューマンインザループワークフローにより、AIの速度と人間の制御を組み合わせた安全なAI支援開発を実現します。"
    }
  },
  "about": {
    "meta": {
      "description": "マルチモデル統合、永続的なターミナル、音声文字起こし、アーキテクチャ統合を備えたAI開発計画。",
      "title": "PlanToCodeについて - AI開発計画ツール"
    },
    "architecture": {
      "comment": "シンプルなAIチャットではなく、複雑な開発ワークフローのために構築されています",
      "title": "技術基盤"
    },
    "capabilities": {
      "automation": {
        "description": "スマートテンプレートによる設定可能なコピーボタン。プレースホルダー置換とターミナル統合で、あらゆるプロンプトを再利用可能なワークフローに変換します。",
        "title": "ワークフロー自動化"
      },
      "discovery": {
        "description": "複数段階のワークフロー:ルートフォルダー選択、正規表現パターンフィルタリング、AIによる関連性評価。パス検証による集中的なファイル選択。",
        "title": "インテリジェントファイル検出"
      },
      "planning": {
        "description": "切り捨てなしの完全なコンテキスト読み込み。番号付きステップによる構造化XMLプラン。マルチモデル生成とアーキテクチャ統合。",
        "title": "実装計画"
      },
      "synthesis": {
        "description": "単純なマージを超えて、SOLID原則による深いアーキテクチャ分析。すべての決定に[src:P1 step 2]帰属を付けたソース追跡可能性。",
        "title": "アーキテクチャ統合"
      },
      "terminal": {
        "description": "5秒間のヘルスモニタリング、自動復旧アクション、エージェント注意検出を備えたPTYセッション。セッションはアプリの再起動後も永続化されます。",
        "title": "ジョブ中心のターミナル"
      },
      "title": "コア機能",
      "voice": {
        "description": "ターミナルコマンド用のOpenAI gpt-4o-transcribe統合。コンテキスト認識処理とリアルタイムジョブ追跡を備えた選択ベースのテキスト改善。",
        "title": "音声とテキストの統合"
      },
      "remote": {
        "description": "プランのレビューとマージ、ジョブ、ペイロード、プロンプト、メタデータの検査、モデルとパラメータの変更、システムプロンプトの確認、デバイスリンク経由のターミナルオープン — SSHポートを公開せずに実行できます。",
        "title": "リモートコントロール (iOS)"
      }
    },
    "company": {
      "contact": "お問い合わせ",
      "jurisdiction": "ドイツ",
      "name": "helpful bits GmbH",
      "title": "会社情報"
    },
    "hero": {
      "subtitle": "PlanToCodeは開発者がコード変更を計画して出荷するのを支援します。影響を受けるファイルを見つけ、プランを生成・マージしてターミナルで実行します。",
      "title": "PlanToCodeについて"
    },
    "philosophy": {
      "noTruncation": {
        "description": "完全なファイルコンテンツを読み込みます。先制的な切り捨てなし、スマートな警告のみ。本格的な開発作業に必要な完全なコンテキストを取得できます。",
        "title": "切り捨てなしポリシー"
      },
      "title": "私たちの哲学",
      "tooling": {
        "description": "Monacoエディタ、xterm.js、適切な開発環境統合。単なる別のチャットインターフェースではなく、完全な開発計画プラットフォームです。",
        "title": "プロフェッショナルツール"
      },
      "traceability": {
        "description": "すべてのAI決定にはソース帰属が含まれます。完全な監査証跡、コスト追跡、セッション永続化。何が起こったか、そしてなぜそうなったかを正確に把握できます。",
        "title": "完全な追跡可能性"
      },
      "transparency": {
        "description": "ローカルストレージ、透明なAIプロバイダー通信、送信内容の完全な制御。API呼び出しを確認する前に、常にコンテキストを確認できます。",
        "title": "透明性と制御"
      }
    },
    "whatWeBuilt": {
      "environment": {
        "description": "Monacoエディタ統合、ヘルスモニタリング付き永続的ターミナルセッション、音声文字起こし、5MBのSQLiteリングバッファ。実際の開発ワークフローのために構築されています。",
        "title": "プロフェッショナル開発環境"
      },
      "intro": "PlanToCodeは、迅速なAIインタラクションよりもコンテキスト、追跡可能性、プロフェッショナルツールが重要な本格的な開発作業向けに設計された包括的な開発計画環境です。従来のAIツールでは対応しきれない複雑な複数ステップ実装のためのシステムを構築しました。",
      "multiModel": {
        "description": "GPT-5.2、Claude Sonnet 4、Gemini 3 Proとの統合。単なるAPI呼び出しではなく、プロジェクト固有の設定、リアルタイムストリーミング、完全な追跡可能性によるインテリジェントなオーケストレーション。",
        "title": "マルチモデルインテリジェンス"
      },
      "title": "私たちが構築したもの"
    }
  },
  "evolution": {
    "meta": {
      "title": "System Evolution and Tradeoffs - PlanToCode",
      "description": "How PlanToCode evolved, why specific technologies were chosen, and what tradeoffs those decisions created."
    }
  },
  "aboutPage": {
    "hero": {
      "title": "What PlanToCode Is For",
      "description": "PlanToCode is a desktop planning workspace that turns tasks into reviewable implementation plans. It connects file discovery, plan generation, and execution handoff into one tracked pipeline."
    },
    "reference": {
      "title": "Reference architecture focus",
      "description": "The system wires together a Tauri shell, a Rust backend, SQLite persistence, and an LLM proxy layer. This page explains how those parts fit together so you can learn from the architecture."
    },
    "governance": {
      "title": "Safety, Governance, and Guardrails",
      "description": "Governance is a core architectural decision: plans are artifacts that can be reviewed, edited, and approved before execution."
    },
    "stack": {
      "title": "Where This Fits in Your Stack",
      "description": "PlanToCode sits alongside your editor and local tools. It assumes Git workflows and external LLM providers, then routes plans and execution through the same session history."
    }
  },
  "architecturePage": {
    "hero": {
      "title": "Architecture Overview",
      "description": "PlanToCodeはTauriデスクトップアプリで、Rustバックエンド、React/Next.jsフロントエンド、SQLiteローカルDBで構成されます。計画と分析はサーバーで管理されるLLMプロバイダーを利用し、セルフホストでは独自キーに対応します。このページでは構成のつながりを説明します。"
    },
    "visuals": {
      "systemMap": {
        "title": "System map snapshot",
        "description": "This diagram depicts the PlanToCode system architecture as four interconnected layers arranged vertically. Top Layer - Desktop Frontend: A React/Next.js box containing components (Plan Viewer, Terminal Panel, Session Manager) connected via labeled arrows \"invoke()\" and \"listen()\" to Tauri IPC Bridge. Second Layer - Rust Backend: Contains WorkflowOrchestrator (scheduling multi-stage jobs), TerminalSessionManager (PTY lifecycle), and JobProcessors (FileDiscovery, PlanGeneration, TextImprovement, DeepResearch). Arrows show \"spawn()\" to job threads and \"emit()\" events back to UI. Third Layer - Persistence: SQLite database cylinder showing tables: sessions, background_jobs, terminal_sessions. Bidirectional arrows labeled \"read/write\" connect to Rust services. Fourth Layer - External Services: Server box with Auth (/api/auth), LLM Proxy (/api/llm/*), and Usage Tracking; arrows point outward to Provider icons (OpenAI, Anthropic, Google, OpenRouter) with \"route()\" labels. Data flows: Task input flows down through layers; LLM responses stream back up via SSE; job status updates propagate via Tauri events. Key labels include \"HTTPS/WSS\" on server connections, \"SQLite\" on persistence, and \"FFI\" on Rust-to-system calls.",
        "imageSrc": "/images/architecture/system-map.svg",
        "imageAlt": "Diagram showing PlanToCode system map",
        "caption": "Four-layer architecture with data flowing down and events streaming back up."
      }
    },
    "sections": {
      "shell": {
        "title": "Tauri Shell and Desktop Frontend",
        "description": "The desktop app bundles a React UI inside a Tauri shell. Frontend code calls Rust commands for tasks like file system access, terminal sessions, and background job orchestration."
      },
      "core": {
        "title": "Rust Core and SQLite Persistence",
        "description": "The Rust core manages background jobs, PTY sessions, and durable state. SQLite stores sessions, job history, and terminal session logs as the local record of work."
      },
      "jobs": {
        "title": "Background Job Orchestration",
        "description": "A workflow orchestrator schedules multi-stage jobs (file discovery, plan generation, research). Each stage is a Rust processor that can call out to LLM providers, read or write to the project, and emit streaming updates back to the UI."
      },
      "llm": {
        "title": "Multi-Model LLM Integration",
        "description": "The server layer routes requests to different providers, normalizes responses, and tracks usage. The desktop app receives a unified streaming API regardless of provider."
      }
    },
    "communication": {
      "title": "How the Pieces Communicate",
      "description": "Commands flow from the React UI into Tauri, which invokes Rust functions. Long-running work is executed as background jobs that stream updates (including partial LLM tokens) back to the UI. SQLite is the durable local store so sessions and terminal history can be replayed or resumed.",
      "followup": "For a deeper dive, read the architecture documentation and the build-your-own guides that map these concepts to code modules."
    },
    "meta": {
      "title": "System Architecture - PlanToCode",
      "description": "Detailed overview of the PlanToCode architecture: Tauri shell, Rust backend, SQLite persistence, and multi-model LLM orchestration."
    }
  },
  "evolutionPage": {
    "hero": {
      "title": "Evolution and Tradeoffs",
      "description": "This page outlines the major architectural decisions behind PlanToCode and how the system changed as new workflows and constraints appeared."
    },
    "visuals": {
      "timeline": {
        "title": "Architecture timeline",
        "description": "This horizontal timeline diagram shows the evolution of PlanToCode across five major phases. Phase 1 'Editor Plugin Era' (leftmost): VS Code extension icon with features listed (inline suggestions, basic file context). Arrow labeled 'Limitation: No execution control' points to Phase 2. Phase 2 'Standalone Shell': Tauri desktop app icon with features (dedicated UI, local SQLite, PTY sessions). Arrow labeled 'Added: Job orchestration' points to Phase 3. Phase 3 'Multi-Stage Workflows': Workflow diagram icon showing connected stages (FileDiscovery, Scoring, Planning, Execution). Arrow labeled 'Added: Review gates' points to Phase 4. Phase 4 'Multi-Provider LLM': Server routing icon with provider logos (OpenAI, Anthropic, Google, OpenRouter) showing unified API normalization. Arrow labeled 'Added: Model flexibility' points to Phase 5. Phase 5 'Current Architecture' (rightmost): Complete system icon showing Desktop + Server + Mobile components. Below the timeline, key architectural decisions are annotated: 'Tauri over Electron' at Phase 2, 'SQLite as local truth' at Phase 2, 'Background job queue' at Phase 3, 'Server-side provider routing' at Phase 4, 'Cross-platform sync' at Phase 5. Tradeoff callouts include 'Binary size vs. ecosystem' (Tauri), 'Local-first vs. cloud sync' (SQLite), 'Latency vs. flexibility' (LLM routing).",
        "imageSrc": "/images/evolution/timeline.png",
        "imageAlt": "Timeline of PlanToCode system evolution",
        "caption": "Placeholder for an evolution timeline graphic."
      }
    },
    "origins": {
      "title": "Project Origins",
      "description": "PlanToCode began as an experiment in separating planning from execution: use LLMs to propose concrete implementation plans, then execute them via local tools and terminals. Early prototypes were editor-centric; over time, the architecture moved toward a dedicated desktop shell with tighter control over file access and job orchestration."
    },
    "choices": {
      "title": "Technology Choices",
      "items": [
        {
          "title": "Tauri over Electron:",
          "description": "Chosen for a smaller binary, a Rust backend, and a more constrained security model. It also enables shared logic between CLI-like workflows and the desktop app."
        },
        {
          "title": "SQLite as the local source of truth:",
          "description": "A file-based database is easy to ship, snapshot, and inspect. It stores sessions, job metadata, and terminal history so workflows can be resumed or reviewed."
        },
        {
          "title": "Multi-provider LLM routing:",
          "description": "The server supports multiple providers and models, normalizing responses and tracking usage centrally. This makes it easier to swap models without rewriting the desktop client."
        }
      ]
    },
    "sourceAvailable": {
      "title": "What the system focuses on",
      "description": "The focus is on planning-first workflows: file discovery, multi-model plan generation, review, and execution handoff. These stages depend on external LLM providers for scoring and drafting, while the desktop app handles review, storage, and execution logs."
    }
  },
  "changelog": {
    "meta": {
      "title": "Changelog - Latest Updates",
      "description": "Release notes for PlanToCode, highlighting architecture, workflow, and system changes."
    },
    "hero": {
      "title": "Changelog",
      "subtitle": "Release notes focused on architecture changes, workflow updates, and system improvements."
    },
    "changes": {
      "added": "Added",
      "improved": "Improved",
      "fixed": "Fixed",
      "removed": "Removed"
    },
    "footer": {
      "title": "Follow updates",
      "subtitle": "Track release notes and architecture changes as the system evolves.",
      "followX": "Follow updates on X",
      "joinCommunity": "Join the community"
    }
  },
  "downloads": {
    "cta": {
      "architect": "エキスパートと話す",
      "docs": "ターミナルドキュメント",
      "footer": "ドイツ製 • GDPR準拠 • ローカルセッションストレージ",
      "professional": "プロフェッショナルオプション",
      "title": "レベルアップの準備はできましたか?"
    },
    "hero": {
      "subtitle": "1つのツールでコード変更を計画 - 関連ファイルを見つけ、プランを生成・マージし、永続的なターミナルでコマンドを実行します。",
      "title": "PlanToCodeをダウンロード"
    },
    "macos": {
      "professional": {
        "description": "Appleによって完全に公証されています。コード署名済み。CLI自動検出とセッション永続化を備えた統合ターミナル。",
        "title": "プロフェッショナル対応"
      },
      "requirements": {
        "internet": "AI機能にはインターネット接続が必要です",
        "os": "macOS 11.0(Big Sur)以降",
        "processor": "Apple Silicon(M1/M2/M3/M4)プロセッサ",
        "ram": "最小4GB RAM(8GB推奨)",
        "title": "システム要件"
      },
      "subtitle": "ヘビーコーディングエージェントユーザー向け",
      "title": "macOS"
    },
    "meta": {
      "description": "macOSおよびWindows向けPlanToCodeをダウンロード。無料で$5クレジット。AIを使用して複数ファイルの変更を計画し、実行前にレビュー。クレジットカード不要。",
      "title": "PlanToCodeをダウンロード - macOSおよびWindows | 無料トライアル"
    },
    "trust": {
      "planning": {
        "description": "GPT-5.2、Claude Sonnet 4、Gemini 3 Pro、o3/o4-mini、Grok 4、DeepSeek R1、Kimi K2。LLM評議会アプローチ。",
        "title": "マルチモデル計画"
      },
      "pricing": {
        "description": "即座に開始。従量課金制。サブスクリプションなし。コストを追跡するパワーユーザー向けのトークン透明性。",
        "title": "使用量ベースの価格設定"
      },
      "professional": {
        "description": "シングルテナントサーバー。オンプレミス展開。ターミナルガバナンス。クラウドのみを使用できないチーム向けに構築されています。",
        "title": "プロフェッショナルオプション"
      },
      "terminal": {
        "description": "claude、cursor、codex、またはgeminiを直接実行します。音声文字起こしが利用可能で、ログはローカルに保持されるため、コンテキストを切り替えることなく作業を再開できます。",
        "title": "統合ターミナル"
      },
      "title": "ヘビーコーディングエージェントユーザー向けに構築"
    },
    "windows": {
      "integration": {
        "description": "PowerShellとコマンドプロンプトのサポート。ヘルスモニタリングと復旧を備えたclaude、cursor、codex、またはgeminiを実行します。",
        "title": "ターミナル統合"
      },
      "requirements": {
        "internet": "AI機能にはインターネット接続が必要です",
        "os1": "Windows 10バージョン1903(ビルド18362)以降",
        "os2": "Windows 11サポート",
        "processor": "x64またはARM64プロセッサ",
        "ram": "最小4GB RAM(8GB推奨)",
        "title": "システム要件"
      },
      "subtitle": "Microsoft Store - プロフェッショナル対応",
      "title": "Windows"
    },
    "mobile": {
      "button": "App Storeでダウンロード",
      "connected": {
        "description": "デスクトップのPlanToCodeセッションをリモートで制御。プランのレビュー、ターミナルの管理、外出先での生産性を維持。",
        "title": "リモートコントロール"
      },
      "features": {
        "design": "ネイティブiOS/iPadOSデザイン言語",
        "monitor": "ターミナルセッションをリモートで監視",
        "review": "外出先で実装プランをレビューおよび編集",
        "sync": "デスクトップワークスペースとシームレスに同期",
        "title": "機能",
        "voice": "迅速なアイデアキャプチャのための音声文字起こし"
      },
      "subtitle": "iPhoneおよびiPad向けリモートコントロール",
      "title": "iOSモバイルアプリ"
    }
  },
  "securityNotarization": {
    "meta": {
      "title": "macOS Notarization and Gatekeeper - PlanToCode",
      "description": "How the macOS build is signed and notarized, how Gatekeeper verifies it, and where to read Apple's docs.",
      "imageAlt": "PlanToCode macOS notarization and Gatekeeper overview"
    },
    "hero": {
      "title": "macOS notarization",
      "subtitle": "The macOS build is signed and notarized by Apple. Notarization validates developer identity and scans the build for malicious content; Gatekeeper uses the notarization ticket when the app is first opened."
    },
    "links": {
      "gatekeeper": {
        "label": "Apple Support:",
        "text": "Gatekeeper and runtime protection"
      },
      "notarize": {
        "label": "Apple Developer:",
        "text": "Notarizing macOS software before distribution"
      }
    },
    "footer": {
      "text": "If Gatekeeper blocks first launch, use Finder -> Open to approve the app, or visit",
      "link": "Downloads"
    }
  },
  "legal": {
    "meta": {
      "title": "Select Your Region - Legal Documents | PlanToCode",
      "description": "Choose your region (EU/UK or United States) to view applicable legal documents including terms of service, privacy policy, and regional compliance requirements."
    },
    "restricted": {
      "meta": {
        "title": "451 - Service Not Available in Your Region",
        "description": "This service is not available in your geographic region."
      }
    }
  },
  "howItWorks": {
    "cta": {
      "links": {
        "architecture": "Architecture overview",
        "buildYourOwn": "Build your own pipeline",
        "docs": "ドキュメントを見る",
        "workflows": "Implementation plan docs",
        "demo": "インタラクティブデモを試す",
        "planning": "プラン編集について学ぶ"
      },
      "subtitle": "会議のキャプチャから安全な実行まで - AIコーディングエージェントを自信を持って採用する企業チーム向けの完全なワークフロー。あらゆるソースから要件をキャプチャし、AIで改善し、詳細なプランを生成し、完全な制御でレビューし、安全に実行します。",
      "title": "企業の開発ワークフローを変革する準備はできましたか?"
    },
    "hero": {
      "badge": "プロフェッショナルAI計画ワークフロー",
      "subtitle": "会議のキャプチャから安全な実行まで - 完全な企業AI開発ワークフロー",
      "title": "仕組み"
    },
    "keyFeatures": {
      "deploy": {
        "description": "リクエストを自社インフラに保持する必要がある場合は、Rustプロキシサーバーをセルフホストして独自のAPIキーを使用してください。ホスト版は管理されたモデルアクセスを利用します。",
        "title": "あなたの条件でデプロイ"
      },
      "governance": {
        "description": "実行前にすべてのプランをレビューします。アプローチを編集し、戦略を統合し、承認または拒否します。AIがアシストし、人間が制御します。コード品質が重要なチーム向けに構築されています。",
        "title": "ヒューマンインザループガバナンス"
      },
      "sessions": {
        "description": "ターミナル出力はローカルに保存され、セッションは起動時に復元されます。アプリを閉じて、来週戻ってきて、デバッグを続けます。",
        "title": "永続的なセッション"
      },
      "title": "企業チームがこのワークフローを選ぶ理由"
    },
    "meta": {
      "description": "AI実装計画は混乱を防ぎます。ファイル検出、マルチモデルプラン、人間のレビュー、あらゆるコーディングエージェントでの安全な実行。",
      "title": "仕組み - AI計画ワークフロー"
    },
    "workflow": {
      "exampleMergeInstructions": "Example merge instructions:",
      "step1": {
        "description": "Capture requirements from recordings, screen captures, or voice notes. Screen recordings are analyzed by the video analysis job and produce a summary you can attach to the task.",
        "meetings": {
          "description": "Upload meeting recordings or design reviews. The analysis uses video and audio to summarize decisions, issues, and UI context.",
          "title": "Meeting Recordings"
        },
        "links": {
          "meeting": "Meeting ingestion details",
          "voice": "Voice transcription details"
        },
        "screen": {
          "description": "Record workflows, bugs, or UI walkthroughs. The analysis summary can be attached to the task description.",
          "title": "Screen Recordings"
        },
        "subtitle": "Stage 1: Voice, video, notes become specifications",
        "title": "Capture Ideas and Context",
        "voice": {
          "description": "Dictate requirements directly into the task input. Speech-to-text runs through the configured provider and inserts text into the active field.",
          "title": "Voice Dictation"
        }
      },
      "step2": {
        "description": "生の会議トランスクリプト、音声録音、ラフなメモを、明確性と完全性の両方を保証する2つの異なるAIプロンプトタイプを使用して、明確で実装可能な仕様に変換します。",
        "subtitle": "明確性と完全性のための2つのAIプロンプトタイプ",
        "taskRefinement": {
          "description": "暗黙の要件を特定し、見落とされたギャップを埋め、期待される動作とエッジケースを明確にし、実装準備のための技術的考慮事項を追加することにより、タスク記述を拡張します。",
          "title": "タスク改善"
        },
        "textEnhancement": {
          "description": "元の意図、トーン、技術的詳細レベルを維持しながら、文法、文構造、明確性、簡潔性を改善します。音声トランスクリプトと会議メモを磨くのに最適です。",
          "title": "テキスト強化"
        },
        "links": {
          "specCapture": "Specification capture details"
        },
        "title": "実行可能な仕様に改善"
      },
      "step3": {
        "description": "AIファイル検出は、コードベース全体で関連ファイルを識別します。複数のAIモデルが、ファイルごとの粒度で実装プランを生成します - 正確なファイルパス、特定の行範囲、明確な操作タイプ(変更/作成/削除)。この粒度により、影響評価が明確になります。",
        "features": {
          "dependencies": "依存関係分析と影響評価",
          "models": "マルチモデルサポート(GPT-5.2、Claude 4、Gemini 3 Pro)",
          "multiple": "アプローチ比較のための複数のプラン生成",
          "operations": "明確な操作タイプ(変更、作成、削除)",
          "paths": "リポジトリ構造からの正確なファイルパス",
          "ranges": "特定の行範囲と変更の詳細"
        },
        "links": {
          "fileDiscovery": "File discovery pipeline",
          "planGeneration": "Plan generation details"
        },
        "subtitle": "正確なリポジトリパスを持つファイルごとのプラン",
        "title": "詳細な実装プランを生成"
      },
      "step4": {
        "capabilities": {
          "approve": "Approve before execution",
          "editing": "すべてのプランステップと詳細の直接編集",
          "editor": "構文ハイライト付きプロフェッショナルMonacoエディタ",
          "merge": "カスタム指示で複数のプランを統合",
          "modifications": "変更または代替アプローチを要求",
          "visibility": "提案された変更への完全な可視性"
        },
        "description": "Plans open in Monaco for review. You can edit steps directly, merge drafts with custom guidance, or delete drafts you do not want to keep. No code changes occur without explicit human approval, keeping scope and dependencies explicit.",
        "links": {
          "governance": "Review and governance",
          "merge": "Plan merging details"
        },
        "subtitle": "コード変更前の完全な制御",
        "title": "レビュー、編集、承認(ヒューマンインザループ)"
      },
      "step5": {
        "description": "承認後、選択したコーディングエージェント(Claude Code、Cursor、Codex)または割り当てられたソフトウェア開発者にプランを安全に送信します。ファイルごとの粒度は、リグレッションと意図しない変更を防ぎます - 安全な実行を保証します。永続的なセッションを備えた統合ターミナルにより、即座の実行とデバッグが可能になります。",
        "links": {
          "terminal": "Terminal integration details",
          "planDocs": "Implementation plan format"
        },
        "subtitle": "開発者またはコーディングエージェントへの安全な引き渡し",
        "title": "自信を持って実行",
        "tools": {
          "audit": "Execution history stored in SQLite",
          "claude": "プランモードサポート付きClaude Code CLI",
          "codex": "OpenAI Codex CLI実行",
          "cursor": "Cursor CLI統合",
          "sessions": "自動復旧付き永続的ターミナルセッション",
          "terminal": "音声文字起こし付き統合ターミナル"
        }
      },
      "title": "完全なワークフロー"
    },
    "demo": {
      "button": "インタラクティブデモを試す",
      "description": "インタラクティブデモを見て完全なワークフローを確認",
      "title": "実際の動作を見る"
    },
    "useCases": {
      "bugs": {
        "description": "バグの画面キャプチャを記録し、AI分析を取得し、デバッグプランを生成し、完全なターミナル制御で実行します。",
        "items": {
          "persistent": "永続的なターミナルログ",
          "systematic": "体系的なデバッグアプローチ",
          "visual": "画面録画による視覚的コンテキスト"
        },
        "title": "複雑なバグ調査"
      },
      "features": {
        "description": "慎重な計画が必要な複数ファイルの機能。複数のアプローチを生成し、最良の部分を統合し、特定のコードベースに合わせて編集します。",
        "items": {
          "api": "API設計と統合",
          "cross": "コンポーネント横断的な機能実装",
          "schema": "データベーススキーマの変更"
        },
        "title": "大規模機能開発"
      },
      "legacy": {
        "description": "AIはレガシーパターンと技術的負債を理解します。安全なリファクタリングプラン、ライブラリアップグレード、アーキテクチャの改善を生成します。",
        "items": {
          "breaking": "破壊的変更移行プラン",
          "cleanup": "技術的負債のクリーンアップ",
          "dependency": "依存関係アップグレード戦略"
        },
        "title": "レガシーコードベースのメンテナンス"
      },
      "professional": {
        "description": "コマンド承認、セッション保持、シングルテナント展開。1つの間違ったコマンドが数百万のコストをかけるチーム向けに構築されています。",
        "items": {
          "audit": "完全な監査証跡",
          "governance": "ターミナルガバナンスと承認",
          "onprem": "オンプレミス展開オプション"
        },
        "title": "プロフェッショナル開発"
      },
      "title": "企業開発チーム向けに構築"
    }
  },
  "support": {
    "button": "サポートに連絡",
    "hero": {
      "subtitle": "PlanToCodeのヘルプを取得",
      "title": "サポート"
    },
    "meta": {
      "description": "PlanToCodeのインストール、Claude Code、Cursor、Codex統合のヘルプを取得します。トラブルシューティングと機能リクエスト。24時間応答時間。",
      "title": "PlanToCodeサポート - ヘルプとトラブルシューティング"
    },
    "resources": {
      "changelog": "変更履歴",
      "feedback": "フィードバック",
      "help": "ヘルプセンター",
      "roadmap": "ロードマップ",
      "title": "FeatureBaseリソース"
    }
  },
  "comparisons": {
    "hub": {
      "badge": "ツール比較",
      "card": {
        "badge": "比較",
        "viewLink": "比較を見る",
        "whySwitchLabel": "開発者が切り替える理由:"
      },
      "cta": {
        "button": "PlanToCodeを無料で試す",
        "footer": "$5の無料クレジット • クレジットカード不要",
        "subtitle": "複雑でミッションクリティカルな作業のために、なぜ開発者がPlanToCodeに切り替えているのかをご覧ください。",
        "title": "違いを体験してください"
      },
      "cursorNote": {
        "link": "PlanToCodeがCursorを補完する方法を学ぶ →",
        "strong": "Cursorの代替をお探しですか?",
        "text": "PlanToCodeはCursorと併用できます。代わりではありません。"
      },
      "description": "PlanToCodeのアーキテクチャ計画アプローチと、従来のターミナルツール、AIコーディングアシスタント、その他の開発ワークフローとの比較をご覧ください。tmux、script、asciinema、Cursor、Claude Code、Aiderなどの人気ツールとPlanToCodeの違いを理解し、各ツールが開発ワークフローのどこに最適かを学びましょう。実装計画、ファイル検出、マルチモデル統合、ターミナルガバナンスなど、PlanToCodeの独自の機能がどのように複雑な開発タスクを安全かつ効率的に処理するかを確認してください。",
      "meta": {
        "description": "PlanToCodeをtmux、script、asciinema、Cursor、Claude Code、その他の開発ツールと比較します。アーキテクチャ計画がワークフローをどのように改善するかをご覧ください。",
        "title": "PlanToCode vs 代替ツール - 機能比較"
      },
      "title": "PlanToCode vs 代替ツール",
      "whatMakesDifferent": {
        "architectural": {
          "description": "複数段階のファイル検出で、変更を加える前にコードベース全体のアーキテクチャをマッピングします。ほとんどのツールは、あなたが見せたものしか見ません。PlanToCodeは、ルートフォルダー選択、正規表現パターンフィルタリング、AI関連性評価、拡張パス検出を含む5段階のインテリジェントワークフローを使用して、タスクに影響を受けるすべてのファイルを自動的に識別します。これにより、コード変更が始まる前に依存関係、影響範囲、潜在的なリグレッションポイントを完全に理解できます。",
          "title": "アーキテクチャ認識"
        },
        "humanInLoop": {
          "description": "実行前にすべてのプランをレビュー、編集、承認。永続的なターミナルセッションで、いつでも一時停止、調査、再開が可能です。Monaco Editorを使用した完全な編集機能により、プランのあらゆる側面を変更できます。明示的な人間の承認なしにコード変更は発生しないため、企業チームに必要なガバナンスとコンプライアンスが保証されます。完全な監査証跡により、誰が何をレビューし、どのような変更が承認されたかを追跡できます。",
          "title": "ヒューマンインザループ"
        },
        "multiModel": {
          "description": "複数のAIモデル(GPT-5.2、Claude 4.5、Gemini 3 Pro)からプランを生成し、最良の洞察を統合します。単一モデルツールは視点を見逃します。各AIモデルは異なる強みを持ち、コード変更に対して異なるアプローチを提供します。PlanToCodeは同じタスクを複数のモデルで実行し、カスタム指示を使用してSOLID原則による深いアーキテクチャ分析で最良の洞察を1つの包括的なプランに統合します。すべての決定にはソース帰属[src:P1 step 2]が含まれるため、各推奨事項がどのモデルから来たかを正確に把握できます。",
          "title": "マルチモデル計画"
        },
        "title": "PlanToCodeを異なるものにするもの"
      }
    }
  },
  "cursorAlternative": {
    "comparison": {
      "intro": "これは競合比較ではありません。ツールがどのように補完し合うかを示しています:",
      "table": {
        "approval": {
          "cursor": "組み込みなし",
          "name": "チーム承認ワークフロー",
          "plan": "完全な監査証跡",
          "together": "PlanToCodeで承認、Cursorで実装"
        },
        "autocomplete": {
          "cursor": "業界をリード",
          "name": "オートコンプリートとIntelliSense",
          "plan": "含まれていません",
          "together": "Cursorがオートコンプリートを処理"
        },
        "capability": "機能",
        "chat": {
          "cursor": "優れたUX",
          "name": "チャットインターフェース",
          "plan": "タスクベースのUI",
          "together": "Cursorのチャットは自然な感じ"
        },
        "cursor": "Cursor",
        "discovery": {
          "cursor": "基本的なインデックス作成",
          "name": "ファイル検出と分析",
          "plan": "高度なワークフロー",
          "together": "PlanToCodeがファイルを見つけ、Cursorが変更"
        },
        "duplicates": {
          "cursor": "組み込みなし",
          "name": "重複ファイル防止",
          "plan": "レビュー中に検出",
          "together": "PlanToCodeが防止、Cursorが正しく実行"
        },
        "multiModel": {
          "cursor": "リクエストごとに単一モデル",
          "name": "マルチモデル統合",
          "plan": "モデルを比較・統合",
          "together": "複数モデルから最良のプラン → Cursor"
        },
        "planning": {
          "cursor": "利用不可",
          "name": "実装計画",
          "plan": "コア機能",
          "together": "PlanToCodeがCursorをガイド"
        },
        "plantocode": "PlanToCode",
        "pricing": {
          "cursor": "月額$20のサブスクリプション",
          "name": "価格モデル",
          "plan": "従量課金制(サブスクリプションなし)",
          "together": "$20/月 + 実際の使用量($5-15が一般的)"
        },
        "review": {
          "cursor": "チャット経由で手動",
          "name": "実行前レビュー",
          "plan": "組み込みワークフロー",
          "together": "PlanToCodeでレビュー、Cursorで実行"
        },
        "speed": {
          "cursor": "優れている",
          "name": "コード生成速度",
          "plan": "含まれていません",
          "together": "Cursorが生成を処理"
        },
        "together": "より良い組み合わせ"
      },
      "title": "機能比較:補完的な強み"
    },
    "faq": {
      "q1": {
        "answer": "いいえ、PlanToCodeはCursorの置き換えではありません。Cursorと並行して動作する補完的なツールです。Cursorはコード生成とオートコンプリートに優れていますが、PlanToCodeは実装計画を通じて安全層を追加します。スピードにはCursorを、安全性にはPlanToCodeを使用してください。",
        "question": "PlanToCodeはCursorの代替または置き換えですか?"
      },
      "q2": {
        "answer": "両方のツールを一緒に使用することで、Cursorの一般的な問題を防ぎます:重複ファイルの作成、間違ったファイルパス(特にマルチワークスペースプロジェクト)、予期しないファイル変更、レビューされていない変更による本番バグ。PlanToCodeの計画フェーズは、実行前にこれらの問題を検出します。",
        "question": "CursorとPlanToCodeを一緒に使用することでどんな問題が解決されますか?"
      },
      "q3": {
        "answer": "ワークフローは次のとおりです:1) PlanToCodeでファイルごとの実装プランを生成、2) プランをレビューして承認(パスエラーや重複を検出)、3) 承認されたプランをCursor AgentまたはComposerに貼り付け、4) Cursorに明確なアーキテクチャコンテキストでコード生成を実行させます。",
        "question": "PlanToCodeをCursorと一緒に使用するにはどうすればよいですか?"
      },
      "q4": {
        "answer": "Cursorはサブスクリプションで月額$20かかります。PlanToCodeはサブスクリプションなしの従量課金制を使用します。合計コスト:Cursorの月額$20 + PlanToCodeでの実際のAPI使用量(通常の使用で月額$5-15が一般的)。多くの開発者は、重複ファイルのクリーンアップに何時間も費やすよりも安いと感じています。",
        "question": "組み合わせた価格はどのようになりますか?"
      },
      "q5": {
        "answer": "もちろんです。Cursorは小規模プロジェクト、グリーンフィールド開発、クイックプロトタイプでスタンドアロンで素晴らしく機能します。大規模なコードベース(50k+ LOC)、複雑なリファクタリング、承認が必要なチーム環境、または重複ファイルの問題を経験した場合にPlanToCodeを追加してください。",
        "question": "PlanToCodeなしでCursorを使用できますか?"
      },
      "q6": {
        "answer": "はい。PlanToCodeで実装プランを生成し、レビューしてから、承認されたプランをCursor Agent TerminalまたはBackground Agentsに貼り付けます。完全なアーキテクチャコンテキストで実行され、一般的なパスと重複エラーを防ぎます。",
        "question": "PlanToCodeはCursor AgentおよびBackground Agentsと連携しますか?"
      },
      "q7": {
        "answer": "計画フェーズは最初に3〜5分追加されますが、デバッグ、重複ファイルのクリーンアップ、パス修正の何時間も節約できます。ほとんどの開発者は、特に大規模なコードベースでの複雑なタスクにおいて、正味の時間節約を報告しています。ミスを修正するのが安いクイックプロトタイプの場合は、計画をスキップしてCursorのみを使用できます。",
        "question": "両方のツールを使用するとワークフローが遅くなりますか?"
      },
      "q8": {
        "answer": "はい、もちろんです。PlanToCodeはCursorのオートコンプリートや他のCursor機能を妨げません。それらは一緒に動作する別々のツールです。通常のコーディングにはCursorのオートコンプリートを使用し、より大きな変更の実装計画が必要な場合はPlanToCodeに切り替えてください。",
        "question": "PlanToCodeでもCursorのオートコンプリートを使用できますか?"
      },
      "title": "よくある質問"
    },
    "finalCta": {
      "description": "答えはCursorを置き換えることではありません。重複ファイル、間違ったパス、本番バグを防ぐ安全層を追加することです。",
      "download": "PlanToCodeをダウンロード(無料)",
      "footer": "無料でダウンロード。従量課金制のAPI使用。既存のCursor設定と連携します。",
      "guide": "統合ガイドを読む",
      "title": "Cursorの代替を探すのをやめてください"
    },
    "gettingStarted": {
      "guide": "セットアップガイド:Cursor + PlanToCode",
      "quickWins": {
        "duplicates": "作成前に重複ファイルを検出",
        "existing": "既存のCursor設定と連携",
        "paths": "実行前に正確なファイルパスをレビュー",
        "plan": "5分以内に最初のプランを生成",
        "subscription": "PlanToCodeにサブスクリプション不要",
        "title": "クイックウィン"
      },
      "resources": {
        "comparison": "詳細なツール比較",
        "discovery": "ファイル検出ワークフロー",
        "documentation": "完全なドキュメント",
        "integration": "Cursor統合ガイド",
        "title": "無料リソース"
      },
      "step1": {
        "cursor": "cursor.shからCursorをダウンロード(トライアル後$20/月)",
        "install": "シームレスなワークフローのために両方を同じマシンにインストール",
        "plan": "ダウンロードページからPlanToCodeをダウンロード(無料、従量課金制のAPI使用)",
        "title": "ステップ1:両方のツールをインストール"
      },
      "step2": {
        "items": {
          "1": "Cursor(コンテキスト用)とPlanToCode(計画用)でプロジェクトを開く",
          "2": "PlanToCodeで:タスクを記述、ファイル検出を実行、実装プランを生成",
          "3": "Monacoエディタでプランをレビュー - ファイルパスを確認、重複がないことを確認",
          "4": "承認されたプランをコピー",
          "5": "Cursorで:Agent TerminalまたはComposerを開き、プランを貼り付け、Cursorに実行させる",
          "6": "Cursorが生成したコードをレビュー(アーキテクチャはすでに検証済み)"
        },
        "title": "ステップ2:最初の組み合わせワークフローを試す"
      },
      "step3": {
        "comparison": "どのツールをいつ使用するかの詳細な比較を参照",
        "docs": "ベストプラクティスのための実装計画ドキュメントを探索",
        "integration": "詳細なワークフローについてはCursor統合ガイドをお読みください",
        "title": "ステップ3:高度なワークフローを学ぶ"
      },
      "title": "両方のツールを始める"
    },
    "hero": {
      "badge": "置き換えではなく、安全なコンパニオン",
      "download": "PlanToCodeをダウンロード(無料)",
      "guide": "Cursor統合ガイドを見る",
      "subtitle": "Cursorの代替を検索するのをやめてください。本当の解決策はCursorを置き換えることではなく、重複ファイル、間違ったパス、本番バグが発生する前に防ぐ安全層を追加することです。",
      "title": "Cursorの代替?",
      "titleHighlight": "いいえ - あなたのCursor安全コンパニオン"
    },
    "meta": {
      "description": "Cursorの置き換えをお探しではありませんか? PlanToCodeはCursorと連携して、重複ファイル、間違ったパス、本番バグを防ぎます。両方を一緒に使用してください。",
      "title": "Cursor安全コンパニオン - 代替ではありません"
    },
    "prevention": {
      "bugs": {
        "generate": "Cursorの生成優先アプローチ:変更は即座に適用されます。Cursorがutils/helpers.tsを変更したことに気付かないかもしれません。これは他の15ファイルを壊します。本番環境またはテスト中に破損を発見します。",
        "plan": "PlanToCodeの計画優先アプローチ:プランは実行前にすべてのファイル変更を示します。utils/helpers.tsが変更されることがわかります。依存関係分析を実行します。15ファイルがそれに依存していることに気づきます。それに応じてプランを調整します。",
        "title": "本番バグの防止"
      },
      "duplicates": {
        "generate": "Cursorの生成優先アプローチ:AIは即座にコードを生成します。正しいファイルが見つからない場合や類似した名前に混乱した場合、新しいファイルを作成します。生成後に重複を発見します。",
        "plan": "PlanToCodeの計画優先アプローチ:プランはコード生成前に正確なファイルパスをリストします。プランにcomponents/Button.tsxとcomponents/ui/Button.tsxが表示されます。レビュー中に重複する命名の問題を検出します。",
        "title": "重複ファイルの防止"
      },
      "intro": "開発者がCursorで経験する問題はランダムではありません。生成優先ワークフローの予測可能な結果です。計画優先がそれぞれをどのように防ぐかを次に示します:",
      "paths": {
        "generate": "Cursorの生成優先アプローチ:特にマルチワークスペースプロジェクトでは、Cursorは間違ったワークスペースでコードを生成したり、相対パスを誤って使用したりする場合があります。コードが実行されないときにパスエラーを発見します。",
        "plan": "PlanToCodeの計画優先アプローチ:ファイル検出は完全なリポジトリ構造を示します。プランは絶対パスを使用します。レビューフェーズ中にパスが実際の構造と一致することを確認します。Cursorはプランから正しいパスを取得します。",
        "title": "間違ったファイルパスの防止"
      },
      "scope": {
        "generate": "Cursorの生成優先アプローチ:「ダークモードトグルを追加」と要求されると、Cursorはテーマシステム全体をリファクタリングし、30のコンポーネントを更新し、CSSアーキテクチャを変更する場合があります。生成後にスコープの拡大を発見します。",
        "plan": "PlanToCodeの計画優先アプローチ:プランには「変更:完全なテーマリファクタリングを含む47ファイル」と表示されます。スコープを即座に確認できます。プロンプトを改善:「トグルコンポーネントを追加するだけ、リファクタリングなし。」プランを再生成。今は3ファイルです。承認して実行します。",
        "title": "スコープクリープの防止"
      },
      "title": "計画優先がCursorの一般的な問題を防ぐ理由"
    },
    "problem": {
      "bugs": {
        "description": "レビューなしで直接適用された変更により、明確なロールバックパスなしで本番コードが壊れます。",
        "source": "— 大規模なコードベースでの一般的な苦情",
        "title": "本番バグ"
      },
      "duplicates": {
        "description": "「なぜCursorは重複ファイル構造を作成するのですか?蓄積された重複のためにプロジェクトを完全に放棄しました。」",
        "source": "— Cursorフォーラム #47028(14以上の返信)",
        "title": "重複ファイルの混乱"
      },
      "insight": "ここに洞察があります:これらはCursorのバグではありません。生成優先、レビュー後のアプローチに固有のものです。解決策は別のコードジェネレーターではありません。計画優先の安全層を追加することです。",
      "intro": "Cursorがコード生成が悪いからCursorの代替を検索しているのではありません。これらの問題の1つ(またはすべて)を経験したために検索しています:",
      "paths": {
        "description": "「Cursorはファイルパスを非常に頻繁に間違えます。複数のワークスペースではほぼ常に間違えます。」",
        "source": "— Cursor Issue #31402",
        "title": "間違ったパスエラー"
      },
      "title": "開発者が「Cursorの代替」を検索する理由",
      "unexpected": {
        "description": "「チャットからコード更新を適用すると、既存のファイルを変更する代わりに新しいファイルが作成されます。」",
        "source": "— Cursor Issue #22347",
        "title": "予期しないファイル作成"
      }
    },
    "testimonials": {
      "enterprise": {
        "quote": "コンプライアンスチームは、実行前にすべてのAI変更をシニアエンジニアがレビューすることを要求しています。PlanToCodeは必要な承認ワークフローを提供します。ジュニア開発者がプランを生成し、シニアがレビューして承認し、ジュニアが承認されたプランをCursorに貼り付けます。みんな満足しています。",
        "title": "エンタープライズチーム、レガシーコードベース(400k LOC)",
        "tools": "ツール:8人の開発者向けCursor Pro($160/月) + PlanToCodeセルフホスティングサーバー"
      },
      "freelancer": {
        "quote": "クライアントに時間単位で請求しています。重複ファイルのクリーンアップに2時間を費やす余裕はありません。PlanToCodeは5分のレビューフェーズ中にすべてを検出します。承認のためにクライアントにプランを見せ、彼らは何に対して支払っているかを正確に見て、それからCursorで実行します。非常にプロフェッショナルです。",
        "title": "フリーランサー、クライアントプロジェクト",
        "tools": "ツール:Cursor Pro($20/月) + PlanToCode(月額約$6の使用)"
      },
      "intro": "これらのワークフローは、開発者が両方のツールを一緒に使用する方法を示しています:",
      "solo": {
        "quote": "モノレポで常に重複ファイルが発生していました。Cursorはpackages/api/auth.tsとpackages/api/src/auth.tsを作成していました。今はPlanToCodeでプランを生成し、パスが正しいことを確認してから、Cursor Agentに貼り付けます。切り替えてから重複はゼロです。",
        "title": "ソロ開発者、モノレポ(120k LOC)",
        "tools": "ツール:Cursor Pro($20/月) + PlanToCode(月額約$8の使用)"
      },
      "startup": {
        "quote": "マルチワークスペースプロジェクトでのCursorのパスエラーは私たちを殺していました。PlanToCodeのファイル検出は、すべてのワークスペースにわたる完全な構造を示します。プランでパスを確認してから、Cursorは適切なコンテキストを持っているので完璧に実行します。",
        "title": "スタートアップCTO、マルチワークスペースプロジェクト",
        "tools": "ツール:Cursor Pro($20/月) + PlanToCode(月額約$12の使用)"
      },
      "title": "PlanToCodeを追加した実際のCursorユーザー"
    },
    "twist": {
      "complement": "PlanToCodeはCursorを置き換えません。欠けている部分を追加します:実行前の実装計画。ミスがコードになる前に検出する安全層と考えてください。",
      "cursorFor": {
        "autocomplete": "スマートオートコンプリート",
        "commands": "自然言語コマンド",
        "ide": "IDE統合",
        "prototypes": "クイックプロトタイプ",
        "speed": "コード生成速度",
        "title": "Cursorを使用する場合:"
      },
      "planFor": {
        "approval": "チーム承認ワークフロー",
        "duplicates": "重複ファイルの防止",
        "paths": "パスエラーの早期検出",
        "planning": "実装計画",
        "review": "実行前のレビュー",
        "title": "PlanToCodeを使用する場合:"
      },
      "strength": "Cursorは得意とすることに優れています:超高速のコード生成、スマートオートコンプリート、直感的なチャットインターフェース。しかし、即座にコードを生成するため、これは強みでもあり弱みでもあります。",
      "title": "ひねり:PlanToCodeは置き換えではありません"
    },
    "whenToUse": {
      "enterprise": {
        "cursor": "個人の貢献者にCursorを使用",
        "cursorDesc": "開発者は毎日Cursorを使用します。PlanToCodeからのプランが彼らの作業をガイドします。",
        "plan": "承認ワークフローにPlanToCodeを使用",
        "planDesc": "利害関係者は実行前にプランをレビューします。コンプライアンスとガバナンスのための監査証跡。",
        "title": "チーム環境とエンタープライズ"
      },
      "greenfield": {
        "cursor": "Cursorをスタンドアロンで使用",
        "cursorDesc": "シンプルな構造の新しいプロジェクトで、ミスをすばやく捉えることができます。ファイル編成はまだ複雑ではありません。",
        "plan": "PlanToCodeはオプション",
        "planDesc": "明確な構造を持つ小規模プロジェクトには重要ではありません。",
        "title": "グリーンフィールドプロジェクトとクイックプロトタイプ"
      },
      "large": {
        "cursor": "Cursorで実行",
        "cursorDesc": "承認されたプランをCursor Agentに貼り付けます。明確なコンテキストでコード生成を処理させます。",
        "plan": "PlanToCode計画から始める",
        "planDesc": "ファイルごとのプランを生成し、レビューフェーズ中に間違ったパスと重複を検出します。",
        "title": "大規模/レガシーコードベース(50k+ LOC)"
      },
      "medium": {
        "cursor": "実装にCursorを使用",
        "cursorDesc": "手動で変更をレビューするのに十分な速さです。優れたオートコンプリートが時間を節約します。",
        "plan": "複雑なタスクにPlanToCodeを追加",
        "planDesc": "リファクタリング、マルチパッケージの変更、またはパスエラーが発生した場合に計画を使用します。",
        "title": "中規模コードベース(10k-50k LOC)"
      },
      "title": "CursorとPlanToCodeをいつ使用するか(並列)"
    },
    "workflow": {
      "combined": "組み合わせワークフロー:計画 → 実行 → レビュー",
      "example": {
        "title": "実際の例:認証システムのリファクタリング",
        "with": "PlanToCodeを使用:変更が必要な12のファイルすべてを示すプランを生成します。Cursorの最初のプランが3つのAPIルートを見逃したことを検出します。修正されたプランを承認します。Cursorに貼り付けます。30分で完了、重複なし。",
        "without": "PlanToCodeなし:Cursorに「JWTを使用してセッションの代わりに認証をリファクタリング」を依頼します。Cursorはauth-new.ts、middleware/auth.ts(重複)を作成し、api/login.tsの更新を見逃します。修正に2時間を費やします。"
      },
      "intro": "最も効果的なワークフローは、両方のツールを組み合わせて、それぞれが得意とすることに使用します:",
      "step1": {
        "catch": "検出するもの:間違ったファイルパス、重複ファイル、欠落している依存関係、スコープクリープ",
        "description": "タスクを記述(音声またはテキスト)、ファイル検出を実行してすべての影響を受けるファイルを見つけ、複数のAIモデル(Claude、GPT、Gemini)から実装プランを生成します。",
        "title": "PlanToCodeで計画"
      },
      "step2": {
        "description": "Monacoエディタでプランを開きます。正確なファイルパスがリポジトリ構造と一致することを確認します。重複を確認します。改善が必要なステップを編集します。必要に応じて異なるモデルからのプランを統合します。",
        "gate": "安全ゲート:明示的な承認なしでは何も起こりません",
        "title": "レビューと承認"
      },
      "step3": {
        "alternative": "代替:完全なログ記録を備えたPlanToCodeの統合ターミナルで直接実行",
        "description": "承認されたプランをコピーします。Cursor Agent TerminalまたはComposerに貼り付けます。Cursorは完全なアーキテクチャコンテキストを持っています - どのファイルを変更するか、何を変更するか、なぜそうするかを正確に知っています。",
        "title": "Cursorで実行"
      },
      "step4": {
        "description": "Cursorは承認されたプランに従ってコードを生成します。実際の実装をレビューします。アーキテクチャはすでに承認されているため、コード品質のみをチェックしています - 構造的なミスを捉えていません。",
        "saved": "節約された時間:重複ファイルのクリーンアップ、パス修正、アーキテクチャの再作業なし",
        "title": "実装をレビュー"
      },
      "title": "CursorとPlanToCodeを一緒に使用する方法"
    }
  },
  "demo": {
    "cta": {
      "button": "すべてのスクリーンショットを見る",
      "description": "実際のワークフローからの実際のスクリーンショットを探索 - ファイル検出、実装プラン、ターミナルセッションなど。",
      "title": "もっと見たいですか?"
    },
    "hero": {
      "screenshots": "実際のスクリーンショットを見る",
      "subtitle": "PlanToCodeがコード変更をどのように計画し実行するかをご覧ください。",
      "title": "インタラクティブデモ",
      "video": "デモを見る"
    },
    "meta": {
      "description": "PlanToCodeがコード変更をどのように計画し実行するかをご覧ください。",
      "title": "インタラクティブデモ"
    }
  },
  "schedule": {
    "benefits": {
      "review": {
        "description": "既存のClaude Code、Cursor、またはAiderワークフローとの統合について話し合います。",
        "title": "アーキテクチャレビュー"
      },
      "session": {
        "description": "チームの要件とPlanToCodeがどのように役立つかについての集中的な相談。",
        "title": "30分セッション"
      },
      "team": {
        "description": "エンタープライズ機能、ターミナルガバナンス、展開オプションについて学びます。",
        "title": "チームソリューション"
      }
    },
    "footer": "適切な時間が見つかりませんか?メールでお問い合わせください",
    "hero": {
      "subtitle": "チームの特定のニーズに合わせたPlanToCodeの使用に関する専門家のガイダンスを取得します。アーキテクチャパターン、統合戦略、展開オプションについて話し合います。",
      "title": "アーキテクトと話す"
    },
    "meta": {
      "description": "チームの特定のニーズに合わせたPlanToCodeの使用に関する専門家のガイダンスを取得します。アーキテクチャパターン、統合戦略、展開オプションについて話し合います。",
      "title": "アーキテクトと話す"
    },
    "topics": {
      "items": {
        "cost": "大規模チーム向けのコスト最適化",
        "deployment": "オンプレミス展開要件",
        "integration": "既存のClaude Code/Cursorワークフローとの統合",
        "orchestration": "CI/CDパイプライン向けターミナルオーケストレーション",
        "planning": "レガシーコード向けマルチモデル計画戦略",
        "security": "セキュリティとコンプライアンスの考慮事項"
      },
      "title": "カバーする一般的なトピック"
    }
  },
  "workflows": {
    "hub": {
      "badge": "AI開発ワークフロー",
      "card": {
        "solves": "解決策:",
        "viewLink": "ワークフローを見る"
      },
      "cta": {
        "downloadLink": "PlanToCodeをダウンロード",
        "subtitle": "ファイル検出から始めて、包括的なプランを生成し、自信を持って実行します。",
        "title": "開発ワークフローを変革する準備はできましたか?"
      },
      "description": "複雑な開発タスクのための実証済みのワークフローを発見します。各ワークフローは、ファイル検出、マルチモデル計画、統合ターミナル実行を組み合わせて、実際のエンジニアリング課題を解決します。",
      "meta": {
        "description": "複雑なタスクのためのAI開発ワークフロー。リファクタリング、バグトリアージ、移行のためにClaude Code、Cursor、Codexと統合します。",
        "title": "AIコーディングワークフロー - PlanToCode統合パターン"
      },
      "title": "AIを活用した開発ワークフロー",
      "toolCategories": {
        "claudeCode": "Claude Codeワークフロー",
        "codexCli": "Codex CLIワークフロー",
        "cursor": "Cursorワークフロー",
        "general": "一般的なワークフロー"
      }
    }
  },
  "screenshots": {
    "title": "PlanToCodeスクリーンショット",
    "description": "実際のワークフローからの実際のスクリーンショットでPlanToCodeの動作をご覧ください。ファイル検出、実装プラン生成、ターミナル統合、音声文字起こし、マルチモデル計画など、すべての主要機能を視覚的に確認できます。開発ワークフロー全体を通じて、AIがどのように作業を支援するかを理解できます。各スクリーンショットは実際の使用例から取得されており、PlanToCodeが複雑な開発タスクをどのように処理するかを示しています。",
    "meta": {
      "title": "スクリーンショット - PlanToCodeの実際の動作",
      "description": "実際のワークフローからの実際のスクリーンショットでPlanToCodeの動作をご覧ください。ファイル検出、実装プラン、ターミナル統合、音声文字起こし、マルチモデルAI計画、アーキテクチャ統合など。開発者がPlanToCodeを使用してコード変更を安全に計画および実行する方法を確認してください。"
    }
  }
}
