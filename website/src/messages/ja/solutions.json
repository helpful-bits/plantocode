{
  "safeRefactoring": {
    "meta": {
      "title": "安全なリファクタリング - PlanToCode",
      "description": "リスクのない変更のためのAI計画。"
    }
  },
  "hub": {
    "meta": {
      "title": "開発ソリューション - PlanToCode",
      "description": "複雑な開発課題を解決:難しいバグ、大規模な機能、ライブラリのアップグレード、安全なリファクタリング、レガシーコードの保守。"
    }
  },
  "solutions": {
    "aiWrongPaths": {
      "meta": {
        "title": "Fix AI Wrong File Paths | PlanToCode File Discovery",
        "description": "AIが誤ったインポートパスやファイル参照を生成するのを防ぎます。PlanToCodeは実行前にすべてのファイルパスを検証します。モノレポやレガシーコードに最適です。"
      },
      "badge": "AIパス検証",
      "comparison": {
        "features": {
          "binaryFiltering": "バイナリファイルフィルタリング",
          "gitIntegration": ".gitignoreを尊重したGit統合",
          "monorepoResolution": "モノレポワークスペース解決",
          "pathAliasResolution": "TypeScriptパスエイリアス解決",
          "preExecutionValidation": "実行前パス検証",
          "realtimeProgress": "リアルタイム検証進捗",
          "symbolicLinks": "シンボリックリンク解決",
          "tokenBatching": "コスト最適化トークンバッチング"
        },
        "title": "PlanToCodeの比較"
      },
      "cta": {
        "description": "AIは実際に存在するファイルを参照する必要があります。PlanToCodeはコード生成前にすべてのパスを検証し、幻のインポートやビルドの破損を排除します。モノレポ、レガシーコードベース、複雑なプロジェクト構造に最適です。",
        "links": {
          "deepDive": "詳細解説:ファイル発見システム",
          "docs": "技術ドキュメントを読む"
        },
        "title": "幻のファイルパスとの戦いを終わらせる"
      },
      "description": "AIツールはインポートパスを幻覚して存在しないファイルを参照し、幻の依存関係でビルドを破壊します。PlanToCodeは実行前にすべてのファイルパスを検証して、モノレポやレガシーコードベースでの幻の参照を排除します。",
      "discoveryInAction": {
        "complete": {
          "description": "すべてのファイルがファイルシステムに対して検証されました。AIは生成されたコードで検証済みパスのみを参照します。幻のインポートは不可能です。",
          "title": "発見完了"
        },
        "stage1": {
          "description": "リポジトリをスキャンし、ルートディレクトリ構造と選択されたルートを表示",
          "title": "リポジトリスキャン開始"
        },
        "stage2": {
          "description": "git ls-filesを実行し、パターンを生成し、バイナリファイルをフィルタリング",
          "title": "Git統合による正規表現フィルタリング"
        },
        "title": "ファイル発見の実践"
      },
      "faq": {
        "cost": {
          "answer": "通常、リポジトリのサイズと複雑さに応じて、完全なワークフローあたり$0.10-0.15です。5段階の発見プロセスは、インテリジェントなトークンバッチングとコンテンツ対応の推定を使用して、APIコストを最小限に抑えながら精度を最大化します。コスト追跡はすべての段階に組み込まれています。",
          "question": "ファイル発見の実行あたりのコストはいくらですか?"
        },
        "excludeDirectories": {
          "answer": "はい。ファイル発見ワークフローは自動的に.gitignoreルールを尊重します。さらに、バイナリファイルと97の一般的な非コード拡張子がデフォルトでフィルタリングされます。プロジェクト設定でカスタム除外パターンを設定することもできます。",
          "question": "発見から特定のディレクトリを除外できますか?"
        },
        "monorepoSupport": {
          "answer": "はい。PlanToCodeはpnpmワークスペース、Yarnワークスペース、npmワークスペース、Nxを含むモノレポ構造を明示的にサポートしています。ファイル発見ワークフローはワークスペース設定を解析し、内部パッケージ参照、ホイストされた依存関係、ワークスペースプロトコルインポートを正しく解決します。",
          "question": "ファイル発見はモノレポで機能しますか?"
        },
        "pathAliases": {
          "answer": "はい。パス検証段階はtsconfig.jsonのパスマッピングを理解し、@/*や~/*のようなTypeScriptエイリアスを実際のファイルシステムに対して解決します。これにより、AI生成のインポートが正しいエイリアス構文を使用することが保証されます。",
          "question": "TypeScriptパスエイリアスで機能しますか?"
        },
        "stillWrongPath": {
          "answer": "ファイル発見はパスの幻覚を劇的に減少させますが、AIモデルは作成しているコードの新しいファイル名を生成することがあります。PlanToCodeは既存のファイルの検証に焦点を当てています。新しく作成されたファイルの場合、実装計画は明確なファイルパスを示し、AIツールにコピーする前に検証できます。",
          "question": "AIがまだ間違ったパスを提案した場合はどうなりますか?"
        },
        "title": "よくある質問",
        "verifiedPaths": {
          "answer": "もちろんです。PlanToCodeは段階ごとの更新でリアルタイムの進捗追跡を提供します。どのディレクトリがスキャンされたか、何個のファイルが検証を通過したか、どのパスが修正されたか、AIが利用できる検証済みファイルの最終リストを正確に確認できます。",
          "question": "どのパスが検証されたかを確認できますか?"
        }
      },
      "gettingStarted": {
        "step1": {
          "description": "macOS、Windows、またはLinux用にインストールします。お好みのAIモデル(Claude、GPT-4、Gemini、またはローカルモデル)に接続します。開始するためにAPIキーは必要ありません。",
          "title": "PlanToCodeをダウンロード"
        },
        "step2": {
          "description": "プロジェクトを開き、ファイル発見ワークフローを開始します。PlanToCodeは自動的にコードベース構造全体をスキャンして検証します。各段階のリアルタイム進捗を監視します。",
          "title": "ファイル発見を実行"
        },
        "step3": {
          "description": "AIは検証済みのファイルパスのみを使用してコードを生成します。幻のインポートなし、幻の依存関係なし、ビルドの破損なし。自信を持ってコピーできます。",
          "title": "検証済みコードを生成"
        },
        "title": "間違ったファイルパスの防止を開始"
      },
      "howPlanToCodePrevents": {
        "monorepoAware": {
          "description": "PlanToCodeはモノレポ構造を理解し、ワークスペース参照、内部パッケージパス、ホイストされた依存関係を正しく解決します。",
          "features": [
            "ワークスペース設定を解析(pnpm、yarn、npm)",
            "内部パッケージの相互参照を解決",
            "複数のnode_modules階層を処理",
            "ワークスペースプロトコルインポートを検出して尊重"
          ],
          "title": "モノレポ対応解決"
        },
        "pathValidation": {
          "description": "発見ワークフローの段階5で、ファイルパスを具体的に検証・修正します。これはAIモデルがコードベースを見る前に自動的に実行されます。",
          "features": [
            "ファイルのアクセス可能性と権限を確認",
            "パスの不整合を自動的に解決",
            "モノレポワークスペースプロトコルを処理",
            "tsconfigからのインポートエイリアスマッピングを検証"
          ],
          "link": "技術ドキュメント",
          "title": "パス検証パイプライン"
        },
        "preExecutionDiscovery": {
          "description": "AIがコードを生成する前に、PlanToCodeは実際のファイルシステムをマッピングする5段階のファイル発見ワークフローを実行します。すべてのファイルパスは、コンテキストに含まれる前に存在することが検証されます。",
          "features": [
            "git ls-files統合でリポジトリをスキャン",
            "実際のファイルシステムに対してファイルの存在を検証",
            "シンボリックリンクとパスエイリアスを解決",
            "クロスプラットフォーム互換性のためにパスを正規化"
          ],
          "link": "ファイル発見について学ぶ",
          "title": "実行前ファイル発見"
        },
        "realTimeFeedback": {
          "description": "段階ごとの更新でリアルタイムのファイル発見進捗を監視します。AIがコードを生成する前に、どのパスが検証され修正されているかを正確に確認できます。",
          "features": [
            "各発見段階のライブ進捗追跡",
            "パス問題の詳細なエラーメッセージ",
            "ファイル数とトークン使用量の推定",
            "コスト追跡:通常ワークフローあたり$0.10-0.15"
          ],
          "title": "リアルタイム検証フィードバック"
        },
        "title": "PlanToCodeが間違ったファイルパスを防ぐ方法"
      },
      "impact": {
        "forDevelopers": {
          "benefits": [
            "幻のインポートのデバッグを停止。AIが最初に生成すべきだった正しいパスを見つけるためにディレクトリツリーを探し回る必要はもうありません。",
            "より速く出荷。AI生成コードが最初の貼り付けで動作すると、速度が劇的に向上します。ロジックに集中し、パス修正ではありません。",
            "AI出力を信頼。パス検証は信頼を構築します。コードをエディタにコピーする前に、インポートが正しいことがわかります。",
            "レガシーコードで作業。複雑で文書化されていないコードベースは、すべてのパスが現実に対して検証されると、ナビゲート可能になります。"
          ],
          "title": "個人開発者向け"
        },
        "forTeams": {
          "benefits": [
            "より速くオンボーディング。新しいチームメンバーは、検証済みファイル発見を通じてコードベース構造を理解します。インポート規約を推測する必要はありません。",
            "PRノイズを削減。誤ったインポートパスを修正するだけのコミットを排除します。コードレビューはロジックに焦点を当て、パス修正ではありません。",
            "モノレポを自信を持ってスケール。ワークスペースが成長するにつれて、パス検証はインポートの混乱の指数関数的増加を防ぎます。",
            "AI使用を標準化。全員が検証済みパスを使用すると、AI生成コードはチーム全体で一貫性を維持します。"
          ],
          "title": "エンジニアリングチーム向け"
        },
        "metrics": {
          "cost": "$0.12 検証ワークフローあたりの平均コスト",
          "disclaimer": "200から5,000ファイルのモノレポコードベースを使用した内部テストに基づいています。リポジトリの構造と複雑さによって結果は異なる場合があります。",
          "reduction": "85% パス関連のデバッグ時間の削減",
          "speed": "23秒 589ファイルの平均スキャン時間",
          "title": "測定された影響"
        },
        "title": "検証済みファイルパスの影響"
      },
      "problem": {
        "description": "コンポーネントのリファクタリングをAIに依頼。AIは@/components/ui/NewButtonからインポートするコードを自信を持って生成しますが、それは存在しないファイルです。ビルドが失敗。幻のインポートを追跡するのに20分を無駄にします。",
        "quote": "AIは存在しないパスからインポートしようとしました",
        "scenarios": {
          "contextWindow": {
            "description": "大規模プロジェクトはAIコンテキストウィンドウを超えます。モデルは不完全な情報に基づいてファイルの場所を推測し、自信があるが誤ったパス参照を生成します。",
            "title": "コンテキストウィンドウの制限"
          },
          "legacy": {
            "description": "コードベースにsrc/componentsとlib/componentsがあります。AIは間違った方を選ぶか、存在しない第3のディレクトリを幻覚します。",
            "title": "レガシーコードの混乱"
          },
          "monorepo": {
            "description": "AIは@workspace/coreと@workspace/sharedを混同し、妥当に見えるが間違ったパッケージを参照するインポートを生成します。",
            "title": "モノレポの悪夢"
          }
        },
        "title": "間違ったファイルパスの問題"
      },
      "realWorldScenarios": {
        "title": "実世界のシナリオ",
        "with": {
          "description": "ファイル発見がパスエラーを防ぎ、最初の試行で正しいインポートを生成し、何時間ものデバッグ時間を節約する方法を示すシナリオ。",
          "title": "PlanToCode検証あり"
        },
        "without": {
          "description": "検証なしでリファクタリングするときのパス幻覚の問題を示すシナリオ。壊れたインポートと手動パス修正作業につながります。",
          "title": "パス検証なし"
        }
      },
      "title": "AIが間違ったファイルパスを生成するのを防ぐ",
      "whyAIGeneratesWrongPaths": {
        "contextOverflow": {
          "description": "200Kトークンのコンテキストウィンドウでさえ、エンタープライズコードベース全体を保持できません。モデルはファイルの一部を見て残りを推測し、パスの不一致につながります。",
          "points": [
            "不完全なディレクトリツリーの可視性",
            "欠落しているインポートエイリアス設定",
            "進化するコードベースの古いスナップショット"
          ],
          "title": "コンテキストウィンドウオーバーフロー"
        },
        "modelHallucination": {
          "description": "大規模言語モデルは、異なる構造を持つ数百万のコードベースでトレーニングされています。コードを生成するとき、実際のファイルシステムではなく、トレーニングデータに対してパターンマッチングを行います。",
          "points": [
            "モデルは実際のパスではなく、確率的なパスを予測",
            "トレーニングデータには一貫性のない命名規則が含まれている",
            "生成ループにファイルシステム検証がない"
          ],
          "title": "モデルの幻覚"
        },
        "monorepoComplexity": {
          "description": "モノレポは、ワークスペースプロトコル、内部パッケージ、複数のnode_modulesディレクトリでパスの混乱を増幅します。",
          "points": [
            "ワークスペース間で競合するパッケージ名",
            "複雑なtsconfigパスマッピング",
            "不明確な解決を伴うホイストされた依存関係"
          ],
          "title": "モノレポの複雑さ"
        },
        "noVerification": {
          "description": "標準的なAIコード生成には、ファイルの存在を検証する後処理ステップがありません。生成されたコードはファイルシステムチェックなしで直接あなたに届きます。",
          "points": [
            "ファイル存在検証なし",
            "インポートパス解決テストなし",
            "実際のディレクトリ構造との相互参照なし"
          ],
          "title": "検証レイヤーなし"
        },
        "title": "AIが間違ったファイルパスを生成する理由"
      }
    },
    "hardBugs": {
      "meta": {
        "title": "Resolve hard bugs with reproducible context - PlanToCode",
        "description": "How PlanToCode captures plan history, terminal logs, and live transcripts so tricky production issues can be reproduced without guesswork."
      },
      "badge": "本番デバッグ",
      "cta": {
        "description": "すべての調査を保存し、すべてのステップを再現し、コンテキストを失わない。これが本番デバッグのあるべき姿です:規律正しく、再現可能で、完全です。",
        "links": {
          "terminal": "ターミナル永続化を探索",
          "voice": "音声ノートについて学ぶ"
        },
        "title": "自信を持って本番問題をデバッグ"
      },
      "description": "PlanToCodeはデバッグ中のジョブに、すべての計画、ターミナルセッション、音声ノートを添付し続けます。問題を分離するために使用した正確なコマンド、トークンバジェット、計画の改訂を再度開けます。",
      "sections": {
        "persistTerminal": {
          "description": "各デバッグターミナルは管理されたPTY内で実行されます。セッションメタデータ、作業ディレクトリ、完全な出力ログはSQLiteに保存され、クラッシュ後に再度開くことができます。CLI検出は、コマンドを実行する前にclaude、cursor、codex、またはgeminiバイナリがインストールされていることを確認します。",
          "link": "ターミナル動作",
          "title": "ターミナル出力を永続化"
        },
        "reproduceSurface": {
          "description": "ファイル発見ワークフローから始めて、インシデントで参照されるモジュールにリポジトリを絞り込みます。ワークフローはセッション入力を検証し、バックグラウンドジョブをキューに入れ、選択されたルートを保存して、すべてのフォローアップ計画が同じスコープを使用できるようにします。",
          "link": "ワークフローの詳細",
          "title": "失敗する表面を再現"
        },
        "reviewFixes": {
          "description": "実装計画は、言語検出、コピーコントロール、履歴ジョブ間のナビゲーションを備えたMonacoビューアにストリーミングされます。トークン推定は、プロンプトを外部ツールにコピーする前に実行され、修正がモデルの制限内に収まることを確認するのに役立ちます。",
          "link": "計画ビューアの概要",
          "title": "すべての提案された修正をレビュー"
        },
        "voiceNotes": {
          "description": "音声文字起こしはターミナルとプロンプトエディタに直接統合されます。録音フックはマイクの権限、デバイスの選択、無音検出を管理し、トリガーしたコマンドの横に認識されたテキストを挿入します。",
          "link": "文字起こしパイプライン",
          "title": "コンテキスト内で音声ノートをキャプチャ"
        }
      },
      "title": "保存されたコンテキストで難しいバグを解決"
    },
    "hub": {
      "badge": "開発ソリューション",
      "categories": {
        "debugging": "デバッグ",
        "development": "開発",
        "maintenance": "メンテナンス",
        "refactoring": "リファクタリング",
        "safety": "安全性"
      },
      "cta": {
        "button": "PlanToCodeをダウンロード",
        "description": "自信を持って複雑な変更を計画し始めましょう。今すぐPlanToCodeをダウンロードしてください。",
        "title": "開発課題を解決する準備はできていますか?"
      },
      "description": "AI搭載の計画で複雑な開発課題に取り組みます。難しいバグのデバッグからレガシーコードのリファクタリングまで、PlanToCodeはチームが必要とする安全性レイヤーを提供します。",
      "solutions": {
        "aiWrongPaths": {
          "description": "実行前にAI生成パスをレビューしてファイル位置エラーを防止",
          "title": "間違ったパスを防止"
        },
        "hardBugs": {
          "description": "再現可能なバグ調査のために計画履歴、ターミナルログ、トランスクリプトをキャプチャ",
          "title": "難しいバグを解決"
        },
        "largeFeatures": {
          "description": "依存関係マッピングと段階的実行で複数ファイル機能を計画して追跡",
          "title": "大規模機能"
        },
        "legacyCodeRefactoring": {
          "description": "レガシーコードベースの安全な近代化のためのAI搭載計画",
          "title": "レガシーコードリファクタリング"
        },
        "libraryUpgrades": {
          "description": "影響分析と包括的なテストで依存関係を安全にアップグレード",
          "title": "ライブラリアップグレード"
        },
        "maintenanceEnhancements": {
          "description": "監査証跡で継続的なタスクを文書化し、リグレッションを防止",
          "title": "メンテナンスと機能強化"
        },
        "preventDuplicateFiles": {
          "description": "実行前ファイル発見でAIが重複ファイルを作成するのを防止",
          "title": "重複ファイルを防止"
        },
        "safeRefactoring": {
          "description": "依存関係の可視性によるリスクフリーのコード変更のためのAI搭載計画",
          "title": "安全なリファクタリング"
        }
      },
      "title": "AI搭載開発ソリューション",
      "viewSolution": "ソリューションを表示"
    },
    "largeFeatures": {
      "meta": {
        "title": "Ship Large Features with Traceable Plans - PlanToCode",
        "description": "Use PlanToCode to coordinate implementation plans, model selections, and background workflows when delivering multi-step features."
      },
      "badge": "機能計画",
      "cta": {
        "description": "最初のワークフローから最終デプロイまで、完璧なトレーサビリティを維持します。これが機能提供のあるべき姿です:調整され、予測可能で、追跡可能です。",
        "links": {
          "plans": "実装計画を見る",
          "workflows": "スコープワークフローについて学ぶ"
        },
        "title": "自信を持って複雑な機能を出荷"
      },
      "description": "複数段階の配信には、一貫したスコープ、レビュー可能な計画、予測可能なトークン使用が必要です。PlanToCodeは最初のワークフロー実行から最終ターミナルセッションまで、これらのシグナルを接続し続けます。",
      "sections": {
        "coordinatePlans": {
          "description": "計画はMonacoビューアにストリーミングされ、バックグラウンドジョブにリンクされたままになります。以前のドラフトをナビゲートし、複数の計画を統合し、コンテキストを失うことなく特定のジョブのターミナルモーダルを開きます。トークン推定は、プロンプトをエクスポートする前に実行されます。",
          "link": "実装計画",
          "title": "実装計画を調整"
        },
        "keepAligned": {
          "description": "ターミナルセッションは出力ログをSQLiteに保存し、接続の健全性を公開するため、長時間実行される機能作業は監査可能なままです。チームがウォークスルーを記録する場合、音声文字起こしは、実行されたコマンドと一緒に検索可能なノートを追加します。",
          "link": "ターミナルと文字起こし",
          "title": "実行を整合させる"
        },
        "pickModel": {
          "description": "各タスクタイプはデフォルトモデルと許可リストを提供します。モデルセレクタトグルは、モデルのコンテキストウィンドウを超えるプロンプトの送信を防ぎ、バックエンドコマンドから引き出された推定トークン要件を表示します。",
          "link": "モデル設定",
          "title": "タスクごとに適切なモデルを選択"
        },
        "sameScope": {
          "description": "ファイル発見ワークフローを使用して、すべてのタスクに関連するディレクトリを収集します。入力は検証され、バックグラウンドジョブはワークフローオーケストレータを介して実行され、選択されたルートが保存されるため、後の計画の改訂は同じリポジトリスライスを再利用します。",
          "link": "ファイル発見ワークフロー",
          "title": "同じスコープで開始"
        }
      },
      "title": "追跡可能な計画で大規模機能を出荷"
    },
    "legacyCodeRefactoring": {
      "meta": {
        "title": "Legacy Code Refactoring - AI Safe Modernization",
        "description": "Refactor legacy code safely with AI planning. Map dependencies, generate migration strategies, and modernize 100K+ line codebases without breaking production."
      },
      "challenge": {
        "description": "5年前のコードベースの近代化を任されています:古いフレームワーク、テストなし、文書化されていないパターン、完全には理解していない重要なビジネスロジック。直接のAIリファクタリングは混沌です。計画はロードマップを提供します。",
        "title": "レガシーコードの課題"
      },
      "cta": {
        "buttons": {
          "download": "PlanToCodeをダウンロード",
          "learnMapping": "依存関係マッピングについて学ぶ"
        },
        "description": "PlanToCodeは、依存関係をマッピングし、移行計画を生成し、本番を破壊することなくリファクタリングするのに役立ちます。",
        "title": "レガシーコードを安全に近代化"
      },
      "description": "レガシーコードは、AI支援リファクタリングが危険になる場所です。一つの間違いで本番が壊れます。AI計画で10万行以上のコードベースを安全に近代化する方法は次のとおりです。",
      "furtherReading": {
        "bestPractices": "AIコード計画のベストプラクティス",
        "safeRefactoring": "本番コードの安全なリファクタリングツール",
        "title": "参考文献",
        "whatIsPlanning": "AIコード計画とは?"
      },
      "gettingStarted": {
        "steps": [
          {
            "title": "リファクタリングする最小の価値単位を選択",
            "description": "10,000行のGodクラスから始めないでください。価値を提供する独立した200行のモジュールを見つけてください。"
          },
          {
            "title": "すべての依存関係をマッピング",
            "description": "ファイル発見を使用して、インポート、エクスポート、関数呼び出しを見つけます。爆発半径を知ります。"
          },
          {
            "title": "特性テストを作成",
            "description": "間違っていても、現在の動作をキャプチャするテスト。リファクタリングが機能を保持することを保証します。"
          },
          {
            "title": "リファクタリング計画を生成",
            "description": "AIを使用してファイルごとの移行戦略を作成します。欠落しているステップやリスクをレビューします。"
          },
          {
            "title": "段階的に実行",
            "description": "デプロイごとに1つの小さな変更。テストを実行。本番を監視。繰り返します。"
          }
        ],
        "title": "レガシーリファクタリングの開始"
      },
      "mistakes": {
        "bigBang": {
          "instead": "代わりに:継続的デプロイによる段階的リファクタリング",
          "problem": "すべてをゼロから書き直すのに6か月を費やします。80%完了したときに、古いコードに知らなかったエッジケースがあることに気付きます。プロジェクトは失敗します。",
          "title": "ビッグバン書き換え"
        },
        "noRollback": {
          "instead": "代わりに:フィーチャーフラグ、down()関数を持つデータベース移行",
          "problem": "50ファイルをリファクタリングし、デプロイし、本番を壊します。変更が絡み合っているため、簡単に元に戻せません。",
          "title": "ロールバック計画なし"
        },
        "noTests": {
          "instead": "代わりに:最初に特性テストを書き、次にリファクタリング",
          "problem": "コードを変更し、動作することを願い、デプロイし、本番でバグを見つけます。信頼が失われるまで繰り返します。",
          "title": "テストなしのリファクタリング"
        },
        "title": "一般的なレガシーリファクタリングの間違いを避ける"
      },
      "patterns": {
        "featureFlag": {
          "bestFor": "重要なパスへの高リスク変更(認証、支払い、コア機能)",
          "howItWorks": "コードをリファクタリングし、フィーチャーフラグの後ろに置きます。数週間かけてユーザーの1%、10%、50%、100%にロールアウト。問題があれば即座にロールバック。",
          "title": "フィーチャーフラグロールアウト"
        },
        "parallelRun": {
          "bestFor": "データ処理パイプライン、重要なアルゴリズム、レポートシステム",
          "howItWorks": "古いコードと新しいコードを並行して実行します。出力を比較します。99.9%の一致率が達成されたときにのみ新しいコードに切り替えます。",
          "title": "並行実行 + 検証"
        },
        "stranglerFig": {
          "bestFor": "モノリス → マイクロサービス、古いフレームワーク → 新しいフレームワーク",
          "howItWorks": "古いコードと並行して新しいコードを構築します。古いコードから新しいコードへトラフィックを徐々にルーティングします。100%移行されたときにのみ古いコードを削除します。",
          "title": "ストラングラーフィグパターン"
        },
        "title": "移行戦略パターン"
      },
      "realExample": {
        "codebase": "2018年に書かれた150のReactクラスコンポーネント。保守性とパフォーマンスのためにフックに近代化する必要があります。",
        "scenario": "シナリオ",
        "title": "実例:Reactクラスからフックへの移行",
        "with": {
          "steps": [
            "第1週:リーフコンポーネントを移行(依存関係なし)",
            "第2週:コンテキストプロバイダを移行(すべてのコンシューマに影響)",
            "第3週:コンテナコンポーネントを移行(子を調整)",
            "第4週:古いHOCを削除、完全にフックベース",
            "結果:クリーンな移行、本番の破損なし、4週間のタイムライン"
          ],
          "title": "計画あり:"
        },
        "without": {
          "steps": [
            "AIが10コンポーネントを変換",
            "他のコンポーネントが依存するライフサイクル依存関係を壊す",
            "コンテキストプロバイダが動作しなくなる(クラスベースAPI)",
            "すべての破損を見つけるのに3日間のデバッグ"
          ],
          "title": "計画なし:"
        }
      },
      "scenarios": {
        "databaseSchema": {
          "approach": "計画アプローチ:",
          "challenge": "2018年からの非正規化スキーマ。user_dataテーブルを5つの正規化されたテーブルに分割する必要があります。",
          "steps": [
            "user_dataから読み取るすべてのクエリを見つける(grep + 静的解析)",
            "どのクエリがどの新しいテーブルを必要とするかをマッピング",
            "デュアルライトフェーズでゼロダウンタイム移行を計画",
            "データの整合性を確保するための検証クエリを作成"
          ],
          "title": "データベーススキーマ移行"
        },
        "frameworkMigration": {
          "approach": "計画アプローチ:",
          "challenge": "DOMを直接操作する200ページのスパゲッティjQuery。コンポーネント構造なし。関心事が至る所で混在。",
          "steps": [
            "すべてのjQueryセレクタをマッピングしてUIコンポーネントを特定",
            "関連するDOM操作を論理コンポーネントにグループ化",
            "段階的移行を計画:一度に1ページ、両方のフレームワークが共存",
            "遷移中の共有状態のためのアダプタレイヤーを作成"
          ],
          "title": "フレームワーク移行(jQuery → React)"
        },
        "monolith": {
          "approach": "計画アプローチ:",
          "challenge": "50万行のモノリス、すべての機能が密結合。ユーザー管理を別のサービスに抽出する必要があります。",
          "steps": [
            "サービス境界を特定:何が残り、何が移動するか",
            "すべての境界を越えたデータフローとAPI呼び出しをマッピング",
            "データベース抽出戦略を計画(デュアルライトフェーズ)",
            "各移行ステップのロールバック計画を作成"
          ],
          "title": "モノリスからマイクロサービスへ"
        },
        "title": "一般的なレガシーリファクタリングシナリオ"
      },
      "title": "レガシーコードリファクタリングツール:AI計画が災害を防ぐ方法",
      "tools": {
        "complexity": {
          "description": "どのファイルが最も複雑か(循環的複雑度)を特定します。シンプルなものからリファクタリングを開始します。",
          "title": "コード複雑度分析",
          "tools": "ツール:SonarQube、ESLint複雑度ルール"
        },
        "dependencyMapping": {
          "description": "すべてのインポートチェーン、関数呼び出しグラフ、型依存関係を見つけます。Xを変更すると何が壊れるかを知ります。",
          "title": "依存関係マッピング",
          "tools": "ツール:PlanToCodeファイル発見、madge、dependency-cruiser"
        },
        "staticAnalysis": {
          "description": "未使用のコード、デッドインポート、型の不一致を見つけます。大規模なリファクタリングの前にこれらをクリーンアップします。",
          "title": "静的解析",
          "tools": "ツール:TypeScript strictモード、ESLint no-unused-vars"
        },
        "testCoverage": {
          "description": "リファクタリング前にどのコードにテストがあるかを知ります。必要に応じて、重要なパスのテストを最初に作成します。",
          "title": "テストカバレッジレポート",
          "tools": "ツール:Jestカバレッジ、Istanbul、Codecov"
        },
        "title": "レガシーコード計画のためのツール"
      },
      "whyBreaks": {
        "description": "レガシーコードベースには、リファクタリングをリスクにする特性があります:",
        "points": {
          "hiddenDeps": {
            "description": "20以上の場所から呼び出される関数、予期せず変更されるグローバル状態、存在を知らなかった循環インポート。",
            "title": "隠れた依存関係"
          },
          "insufficientTests": {
            "description": "30%のコードカバレッジ、通過するが実際には動作を検証しないテスト、実行に45分かかる統合テスト。",
            "title": "不十分なテスト"
          },
          "outdatedPatterns": {
            "description": "現代のベストプラクティスの前に書かれたコード。コールバック地獄、密結合モジュール、関心の分離なし。",
            "title": "古いパターン"
          },
          "poorDocs": {
            "description": "コメントなし、謎めいた変数名、実装の詳細に埋もれたビジネスロジック。物を壊して学びます。",
            "title": "貧弱なドキュメント"
          }
        },
        "title": "レガシーコードが簡単に壊れる理由"
      },
      "workflow": {
        "steps": [
          {
            "title": "既存システムをマッピング",
            "description": "ファイル発見を実行し、リファクタリングする領域に触れるすべてのファイルを特定します。何かを変更する前に依存関係を理解します。"
          },
          {
            "title": "複数の移行戦略を生成",
            "description": "AIに3つの異なるアプローチを依頼します:ビッグバン移行、段階的ロールアウト、ストラングラーフィグパターン。トレードオフを比較します。"
          },
          {
            "title": "段階的計画を作成",
            "description": "週次マイルストーンに分割します。各ステップは独立してデプロイ可能でテスト可能でなければなりません。本番環境で「半分移行された」状態はありません。"
          },
          {
            "title": "チームでレビュー(レガシーには必須)",
            "description": "チームの誰かが隠れた落とし穴を知っています。計画レビューは、物を壊す前にその部族の知識を表面化します。"
          },
          {
            "title": "ロールバック計画で実行",
            "description": "ステップ1を実装し、動作することを確認してから、ステップ2。常に元に戻す方法を持ちます。フィーチャーフラグはあなたの友達です。"
          }
        ],
        "subtitle": "安全なレガシーリファクタリングプロセス",
        "title": "計画優先リファクタリングワークフロー"
      }
    },
    "libraryUpgrades": {
      "meta": {
        "title": "Upgrade Libraries with Guardrails - PlanToCode",
        "description": "Plan migrations, monitor terminal output, and keep transcripts when updating frameworks or dependencies."
      },
      "badge": "アップグレード計画",
      "cta": {
        "description": "すべての変更を監査し、すべての移行を追跡し、完全な制御を維持します。これがライブラリアップグレードのあるべき姿です:安全で、監査可能で、可逆的です。",
        "links": {
          "planning": "アップグレード計画を探索",
          "scope": "スコープ分析について学ぶ"
        },
        "title": "恐れることなく依存関係をアップグレード"
      },
      "description": "依存関係の近代化は、しばしば複数のリポジトリとチームにまたがります。PlanToCodeは、作業のスコープを設定し、各ステップを文書化し、変更内容の監査可能な証跡を維持するのに役立ちます。",
      "sections": {
        "executionHistory": {
          "description": "ターミナルセッションは、再起動後も完全な出力ログと接続の健全性を維持します。音声文字起こしは、トリッキーな移行ステップに音声コンテキストを追加でき、リリースノートと変更レビューのための検索可能な証跡を作成します。",
          "link": "ターミナルと文字起こし",
          "title": "実行履歴を文書化"
        },
        "identifyFiles": {
          "description": "プロジェクトディレクトリに対してファイル発見ワークフローをトリガーして、アップグレードホットスポットを収集します。オーケストレーションされたバックグラウンドジョブは、選択されたルートを記録し、すべての後続の計画またはプロンプトで利用できるようにします。",
          "link": "ファイル発見ワークフロー",
          "title": "影響を受けるファイルを特定"
        },
        "modelLimits": {
          "description": "アップグレードプロンプトには、しばしば大きな差分が含まれます。タスクレベルのモデル設定は、どのモデルが許可されるかを定義し、セレクタトグルは、コンテキストウィンドウが推定プロンプトと出力トークンを処理できない選択をブロックします。",
          "link": "モデルガードレール",
          "title": "モデル制限内に留まる"
        },
        "trackPlans": {
          "description": "Monacoビューア内で生成された計画をレビューし、リビジョンを比較し、重複する提案を統合します。計画はバックグラウンドジョブにリンクされたままなので、アップグレードを再訪するたびに関連するターミナルセッションまたはプロンプトコピーモーダルを再度開くことができます。",
          "link": "実装計画",
          "title": "アップグレード計画を追跡"
        }
      },
      "title": "ガードレール付きでライブラリをアップグレード"
    },
    "maintenanceEnhancements": {
      "meta": {
        "title": "Maintenance & Enhancements with Repeatable Workflows - PlanToCode",
        "description": "Apply systematic maintenance tasks with scoped discovery, plan history, and auditable terminal logs."
      },
      "badge": "継続的メンテナンス",
      "cta": {
        "description": "体系的なメンテナンスワークフローを構築します。保存されたコンテキスト、再利用可能な計画、モデルガードレールが技術的負債を管理可能で反復可能なプロセスに変えます。",
        "links": {
          "history": "計画履歴について学ぶ",
          "workflows": "スコープワークフローを探索"
        },
        "title": "メンテナンスを戦略的優位性に変える"
      },
      "description": "チームがスコープを見失ったり、同じ調査を繰り返したりすると、メンテナンス作業は遅くなります。PlanToCodeは、修正を安全に適用するために必要なコンテキスト、計画、実行履歴を保持します。",
      "sections": {
        "controlModels": {
          "description": "モデルセレクタトグルは、メンテナンスタスクごとのコンテキストウィンドウを強制します。バックエンドからのトークン推定により、大きなパッチの説明が、エージェントに送信する前に選択したモデルに適合することを確認できます。",
          "link": "モデルガードレール",
          "title": "モデル使用を制御"
        },
        "planHistory": {
          "description": "メンテナンス計画は、リビジョン間のナビゲーション、マージアクション、プロンプトコピーコントロールを備えたMonacoビューアにストリーミングされます。以前のジョブを再度開いて、正確にどのステップが実行されたか、それらを繰り返す必要があるかどうかを確認します。",
          "link": "実装計画",
          "title": "計画履歴を保持"
        },
        "preserveLogs": {
          "description": "ターミナルセッションは、タイムスタンプ、終了コード、キャプチャされた出力とともにSQLiteに永続化されます。音声文字起こしは、同じジョブに音声ノートを追加でき、将来のメンテナが何が変更されたか、なぜ変更されたかについて完全なコンテキストを提供します。",
          "link": "ターミナルと文字起こし",
          "title": "実行ログを保存"
        },
        "reuseWorkflows": {
          "description": "ファイル発見ジョブは、以前のメンテナンスタスクによって触れられたディレクトリを収集します。類似の作業が戻ってきたときに、スコープを手動で再構築する代わりに、保存されたルートに対して計画を再実行できます。",
          "link": "ファイル発見ワークフロー",
          "title": "スコープワークフローを再利用"
        }
      },
      "title": "反復可能なワークフローでシステムをメンテナンス"
    },
    "preventDuplicateFiles": {
      "meta": {
        "title": "Prevent AI from Creating Duplicate Files",
        "description": "Stop AI tools from creating duplicate files. PlanToCode file discovery prevents duplicates before execution for Cursor, Copilot users."
      },
      "badge": "重複ファイル防止",
      "beforeAfter": {
        "title": "前後:計画なしAI vs. PlanToCodeあり",
        "with": {
          "benefits": {
            "items": [
              "重複ファイルの作成ゼロ",
              "既存コードへのクリーンな変更",
              "すべてのインポートが有効なまま",
              "節約された時間:2-4時間"
            ],
            "title": "達成された利点:"
          },
          "steps": [
            {
              "label": "ユーザー:「認証にJWT検証を追加」",
              "detail": "ファイル発見ワークフローが自動的に開始"
            },
            {
              "label": "5段階の発見がコードベース全体をマッピング",
              "detail": "authService.ts、auth-helpers.ts、関連設定ファイルを発見"
            },
            {
              "label": "レビュー用の実装計画を生成",
              "detail": "既存のauthService.tsを変更し、重複なしであることを示す"
            },
            {
              "label": "計画をレビューして承認",
              "detail": "コードがファイルシステムに触れる前に正確な変更を確認"
            },
            {
              "label": "結果:クリーンでターゲットを絞った変更",
              "detail": "既存のauthService.tsにJWT検証が追加され、重複は作成されない"
            }
          ],
          "title": "PlanToCodeあり"
        },
        "without": {
          "cleanup": {
            "items": [
              "重複コードを手動でマージ",
              "すべてのインポート参照を更新",
              "壊れたテストと依存関係を修正",
              "無駄にした時間:2-4時間"
            ],
            "title": "必要な手動クリーンアップ:"
          },
          "steps": [
            {
              "label": "ユーザー:「認証にJWT検証を追加」",
              "detail": "AIは限られたコンテキストを持ち、現在開いているファイルのみを見る"
            },
            {
              "label": "AIが検索し、既存の認証ファイルを見つけられない",
              "detail": "命名/パスの不一致によりsrc/services/authService.tsを見逃す"
            },
            {
              "label": "すぐにjwtValidation.tsを作成",
              "detail": "レビューステップなし、変更はファイルシステムに直接適用"
            },
            {
              "label": "結果:重複ファイルが作成された",
              "detail": "authService.tsとjwtValidation.tsの両方が重複機能を持つ"
            }
          ],
          "title": "PlanToCodeなし"
        }
      },
      "cta": {
        "description": "実行前のファイル発見。適用前のレビュー。重複ゼロ。これがAI支援開発のあるべき姿です:インテリジェント、予防的、クリーン。",
        "links": {
          "howItWorks": "動作を見る",
          "planReview": "計画レビューについて学ぶ",
          "technical": "技術ガイドを読む"
        },
        "title": "今日から重複ファイルの作成を停止"
      },
      "description": "AIコーディングツールは、既存のコード構造に関するコンテキストが不足しているため、頻繁に重複ファイルを作成します。PlanToCodeは、コードを生成する前にコードベース全体をマッピングするインテリジェントなファイル発見でこれを解決します。",
      "faq": {
        "discoveryCost": {
          "answer": "ファイル発見は関連性評価段階(段階3)でAIを使用し、わずかなAPIコストが発生します。ただし、コストは最小限(通常、発見実行あたり$0.01-0.05)であり、システムは実行前にコスト見積もりを提供します。重複を防ぐことで節約される2-4時間の手動クリーンアップ時間と比較して、投資は価値があります。",
          "question": "ファイル発見の実行にコストはかかりますか?"
        },
        "discoveryTime": {
          "answer": "ファイル発見は、中規模プロジェクト(500-2000ファイル)では通常30-90秒で完了します。10,000以上のファイルを持つ非常に大きなモノレポでは2-3分かかる場合があります。ワークフローはバックグラウンドで実行されるため、実行中も作業を続けることができます。進捗更新はリアルタイムで表示されます。",
          "question": "ファイル発見ワークフローにはどのくらい時間がかかりますか?"
        },
        "hugeCodebase": {
          "answer": "PlanToCodeには、インテリジェントなタイムアウト管理とキャッシングメカニズムが含まれています。非常に大きなコードベースの場合、カスタムタイムアウト値を設定し、除外パターンを使用して無関係なディレクトリ(ベンダーコード、生成ファイルなど)をスキップできます。システムはセッションごとに発見結果をキャッシュするため、同じセッションでの後続の計画はキャッシュされたファイルコンテキストを再利用します。",
          "link": "設定オプション",
          "question": "巨大なコードベースがある場合はどうなりますか?発見はタイムアウトしますか?"
        },
        "newFiles": {
          "answer": "もちろんです。PlanToCodeのファイル発見は新しいファイルの作成を防ぐのではなく、重複ファイルの作成を防ぎます。タスクが本当に新しいファイル(完全に新しい機能モジュールの追加など)を必要とする場合、PlanToCodeは実装計画でそれを提案します。違いは、提案を見て、偶発的な重複ではなく本当に新しい機能であることを確認できることです。",
          "question": "必要なときに本当に新しいファイルを作成できますか?"
        },
        "nonJavaScript": {
          "answer": "はい。PlanToCodeのファイル発見は言語に依存しません。Python、Go、Rust、Java、TypeScript、JavaScript、Ruby、PHP、C++、その他のテキストベースのコードベースで動作します。正規表現生成とAI関連性評価は、タスクの説明と発見されたファイル拡張子に基づいて、プロジェクトの特定の言語とフレームワークに適応します。",
          "question": "非JavaScriptプロジェクトで動作しますか?"
        },
        "refactoringDuplicates": {
          "answer": "はい。コードベースにすでに重複ファイルがある場合、PlanToCodeを使用してそれらの統合を計画できます。タスクを「重複認証サービスをauthService.tsにマージ」または類似のものとして記述します。ファイル発見はすべての関連ファイルを見つけ、実装計画はそれらをクリーンに統合する方法を正確に示します。",
          "question": "既存の重複をリファクタリングするためにPlanToCodeを使用できますか?"
        },
        "stillProposesDuplicate": {
          "answer": "ファイル発見が包括的なコンテキストを提供するため、これはまれですが、発生した場合はレビューステップ中に捕捉します。計画を拒否し、タスクの説明を改良(変更する既存ファイルについてより具体的に)するか、ファイル選択を手動で調整するだけです。重要な利点は、ダメージが発生した後ではなく、実行前に重複を捕捉することです。",
          "question": "AIが計画でまだ重複を提案した場合はどうなりますか?"
        },
        "title": "よくある質問",
        "worksWithCursor": {
          "answer": "はい。PlanToCodeは、既存のAIコーディングツールと並行して動作する計画レイヤーとして設計されています。PlanToCodeを使用してファイルを発見し、実装計画を生成し、Cursor、GitHub Copilot、Claude Code、またはその他のAIアシスタントを使用してそれらの計画を実行します。ファイル発見と計画は、どのツールがコードを実行しても重複を防ぎます。",
          "question": "PlanToCodeはCursorとGitHub Copilotで動作しますか?"
        }
      },
      "gettingStarted": {
        "step1": {
          "description": "プラットフォーム用のPlanToCodeデスクトップアプリケーションをダウンロードします。ファイル発見ワークフローと実装計画機能は、デスクトップクライアントに直接組み込まれています。",
          "title": "ステップ1:PlanToCodeデスクトップをインストール"
        },
        "step2": {
          "description": "PlanToCodeを開き、プロジェクトのルートディレクトリを選択します。PlanToCodeはgitリポジトリのステータスを検証し、すべてのファイル操作のベースディレクトリを確立します。スキップしたいディレクトリ(node_modules、dist、buildなど)のカスタム除外パターンを設定します。",
          "tip": "デフォルトの除外パターンは、node_modules、.git、ビルド成果物などの一般的なディレクトリをすでにカバーしています。プロジェクトに異常なディレクトリ構造がある場合にのみカスタマイズする必要があります。",
          "title": "ステップ2:プロジェクトルートを設定"
        },
        "step3": {
          "description": "実現したいことを自然言語で入力します。例:「認証サービスにJWT検証を追加」または「テーマプロバイダにダークモードサポートを実装」。必要な機能についてできるだけ具体的にしてください。",
          "goodDescriptions": {
            "examples": [
              "ユーザープロファイルAPIエンドポイントにRedisキャッシングを追加",
              "チャットサービスでWebSocket接続管理を実装",
              "すべてのフォームコンポーネントに入力検証を追加",
              "ユーザーロールテーブルを追加するためにデータベース移行を更新"
            ],
            "title": "良いタスクの説明:"
          },
          "title": "ステップ3:タスクを説明"
        },
        "step4": {
          "description": "PlanToCodeはバックグラウンドで5段階のファイル発見ワークフローを実行します。関連ファイルを発見するときにリアルタイムの進捗更新が表示されます。ワークフローは通常、コードベースのサイズに応じて30-90秒で完了します。完了したら、発見されたファイルのリストをレビューします。PlanToCodeがタスクに関連すると識別したファイルが表示されます。これは、システムが既存ファイルに関する適切なコンテキストを持っていることを確認するための最初のチェックポイントです。",
          "link": "発見プロセスについてもっと学ぶ",
          "title": "ステップ4:ファイル発見をレビュー"
        },
        "step5": {
          "checkpoint": "重複のように見えるファイル作成(例:auth-new.tsやUserService2.tsx)が表示された場合は、ここで停止してください。先に進む前に、タスクの説明を改良するか、ファイルリストを手動で調整してください。",
          "description": "PlanToCodeは発見されたファイルに基づいて詳細な実装計画を生成します。Monacoエディタで計画を開き、慎重にレビューします:",
          "reviewItems": [
            "どのファイルが変更されるか(既存のファイルパスを探す)",
            "どのファイルが作成されるか(これらが本当に必要な新しいファイルであることを確認)",
            "各ファイルに提案された具体的なコード変更",
            "インポート文と依存関係の更新"
          ],
          "title": "ステップ5:実装計画をレビュー"
        },
        "step6": {
          "description": "計画をレビューして承認したら、実装指示をお好みのAIコーディングツール(Cursor、Copilot、Claudeなど)にコピーするか、統合ターミナルを介して直接実行します。PlanToCodeがすでにファイル発見と計画の重労働を行っているため、実行は明確に定義された変更を適用する簡単なプロセスになります。",
          "link": "ターミナル統合ガイド",
          "title": "ステップ6:自信を持って実行"
        },
        "title": "開始:今日から重複の作成を停止"
      },
      "howPlanToCodePrevents": {
        "comprehensiveDiscovery": {
          "description": "PlanToCodeは、実装計画を生成する前に5段階のファイル発見ワークフローを実行します。このワークフローは、Git統合、正規表現フィルタリング、AI搭載の関連性評価、関係分析、パス検証を使用して、コードベースの完全なマップを構築します。",
          "link": "技術ドキュメント",
          "process": {
            "steps": [
              "Gitリポジトリとルートフォルダを検証",
              "タスク固有の正規表現パターンを生成",
              "ファイル内容のAI関連性評価",
              "関係を介した拡張パス発見",
              "最終的なパス修正と検証"
            ],
            "title": "発見プロセス:"
          },
          "result": "この深い発見により、PlanToCodeは変更を提案する前にauthService.ts、auth-helpers.ts、authentication/ディレクトリについて知っています。完全なコンテキストを持っているため、重複を作成しません。",
          "title": "包括的なファイル発見"
        },
        "description": "PlanToCodeは、計画優先アプローチでワークフローを根本的に変更します。即座にコードを生成して実行する代わりに、PlanToCodeは変更を提案する前にコードベース構造全体をマッピングする包括的なファイル発見システムを使用します。このアーキテクチャの違いが、重複ファイル作成の根本原因を排除します。",
        "gitAwareTracking": {
          "command": "git ls-files --cached --others --exclude-standard は、すべての追跡ファイルと無視されていない未追跡ファイルをキャプチャし、PlanToCodeに進行中のファイルを含むコードベースの状態の完全なビューを提供します。",
          "description": "ファイル発見ワークフローはGitに直接統合されて.gitignoreルールを尊重し、コミット済みおよび未コミットの変更の両方を追跡します。このGit統合により、PlanToCodeは、まだコミットされていない最近作成されたファイルを含む実際の作業ツリーを見ることができます。",
          "title": "Git対応ファイル追跡"
        },
        "intelligentPatternMatching": {
          "advanced": "システムは、単純な文字列マッチングではなく、コンテキスト対応の正規表現パターンを生成するためにAIを使用します。「JWT検証を追加」のようなタスクの場合、auth*、jwt*、token*、middleware/auth*および関連パターンをカバーするパターンを生成します。",
          "description": "PlanToCodeの正規表現生成段階は、複数の命名規則、大文字小文字のバリエーション、一般的なファイル組織パターンを考慮するインテリジェントなパターンを作成します。「ユーザーサービスを更新」というリクエストが、userService.ts、user-service.ts、UserService.ts、またはservices/user/にマッチすることを理解しています。",
          "title": "インテリジェントパターンマッチング"
        },
        "reviewBeforeExecution": {
          "contents": {
            "items": [
              "変更されるファイルの完全なリスト",
              "完全なパスで作成される新しいファイル",
              "前後のコンテキストを含む特定の変更",
              "操作ごとのトークン数の推定",
              "必要な依存関係とインポートの更新"
            ],
            "title": "計画の内容には以下が含まれます:"
          },
          "description": "即座に変更を適用するツールとは異なり、PlanToCodeは、コードがファイルシステムに触れる前にMonacoエディタでレビューする詳細な実装計画を生成します。どのファイルが作成、変更、削除されるかを正確に確認できます。",
          "link": "実装計画ガイド",
          "review": "このレビューステップにより、実行前に重複を捕捉できます。計画がauth-new.tsを作成したい場合、それを拒否して発見スコープを改良できます。",
          "title": "実行前のレビュー"
        },
        "title": "PlanToCodeが重複ファイルを防ぐ方法"
      },
      "problem": {
        "caseStudy1": {
          "description": "開発者がCursorフォーラムで、「認証サービスを更新」するようにAIに依頼したときに、Cursorが既存のsrc/services/authService.tsを変更する代わりに新しいファイルsrc/services/auth-service-new.tsを作成したと報告しました。これは、AIが類似の命名パターンを持つ既存の実装を適切にスキャンしなかったために発生しました。",
          "impact": "開発者は、重複コードを手動で統合し、15ファイル全体のインポートの競合を解決し、重複を削除するのに3時間を費やしました。一部のインポートがまだ古いファイルパスを指していたため、プロジェクトは本番環境で壊れた参照で終わりました。",
          "link": "Cursorフォーラムディスカッションを表示",
          "title": "ケーススタディ:Cursor問題#47028"
        },
        "caseStudy2": {
          "description": "別の文書化されたケースでは、開発者が「ダークモードサポートを追加」するように依頼したReactプロジェクトが関係していました。既存のcomponents/ThemeProvider.tsxを変更する代わりに、Cursorは重複機能を持つcomponents/DarkModeProvider.tsxを作成しました。コードベースは、同時に実行される2つの競合するテーマシステムで終わりました。",
          "impact": "重複テーマプロバイダは状態管理の競合を引き起こし、バンドルサイズを45KB増加させ、テーマの設定が正しく保持されないユーザーエクスペリエンスのバグを作成しました。クリーンアップには完全なリファクタリングスプリントが必要でした。",
          "link": "Cursorフォーラムディスカッションを表示",
          "title": "ケーススタディ:Cursor問題#31402"
        },
        "commonScenarios": {
          "examples": [
            "類似機能を持つhelpers.jsが存在するときにutils-new.tsを作成",
            "api/client.tsを更新する代わりにapiClient2.tsを生成",
            "Button.tsxがすでに存在するときにButtonComponent.tsxを作成",
            "testHelpers.jsを変更する代わりにtest-helper-updated.jsを作成",
            "config-new.jsonやsettings-v2.yamlのような設定ファイルを重複"
          ],
          "title": "一般的な重複ファイルシナリオ"
        },
        "description": "重複ファイルは、AIコーディングアシスタントを使用するときに開発者が直面する最も一般的でイライラする問題の1つです。Cursor、GitHub Copilot、その他のコード生成システムのようなAIツールが既存のコードベースに関する適切なコンテキストを欠いている場合、既存のファイルを変更する代わりに新しいファイルを作成します。これはコードの断片化、マージの競合、何時間もの手動クリーンアップ作業につながります。",
        "title": "重複ファイル問題:実例"
      },
      "title": "AIが重複ファイルを作成するのを防ぐ",
      "whyAICreatesDuplicates": {
        "conflictAvoidance": {
          "description": "AIモデルは、しばしば安全第一のアプローチでトレーニングされています:ファイルが存在するかどうか、または正確なパスが何であるかが不確かな場合、既存のコードを上書きするリスクを冒すのではなく、新しいファイルを作成することをデフォルトとします。この「安全を期す」バイアスは、重複ファイルの増殖につながります。",
          "title": "競合回避バイアス",
          "training": "AIモデルは、保守的なアクション(不要な重複の作成)よりも破壊的なアクション(重要なコードの上書き)に対してより重いペナルティを受けます。トレーニングデータのこの非対称ペナルティ構造は、「より安全な」オプションとして重複作成を奨励します。"
        },
        "description": "重複ファイル作成の背後にある技術的な理由を理解することは、この問題がAIコーディングツール全体でなぜこれほど持続的なのかを説明するのに役立ちます。これは単純なバグではありません - ほとんどのAIアシスタントがコードベースとどのように相互作用するかの根本的なアーキテクチャの制限です。",
        "incompleteDiscovery": {
          "description": "AIツールがファイル発見を試みるとき、現在開いているファイル、最近アクセスしたファイル、または基本的なパターンマッチングの検索のような浅い方法をしばしば使用します。これらのアプローチは、アクティブに開いていないファイルや非標準の命名規則を持つファイルを見逃します。",
          "example": "認証サービスがauthService.tsという名前ですが、AIが「auth*」にマッチするファイルを検索する場合、検索が大文字小文字を区別するか、特定のディレクトリに制限されている場合、それを見逃す可能性があります。AIはファイルが存在しないと結論付け、重複を作成します。",
          "title": "不完全なファイル発見"
        },
        "limitedContext": {
          "description": "ほとんどのAIコーディングアシスタントは、任意の時点でコードベースの小さな部分しか「見る」ことができない限られたコンテキストウィンドウで動作します。機能を作成または変更するように依頼すると、AIは現在開いているファイルまたはプロジェクト構造の狭いスライスにのみアクセスできる場合があります。",
          "details": "大きなコンテキストウィンドウ(128K+トークン)でさえ、AIモデルはプロジェクト全体の認識に苦労します。500ファイルの典型的な中規模プロジェクトは、完全にインデックス化するために200万から500万トークンを必要とする可能性があり、実用的な制限をはるかに超えています。これにより、AIツールは完全な知識を持つのではなく、ファイルの場所について教育的な推測をすることを余儀なくされます。",
          "title": "限られたコンテキストウィンドウ"
        },
        "namingMismatches": {
          "description": "異なるプロジェクトは異なる命名規則を使用します:camelCase、PascalCase、kebab-case、snake_case、またはカスタムパターン。AIツールは、user-service.ts、UserService.ts、user_service.tsがすべて「ユーザーサービス」ファイルの潜在的な一致であることを認識するのに苦労することがよくあります。",
          "impact": "複数の言語(TypeScript、Python、Go)を混在させる多言語プロジェクトでは、命名規則は言語エコシステムによって異なります。主にJavaScriptパターンでトレーニングされたAIは、同等のPythonモジュールを認識できない可能性があり、言語間の重複につながります。",
          "title": "命名規則の不一致"
        },
        "noValidation": {
          "description": "ほとんどのAIコーディングツールは、レビューステップなしで即座に変更を実行します。コードを生成してファイルシステムに直接適用します。重複が作成されたことに気付く頃には、ダメージはすでに完了しています。実行前に間違いを捕捉する機会はありません。",
          "title": "実行前検証なし",
          "workflow": "従来のAIアシスタントは「生成 → 適用」パターンに従います。「生成 → レビュー → 適用」ワークフローがなければ、開発者は変更がディスクに書き込まれる前にファイルパスを確認したり、重複をチェックしたり、AIのコードベース構造の理解を検証したりする機会がありません。"
        },
        "title": "AIツールが重複ファイルを作成する理由"
      }
    },
    "safeRefactoring": {
      "comparison": {
        "aiDirect": {
          "approach": "AI直接",
          "bestFor": "プロトタイプ",
          "safety": "低",
          "speed": "速い(分)",
          "visibility": "事後"
        },
        "aiPlanning": {
          "approach": "AI + 計画",
          "bestFor": "本番コード",
          "safety": "高",
          "speed": "速い(分 + レビュー)",
          "visibility": "実行前"
        },
        "headers": {
          "approach": "アプローチ",
          "bestFor": "最適な用途",
          "safety": "安全性",
          "speed": "速度",
          "visibility": "可視性"
        },
        "manual": {
          "approach": "手動",
          "bestFor": "小さな変更",
          "safety": "高",
          "speed": "遅い(時間/日)",
          "visibility": "完全"
        },
        "title": "手動 vs AI vs AI + 計画"
      },
      "cta": {
        "buttons": {
          "download": "PlanToCodeをダウンロード",
          "howItWorks": "計画の仕組み"
        },
        "description": "AIコーディングワークフローに安全性レイヤーを追加します。発生する前に変更をレビューします。",
        "title": "リファクタリングで本番を壊すのを停止"
      },
      "description": "AIコーディングツールは、人間の10倍速くコードをリファクタリングできます。また、本番を10倍速く壊すこともできます。混沌なしで速度を得る方法は次のとおりです。",
      "faq": {
        "compatibility": {
          "answer": "はい。PlanToCodeは、任意のAIコーディングツールにコピーできる実装計画を生成します。計画はコンテキストを提供するため、ツールはコード生成中により良い決定を下します。",
          "question": "Cursor/Claude Code/Copilotで使用できますか?"
        },
        "dependencyMapping": {
          "answer": "AI搭載のファイル発見は、インポート文、型参照、ファイル間の依存関係を分析します。どのファイルがどのファイルに依存しているかのグラフを構築するため、リファクタリング計画にはすべての影響を受けるファイルが含まれます。",
          "question": "依存関係マッピングはどのように機能しますか?"
        },
        "languages": {
          "answer": "すべての言語。ファイル発見はファイルシステムレベルで動作し、インポートに静的解析を使用します。TypeScript、JavaScript、Python、Rust、Go、Javaなど。",
          "question": "どのプログラミング言語がサポートされていますか?"
        },
        "slowDown": {
          "answer": "初期レビュー:はい、計画のレビューには5-15分かかります。壊れたリファクタリングのデバッグ:数時間または数日かかることがあります。正味の結果:特に複雑な変更の場合、全体的により速いです。",
          "question": "これは開発を遅くしますか?"
        },
        "title": "よくある質問"
      },
      "gettingStarted": {
        "steps": [
          "PlanToCodeをダウンロード(macOS、Windows、Linux)",
          "ターミナルでプロジェクトディレクトリを開く",
          "リファクタリングを説明し、生成された計画をレビュー"
        ],
        "subtitle": "3ステップで安全なリファクタリングを試す:",
        "title": "開始"
      },
      "howPlanToCodeHelps": {
        "description": "PlanToCodeは、コードが書かれる前に計画レイヤーを追加します。即座に実行する代わりに、AIは最初にレビューする詳細な実装計画を生成します。",
        "title": "PlanToCodeがリファクタリングを安全にする方法",
        "workflow": {
          "steps": [
            {
              "title": "リファクタリングを説明",
              "description": "「コードベース全体でgetUserDataをfetchUserProfileに名前変更」"
            },
            {
              "title": "AIが依存関係をマッピング",
              "description": "ファイル発見が関数をインポートまたは参照するすべてのファイルを識別"
            },
            {
              "title": "実装計画を生成",
              "description": "ファイルごとの内訳:各ファイルで何が変更されるか、どの順序で"
            },
            {
              "title": "レビューして改良",
              "description": "実行前に欠落しているファイル、誤った仮定、またはエッジケースを捕捉"
            },
            {
              "title": "自信を持って実行",
              "description": "承認された計画をClaude Code、Cursorに渡すか、手動で実装"
            }
          ],
          "title": "安全なリファクタリングワークフロー"
        }
      },
      "integration": {
        "description": "PlanToCodeはAIコーディングツールを置き換えるのではなく、補完します:",
        "title": "既存ツールとの統合",
        "workflow": {
          "steps": [
            {
              "title": "PlanToCodeで計画",
              "description": "依存関係マッピングで実装計画を生成してレビュー"
            },
            {
              "title": "お好みのツールで実行",
              "description": "計画をCursor、Claude Code、またはCopilotに貼り付けてコード生成"
            },
            {
              "title": "変更を検証",
              "description": "テストを実行し、計画に対して差分をチェック"
            }
          ],
          "title": "結合ワークフロー"
        }
      },
      "keyFeatures": {
        "changeOrdering": {
          "description": "計画は正しい順序を指定します:最初に型を更新し、次に実装、次にテスト。中間の壊れた状態を避けます。",
          "title": "変更順序"
        },
        "dependencyMapping": {
          "description": "AI搭載のファイル発見は、隠れたインポート、型依存関係、モジュール間参照を含む、リファクタリングによって影響を受けるすべてのファイルを明らかにします。",
          "title": "依存関係マッピング"
        },
        "preExecutionReview": {
          "description": "コードが書かれる前に何が変更されるかを正確に確認します。ファイルごとの変更をレビューし、計画を編集し、準備ができたら承認します。",
          "title": "実行前レビュー"
        },
        "testCoverageCheck": {
          "description": "本番コードと一緒に更新が必要なテストファイルを識別します。壊れたテストスイートでリファクタリングを出荷しないでください。",
          "title": "テストカバレッジチェック"
        },
        "title": "主要な安全機能"
      },
      "realWorldExample": {
        "scenario": "シナリオ:RESTからGraphQLへの移行",
        "task": "50,000行のNext.jsコードベース全体でRESTAPI呼び出しをGraphQLクエリに置き換えます。",
        "title": "実世界の例:50K行のコードベースのリファクタリング",
        "withPlanning": {
          "steps": [
            "ファイル発見がREST APIを使用する47ファイルを発見",
            "計画が移行順序を示す:型 → クライアント → コンポーネント → ユーティリティ",
            "保持するエラーハンドリングパターンを識別",
            "GraphQLモック更新が必要なテストファイルを捕捉",
            "結果:20分で計画をレビュー、安全に実行"
          ],
          "title": "PlanToCodeあり:"
        },
        "withoutPlanning": {
          "steps": [
            "AIがAPIクライアントファイルを変更",
            "一部のコンポーネントインポートを更新",
            "ユーティリティ関数のAPI呼び出しを見逃す",
            "エラーハンドリングの更新を忘れる",
            "変更はコンパイルするが実行時に失敗",
            "結果:本番エラーのデバッグに4時間"
          ],
          "title": "計画なし(Cursor/Copilot直接):"
        }
      },
      "refactoringProblem": {
        "aiPowered": "AI搭載リファクタリング:速いがリスキー。Cursor、Copilot、Claudeは数秒で20ファイルを変更できますが、完了するまで何が変更されたかわかりません。",
        "gap": "ギャップ:レビューステップなし。「これから変更する内容」のプレビューなし。即座の実行と最善を期待するだけです。",
        "manual": "手動リファクタリング:安全だが遅い。各ファイルを注意深く更新し、依存関係をチェックし、テストを実行します。",
        "title": "リファクタリングの問題"
      },
      "title": "安全なリファクタリングツール:AIが計画レイヤーを必要とする理由",
      "whenToUse": {
        "skipPlanningWhen": {
          "scenarios": [
            "単一ファイルの変更 - 外部依存関係のない分離されたリファクタリング",
            "プロトタイプ - 物を壊すことが許容される使い捨てコード",
            "小さなプロジェクト - 1,000行未満、すべてを手動でレビューするのが簡単"
          ],
          "title": "計画をスキップする場合:"
        },
        "title": "安全なリファクタリングを使用する場合",
        "usePlanningWhen": {
          "scenarios": [
            "大規模コードベース(50K+行) - 変更後に手動でレビューするにはコードが多すぎる",
            "複数ファイルのリファクタリング - 5以上のファイル全体での名前変更、移動、または再構築",
            "本番コード - ユーザーに届く変更、使い捨てプロトタイプではない",
            "モノレポ - 共有依存関係を持つパッケージ間のリファクタリング",
            "チーム環境 - 複数の開発者が変更のスコープを理解する必要がある",
            "破壊的変更 - APIシグネチャの変更、型の変更、アーキテクチャの変更"
          ],
          "title": "計画優先リファクタリングを使用する場合:"
        }
      },
      "whyBreaks": {
        "description": "AIツールが隠れた依存関係を見逃すとリファクタリングは失敗します:",
        "importChains": {
          "description": "getUserData() → fetchUserProfile()に名前変更すると、それをインポートする8ファイルが壊れます。AIは関数を見ますがカスケードを見逃します。",
          "title": "インポートチェーン"
        },
        "sideEffects": {
          "description": "起動スクリプトを更新せずにデータベース初期化コードを移動します。変更はコンパイルされますが、DBが準備されていないときに実行時に失敗します。",
          "title": "副作用"
        },
        "testAssumptions": {
          "description": "エラーハンドリングロジックをリファクタリングし、特定のエラーメッセージを期待する15の統合テストを壊します。AIは本番コードを更新しますがテストモックを忘れます。",
          "title": "テストの仮定"
        },
        "title": "リファクタリングが物を壊す理由",
        "typeDefinitions": {
          "description": "インターフェースプロパティを変更し、コードベース全体でTypeScriptエラーが爆発するのを見ます。AIは型を変更しますが、古い形状に依存するファイルを忘れます。",
          "title": "型定義"
        }
      }
    }
  }
}
