{
  "meta": {
    "title": "ドキュメント - PlanToCode",
    "description": "PlanToCodeでコード変更を計画・実装する方法を学びましょう：ファイル検出、実装計画、ターミナルセッション、モデルガードレール、音声機能について解説します。"
  },
  "architecture": {
    "meta": {
      "title": "PlanToCodeアーキテクチャ概要",
      "description": "実装計画、ワークフロー、ターミナルセッションを支えるデスクトップ、オーケストレーション、永続化レイヤー。"
    },
    "category": "アーキテクチャ",
    "date": "2025-09-19",
    "description": "デスクトップシェル、バックグラウンドワークフロー、共有サービスの構成について。",
    "frontend": {
      "heading": "フロントエンド層",
      "providers": "共有プロバイダーは通知、ランタイム設定、プラン状態を管理します。実装計画パネルはプランのメタデータを保持し、モーダルの表示を管理し、必要に応じてトークン見積もりやプロンプト内容をリクエストします。",
      "ui": "デスクトップUIはReactコンポーネントで構築されています。実装計画の内容は、大規模なプランを仮想化し、言語を検出し、コピー操作をサポートするMonacoベースのビューアで表示されるため、レビュアーはパフォーマンスの問題なくプランテキストを確認できます。ターミナルセッションは、PTY出力に接続し接続状態の更新を表示するバッファ付きビュー内でレンダリングされます。"
    },
    "intro": "PlanToCodeはReactフロントエンドを持つTauriデスクトップアプリケーションです。UIは実装計画、ターミナル、設定コントロールをレンダリングし、Rustバックエンドはワークフロー、トークン見積もり、永続的なターミナルセッション用のコマンドを公開します。この概要では、これらの要素がどのように連携するかを説明します。",
    "metaDescription": "実装計画、ワークフロー、ターミナルセッションを支えるデスクトップ、オーケストレーション、永続化レイヤー。",
    "metaTitle": "PlanToCodeアーキテクチャ概要",
    "ogDescription": "デスクトップアプリ内でReactフロントエンド、Tauriコマンド、バックグラウンドサービスがどのように連携するかを学びます。",
    "ogTitle": "PlanToCodeアーキテクチャ概要",
    "persistence": {
      "database": "ターミナル出力とセッションメタデータは、ターミナルセッションリポジトリを介してSQLiteに保存されます。各レコードには識別子、タイムスタンプ、作業ディレクトリ、環境変数、蓄積されたログが含まれ、再起動時に以前の出力を復元できます。同じリポジトリがセッション状態の変更時にイベントを発行します。",
      "heading": "永続化と設定",
      "modelConfig": "モデルのデフォルト設定はアプリケーション設定テーブルに保存されます。各タスクはデフォルトモデル、許可された代替モデルのリスト、トークン予算、オプションのコピーボタンプリセットを定義します。Reactレイヤーはこれらの設定を読み取り、モデルセレクターとガードレールを設定します。"
    },
    "readTime": "7分",
    "tauriCommands": {
      "commands": "アプリケーションのRust側は、ワークフロー、ターミナルセッション、モデルツール用のコマンドを公開します。ワークフローコマンドはWorkflow Orchestratorを通じてバックグラウンドジョブを開始し、入力を検証し、ファイル検出パイプラインの実行中に進行状況イベントを発行します。トークン見積もりコマンドは、現在選択されているモデルのプロンプトサイズを計算します。",
      "heading": "Tauriコマンドとサービス",
      "terminal": "ターミナルコマンドはPTYプロセスを管理し、リモートクライアントを追跡し、セッションを起動する前にサポートされているCLIバイナリが利用可能かどうかを確認します。ヘルスチェックはPTYステータスとデータベースレコードを組み合わせて、セッションがまだ稼働しているかどうかを報告します。"
    },
    "title": "PlanToCodeアーキテクチャ",
    "voicePipeline": {
      "description": "音声文字起こしは、メディア権限、マイク選択、ストリーミング文字起こしリクエストを調整するReactフックとして実装されています。このフックはプランターミナルとプロンプトエディタと統合され、認識されたテキストをアクティブなコンポーネントに直接挿入し、文字起こしが失敗した場合は通知を表示します。",
      "heading": "音声文字起こしパイプライン"
    },
    "server": {
      "heading": "サーバーレイヤー",
      "description": "サーバーはプロバイダー設定（暗号化されたボールトのAPIキー、レート制限、OpenAI、Anthropic、Google向けのルーティングルール）、モデルルーティング（リクエストプロキシ、自動フェイルオーバー、負荷分散、ユーザー/プロジェクトごとのコスト追跡）、課金（サブスクリプション管理、使用量計測、クォータ適用、コストアラート）、およびWeb検索API（30日/7日TTLの結果キャッシュ、地理的制限、JWT認証）を処理します。"
    },
    "dataFlows": {
      "heading": "データフロー",
      "description": "タスク、プラン、ジョブ、セッションはコンポーネント間を流れます：(1) タスク改善：React UI → TextImprovementPopover → Tauriコマンド → WorkflowOrchestrator → text_improvementプロンプト → SQLite → Reactプロバイダーがテキストを置換。(2) ファイル検出：実装計画パネル → Tauriコマンド → 4つの連続ジョブ → 進行状況イベント → SQLite → UI表示。(3) 実装計画：ファイル検出 → プラン生成 → Tauriコマンド → LLMストリーミング → SQLite → Monacoビューア → レビュー/承認 → エクスポート。(4) ターミナル実行：PTYセッション → SQLite → コマンド実行 → 出力ストリーミング → 音声文字起こし挿入 → エージェント注意検出 → 監査ログ。"
    },
    "visuals": {
      "systemMap": {
        "description": "This diagram depicts the PlanToCode system architecture as four interconnected layers arranged vertically. Top Layer - Desktop Frontend: A React/Next.js box containing components (Plan Viewer, Terminal Panel, Session Manager) connected via labeled arrows \"invoke()\" and \"listen()\" to the Tauri IPC bridge. Second Layer - Rust Backend: WorkflowOrchestrator (scheduling multi-stage jobs), TerminalSessionManager (PTY lifecycle), and job processors (FileDiscovery, PlanGeneration, TextImprovement, DeepResearch). Third Layer - Persistence: SQLite tables for sessions, background_jobs, and terminal_sessions with read/write arrows. Fourth Layer - External Services: Server routes under /api/llm/* and /api/auth with provider icons (OpenAI, Anthropic, Google, OpenRouter). Data flows run down through the layers; streaming responses and job events flow back up to the UI."
      }
    }
  },
  "deepResearch": {
    "meta": {
      "title": "ディープリサーチ - PlanToCode",
      "description": "Web検索ワークフローの技術ドキュメント：API統合、クエリ最適化、結果処理、開発ワークフロー統合。"
    },
    "apiIntegration": {
      "heading": "API統合の詳細",
      "pipeline": {
        "description": "調査結果は、フォーマットとコンテキストを保持しながら意味のある情報を抽出する標準化された処理パイプラインを通過します。パイプラインはさまざまなコンテンツタイプを処理し、開発ワークフロー向けの実用的なインサイトに統合します。",
        "heading": "コンテンツ処理パイプライン"
      },
      "providerConfig": {
        "description": "システムはOpenRouterを介してAI言語モデルを使用し、インテリジェントなWeb調査を実行します。LLMはタスクコンテキストに基づいて的を絞った調査クエリを生成し、トレーニングデータとWeb検索機能から得た知見を統合します。モデルの選択と設定はアプリケーション設定で管理されます。",
        "heading": "AI調査設定"
      }
    },
    "architecture": {
      "description": "ディープリサーチシステムは2段階のワークフローとして動作します：(1) WebSearchPromptsGeneration - AIがタスクとプロジェクトコンテキストを分析し、的を絞った調査クエリを生成、(2) WebSearchExecution - LLMが調査プロンプトを並列実行し、結果を統合します。各段階は信頼性、コスト効率、コンテキストの関連性を考慮して設計されています。",
      "heading": "アーキテクチャ概要"
    },
    "bestPractices": {
      "examples": {
        "description": "一般的な統合パターンは、特定のエラーのデバッグから不慣れなAPIを使用した新機能の実装まで、Web検索結果がさまざまな開発シナリオをどのように強化するかを示しています。",
        "heading": "統合例"
      },
      "heading": "ベストプラクティスと例",
      "strategies": {
        "description": "Web検索統合の価値を最大化するには、クエリの作成、結果の解釈、開発ワークフローへの統合に関するこれらの実証済みの戦略に従ってください。",
        "heading": "効果的な検索戦略",
        "queryFormulation": {
          "constraints": "プラットフォームや環境の制約を含める",
          "errors": "ライブラリ名と特定のエラーメッセージを組み合わせる",
          "heading": "クエリの作成",
          "practices": "パターン検索には「ベストプラクティス」や「推奨アプローチ」を使用",
          "versions": "関連する場合は特定のバージョン番号を含める"
        },
        "resultEvaluation": {
          "crossReference": "複数のソース間でソリューションを相互参照",
          "dates": "時間に敏感な情報については公開日を確認",
          "heading": "結果の評価",
          "official": "サードパーティソースより公式ドキュメントを優先",
          "verify": "開発環境でコード例を検証"
        }
      }
    },
    "category": "技術リファレンス",
    "configuration": {
      "heading": "設定とカスタマイズ",
      "preferences": {
        "description": "調査動作はモデル選択とタスク設定で設定されます。調査タスクに使用するAIモデルを選択し、タイムアウトを設定し、コンテキストに含めるファイルを選択します。",
        "filters": "モデル選択が調査の品質とコストを決定",
        "heading": "調査設定",
        "limits": "タスクごとに最大12個の調査プロンプトを生成",
        "optionsHeading": "設定可能なオプション",
        "patterns": "より良いコンテキストのために関連するプロジェクトファイルを含める",
        "sources": "コンテキスト用のプロジェクトディレクトリとファイル選択",
        "triggers": "ワークフローコマンドで手動で調査を開始"
      },
      "projectSettings": {
        "description": "調査設定はセッション対応です。システムは現在のセッションのプロジェクトディレクトリと含まれるファイルを使用してコンテキストを提供します。除外パス（node_modules、distなど）はAIに表示されるディレクトリツリーから自動的にフィルタリングされます。",
        "heading": "プロジェクト固有の設定"
      }
    },
    "costs": {
      "heading": "コストの考慮事項",
      "optimization": {
        "description": "調査コストはインテリジェントなプロンプト生成で管理されます - システムは調査プロンプトをタスクごとに最大12個に制限します。並列実行により実行時間を最小化します。各ジョブはメタデータでトークン使用量と推定コストを追跡し、完全な透明性を提供します。",
        "heading": "コスト最適化"
      },
      "rateLimiting": {
        "cacheFirst": "調査結果はセッションごとにキャッシュされ、冗長なクエリを回避",
        "description": "ディープリサーチはOpenRouterを介して設定されたAIクレジットを使用します。各調査タスクは複数の並列LLM呼び出しを生成するため、コストは生成される調査プロンプトの数に応じてスケールします。システムは透明性のためにジョブごとのトークン使用量とコストを追跡します。",
        "guidelinesHeading": "コスト管理のヒント",
        "heading": "使用量とコスト",
        "personal": "調査ジョブごとに詳細なコスト内訳でトークン使用量を追跡",
        "team": "コストはOpenRouterまたはPlanToCodeサブスクリプションクレジットで管理",
        "throttling": "ジョブメタデータでトークン数と推定コストを監視"
      }
    },
    "cta": {
      "description": "ディープリサーチとWeb検索機能はPlanToCodeデスクトップアプリケーションで利用できます。プラットフォーム用のビルドをダウンロードして、Web調査を開発ワークフローに統合しましょう。",
      "heading": "ディープリサーチを使う準備はできましたか？",
      "links": {
        "architecture": "システムアーキテクチャを見る",
        "buildYourOwn": "独自の統合を構築"
      }
    },
    "date": "2025-09-20",
    "description": "PlanToCodeがWeb検索を実行し、結果を処理し、開発ワークフローに統合する方法。",
    "devIntegration": {
      "caching": {
        "description": "調査結果はジョブメタデータに保存され、ジョブ詳細パネルからアクセスできます。結果はセッション期間中保持され、実装計画の作成やコーディングの決定を行う際に参照できます。",
        "heading": "結果の保存"
      },
      "contextAware": {
        "description": "調査リクエストは現在のセッションからのコンテキストで自動的に強化されます。システムはプロンプト生成フェーズでプロジェクトのディレクトリツリーと選択したファイルの内容を含め、AIがコードベースに固有の調査クエリを作成できるようにします。",
        "heading": "コンテキスト対応の調査"
      },
      "heading": "開発ワークフロー統合",
      "resultIntegration": {
        "description": "調査結果は実装計画の情報として使用できます。調査タスクが完了すると、結果はresearch_findingタグとしてフォーマットされ、後続の計画タスクに組み込むことができ、実装が最新のベストプラクティスと正確なドキュメントに基づいて行われることを保証します。",
        "heading": "結果の統合"
      }
    },
    "intro": "ディープリサーチ機能により、PlanToCodeはインテリジェントなAI駆動の調査を実行し、関連情報を収集し、開発ワークフローに直接統合できます。このシステムは大規模言語モデルを使用して、プロジェクトコンテキストに基づいた的を絞った調査クエリを生成し、並列調査タスクを実行し、コード生成と問題解決能力を強化する実用的なインサイトを統合します。",
    "metaDescription": "Web検索ワークフローの技術ドキュメント：API統合、クエリ最適化、結果処理、開発ワークフロー統合。",
    "metaTitle": "ディープリサーチ - PlanToCode",
    "ogDescription": "PlanToCode内でWeb検索がどのように動作するかを理解する：クエリ生成から結果処理、開発ワークフローとの統合まで。",
    "ogTitle": "ディープリサーチ - PlanToCode",
    "readTime": "8分",
    "title": "ディープリサーチとWeb検索",
    "troubleshooting": {
      "commonIssues": {
        "description": "ほとんどの調査の問題は、LLM API接続、クレジット不足、または広すぎるプロンプトに起因します。システムはトラブルシューティング用に明確なエラーメッセージとジョブステータス追跡を提供します。",
        "geographic": "モデルの可用性",
        "geographicSolution": "一部のモデルはOpenRouter経由で地域制限がある場合があります",
        "heading": "よくある問題",
        "noResults": "調査プロンプトが生成されない",
        "noResultsSolution": "より具体的なタスク説明を提供するか、コンテキスト用の関連ファイルを含めてください",
        "rateLimit": "APIエラー",
        "rateLimitSolution": "OpenRouter APIのステータスとクレジット残高を確認してください"
      },
      "heading": "トラブルシューティングとサポート",
      "performance": {
        "description": "最適なパフォーマンスを得るには、明確で具体的なタスク説明を提供してください。AIにより良いコンテキストを与えるために関連するプロジェクトファイルを含めてください。システムは総実行時間を最小化するために調査プロンプトを並列実行します。",
        "heading": "パフォーマンス最適化"
      }
    },
    "workflow": {
      "execution": {
        "blogs": "ベストプラクティスと実装パターン",
        "description": "調査プロンプトはAI言語モデルによって並列実行されます。各プロンプトは独立して処理され、システムがタスクの複数の側面に関する情報を同時に収集できます。結果はタイトルと実用的なインサイトを含む構造化された知見に統合されます。",
        "documentation": "APIドキュメントと技術仕様",
        "forums": "エラー解決とトラブルシューティングのアプローチ",
        "github": "コード例と実装パターン",
        "heading": "調査の実行",
        "releases": "バージョン互換性と移行ガイダンス",
        "sourcesHeading": "調査フォーカスエリア"
      },
      "heading": "調査ワークフローの段階",
      "processing": {
        "deduplication": "複数の調査プロンプトにわたって知見を統合",
        "description": "調査結果はタイトルと詳細な知見を含むJSON形式に構造化されます。システムは並列調査タスクからの結果を集約し、成功と失敗のカウントを追跡し、調査結果のサマリーを提供します。結果は簡単にアクセスできるようにジョブメタデータに保存されます。",
        "extraction": "主要な知見を抽出し統合用にフォーマット",
        "heading": "結果の処理と統合",
        "scoring": "調査トピックと関連性で結果を整理",
        "snippets": "実用的なインサイトと推奨事項を強調",
        "stepsHeading": "処理ステップ",
        "timestamp": "タイミングメトリクスで調査実行を追跡"
      },
      "queryGeneration": {
        "api": "APIドキュメントとライブラリ固有の調査",
        "compatibility": "バージョン互換性と移行パス",
        "description": "調査プロンプトは、タスクの説明、プロジェクトコンテキスト、含まれるファイルに基づいてAIによって自動生成されます。システムはディレクトリツリーとファイル内容を通じてコードベース構造を分析し、的を絞った調査クエリを作成します。タスクごとに最大12個のフォーカスされた調査プロンプトが生成されます。",
        "errors": "エラー解決とデバッグアプローチ",
        "heading": "プロンプト生成",
        "practices": "ベストプラクティスと推奨パターン",
        "security": "セキュリティの考慮事項と脆弱性への認識",
        "typesHeading": "調査トピック"
      }
    },
    "visuals": {
      "pipeline": {
        "title": "ディープリサーチパイプライン",
        "description": "2段階のワークフロー：プロンプト生成と並列調査実行。",
        "imageSrc": "/images/docs/deep-research/workflow.svg",
        "imageAlt": "プロンプト生成と実行段階を示すディープリサーチパイプライン図",
        "caption": "プロンプト生成と並列実行段階を示すディープリサーチワークフロー"
      },
      "workflow": {
        "title": "ディープリサーチワークフロー",
        "description": "2段階のワークフロー：プロンプト生成と並列調査実行。",
        "imageSrc": "/images/docs/deep-research/workflow.svg",
        "caption": "すべての処理段階を示すディープリサーチワークフロー"
      }
    }
  },
  "fileDiscovery": {
    "meta": {
      "title": "File discovery workflow - PlanToCode",
      "description": "Comprehensive technical guide to the 4-stage AI workflow that identifies and filters relevant files for task execution."
    },
    "apiUsage": {
      "heading": "API Usage Examples",
      "monitoring": "Monitoring Progress",
      "retrieving": "Retrieving Results",
      "starting": "Starting a Workflow"
    },
    "architecture": {
      "caching": "Intermediate results are persisted in SQLite job records for reuse and debugging.",
      "costTracking": "Cost tracking and timeout management for AI operations",
      "distributed": "The system uses a distributed job architecture where each stage runs as an independent background job, enabling cancellation, retry logic, and detailed progress tracking. Real-time events are published throughout execution to provide immediate feedback to the user interface.",
      "errorHandling": "Comprehensive error handling with automatic retry mechanisms",
      "eventDriven": "Event-driven progress reporting with WebSocket-like updates",
      "featuresHeading": "Key Architecture Features:",
      "gitIntegration": "Git integration with fallback to directory traversal",
      "heading": "Workflow Architecture",
      "overview": "The workflow operates as an orchestrated background job system with four distinct stages that execute sequentially. Each stage builds upon the previous stage's output, progressively refining the file selection based on task requirements."
    },
    "category": "Technical Guide",
    "configuration": {
      "exclusion": {
        "description": "Define directories and file patterns to exclude from the discovery process.",
        "heading": "Exclusion Patterns"
      },
      "heading": "Configuration Options",
      "retry": {
        "description": "Set maximum retry attempts for failed stages with exponential backoff.",
        "heading": "Retry Configuration"
      },
      "timeout": {
        "description": "Configure maximum execution time for the entire workflow or individual stages to prevent indefinite hanging.",
        "heading": "Timeout Management"
      },
      "workflowConfig": "Workflow Configuration"
    },
    "cta": {
      "description": "The file discovery workflow runs inside the desktop client alongside implementation planning and terminal sessions.",
      "heading": "Need the desktop app?",
      "links": {
        "architecture": "Learn about architecture",
        "buildYourOwn": "Build your own pipeline"
      }
    },
    "date": "2025-09-21",
    "description": "Comprehensive technical guide to the 4-stage AI workflow that identifies and filters relevant files for task execution.",
    "errorHandling": {
      "commonIssues": {
        "binaryDetection": "Binary file detection: Uses both extension-based and content-based binary detection",
        "gitNotFound": "Git repository not found: Falls back to directory traversal with standard exclusions",
        "heading": "Common Issues",
        "networkTimeout": "Network timeouts: Automatic retry with exponential backoff for transient failures",
        "tokenLimit": "Token limit exceeded: Implements intelligent batching and provides clear error messages"
      },
      "debugging": {
        "description": "The workflow provides comprehensive logging, performance metrics export, and detailed error context including stage information, retry attempts, and intermediate data for troubleshooting.",
        "heading": "Debugging Tools"
      },
      "errorCategories": {
        "billing": "Billing Errors: Insufficient credits or payment failures with actionable guidance",
        "heading": "Error Categories",
        "system": "System Errors: File system access, git command failures, or memory constraints",
        "validation": "Validation Errors: Invalid session ID, missing task description, or invalid project directory",
        "workflow": "Workflow Errors: Stage-specific failures with detailed context and retry suggestions"
      },
      "heading": "Error Handling & Troubleshooting"
    },
    "integration": {
      "desktop": {
        "description": "The workflow integrates seamlessly with the desktop application through Tauri commands, providing native file system access and event-driven updates via the WorkflowTracker class.",
        "heading": "Desktop Application"
      },
      "heading": "Integration Patterns",
      "implementationPlans": {
        "description": "Selected files are automatically fed into the Implementation Plans panel, ensuring that plan generation uses the same optimized file context without requiring re-execution of the discovery workflow.",
        "heading": "Implementation Plans Integration"
      },
      "sessionManagement": {
        "description": "Selected files and task history persist per session so follow-up actions can reuse the same context without rerunning discovery.",
        "heading": "Session Management"
      }
    },
    "intro": "PlanToCode identifies the right files before you plan or run commands. The 4-stage workflow narrows scope and keeps context tight.",
    "metaDescription": "Comprehensive technical guide to the 4-stage AI workflow that identifies and filters relevant files for task execution.",
    "metaTitle": "File discovery workflow - PlanToCode",
    "ogDescription": "Technical documentation for the multi-stage file discovery workflow architecture.",
    "ogTitle": "File discovery workflow - PlanToCode",
    "performance": {
      "costOptimization": {
        "description": "AI stages track actual costs from API responses, implement intelligent batching to minimize token usage, and provide cost estimates before execution to help manage expenses.",
        "heading": "Cost Optimization"
      },
      "heading": "Performance Considerations",
      "memory": {
        "description": "The workflow uses token-aware chunking, streaming responses, and cleanup of temporary data to manage memory. There is no fixed file batch size.",
        "heading": "Memory Management"
      },
      "monitoring": {
        "description": "Built-in performance tracking monitors execution times, memory usage, throughput metrics, and provides recommendations for optimization based on historical data analysis.",
        "heading": "Performance Monitoring"
      }
    },
    "readTime": "12 min",
    "stages": {
      "heading": "4-Stage Workflow Process",
      "stage1": {
        "description": "Uses AI to intelligently select the most relevant root directories from a list of candidate paths based on the task description. The LLM analyzes the primary project directory and candidate roots to determine which directories are most likely to contain files relevant to the task.",
        "heading": "Stage 1: Root Folder Selection",
        "technical": "Technical Details: Receives candidate root directories (up to depth 2) and the task description. The LLM evaluates each path against the task context and returns a filtered list of root directories that will be searched in subsequent stages.",
        "inputOutput": "Input/Output: Receives candidate_roots array and task_description. Returns root_directories array containing the AI-selected directories most relevant to the task."
      },
      "stage2": {
        "binaryDetection": "Binary Detection: Filters out files with binary extensions (.jpg, .png, .pdf, .exe, etc.) and uses content analysis to detect binary files by null bytes and non-printable character ratios.",
        "description": "Uses AI to generate intelligent regex pattern groups based on the task description and directory structure. Each pattern group can include path patterns (positive and negative) and content patterns. The processor then applies these patterns to filter files from each selected root directory.",
        "gitIntegration": "Git Integration: Finds the git repository root for each selected directory and uses git_utils to get all non-ignored files, respecting .gitignore rules while including both tracked and untracked files.",
        "heading": "Stage 2: Regex File Filter",
        "technical": "Technical Details: Generates a directory tree for each root, calls the LLM to produce patternGroups with path_pattern, content_pattern, and negative_path_pattern fields. Uses fancy-regex for lookahead/lookbehind support. Processes roots in parallel with configurable concurrency."
      },
      "stage3": {
        "aiProcessing": "AI Processing: Uses large language models to evaluate file content against task requirements, with intelligent chunking based on actual file sizes and token estimates to manage context windows efficiently.",
        "description": "Employs AI models to analyze file content and assess relevance to the specific task description. This stage performs deep content analysis by reading file contents and having the LLM identify which files are most relevant to the task.",
        "heading": "Stage 3: AI File Relevance Assessment",
        "technical": "Technical Details: Estimates tokens per file using file-type-aware heuristics (code ~3 chars/token, structured data ~5 chars/token). Creates content-aware chunks to stay under the 90k token threshold. Processes chunks in parallel with streaming to avoid timeouts. Validates all LLM-suggested paths against the filesystem."
      },
      "stage4": {
        "description": "Discovers additional relevant files by providing the LLM with the previously identified files and their contents, along with the directory tree. The AI analyzes imports, dependencies, and project structure to find related files that enhance the context for the task.",
        "heading": "Stage 4: Extended Path Finder",
        "relationship": "Relationship Analysis: Reads content of all previously identified files and provides it to the LLM alongside the directory tree (scoped to selected roots if available). The AI identifies additional files based on imports, references, and structural relationships.",
        "technical": "Technical Details: Generates a combined directory tree for selected root directories. Reads content of all initial_paths files. Uses streaming LLM calls to avoid Cloudflare timeouts. Validates discovered paths against the filesystem and normalizes to relative paths within the project."
      }
    },
    "stateManagement": {
      "eventDriven": {
        "description": "The system publishes real-time events for workflow status changes, stage completions, and error conditions. These events enable responsive user interfaces and integration with external monitoring systems.",
        "heading": "Event-Driven Updates"
      },
      "heading": "Workflow State Management",
      "intermediateData": {
        "description": "Each stage stores its output in a structured intermediate data format, including directory tree content, regex patterns, filtered file lists results. This data is accessible for debugging and can be used to resume workflows from specific stages.",
        "heading": "Intermediate Data Storage"
      },
      "transitions": {
        "description": "The workflow progresses through clearly defined states: Created → Running → Paused (optional) → Completed/Failed/Canceled. Each state transition publishes events that can be monitored for real-time updates.",
        "heading": "State Transitions"
      }
    },
    "visuals": {
      "pipeline": {
        "title": "File discovery pipeline",
        "description": "The 4-stage workflow: root folder selection, regex filtering, AI relevance assessment, and extended path discovery.",
        "imageSrc": "/images/docs/file-discovery/pipeline.svg",
        "caption": "File discovery pipeline showing all 4 stages",
        "imageAlt": "Diagram showing the 4-stage file discovery workflow: Root Folder Selection, Regex File Filter, AI File Relevance Assessment, and Extended Path Finder"
      }
    },
    "title": "File Discovery Workflow",
    "sqliteStorage": {
      "heading": "SQLite Storage",
      "description": "All workflow state, intermediate results, and job metadata are persisted in SQLite. Each stage stores its output in the background_jobs table, enabling workflow resumption and debugging. The job records include token usage, cost tracking, and system prompt templates for each AI stage."
    }
  },
  "hub": {
    "ctaDescription": "PlanToCodeをダウンロードして、このドキュメントで説明されている実装プランナー、モデルガードレール、ターミナルセッション、文字起こし機能にアクセスしましょう。",
    "ctaHeading": "これらのワークフローを試す準備はできましたか？",
    "ctaLinks": {
      "overview": "概要から始める",
      "runtime": "ランタイムウォークスルー"
    },
    "description": "PlanToCodeでコード変更を計画・実装する方法を学びましょう：ファイル検出、実装計画、ターミナルセッション、モデルガードレール、音声機能について。",
    "exploreHeading": "ドキュメントを探索",
    "learnMore": "詳細を見る",
    "searchAriaLabel": "ドキュメントを検索",
    "searchPlaceholder": "ドキュメントを検索...",
    "searchShortcut": "⌘K",
    "title": "PlanToCodeドキュメント"
  },
  "onThisPage": {
    "title": "このページの内容"
  },
  "sidebar": {
    "title": "ドキュメント"
  },
  "sections": {
    "architecture": {
      "title": "アーキテクチャと内部構造"
    },
    "inputs": {
      "title": "入力とキャプチャ"
    },
    "planning": {
      "title": "計画パイプライン"
    },
    "execution": {
      "title": "実行と自動化"
    },
    "research": {
      "title": "調査とモデル"
    },
    "platform": {
      "title": "ビルドとデプロイ"
    }
  },
  "items": {
    "overview": {
      "title": "システム概要",
      "description": "ここから始めましょう：システムの機能、コアループの仕組み、各コンポーネントの配置について。"
    },
    "runtime-walkthrough": {
      "title": "ランタイムウォークスルー",
      "description": "タスク入力から実行までの一連の流れ。"
    },
    "architecture": {
      "title": "システムアーキテクチャ",
      "description": "デスクトップシェル、Rustサービス、サーバーAPI、永続化レイヤーの連携方法。"
    },
    "desktop-app": {
      "title": "デスクトップアプリの内部構造",
      "description": "Tauri v2シェル、Rustコマンドレイヤー、PTYセッション、UI状態管理。"
    },
    "server-api": {
      "title": "サーバーAPIとLLMプロキシ",
      "description": "認証、プロバイダールーティング、モデル設定、WebSocketエンドポイント。"
    },
    "mobile-ios": {
      "title": "iOSクライアントアーキテクチャ",
      "description": "Swiftワークフロー、Auth0ログインフロー、デバイスリンクセッション管理。"
    },
    "background-jobs": {
      "title": "バックグラウンドジョブとオーケストレーション",
      "description": "ジョブレコード、ワークフローオーケストレーション、プロセッサ、イベントストリーミング。"
    },
    "data-model": {
      "title": "データモデルとストレージ",
      "description": "SQLiteエンティティ、リレーションシップ、状態の再水和方法。"
    },
    "decisions-tradeoffs": {
      "title": "技術的決定とトレードオフ",
      "description": "Tauri、SQLite、専用LLMプロキシを選択した理由とそのコスト。"
    },
    "build-your-own": {
      "title": "独自のパイプラインを構築",
      "description": "ファイル検出とプラン生成ワークフローを設計するための概念ガイド。"
    },
    "meeting-ingestion": {
      "title": "会議と録音の取り込み",
      "description": "録音が構造化されたタスク入力とアーティファクトになる仕組み。"
    },
    "video-analysis": {
      "title": "動画分析",
      "description": "フレームサンプリング、プロンプト、録音からの分析アーティファクト。"
    },
    "voice-transcription": {
      "title": "音声文字起こし",
      "description": "録音ライフサイクル、プロジェクト対応設定、デバイス管理。"
    },
    "text-improvement": {
      "title": "テキスト改善",
      "description": "選択ポップオーバー、ジョブキュー、プロンプトクリーンアップの統合。"
    },
    "file-discovery": {
      "title": "ファイル検出ワークフロー",
      "description": "各タスクに関連するパスを収集するバックグラウンドワークフロー。"
    },
    "implementation-plans": {
      "title": "実装計画",
      "description": "プランがMonacoビューアにストリーミングされ、プラン履歴とリンクされる仕組み。"
    },
    "merge-instructions": {
      "title": "マージ指示",
      "description": "XMLタグ付きソースプランとユーザーガイダンスを使用して複数のプランドラフトをマージする方法。"
    },
    "prompt-types": {
      "title": "プロンプトタイプとテンプレート",
      "description": "プロンプト駆動ジョブタイプとテンプレートアセンブリのカタログ。"
    },
    "terminal-sessions": {
      "title": "ターミナルセッション",
      "description": "永続的なPTYセッション、CLI検出、リカバリ動作。"
    },
    "copy-buttons": {
      "title": "コピーボタン",
      "description": "プランからターミナルおよび外部ツールへのテンプレートハンドオフ。"
    },
    "deep-research": {
      "title": "ディープリサーチとWeb検索",
      "description": "Web検索ワークフロー、API統合、クエリ最適化、開発ワークフロー統合。"
    },
    "provider-routing": {
      "title": "プロバイダールーティングとストリーミング",
      "description": "プロバイダーリクエストの正規化、ストリーミング、追跡方法。"
    },
    "model-configuration": {
      "title": "モデル設定",
      "description": "タスクごとの許可モデルとセレクタートグルのトークンガードレール。"
    },
    "server-setup": {
      "title": "専用サーバーセットアップ",
      "description": "Ansibleベースのインフラ：ベース強化、アプリデプロイ、ボールト管理シークレット。"
    },
    "tauri-v2": {
      "title": "Tauri v2開発ガイド",
      "description": "プロジェクトレイアウト、コマンド、Tauri v2の機能ベースのパーミッション。"
    },
    "distribution-macos": {
      "title": "macOS配布",
      "description": "署名、公証、DMGパッケージング、アップデーターアーティファクト。"
    },
    "distribution-windows": {
      "title": "Windows配布とストア",
      "description": "NSISビルド、MSIXパッケージング、Microsoft Store提出。"
    }
  },
  "implementationPlans": {
    "meta": {
      "title": "実装計画 - AI変更のレビュー",
      "description": "AI実装計画のガイド。実行前にファイル単位のプランを生成、レビュー、承認します。重複や誤ったパスを防止します。"
    },
    "category": "製品ガイド",
    "context": {
      "audit": "Plan metadata persists with each job so you can review which inputs were used (task description, selected roots/files, model settings) and compare drafts later.",
      "heading": "企業ガバナンスのためのコンテキストとメタデータ",
      "storage": "パネルは、ファイル検出ワークフロー中に選択されたリポジトリルートを保存し、フォローアップアクションが同じスコープを再利用できるようにします。また、プロジェクトディレクトリや準備されたプロンプトコンテンツなどのプラン固有のメタデータも記録し、ワークフローを再計算せずにダウンストリームプロンプトを生成またはコピーできます。",
      "tokenEstimation": "トークン見積もりはプロンプトがコピーされる前に実行されます。パネルはプロジェクトディレクトリ、選択されたファイル、現在選択されているモデルでトークン見積もりコマンドを呼び出し、チームがモデル制限内に収まるようにシステムプロンプトとユーザープロンプトの両方の合計を表示します。"
    },
    "cta": {
      "claudeCodeLink": "Claudeプランモードワークフローを見る",
      "codexLink": "Codexプランモードワークフローを見る",
      "cursorLink": "Cursorプランモードワークフローを見る",
      "description": "ヒューマンインザループ実装計画はPlanToCodeデスクトップアプリケーション内で利用できます。プラットフォーム用のビルドをダウンロードして、安全でガバナンスの効いたAI支援開発を体験しましょう。",
      "heading": "AIコーディングエージェントを安全に採用する準備はできましたか？",
      "links": {
        "architecture": "システムアーキテクチャ",
        "decisions": "決定とトレードオフ",
        "buildYourOwn": "独自のパイプラインを構築",
        "fileDiscovery": "ファイル検出ワークフロー"
      }
    },
    "date": "2025-09-19",
    "description": "How PlanToCode enables confident adoption of AI coding agents through human-in-the-loop review, granular file-by-file plans, and clear handoff workflows.",
    "fileGranularity": {
      "created": "作成（完全なファイルパスと初期コンテンツ構造付き）",
      "declaredFiles": "プランの各ステップは、どのファイルが対象になるかを明示的に宣言します：",
      "deleted": "削除（正当性と依存関係分析付き）",
      "heading": "ファイル単位の詳細度",
      "impact": "Reviewers can immediately identify if critical legacy code will be modified, if breaking changes are proposed, or if the plan touches files that require additional scrutiny.",
      "intro": "Implementation plans use a highly granular structure that breaks down development tasks on a file-by-file basis, with exact file paths corresponding to the project's repository structure. This granularity makes scope explicit before any code is touched.",
      "modified": "変更（特定の行範囲と変更内容の説明付き）",
      "referenced": "参照（コンテキスト用だが変更なし）",
      "transmission": "ファイル単位のアプローチは、承認されたプランをコーディングエージェントに正確に伝達することも可能にします。「認証システムを更新」のような曖昧な指示の代わりに、エージェントは正確な仕様を受け取ります：「src/auth/session_manager.rsの45-67行目を変更してトークンローテーションを追加、次の構造でsrc/auth/token_store.rsを作成...」"
    },
    "hitl": {
      "approve": "承認：",
      "approveDesc": "When you are ready, you can hand the plan off to a coding agent or developer for execution.",
      "conclusion": "This workflow keeps execution aligned with the plan you reviewed and helps prevent surprise changes.",
      "edit": "編集：",
      "editDesc": "You can directly modify steps, adjust approaches, add constraints, or remove risky operations using VS Code editing features.",
      "heading": "ヒューマンインザループガバナンス",
      "intro": "PlanToCode keeps planning human-in-the-loop so you can review, edit, and decide when to hand off a plan for execution.",
      "reject": "Discard:",
      "rejectDesc": "If a draft isn't useful, you can delete it from the session list.",
      "requestChanges": "変更をリクエスト：",
      "requestChangesDesc": "Generate alternative plans or merge drafts with custom instructions to converge on the approach you want.",
      "review": "レビュー：",
      "reviewDesc": "プランはMonacoエディタで開き、レビュアーは完全なシンタックスハイライトとプロフェッショナルな編集ツールですべての提案された変更を確認できます。",
      "workflow": "Plans are designed for a structured review workflow before any code modifications begin:"
    },
    "intro": "Review and approve every plan before execution. File-by-file granularity keeps scope explicit and changes aligned with your requirements.",
    "metaDescription": "AI実装計画のガイド。実行前にファイル単位のプランを生成、レビュー、承認します。重複や誤ったパスを防止します。",
    "metaTitle": "実装計画 - AI変更のレビュー",
    "multiplePlans": {
      "description": "Plans can be merged, deleted, or reopened later. The panel keeps a list of selected plan identifiers, manages a dedicated modal for terminal output tied to a plan, and exposes navigation helpers so reviewers can page through earlier plans without closing the viewer. Terminal access, prompt copy controls, and merge instructions all share the same job identifier so plan history stays consistent.",
      "heading": "複数のプランでの作業"
    },
    "ogDescription": "ヒューマンインザループガバナンスとファイル単位のレビューワークフローが、コード変更を完全に制御しながら安全なAI開発をどのように保証するかを理解します。",
    "ogTitle": "PlanToCodeにおけるヒューマンインザループ実装計画",
    "plansOrigin": {
      "description": "各プランは現在のセッションのバックグラウンドジョブに対応しています。パネルはプランデータを購読し、現在開いているプランを追跡し、以前のジョブと新しいジョブ間のナビゲーションを公開します。この動作は{code}と周囲のパネルコンポーネント内にあります。",
      "heading": "プランの由来",
      "processor": "ImplementationPlanProcessorがプラン生成を処理します。関連ファイルを読み取り、オプションで選択されたルートディレクトリに基づいてディレクトリツリーを生成し、LLM用の統一プロンプトを組み立てます。",
      "storage": "Plan responses are stored in the background_jobs table with metadata including planTitle, summary, sessionName, and token usage. The raw LLM response is preserved for review and debugging.",
      "streaming": "プランはリアルタイム進行状況イベントと共にLlmTaskRunnerを介してストリーミングされます。100kトークンを超えるプロンプトにはトークン警告がログに記録されますが、処理は完全なコンテンツで続行されます。"
    },
    "readTime": "6分",
    "reviewingPlans": {
      "description": "プランコンテンツは、Monaco Editorをラップする共有{code}を通じてレンダリングされます。ビューアは一般的な言語を自動検出し、クリップボードへのコピーアクションをサポートし、非常に大きなプランを仮想化し、文字数やシンタックス対応のハイライトなどのオプションメトリクスを提供します。",
      "heading": "Monacoでプランをレビュー",
      "opening": "プランが開かれると、パネルはジョブ識別子でアクティブなプランを解決し、コンテンツをMonacoに渡し、レビュアーが現在開いているモーダルを失わずに隣接するジョブ間を移動できるようにします。"
    },
    "visuals": {
      "structure": {
        "title": "実装計画の構造",
        "description": "ファイル単位の詳細度とメタデータを持つ実装計画のXML形式。",
        "imageSrc": "/images/docs/implementation-plans/structure.svg",
        "caption": "ステップ、ファイル、依存関係追跡を示すプラン構造"
      }
    },
    "title": "実装計画",
    "planProcessor": {
      "heading": "プラン生成パイプライン",
      "description": "ImplementationPlanProcessorは、ファイル内容のロード、コンテキストの構築、LLMタスクランナーを通じた結果のストリーミングによってプラン生成をオーケストレーションします。",
      "inputs": "セッションコンテキスト、タスク説明、選択された関連ファイル、オプションのディレクトリツリー（include_project_structureフラグで設定可能）、外部調査用のWeb検索フラグ。",
      "prompt": "prompt_utils::build_unified_promptを使用して、タスクの説明、完全なファイル内容（切り捨てなし）、ディレクトリツリーを推定トークン数と共にモデル固有の形式に組み合わせます。",
      "output": "生のLLMレスポンスはJobResultData::Textとして保存されます。メタデータにはplanTitle、summary、トークン使用量、キャッシュ統計、実際のコストが含まれます。",
      "display": "レスポンスは進行状況イベントを介してUIにストリーミングされます。プランはシンタックスハイライトとコピーアクションをサポートするMonacoベースのVirtualizedCodeViewerでレンダリングされます。"
    },
    "schema": {
      "heading": "プランデータ構造",
      "description": "実装計画は、関連するメタデータと共に生のLLMレスポンスとして保存されます。レスポンステキストは生成されたまま正確に保存され、構造化されたメタデータはプランのコンテキストと使用状況を追跡します。",
      "fieldsHeading": "メタデータフィールド",
      "fields": [
        "planTitle - プランの生成またはユーザー提供のタイトル",
        "summary - プランの人間が読める要約",
        "sessionName - プランを生成したセッションの名前",
        "isStructured - True for implementation_plan jobs; false for merge outputs",
        "isStreaming - 完了したプランではfalse（生成中はtrue）",
        "planData - agent_instructions（オプション）とsteps配列を含む"
      ],
      "exampleHeading": "メタデータ例",
      "example": "{\n  \"planTitle\": \"Authentication System Refactor\",\n  \"summary\": \"Implementation plan generated\",\n  \"sessionName\": \"my-project\",\n  \"isStructured\": true,\n  \"isStreaming\": false,\n  \"planData\": {\n    \"agent_instructions\": null,\n    \"steps\": []\n  }\n}"
    }
  },
  "modelConfiguration": {
    "meta": {
      "title": "モデル設定とガードレール - PlanToCode",
      "description": "PlanToCodeでタスクごとに許可されたモデルを選択し、プロンプトをアクティブなコンテキストウィンドウ内に収める方法。"
    },
    "category": "製品ガイド",
    "date": "2025-09-20",
    "description": "デスクトップクライアントでのタスクレベルのモデルリスト、セレクターコントロール、トークンガードレール。",
    "intro": "PlanToCodeはモデル選択をタスクレベルの決定として扱います。各ワークフローにはデフォルトモデルと許可リストが付属し、デスクトップクライアントはアクティブなコンテキストウィンドウを超えるプロンプトの送信を防ぐトグルを通じてこれらのオプションを公開します。",
    "metaDescription": "PlanToCodeでタスクごとに許可されたモデルを選択し、プロンプトをアクティブなコンテキストウィンドウ内に収める方法。",
    "metaTitle": "モデル設定とガードレール - PlanToCode",
    "ogDescription": "タスクレベルのモデル設定、セレクタートグル、トークン見積もりがどのように連携するかを学びます。",
    "ogTitle": "モデル設定とガードレール - PlanToCode",
    "promptEstimation": {
      "description": "トークン数はトークン見積もりコマンドを通じて計算されます。パネルはセッションID、タスクの説明、関連ファイル、選択されたモデルを送信し、バックエンドがシステム、ユーザー、合計トークン値を返すことができます。これらの数値はセレクターガードレールに直接フィードされ、チームが別のツールにコピーする前に制限超過のプロンプトを特定できます。",
      "heading": "プロンプト見積もり"
    },
    "readTime": "5分",
    "selectorToggle": {
      "description": "実装計画パネルは{code}で許可されたモデルをレンダリングします。トグルは各許可モデルを表示し、アクティブな選択を追跡し、推定プロンプトと計画された出力トークンがモデルの公表されたコンテキストウィンドウ内に収まるかどうかを切り替えを許可する前に確認します。",
      "guardrails": "モデルが合計トークン要件をサポートできない場合、トグルはボタンを無効にし、計算された超過分を含むツールチップを表示し、レビュアーがエージェントに作業を送信する前に安全な制限内に収めます。",
      "heading": "クライアントでのセレクタートグル"
    },
    "taskDefaults": {
      "description": "デフォルトモデルと許可された代替モデルはサーバー側のアプリケーション設定に保存されます。実装計画、マージ、プロンプト生成、音声文字起こしなどの各タスクタイプは、優先モデル、許可されたオプションのリスト、デスクトップアプリがランタイムで読み取るトークン制限を定義します。",
      "heading": "タスク駆動のデフォルト"
    },
    "title": "モデル設定"
  },
  "terminalSessions": {
    "meta": {
      "title": "ターミナルセッション - PlanToCode",
      "description": "PlanToCodeでのPTYターミナル実装の技術ガイド。セッションの永続化、エージェント非アクティブ検出の仕組み、リカバリメカニズムについて学びます。"
    },
    "attentionDetection": {
      "conclusion": "このアプローチは、エージェントが停止した理由を推測することなく、タスクを完了したか、ガイダンスが必要かを追跡するのに役立ちます。注意インジケーターは新しい出力を受信すると自動的にクリアされます。",
      "heading": "エージェント注意検出",
      "intro": "ターミナルは2段階の非アクティブ検出システムを通じてエージェントのアクティビティを監視します。エージェントが出力を停止すると、システムは段階的に何が起こったかを確認するよう警告します：",
      "level1": "レベル1（30秒）：黄色のインジケーターで「エージェントがアイドル状態 - タスクを完了した可能性があります」",
      "level2": "レベル2（2分）：赤いインジケーターとデスクトップ通知で「エージェントに注意が必要 - ターミナルを確認してください」"
    },
    "category": "製品ガイド",
    "date": "2025-09-22",
    "dependencyChecks": {
      "description": "コマンドを起動する前に、ターミナルはclaude、cursor、codex、geminiなどのサポートされているCLIツールの存在を確認します。同じコマンドはデフォルトシェルも報告するため、ユーザーはどの環境で実行されるかを知ることができます。これにより、必要なバイナリが見つからないセッションへの起動を防ぎます。",
      "heading": "依存関係チェック"
    },
    "description": "実装計画ターミナルでの永続的なPTYセッション、エージェント注意検出、リカバリ動作。",
    "intro": "ヘルスチェックとログを備えた永続的なPTYでコマンドを実行します。必要なときに音声文字起こしが利用可能です。",
    "lifecycle": {
      "description": "ターミナルが開くと、UIコンポーネントはPTYセッションを作成し、バッファ付きビューを通じて出力をストリーミングします。コンポーネントは即座に接続ステータスを表示し、キーストロークをPTYに転送し、セッションが失敗した場合は自動的にリトライします。セッションメタデータは、タイムスタンプ、終了コード、作業ディレクトリ、完全な出力ログと共にSQLiteに保存され、再起動時に以前のコンテキストを再開できます。",
      "heading": "セッションライフサイクル"
    },
    "metaDescription": "PlanToCodeでのPTYターミナル実装の技術ガイド。セッションの永続化、エージェント非アクティブ検出の仕組み、リカバリメカニズムについて学びます。",
    "metaTitle": "ターミナルセッション - PlanToCode",
    "ogDescription": "プランターミナルでのセッション永続化、エージェント注意検出、リカバリを理解します。",
    "ogTitle": "ターミナルセッション - PlanToCode",
    "readTime": "6分",
    "title": "ターミナルセッション",
    "voiceRecovery": {
      "heading": "音声文字起こしとリカバリ",
      "recovery": "PTYセッションが切断された場合、ターミナル画面はリカバリコントロールを表示し、指数バックオフで接続を再試行します。ヘルスチェックはセッション状態の監視を継続し、接続の問題が検出されたときに自動リカバリアクションを提供します。",
      "voice": "Inside the terminal modal, voice transcription can capture speech and paste it into the terminal input area. The recording hook looks up project-level transcription settings, tracks recording state, and inserts transcribed text when the recording stops."
    }
  },
  "copyButtons": {
    "meta": {
      "title": "Copy Buttons - PlanToCode",
      "description": "How template-driven copy buttons resolve placeholders against plans and hand off to terminals or clipboard for agent execution."
    },
    "category": "Execution",
    "date": "2025-09-23",
    "readTime": "10 min",
    "title": "Copy Buttons",
    "description": "Template-driven handoff from implementation plans to PTY terminals and external tools.",
    "intro": "Copy buttons resolve template placeholders against the active plan and then send the result to the clipboard (plan views) or the PTY (terminal modal).",
    "metaTitle": "Copy buttons - PlanToCode",
    "metaDescription": "How template-driven copy buttons resolve placeholders against plans and hand off to terminals or clipboard for agent execution.",
    "ogTitle": "Copy buttons - PlanToCode",
    "ogDescription": "Technical guide to copy button templates, placeholder resolution, and terminal handoff.",
    "visuals": {
      "templateFlow": {
        "title": "Template resolution flow",
        "description": "Templates resolve {{IMPLEMENTATION_PLAN}}, {{TASK_DESCRIPTION}}, and {{STEP_CONTENT}} before copying or sending to the terminal.",
        "imageSrc": "/images/docs/copy-buttons/templates.svg",
        "imageAlt": "Flow showing copy button template resolution",
        "caption": "Placeholder for a template resolution flow diagram."
      }
    },
    "templateConfiguration": {
      "heading": "Template Configuration Sources",
      "description": "Copy button templates follow a layered configuration model. Server defaults provide baseline templates, and project-level overrides customize the implementation_plan task for a given repo.",
      "serverDefaults": {
        "heading": "Server Defaults",
        "description": "Shared templates from /api/config/desktop-runtime-config. Includes button labels and template strings."
      },
      "projectOverrides": {
        "heading": "Project Overrides",
        "description": "Project overrides are stored in SQLite key_value_store under project_task_settings and merged with server defaults."
      },
      "taskSpecific": {
        "heading": "Task-Specific",
        "description": "Copy buttons are configured per task type (implementation_plan) and stored per project. There are no per-job overrides."
      }
    },
    "placeholderResolution": {
      "heading": "Placeholder Resolution",
      "description": "Templates use double-brace placeholders that are resolved against plan content and the current task description.",
      "placeholdersHeading": "Available Placeholders",
      "placeholders": [
        {
          "placeholder": "{{IMPLEMENTATION_PLAN}}",
          "description": "Full implementation plan content as generated by the LLM"
        },
        {
          "placeholder": "{{TASK_DESCRIPTION}}",
          "description": "The task description from the current session"
        },
        {
          "placeholder": "{{STEP_CONTENT}}",
          "description": "Content for the selected plan step (when a step is selected)"
        }
      ],
      "resolutionOrder": "Missing placeholders are replaced with empty strings. Step content is only available when a plan step is selected.",
      "exampleTemplate": "Example template:\n\n{{IMPLEMENTATION_PLAN}}\n\nUnderstand the implementation plan above thoroughly. Analyze the architecture, data flows, and sequence of events.\n\nTask: {{TASK_DESCRIPTION}}"
    },
    "processingPipeline": {
      "heading": "Template Processing Pipeline",
      "description": "When a button is clicked, placeholders are extracted, values are resolved, and the output is sent to clipboard or PTY depending on where the button is used.",
      "steps": [
        {
          "number": 1,
          "title": "Extract Placeholders",
          "description": "Regex scan for {{...}} patterns in the template string"
        },
        {
          "number": 2,
          "title": "Lookup Context",
          "description": "Resolve plan content and task description values for placeholders"
        },
        {
          "number": 3,
          "title": "Substitute Values",
          "description": "Replace placeholders with resolved values"
        },
        {
          "number": 4,
          "title": "Send Output",
          "description": "Copy to clipboard or write to the PTY input buffer"
        }
      ],
      "chunking": {
        "heading": "Large Plan Chunking",
        "description": "When sending to the PTY, the text is chunked into 4KB segments and a carriage return is appended."
      }
    },
    "terminalHandoff": {
      "heading": "PTY Terminal Handoff",
      "description": "In the plan terminal modal, copy buttons write the resolved template to the PTY input buffer as if typed by the user.",
      "detailsHeading": "Handoff Details",
      "details": [
        "Content sent via write_terminal_input_command to the PTY input buffer",
        "Chunked into 4KB segments for large plans",
        "Appends a carriage return after sending"
      ],
      "codeExample": "// Terminal handoff (PlanTerminalModal)\nconst textToSend = replacePlaceholders(button.content, {\n  IMPLEMENTATION_PLAN: planContent,\n  TASK_DESCRIPTION: taskDescription ?? \"\"\n});\nawait sendInChunks(sessionId, textToSend);"
    },
    "clipboardHandoff": {
      "heading": "Clipboard Handoff",
      "description": "In plan cards and plan modals, buttons copy the resolved template to the system clipboard using the browser clipboard API.",
      "crossPlatform": {
        "heading": "Cross-Platform API",
        "description": "Uses navigator.clipboard.writeText() inside the Tauri webview for clipboard access."
      },
      "feedback": {
        "heading": "User Feedback",
        "description": "Toast notification confirms the copy action."
      }
    },
    "defaultButtons": {
      "heading": "Default Copy Buttons",
      "description": "PlanToCode ships with several default copy buttons for implementation plans. These are templates you can edit in settings.",
      "buttonsHeading": "Built-in Buttons",
      "buttons": [
        {
          "id": "parallel-agents",
          "label": "Parallel Claude Coding Agents",
          "description": "Template that instructs Claude Code to launch parallel agents using the plan."
        },
        {
          "id": "investigate-results",
          "label": "Investigate Results",
          "description": "Template that asks the agent to review changes without launching new agents."
        },
        {
          "id": "task-only",
          "label": "Task",
          "description": "Copies only the task description."
        },
        {
          "id": "task-and-plan",
          "label": "Task + Plan",
          "description": "Combines task description and implementation plan for full context."
        },
        {
          "id": "plan-only",
          "label": "Plan",
          "description": "Copies only the implementation plan content."
        }
      ]
    },
    "customization": {
      "heading": "Customizing Copy Buttons",
      "description": "Copy buttons can be customized at multiple levels: global defaults, project-level overrides, and per-task configurations.",
      "globalDefaults": {
        "heading": "Global Defaults",
        "description": "Server-side configuration in /api/config/desktop-runtime-config defines the base set of copy buttons. These are loaded when the desktop app starts and cached for offline use."
      },
      "projectSettings": {
        "heading": "Project-Level Customization",
        "description": "Each project can override the default buttons through the Settings panel. Project-specific buttons are stored in key_value_store and merged with server defaults at runtime."
      },
      "taskSettings": {
        "heading": "Task-Level Configuration",
        "description": "Copy buttons are configured per task type (implementation_plan) and applied per project."
      },
      "editorDescription": "The copy button editor supports drag-and-drop ordering, inline label editing, and template content modification. Changes are persisted automatically."
    },
    "uiIntegration": {
      "heading": "UI Integration and Safety",
      "description": "Copy buttons appear in plan viewers and terminal headers. Clicking a button sends output immediately; there is no preview step by default.",
      "tokenEstimation": {
        "heading": "Token Estimation",
        "description": "Plan cards display token counts for the plan job; copy buttons do not compute per-template token estimates."
      },
      "previewModal": {
        "heading": "Full Preview Modal",
        "description": "There is no dedicated preview modal; open the plan content to inspect what will be copied."
      },
      "disabledState": {
        "heading": "Disabled State",
        "description": "Buttons are disabled when required context is missing (e.g., no active plan, missing session). Tooltips explain what context is needed to enable the button."
      }
    },
    "auditTrail": {
      "heading": "History and signoff",
      "description": "Copy button clicks are not stored in a dedicated table. Plan edits are stored in background_jobs.response and signoff state is recorded in background_jobs.metadata.userSignoff.",
      "schemaHeading": "Notes",
      "schema": "No copy_button_actions table exists in the current release.",
      "fieldsHeading": "Stored plan signals",
      "fields": [
        {
          "field": "background_jobs.response",
          "description": "Plan content after edits or merges"
        },
        {
          "field": "background_jobs.metadata.userSignoff",
          "description": "User signoff state and timestamp"
        }
      ],
      "retention": "No separate retention policy exists for copy button actions; job history retention is controlled in app settings."
    },
    "mobileIntegration": {
      "heading": "Mobile Integration",
      "description": "Copy buttons work in the iOS remote terminal actions bar. Resolved templates are sent to the linked desktop terminal.",
      "deviceLink": {
        "heading": "Device Link Support",
        "description": "When a mobile device is linked to a desktop session, copy buttons can target the desktop terminal directly. The resolved content is sent through the device link WebSocket connection."
      },
      "mobileButtons": {
        "heading": "Mobile-Specific Buttons",
        "description": "Mobile clients use the same copy button configuration stored in project task settings."
      }
    },
    "cta": {
      "heading": "Trace handoff to execution",
      "description": "Terminal sessions show where copy button output lands and how it is logged.",
      "terminalLink": "Terminal sessions",
      "plansLink": "Implementation plans"
    }
  },
  "textImprovement": {
    "meta": {
      "title": "Text improvement - PlanToCode",
      "description": "How the desktop workspace rewrites highlighted text, preserves formatting, and links the feature to voice and video inputs."
    },
    "category": "Product Guide",
    "cta": {
      "description": "Download PlanToCode to combine voice capture, video context, and inline rewriting before you generate implementation plans.",
      "heading": "Try text improvement in the desktop app",
      "links": {
        "architecture": "Architecture overview",
        "buildYourOwn": "Build your own"
      }
    },
    "date": "2025-09-21",
    "description": "How PlanToCode rewrites highlighted text without changing formatting and links the result back to your workspace.",
    "intro": "Refine text with AI context. Select text in any editor, trigger a background job, and get improved content that keeps your formatting intact.",
    "metaDescription": "How the desktop workspace rewrites highlighted text, preserves formatting, and links the feature to voice and video inputs.",
    "metaTitle": "Text improvement - PlanToCode",
    "ogDescription": "Understand the selection popover, job queue, model configuration, and integrations that power text improvement.",
    "ogTitle": "Text improvement - PlanToCode",
    "readTime": "7 min",
    "selectionPopover": {
      "component": "The popover itself is a minimal component rendered by {code}, which simply triggers the provider hook and shows a loading indicator while a rewrite is running. Because the provider registers global listeners, the popover appears in Monaco plan viewers, the plan terminal dictation field, and any task description inputs without extra wiring.",
      "heading": "Selection popover behaviour",
      "provider": "The {code} listens for selection events on standard inputs and Monaco editors. When you highlight non-empty text it positions a popover near the cursor, stores the selected range, and tracks whether the popover should be visible. Clicking the button kicks off the job and disables the control until the result returns. When the job completes the provider applies the improved text back into the same selection and flushes any pending saves to keep session state in sync."
    },
    "title": "Text Improvement",
    "triggerImprovement": {
      "action": "Pressing the popover button calls {code}. The action validates the selection, ensures a session identifier exists, and invokes the Rust command {code} via Tauri. The command builds a {code} containing the original text and queues a background job against the active session.",
      "backend": "On the backend, the {code} resolves the configured model for the {code} task, wraps the selection in XML tags, and runs the request through the {code} without streaming. When the model response returns it records token usage, cost, and the system prompt template before emitting the improved text back to the UI. The default configuration ships with Claude Sonnet 4.5 and Gemini 3 Pro as the approved models, capped at 4,096 tokens with a temperature of 0.7.",
      "heading": "What happens when you trigger an improvement",
      "metadata": "The background jobs sidebar records the original text in job metadata, so you can review what was sent alongside the rewritten copy. If the selection changes while a job is running, the provider skips replacing the text to avoid clobbering manual edits."
    },
    "videoCapture": {
      "dialog": "The video analysis dialog combines the current task description with an optional focus prompt wrapped in <description> and <video_attention_prompt> tags before sending the job. You can narrate while recording; the resulting summary can be pasted into the task description and refined with the improvement popover.",
      "features": "Video jobs include frame-rate controls, optional audio capture, and usage tracking. Results appear in the background jobs sidebar alongside text improvements.",
      "heading": "Video capture and prompt scaffolding"
    },
    "voiceIntegration": {
      "heading": "Voice transcription integration",
      "hook": "Voice recordings use the {code} hook. It loads per-project transcription defaults, requests microphone access, and inserts transcribed text at the cursor inside the task description or terminal dictation buffer. The inserted text can be highlighted and passed through the improvement popover.",
      "preferences": "Language, model, and temperature preferences persist at the project level, so teams get consistent transcription quality before refining the copy. Silence detection warns about bad audio levels, and a ten-minute cap prevents oversized recordings from blocking improvement jobs with large payloads."
    },
    "visuals": {
      "popoverFlow": {
        "title": "Text improvement flow",
        "description": "Selection popover triggers improvement job and returns enhanced text.",
        "imageSrc": "/images/docs/text-improvement/flow.svg",
        "imageAlt": "Text improvement flow diagram"
      }
    },
    "processorDetails": {
      "heading": "Processor implementation details",
      "processor": "The {code} handles the text rewriting workflow on the Rust backend.",
      "stepsHeading": "Processing steps",
      "steps": [
        "Parse the incoming payload with original text and selection metadata",
        "Build the system prompt from the configured text_improvement template",
        "Submit the request to the LLM task runner without streaming",
        "Extract the improved text from the model response",
        "Record token usage, cost, and prompt template for billing",
        "Emit the result back to the UI via Tauri events"
      ]
    },
    "inlineRewriting": {
      "heading": "Inline rewriting behaviour",
      "description": "When the improved text returns, the provider automatically replaces the original selection. The rewriting preserves whitespace, line breaks, and any inline formatting present in the source. If the editor is Monaco-based, the change is applied as a single undo-able edit operation.",
      "contextsHeading": "Supported contexts",
      "contexts": [
        "Task description input fields",
        "Plan terminal dictation area",
        "Monaco plan viewers and editors",
        "Any standard HTML input or textarea"
      ]
    },
    "modelConfiguration": {
      "heading": "Model configuration",
      "description": "Text improvement uses the text_improvement task configuration from the desktop runtime config. You can override the default model and parameters in the settings panel.",
      "settingsHeading": "Configurable settings",
      "settings": [
        "Allowed models list (default: Claude Sonnet 4.5, Gemini 3 Pro)",
        "Maximum token limit (default: 4096)",
        "Temperature setting (default: 0.7)",
        "System prompt template override"
      ]
    },
    "keyFiles": {
      "heading": "Key implementation files",
      "items": [
        "desktop/src/contexts/TextImprovementProvider.tsx",
        "desktop/src/components/TextImprovementPopover.tsx",
        "desktop/src/actions/text-improvement/index.ts",
        "desktop/src-tauri/src/jobs/processors/text_improvement.rs",
        "server/src/config/task_model_config.rs"
      ]
    }
  },
  "voiceTranscription": {
    "meta": {
      "title": "Voice transcription - PlanToCode",
      "description": "How PlanToCode records audio, sends it to the configured transcription provider, and inserts text into task or terminal inputs."
    },
    "category": "Product Guide",
    "date": "2025-09-22",
    "description": "Recording lifecycle, device management, and transcription behavior for voice-driven prompts.",
    "deviceManagement": {
      "description": "The feature requests microphone permission, enumerates available audio inputs, and lets users choose the active device before recording. Changes take effect on the next recording.",
      "heading": "Device management",
      "monitoring": "Real-time audio level monitoring displays visual feedback during recording. The system warns when audio is silent so you can catch muted microphones before sending the recording."
    },
    "intro": "Voice transcription is available anywhere the desktop app exposes dictation controls, including the plan terminal and prompt editors. The feature records audio locally and sends a single recording to the transcription service when you stop, then inserts text into the active input field without blocking manual typing.",
    "metaDescription": "How PlanToCode records audio, sends it to the configured transcription provider, manages permissions, and inserts text into task or terminal inputs.",
    "metaTitle": "Voice transcription - PlanToCode",
    "ogDescription": "Learn how the recording hook manages devices, permissions, and streaming text.",
    "ogTitle": "Voice transcription - PlanToCode",
    "projectSettings": {
      "description": "When a recording session starts, the hook looks up the active project's transcription configuration so recordings follow the project's preferences.",
      "heading": "Project-aware settings",
      "storage": "Project transcription preferences are stored in SQLite key_value_store under project_task_settings and include the preferred model, language code, prompt, and temperature. Hosted uses managed providers; self-hosting can adjust the allowlist."
    },
    "readTime": "5 min",
    "recordingWorkflow": {
      "description": "The recording hook keeps a state machine with idle, recording, processing, and error states. It records audio into a single blob, enforces a ten-minute cap, and sends the recording on stop.",
      "heading": "Recording workflow",
      "statesHeading": "Recording states",
      "states": [
        "idle: No recording in progress, microphone permissions may or may not be granted",
        "recording: Capturing audio via MediaRecorder with live level monitoring",
        "processing: Uploading the recording to the transcription endpoint and awaiting a response",
        "error: Recording failed due to permission denial, device disconnection, or transcription API error"
      ]
    },
    "routingBehavior": {
      "heading": "Multi-destination routing",
      "description": "Transcribed text is routed based on the active UI context and inserted into the appropriate input.",
      "destinations": [
        "Task description editors: Cursor insertion with optional follow-up text_improvement",
        "Terminal dictation buffer: Command text inserted into PTY input",
        "Prompt editors: Direct insertion into active text inputs"
      ]
    },
    "pipeline": {
      "heading": "Transcription pipeline",
      "hook": "The {code} React hook manages the complete recording lifecycle. It initializes {code} for audio capture in WebM format with Opus codec, monitors audio levels, and handles device switching.",
      "command": "The desktop app invokes {code} to send audio data to the server endpoint {code}. The command validates minimum size (1KB), duration, temperature (0.0-1.0), and prompt length (max 1000 characters); the server enforces max file size (100MB).",
      "constraints": "Audio files must be between 1KB and 100MB. Supported formats: WAV, MP3, M4A, OGG, WebM, FLAC, AAC, and MP4. The transcription model must be specified explicitly and must be in the server allowlist (OpenAI models by default on hosted)."
    },
    "serverProcessing": {
      "heading": "Server-side processing",
      "endpoint": "The server exposes {code} which accepts multipart form data. It routes requests to OpenAI or Google based on the model's provider configuration, validates user credits, and calculates billing based on audio duration.",
      "parametersHeading": "Request parameters",
      "parameters": [
        "file: Audio file data (required) - WAV, MP3, M4A, OGG, WebM, FLAC, AAC, or MP4",
        "model: Transcription model ID (required) - from server allowlist (e.g., openai/gpt-4o-transcribe)",
        "durationMs: Recording duration in milliseconds (required for billing calculation)",
        "language: ISO 639-1 language code (optional) - improves accuracy for specific languages",
        "prompt: Context hint for transcription (optional, max 1000 characters) - helps with domain-specific vocabulary",
        "temperature: Sampling temperature 0.0-1.0 (optional, default 0.0) - lower values produce more deterministic output"
      ]
    },
    "dataFlow": {
      "heading": "Data flow",
      "description": "Audio data flows from the browser through the Tauri command layer to the server, which proxies requests to the appropriate transcription provider.",
      "stepsHeading": "Processing steps",
      "steps": [
        "Browser MediaRecorder captures audio in a single recording (WebM by default)",
        "useVoiceTranscription tracks duration and recording state",
        "On stop, the audio blob is converted to bytes and sent via transcribe_audio_command",
        "Tauri command validates size, duration, temperature, and prompt length",
        "Request sent to server /api/audio/transcriptions endpoint with auth token",
        "Server routes to the configured provider and returns transcribed text",
        "Transcribed text returned to desktop and inserted via callback"
      ]
    },
    "keyFiles": {
      "heading": "Key implementation files",
      "items": [
        "desktop/src/hooks/use-voice-recording/use-voice-transcription.ts",
        "desktop/src/actions/voice-transcription/transcribe.ts",
        "desktop/src-tauri/src/commands/audio_commands.rs",
        "server/src/handlers/proxy/specialized/transcription.rs",
        "server/src/clients/openai/transcription.rs",
        "server/src/clients/google_client.rs"
      ]
    },
    "examples": {
      "heading": "Usage examples",
      "description": "Common voice transcription workflows:",
      "items": [
        "Sprint planning: Dictate tasks, then run text_improvement and task_refinement",
        "Terminal commands: Dictation transcribed and typed directly into PTY for execution",
        "Bug reports: Verbal description captured, refined with text_improvement, then stored in task history",
        "Walkthrough notes: Narrate a screen recording and attach the video analysis summary to the task"
      ]
    },
    "cta": {
      "heading": "Continue exploring",
      "description": "Learn how transcribed text can be refined and how meeting recordings are processed into actionable tasks.",
      "links": {
        "textImprovement": "Text Improvement",
        "meetingIngestion": "Meeting Ingestion"
      }
    },
    "title": "Voice Transcription",
    "visuals": {
      "recordingFlow": {
        "title": "Voice transcription pipeline",
        "description": "Audio capture, provider transcription, and text insertion flow.",
        "imageSrc": "/images/docs/voice-transcription/pipeline.svg",
        "imageAlt": "Voice transcription pipeline diagram",
        "caption": "Audio flows from browser capture through Tauri commands to the configured transcription provider."
      }
    }
  },
  "overview": {
    "meta": {
      "title": "システム概要 - PlanToCode",
      "description": "ここから始めましょう：PlanToCodeの機能、コアループの仕組み、リポジトリ内の各コンポーネントの配置。"
    },
    "category": "概要",
    "date": "2025-09-25",
    "readTime": "15分",
    "title": "システム概要",
    "description": "システム、コアループ、必要な依存関係の簡潔なマップ。",
    "intro": "PlanToCodeは、実行前にコード変更を計画・検証するデスクトップワークスペースです。ローカルのRustジョブエンジン、React UI、LLM呼び出し用のサーバープロキシを調整します。システムはオフラインファーストアーキテクチャに従い、デスクトップアプリはローカル状態にSQLiteを使用して独立して動作し、サーバーは認証、LLMプロバイダールーティング、課金を処理します。LLMアクセスがない場合（ホスト版は管理、セルフホストは独自キー）、計画と分析パイプラインは実行されません。",
    "visuals": {
      "systemMap": {
        "title": "システムマップ",
        "description": "デスクトップアプリ、Rustコア、ローカルSQLiteストレージ、サーバープロキシのマップ。",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "PlanToCodeシステムマップ図",
        "caption": "データが下に流れ、イベントが上にストリーミングされる4層アーキテクチャ。"
      }
    },
    "systemLayers": {
      "heading": "システムレイヤー",
      "description": "システムは、明確に定義されたインターフェースを通じて通信する4つの異なるレイヤーに編成されています：",
      "items": [
        "プレゼンテーションレイヤー：Monacoエディタ、ターミナルパネル、ワークフローコントロールを備えたReact UI（desktop/src/）",
        "コマンドレイヤー：ReactとRustを橋渡しし、IPCと状態管理を処理するTauriコマンド（desktop/src-tauri/src/commands/）",
        "処理レイヤー：Rustでのジョブプロセッサ、ワークフローオーケストレーター、ビジネスロジック（desktop/src-tauri/src/jobs/）",
        "永続化レイヤー：ローカル状態用のSQLiteリポジトリと認証/課金用のサーバーPostgreSQL（desktop/src-tauri/src/db_utils/）"
      ]
    },
    "coreLoop": {
      "heading": "実践におけるコアループ",
      "description": "すべてのタスクはキャプチャから実行まで明確に定義されたライフサイクルを流れます：",
      "steps": [
        "テキスト、音声文字起こし（useVoiceTranscriptionフック経由）、またはビデオ録画分析からタスクをキャプチャ。",
        "TextImprovementProcessorを通じてtext_improvementジョブでタスクの説明と目標を洗練。",
        "ファイル検出ワークフローを実行：RootFolderSelectionProcessorがディレクトリを選択、RegexFileFilterProcessorがパターンを適用、FileRelevanceAssessmentProcessorが内容をスコアリング、ExtendedPathFinderProcessorがコンテキストを拡張。",
        "ImplementationPlanProcessorを介して実装計画を生成し、XML形式のプランをMonacoビューアにストリーミング。",
        "オプションで、XMLタグ付きソースプランを使用してImplementationPlanMergeProcessorで複数のプランドラフトをマージ。",
        "PTYターミナルセッションまたは外部エージェント用のコピーボタンテンプレートを通じて承認されたプランを実行またはエクスポート。",
        "Persist every job, artifact, and terminal log to SQLite (background_jobs, terminal_sessions tables) for history and recovery."
      ]
    },
    "components": {
      "heading": "主要コンポーネント",
      "description": "各コンポーネントには特定の責任があり、型付きインターフェースを通じて通信します：",
      "items": [
        "デスクトップUI（React）：desktop/src/内にMonacoプランビュー、ターミナルパネル、プロバイダー（SessionProvider、TextImprovementProvider）。",
        "Rustコア（Tauri v2）：desktop/src-tauri/内でコマンド、ジョブ、永続化を機能ベースのパーミッションで処理。",
        "ローカルSQLiteスキーマ：並行アクセス用のWALモードを持つdesktop/src-tauri/migrations/consolidated_schema.sql。",
        "サーバープロキシ（Actix-Web）：認証、プロバイダールーティング、ストリーミングレスポンス、Stripe経由の課金用にserver/src/内。",
        "モバイルiOSクライアント：SwiftUIインターフェース、Auth0 PKCE、WebSocketデバイスリンクを持つmobile/ios/Core/内。",
        "インフラ自動化：Hetzner（EU）とInterServer（US）専用サーバー用のinfrastructure/ansible/内。"
      ]
    },
    "dependencies": {
      "heading": "必要な依存関係",
      "description": "システムには以下の外部サービスとリソースが必要です：",
      "items": [
        "プラン生成、文字起こし、分析用の外部LLMプロバイダー（OpenAI、Anthropic、Google、X.AI、OpenRouter）。",
        "デスクトップとモバイルセッション用のPKCEフローを持つAuth0ベースの認証。",
        "サーバー側のユーザーアカウント、課金状態、ジョブキュー用のPostgreSQL 17とRedis 7+（セルフホストデプロイメント）。",
        "ファイル検出ワークフロー用のgit ls-filesまたはディレクトリトラバーサルによるローカルファイルシステムアクセス。",
        "音声入力処理用のWhisper互換文字起こしエンドポイント。"
      ]
    },
    "codeMap": {
      "heading": "リポジトリ内の動作の場所",
      "description": "主要なディレクトリとファイルへのクイックリファレンス：",
      "items": [
        "Tauriコマンド：desktop/src-tauri/src/commands/（35以上のコマンドモジュール：job_commands.rs、workflow_commands.rs、terminal_commands.rs、session_commands.rs、auth0_commands.rs）",
        "ワークフローオーケストレーション：desktop/src-tauri/src/jobs/workflow_orchestrator/（definition_loader.rs、stage_scheduler.rs、event_emitter.rs、payload_builder.rs）",
        "ジョブプロセッサ：desktop/src-tauri/src/jobs/processors/（implementation_plan_processor.rs、text_improvement_processor.rs、root_folder_selection_processor.rs）",
        "SQLiteリポジトリ：desktop/src-tauri/src/db_utils/（background_job_repository/、session_repository.rs、terminal_repository.rs）",
        "サーバールート：server/src/routes.rs（configure_routes、configure_public_auth_routes、configure_webhook_routes）",
        "LLMプロキシハンドラー：server/src/handlers/proxy_handlers.rsとserver/src/handlers/proxy/（router.rs、providers/）",
        "プロバイダートランスフォーマー：server/src/handlers/provider_transformers/（openai.rs、google.rs、anthropic.rs、xai.rs）",
        "iOSワークフロー：MobileSessionManagerとAPIClientを持つmobile/ios/Core/Sources/Workflows/WorkflowManager.swift",
        "インフラプレイブック：infrastructure/ansible/site-base.yml（強化、PostgreSQL、Redis）とsite-app.yml（デプロイメント）"
      ]
    },
    "keyAbstractions": {
      "heading": "主要な抽象化",
      "description": "これらのコア概念を理解することでコードベースのナビゲーションが容易になります：",
      "items": [
        "セッション：task_description、included_files、モデル設定を持つsessionsテーブルに保存されたプロジェクトコンテキスト。UUIDで識別。",
        "バックグラウンドジョブ：task_type、プロンプト、レスポンス、トークン追跡、コストを持つbackground_jobsテーブルに保存されたLLMバックアップ操作。",
        "ワークフロー：ステージ間でIntermediateDataを渡すWorkflowOrchestratorによって調整される多段階オーケストレーションプロセス（例：file_finder_workflow）。",
        "Terminal Session: PTY process stored in terminal_sessions with output_log, status, and optional job_id linking for traceability.",
        "プロバイダー：リクエスト変換とレスポンス正規化を持つserver/src/handlers/proxy/providers/内のLLMサービス抽象化。"
      ]
    },
    "dataFlowSummary": {
      "heading": "データフローサマリー",
      "description": "典型的な計画タスクでデータがシステムをどのように移動するか：",
      "items": [
        "ユーザー入力はReactコンポーネントを通じて入り、@tauri-apps/api/core invoke()を介してTauriコマンドに流れます。",
        "コマンドはbackground_jobsレコードを作成し、ジョブキューを介してジョブプロセッサにディスパッチします。",
        "プロセッサはプロンプトを構築し、サーバーLLMプロキシを通じてリクエストを送信し、Tauriイベントを介してレスポンスをストリーミングします。",
        "レスポンスはSQLiteに保存され、UI状態を更新するReactプロバイダーに発行されます。",
        "ターミナル実行はPTY出力をUIにストリーミングし、セッションリカバリ用にログを永続化します。"
      ]
    }
  },
  "runtimeWalkthrough": {
    "meta": {
      "title": "ランタイムウォークスルー - PlanToCode",
      "description": "入力からプラン出力までのタスクのエンドツーエンドタイムライン、ジョブタイプとアーティファクトフローを含む。"
    },
    "category": "アーキテクチャ",
    "date": "2025-09-25",
    "readTime": "12分",
    "title": "ランタイムウォークスルー",
    "description": "タスク入力からプラン出力までのエンドツーエンドランタイムタイムライン。",
    "intro": "このウォークスルーは、初期キャプチャからファイル検出、プラン生成、ターミナル実行までの単一タスクを追跡します。各ステージは特定のジョブタイプにマップされ、SQLiteに保存されるアーティファクトを生成します。",
    "visuals": {
      "timeline": {
        "title": "ランタイムタイムライン",
        "description": "タスク入力、ワークフローステージ、プラン出力を示すビジュアルタイムライン。",
        "imageSrc": "/images/docs/runtime-walkthrough/timeline.svg",
        "imageAlt": "ランタイムタイムライン図",
        "caption": "タスク実行は6つのステージを流れ、すべてのアーティファクトはSQLiteに永続化されます。"
      },
      "walkthroughVideo": {
        "title": "ランタイムウォークスルービデオ",
        "description": "入力からプラン出力までの完全なタスク実行のビデオデモンストレーション。",
        "videoSrc": "",
        "posterSrc": "",
        "caption": "ビデオウォークスルーのプレースホルダー - 完全な計画ワークフローのデモンストレーションを録画してください。"
      }
    },
    "timeline": {
      "heading": "ハイレベルランタイムシーケンス",
      "description": "完全なタスク実行は次の操作シーケンスに従います：",
      "steps": [
        "ユーザーがTaskDescriptionEditorコンポーネントを介してデスクトップUIでタスクの説明を入力または音声入力。",
        "オプション：text_improvementジョブがTextImprovementProcessorを通じて生の入力を洗練。",
        "ユーザーが実装計画パネルのstart_file_finder_workflowコマンドを介してファイル検出ワークフローをトリガー。",
        "desktop/src-tauri/src/jobs/workflow_orchestrator/のWorkflowOrchestratorがワークフローレコードを作成しステージ1をスケジュール。",
        "ステージ1（root_folder_selection）：RootFolderSelectionProcessorがディレクトリツリーをLLMに送信、選択されたルートをIntermediateData.selectedRootsに保存。",
        "ステージ2（regex_file_filter）：RegexFileFilterProcessorがパターンを生成、git ls-filesを実行、マッチをIntermediateData.locallyFilteredFilesに保存。",
        "ステージ3（file_relevance_assessment）：FileRelevanceAssessmentProcessorがファイル内容をチャンキング、関連性をスコアリング、IntermediateData.aiFilteredFilesに保存。",
        "ステージ4（extended_path_finder）：ExtendedPathFinderProcessorがインポートと依存関係でコンテキストを拡張、IntermediateData.verifiedPathsに保存。",
        "UIがevent_emitter.rs経由でworkflow-completedイベントを受信、ファイル選択表示を更新。",
        "ユーザーがgenerate_implementation_planコマンドを介して選択されたファイルでプラン生成をトリガー。",
        "desktop/src-tauri/src/jobs/processors/implementation_plan_processor.rsのImplementationPlanProcessorがjob:stream-progressイベントを介してXMLプラン内容をMonacoビューアにストリーミング。",
        "ユーザーがVirtualizedCodeViewerコンポーネントでプランをレビュー、直接編集またはマージをリクエスト可能。",
        "承認されたプランがコピーボタンテンプレートを介してターミナルにコピーされるか、外部エージェント用にエクスポート。",
        "terminal_commands.rsのターミナルセッションがPTY出力をキャプチャし、エージェント注意状態を検出。",
        "All artifacts persist in SQLite background_jobs and terminal_sessions tables for history and session recovery."
      ]
    },
    "jobTypes": {
      "heading": "ランタイムでのジョブタイプ",
      "description": "各task_typeは特定のプロセッサにマップされ、異なるアーティファクトを生成します：",
      "items": [
        "text_improvement：TextImprovementProcessorがテキストをXMLでラップし、LLMに送信、洗練されたテキストを返す。background_jobs.responseに保存。",
        "root_folder_selection：RootFolderSelectionProcessorがディレクトリツリーを受信、選択されたディレクトリのJSON配列を返す。",
        "regex_file_filter：RegexFileFilterProcessorがタスクの説明からパターンを生成、gitファイルリストに適用。",
        "file_relevance_assessment：FileRelevanceAssessmentProcessorがファイル内容をロード、トークン制限でチャンキング、関連性をスコアリング。",
        "extended_path_finder：ExtendedPathFinderProcessorがインポート/依存関係を分析、関連ファイルでコンテキストを拡張。",
        "implementation_plan：ImplementationPlanProcessorがplan_step要素を持つXML形式のプランをストリーミング。",
        "implementation_plan_merge：ImplementationPlanMergeProcessorがsource_plans XMLタグとユーザー指示を使用してプランを結合。",
        "video_analysis: Processes screen recordings via /api/llm/video/analyze with a framerate hint.",
        "web_search_prompts_generation：ディープリサーチワークフロー用のresearch_task XMLブロックを生成。",
        "web_search_execution：調査プロンプトを並列実行、結果を集約。"
      ]
    },
    "inputCapture": {
      "heading": "タスク入力のキャプチャ",
      "description": "タスクは複数の入力サーフェスからシステムに入ります：",
      "text": "タスク説明はTaskDescriptionEditorに入力または貼り付けされ、sessions.task_descriptionに永続化され、マルチデバイス同期用のdevice_idを含むtask_description_historyテーブルに履歴エントリが作成されます。",
      "voice": "音声入力はuseVoiceTranscriptionフックを使用し、MediaRecorder APIで録音し、/api/audio/transcriptionsに送信し、カーソル位置に挿入します。",
      "video": "ビデオ分析はVideoAnalysisDialogを使用して画面録画をキャプチャし、/api/llm/video/analyzeにアップロードし、UI状態の観察を抽出します。"
    },
    "workflowExecution": {
      "heading": "ワークフロー実行の詳細",
      "description": "WorkflowOrchestratorが複数ステージのワークフローを調整します：",
      "scheduling": "workflow_lifecycle_manager.rsがワークフローレコードを作成し、stage_scheduler.rsがワークフローJSON定義に基づいてステージを順次ディスパッチします。",
      "data": "workflow_types.rsのIntermediateData構造体がステージ間で出力を渡します：selectedRoots、rawRegexPatterns、locallyFilteredFiles、aiFilteredFiles、verifiedPaths。",
      "events": "event_emitter.rsがworkflow-statusとworkflow-stage Tauriイベントを発行し、React UIのWorkflowTrackerが消費します。"
    },
    "persistence": {
      "heading": "状態の永続化",
      "description": "All artifacts are persisted for review and recovery:",
      "jobs": "background_job_repository/がsession_id、task_type、status、prompt、response、tokens_sent/received、actual_costを含むジョブレコードを保存します。",
      "sessions": "session_repository.rsがtask_description、included_files、model_used、履歴バージョンを含むsessionsテーブルを管理します。",
      "terminals": "terminal_repository.rsがセッションリカバリ用のoutput_log、status、exit_code、working_directoryを含むterminal_sessionsを永続化します。",
      "rehydration": "アプリ再起動時、Rustコアがsqliteからセッション状態を復元し、古い実行中ジョブを失敗としてマークし、ターミナル出力ログを復元します。"
    },
    "inputs": {
      "heading": "Task input capture",
      "capture": "Tasks enter the system through multiple input surfaces: typed text in TaskDescriptionEditor, voice dictation via useVoiceTranscription hook, or video analysis through VideoAnalysisDialog.",
      "artifacts": "Each input type updates SQLite state: task_description in sessions and task_description_history, voice transcription inserts text into the session or terminal input, and video analysis responses are stored in background_jobs."
    },
    "refinement": {
      "heading": "入力の洗練",
      "jobs": "text_improvementジョブタイプはTextImprovementProcessorを通じて生の入力を洗練し、テキストをXMLでラップしてLLMに送信し、文法、明確さ、構造の改善を行います。",
      "storage": "洗練されたテキストはbackground_jobs.responseに保存され、Reactプロバイダー経由でsessions.task_descriptionを更新できます。"
    },
    "discovery": {
      "heading": "ファイル検出ワークフロー",
      "workflow": "FileFinderWorkflowは4つの連続ステージを実行します：root_folder_selectionがディレクトリを絞り込み、regex_file_filterがパターンを適用し、file_relevance_assessmentがコンテンツをスコアリングし、extended_path_finderが依存関係で拡張します。",
      "outputs": "各ステージは結果をプロセッサ間で渡されるIntermediateData構造体に保存し、最終的なファイル選択はsessions.included_filesに永続化されます。"
    },
    "planGeneration": {
      "heading": "計画生成",
      "jobs": "implementation_planジョブタイプはImplementationPlanProcessorを使用して、ファイルパス、操作タイプ、コード変更を含むplan_step要素を持つXMLフォーマットの計画を生成します。",
      "streaming": "計画コンテンツはjob:stream-progress Tauriイベント経由でUIにストリーミングされ、シンタックスハイライト付きでVirtualizedCodeViewer Monacoコンポーネントに表示されます。"
    },
    "merge": {
      "heading": "計画のマージ",
      "instructions": "implementation_plan_mergeジョブはsource_plans XMLタグとユーザー提供のマージ指示を使用して複数の計画を結合し、競合を解決して変更を統合します。",
      "outputs": "マージされた計画はソース計画へのトレーサビリティを維持し、最終的なbackground_jobsレコードにmerged_fromメタデータを含みます。"
    },
    "review": {
      "heading": "Plan review",
      "editor": "Plans open in the Monaco-based VirtualizedCodeViewer for review. Users can edit plan text directly, request modifications, or approve for execution.",
      "audit": "Plan edits are persisted in background_jobs.response; signoff state is recorded in background_jobs.metadata.userSignoff."
    },
    "execution": {
      "heading": "実行ハンドオフ",
      "terminal": "承認された計画はコピーボタンテンプレート経由で統合ターミナルにコピーされるか、Claude Code、Cursor、Codexなどの外部エージェント用にエクスポートされます。",
      "logging": "terminal_commands.rsのターミナルセッションはPTY出力をキャプチャし、エージェント注意状態を検出し、すべての実行アクティビティをterminal_sessionsテーブルにログ記録します。"
    },
    "state": {
      "heading": "状態の永続化",
      "jobs": "すべてのジョブアーティファクトはsession_id、task_type、status、prompt、response、トークン数、コスト追跡を含むbackground_jobsテーブルに永続化されます。",
      "rehydration": "アプリ再起動時、RustコアがSQLiteからセッション状態を復元し、古い実行中ジョブを失敗としてマークし、ターミナル出力ログを復元します。"
    },
    "jobMap": {
      "heading": "ジョブタイプマッピング",
      "items": [
        "text_improvement → TextImprovementProcessor → 洗練されたタスク説明",
        "root_folder_selection → RootFolderSelectionProcessor → 選択されたディレクトリ",
        "regex_file_filter → RegexFileFilterProcessor → パターンマッチしたファイル",
        "file_relevance_assessment → FileRelevanceAssessmentProcessor → スコアリングされたファイル",
        "extended_path_finder → ExtendedPathFinderProcessor → 拡張されたコンテキスト",
        "implementation_plan → ImplementationPlanProcessor → XML計画ドキュメント",
        "implementation_plan_merge → ImplementationPlanMergeProcessor → マージされた計画"
      ]
    },
    "cta": {
      "heading": "アーキテクチャを探索",
      "description": "コンポーネントがどのように組み合わさっているかを詳細に理解しましょう。",
      "links": {
        "architecture": "アーキテクチャ概要",
        "jobs": "バックグラウンドジョブ",
        "desktop": "デスクトップアプリの内部",
        "dataModel": "データモデル",
        "plans": "実装計画"
      }
    }
  },
  "desktopApp": {
    "meta": {
      "title": "デスクトップアプリの内部 - PlanToCode",
      "description": "Tauriデスクトップシェル、Rustコマンドレイヤー、SQLite永続化、PTYセッションがどのように連携するかを解説します。"
    },
    "category": "デスクトップ",
    "date": "2025-09-25",
    "readTime": "14分",
    "title": "デスクトップアプリの内部",
    "description": "Tauri v2シェル、Rustコマンドレイヤー、PTYセッション、UI状態管理。",
    "intro": "デスクトップアプリはReact UIを実行するTauri v2シェル（バージョン2.9.1）です。Rustサービスがワークフロー、ターミナルセッション、設定用のコマンドを公開し、SQLiteにローカルで状態を永続化します。機能ベースの権限モデルが、ファイルシステムアクセス、HTTPリクエスト、シェル実行、システム通知に対するきめ細かいセキュリティ制御を提供します。",
    "visuals": {
      "shell": {
        "title": "デスクトップシェル概要",
        "description": "計画エディター、ターミナルタブ、ジョブステータスサイドバーを示すスクリーンショット。",
        "imageSrc": "/assets/images/demo-implementation-plans.jpg",
        "imageAlt": "PlanToCodeデスクトップシェル",
        "caption": "実装計画パネルとサイドバーを表示するデスクトップアプリ。"
      }
    },
    "projectLayout": {
      "heading": "プロジェクトレイアウト",
      "description": "デスクトップアプリケーションは標準的なTauri v2構造に従います：",
      "items": [
        "desktop/src/：React UIコンポーネント、フック、プロバイダー、デスクトップ固有のアダプター。",
        "desktop/src-tauri/：コマンド、ジョブ、リポジトリ、サービスを含むRustコア。",
        "desktop/src-tauri/src/lib.rs：プラグイン登録とAppState管理を含むアプリケーションエントリポイント。",
        "desktop/src-tauri/src/commands/：ドメイン別に整理された35以上のTauriコマンドハンドラーモジュール。",
        "desktop/src-tauri/src/jobs/：バックグラウンドジョブプロセッサ、ワークフローオーケストレーション、キュー管理。",
        "desktop/src-tauri/capabilities/：セキュリティ権限用のJSON機能定義（default.json、desktop-default.json、plantocode-api.json）。",
        "desktop/src-tauri/migrations/：consolidated_schema.sqlのSQLiteスキーママイグレーション。"
      ]
    },
    "ui": {
      "heading": "React UIとサーフェスエリア",
      "description": "React UIはタスク説明エディター、計画ビューア、ターミナルパネルをレンダリングします：",
      "components": [
        "TaskDescriptionEditor：音声文字起こし統合とテキスト改善ポップオーバーを備えた複数行入力。",
        "VirtualizedCodeViewer：シンタックスハイライトとコピーアクションを備えたMonacoベースの計画表示。",
        "TerminalSurface：接続ステータス、エージェント注意インジケーター、音声入力を備えたPTY出力バッファ。",
        "SessionProvider：アクティブセッション、ファイル選択、モデル設定のグローバル状態管理。",
        "TextImprovementProvider：インラインリライト用の選択リスナーとポップオーバー配置。",
        "WorkflowTracker：複数ステージワークフローのリアルタイム進捗表示。"
      ]
    },
    "commands": {
      "heading": "Tauriコマンド",
      "description": "desktop/src-tauri/src/commands/のコマンドがRust機能をReact UIに公開します。主要モジュール：",
      "modules": [
        "job_commands.rs：create_job、get_job、cancel_job、get_jobs_for_session、clear_job_history。",
        "workflow_commands.rs：start_file_finder_workflow、get_workflow_status、retry_workflow、pause_workflow、resume_workflow。",
        "terminal_commands.rs: start_terminal_session, attach_terminal_output, write_terminal_input, resize_terminal_session, get_terminal_metadata, graceful_exit_terminal.",
        "session_commands.rs：create_session、get_session、update_session、sync_task_description_history、sync_file_selection_history。",
        "auth0_commands.rs：initiate_login、complete_login、refresh_token、logout、get_user_info。",
        "implementation_plan_commands.rs：generate_implementation_plan、merge_implementation_plans、estimate_tokens。",
        "config_commands.rs：get_runtime_config、get_model_config、get_system_prompts、refresh_config_cache。",
        "settings_commands.rs：get_setting、set_setting、get_project_system_prompt、set_project_system_prompt。"
      ]
    },
    "appState": {
      "heading": "AppState管理",
      "description": "RustコアがTauriの状態システムを通じてアプリケーション状態を管理します：",
      "structure": "lib.rsのAppState構造体が保持：config_load_error (Option<String>)、HTTPクライアント (reqwest::Client)、Mutex背後のRuntimeConfig（サーバーURL、オンボーディングステータス）、認証用のAuth0State。",
      "config": "RuntimeConfigにはserver_url、onboarding_completeフラグが含まれ、set_runtime_configコマンドで更新されます。ConfigCacheはプロジェクトごとのオーバーライド付きでランタイムAI設定を保存します。",
      "tokens": "TokenManagerはOSキーリング（keyringクレート経由）を使用してaccess_token、refresh_token、jwtを安全に保存し、有効期限前に自動更新します。"
    },
    "jobs": {
      "heading": "ジョブプロセッサとワークフロー",
      "description": "desktop/src-tauri/src/jobs/のジョブ処理アーキテクチャ：",
      "queue": "queue.rsがインメモリの保留ジョブとSQLite永続化でジョブキューを管理。ジョブは次のステータスを遷移：idle、created、queued、acknowledged_by_worker、preparing、preparing_input、running、generating_stream、processing_stream、completed、failed、canceled。",
      "processors": "processors/ディレクトリにタスク固有のプロセッサを含む：ImplementationPlanProcessor（ストリーミング計画）、TextImprovementProcessor（インラインリライト）、RootFolderSelectionProcessor、RegexFileFilterProcessor、FileRelevanceAssessmentProcessor、ExtendedPathFinderProcessor。",
      "orchestrator": "workflow_orchestrator/が複数ステージワークフローを調整：definition_loader.rsがJSONワークフロー定義をロード、stage_scheduler.rsがステージをディスパッチ、payload_builder.rsが入力を構築、event_emitter.rsが進捗イベントを発行。",
      "streaming": "processors/generic_llm_stream_processor.rsがストリーミングLLMレスポンスを処理し、job:stream-progressイベントを発行してbackground_jobs.responseにコンテンツを蓄積。"
    },
    "persistence": {
      "heading": "ローカル永続化",
      "description": "desktop/src-tauri/migrations/consolidated_schema.sqlのSQLiteストレージ：",
      "tables": [
        "sessions：id (UUID)、name、project_directory、project_hash、task_description、included_files、force_excluded_files、model_used、履歴バージョン。",
        "background_jobs：id (UUID)、session_id (FK)、task_type、status、prompt、response、tokens_sent/received、cache_read/write_tokens、actual_cost、metadata (JSON)、server_request_id。",
        "terminal_sessions：id、job_id (nullable FK)、session_id、status、process_pid、output_log、working_directory、environment_vars、last_output_at。",
        "task_description_history：session_id (FK)、description、device_id、sequence_number、マルチデバイス同期用のversion。",
        "file_selection_history：session_id (FK)、included_files、force_excluded_files、device_id、sequence_number。",
        "project_system_prompts：project_hash、task_type、プロジェクトごとのプロンプトオーバーライド用のsystem_prompt。",
        "key_value_store：key、value (JSON)、アプリ設定用のupdated_at。",
        "error_logs：timestamp、level、error_type、message、context、stack、クライアントサイドエラー追跡用のmetadata。"
      ],
      "repositories": "db_utils/のリポジトリが型付きアクセスを提供：background_job_repository/（base.rs、worker.rs、metadata.rs、cleanup.rsでモジュール化）、session_repository.rs、terminal_repository.rs、settings_repository.rs、error_log_repository.rs。"
    },
    "terminal": {
      "heading": "ターミナルセッション",
      "description": "PTYターミナル実装：",
      "commands": "terminal_commands.rsがセッションライフサイクルを管理：create_terminal_sessionがportable-ptyクレート経由でPTYを生成、send_terminal_inputがキーストロークを転送、resize_terminalがサイズを調整、check_cli_availabilityがツールの存在を確認（claude、cursor、codex、gemini）。",
      "persistence": "terminal_repository.rsがoutput_log（蓄積されたターミナル出力）、status（idle/running/completed/failed/agent_requires_attention）、exit_code、working_directoryを含むセッションを永続化。アプリ再起動後にセッションを復元可能。",
      "attention": "エージェント注意検出がlast_output_atタイムスタンプを監視。レベル1（30秒アイドル）：黄色インジケーター。レベル2（2分アイドル）：デスクトップ通知付きの赤インジケーター。"
    },
    "inputStability": {
      "heading": "タスク説明の安定性",
      "description": "タスク説明エディターにはカーソルジャンプを防ぐセーフガードが含まれます：",
      "items": [
        "ユーザー入力中はリモート更新がキューに入れられ、アイドルまたはブラー時にフラッシュされます。",
        "選択状態はReact再レンダリング後に追跡および復元されます。",
        "バックグラウンドライターはsessionActions.updateCurrentSessionFieldsを呼び出して更新を調整します。",
        "マルチデバイス同期はsequence_numberとversionフィールドを使用して競合を解決します。"
      ]
    },
    "plugins": {
      "heading": "Tauriプラグイン",
      "description": "PlanToCodeはTauri v2プラグインエコシステムを使用します：",
      "list": [
        "tauri-plugin-http (2.5.2)：APIコール用のCSP対応フェッチを備えたHTTPクライアント。",
        "tauri-plugin-dialog (2.4.2)：ネイティブファイル/フォルダーピッカーとメッセージダイアログ。",
        "tauri-plugin-shell (2.3.3)：外部CLIツール用のシェルコマンド実行。",
        "tauri-plugin-store (2.4.1)：アプリ設定用の永続的キーバリューストレージ。",
        "tauri-plugin-notification (2.3.0)：エージェント注意用のデスクトップ通知。",
        "tauri-plugin-updater (2.9.0)：署名検証付きのアプリ内更新。",
        "tauri-plugin-single-instance (2.3.4)：シングルインスタンス強制。",
        "tauri-plugin-process (2.3.1)：プロセス再起動機能。"
      ]
    }
  },
  "serverApi": {
    "meta": {
      "title": "サーバーAPIとLLMプロキシ - PlanToCode",
      "description": "デスクトップおよびモバイルクライアントが使用する認証、プロバイダールーティング、モデル設定、WebSocketエンドポイント。"
    },
    "category": "サーバー",
    "date": "2025-09-25",
    "readTime": "12分",
    "title": "サーバーAPI & LLMプロキシ",
    "description": "認証、プロバイダールーティング、モデル設定、課金、WebSocketエンドポイント。",
    "intro": "サーバーは認証、モデル設定、LLMプロキシ、課金を提供するRustで書かれたActix-Webサービスです。デスクトップおよびモバイルクライアントは、安全なプロバイダールーティングとストリーミングレスポンスのためにこれに依存しています。サーバーは2つのリージョンの専用インフラストラクチャで稼働しています：Hetzner（EU）はapi-eu.plantocode.com、InterServer（US）はapi-us.plantocode.com。",
    "visuals": {
      "flow": {
        "title": "サーバーリクエストフロー",
        "description": "クライアント、APIルート、LLMプロキシを示す図。",
        "imageSrc": "/images/docs/provider-routing/routing-map.svg",
        "imageAlt": "サーバーリクエストフロー図",
        "caption": "サーバーリクエストフローのプレースホルダー。"
      }
    },
    "routeOrganization": {
      "heading": "ルート構成",
      "description": "ルートはserver/src/routes.rsで3つの設定関数で整理されています：",
      "functions": [
        "configure_routes()：/apiスコープ下のJWT認証ルート。auth、billing、config、providers、models、llm proxy、audio、system-prompts、consent、devices、notificationsを含む。",
        "configure_public_auth_routes()：/authスコープ下のブラウザベース認証フロー。Auth0 initiate-login、callback、logged-outルートを含む。",
        "configure_webhook_routes()：/webhooksスコープ下の未認証webhookエンドポイント。現在Stripe webhooksを処理。"
      ]
    },
    "auth": {
      "heading": "認証エンドポイント",
      "description": "認証はAuth0とPKCEフローを使用します：",
      "routes": [
        "/auth/auth0/initiate-login (GET)：code_challengeでOAuthフローを開始し、Auth0にリダイレクト。",
        "/auth/auth0/callback (GET)：Auth0リダイレクトを処理し、コードをトークンと交換。",
        "/api/auth/userinfo (GET)：Auth0から認証済みユーザー情報を返す。",
        "/api/auth/logout (POST)：トークンを取り消しセッションをクリア。",
        "/api/auth/account (DELETE)：カスケードクリーンアップ付きのアカウント削除。",
        "/api/auth0/refresh-app-token (POST)：リフレッシュトークンを使用してアクセストークンを更新。"
      ],
      "implementation": "認証ハンドラーはserver/src/handlers/auth0_handlers.rsとserver/src/handlers/auth/にあります。JWT検証はJWKSローテーション付きでservices/auth/jwt.rsを使用。失効トークンはrevoked_token_repository.rsで追跡。"
    },
    "llmProxy": {
      "heading": "LLMプロキシとストリーミング",
      "description": "LLMプロキシはプロバイダー間でリクエストを正規化し、レスポンスをストリーミングします：",
      "routes": [
        "/api/llm/chat/completions (POST)：メインチャット完了エンドポイント。モデルIDに基づいてOpenAI、Anthropic、Google、X.AI、またはOpenRouterにルーティング。",
        "/api/llm/video/analyze (POST): Multipart video upload for video analysis (FPS hint). Requires google/* models with video capability.",
        "/api/llm/cancel (POST)：request_idで進行中のストリーミングリクエストをキャンセル。",
        "/api/llm/status/{request_id} (GET)：リクエストのステータスを返す（active、completed、cancelled）。",
        "/api/audio/transcriptions (POST)：Whisper互換の文字起こし。オーディオファイルとパラメータのマルチパートアップロード。"
      ],
      "routing": "server/src/handlers/proxy/router.rsのルーターがモデルIDプレフィックス（openai/、anthropic/、google/、xai/、openrouter/）に基づいてプロバイダーを選択。server/src/handlers/proxy/providers/のプロバイダー固有ハンドラーがリクエストを変換しレスポンスを正規化。",
      "streaming": "ストリーミングレスポンスはstreaming/sse_adapter.rs経由でServer-Sent Events（SSE）を使用。プロキシはプロバイダーからチャンクを転送し、共通フォーマットに変換し、リアルタイムでトークン使用量を追跡。"
    },
    "providers": {
      "heading": "プロバイダールーティング",
      "description": "server/src/handlers/proxy/providers/のプロバイダーハンドラー：",
      "handlers": [
        "openai.rs：OpenAIおよびOpenAI互換API（GPT-4、o1、o3）。",
        "anthropic.rs：プロンプトキャッシングサポート付きのAnthropic Claudeモデル。",
        "google.rs：ビデオ分析機能を含むGoogle Geminiモデル。",
        "xai.rs：X.AI Grokモデル。",
        "openrouter.rs：モデルルーティング用のOpenRouterアグリゲーション。"
      ],
      "transformers": "server/src/handlers/provider_transformers/のリクエスト/レスポンストランスフォーマーがAPI差異を正規化。各トランスフォーマーが処理：リクエストボディフォーマット、認証ヘッダー、ストリーミングチャンクフォーマット、使用量抽出、エラー正規化。"
    },
    "config": {
      "heading": "設定エンドポイント",
      "description": "設定とモデルメタデータエンドポイント：",
      "routes": [
        "/api/config/all-configurations (GET)：タスクタイプごとのモデル設定を含むすべてのアプリケーション設定を返す。",
        "/api/config/desktop-runtime-config (GET)：デスクトップ固有のランタイム設定。",
        "/api/config/billing (GET/PUT)：課金設定管理。",
        "/api/providers (GET)：機能付きの利用可能なLLMプロバイダーリスト。",
        "/api/providers/with-counts (GET)：モデル数付きのプロバイダー。",
        "/api/providers/by-capability/{capability} (GET)：機能でプロバイダーをフィルター。",
        "/api/models (GET)：価格付きのすべての利用可能なモデル。",
        "/api/models/{id} (GET)：単一モデルの詳細。",
        "/api/models/by-provider/{provider_code} (GET)：特定プロバイダーのモデル。",
        "/api/models/estimate-cost (POST)：リクエストのコスト見積もり。",
        "/api/models/estimate-tokens (POST)：トークン数見積もり。",
        "/api/system-prompts/defaults (GET)：タスクタイプ別のデフォルトシステムプロンプト。"
      ]
    },
    "billing": {
      "heading": "課金エンドポイント",
      "description": "Stripeと統合されたクレジットベースの課金システム：",
      "routes": [
        "/api/billing/dashboard (GET)：ユーザー課金ダッシュボードデータ。",
        "/api/billing/usage-summary (GET)：コスト内訳付きの詳細使用量。",
        "/api/billing/credits/balance (GET)：現在のクレジット残高。",
        "/api/billing/credits/details (GET)：付与と購入を含むクレジット詳細。",
        "/api/billing/credits/unified-history (GET)：取引履歴。",
        "/api/billing/checkout/credit-purchase (POST)：クレジット用のStripeチェックアウトを作成。",
        "/api/billing/checkout/setup (POST)：支払い方法用のStripeセットアップセッションを作成。",
        "/api/billing/auto-top-off (GET/PUT)：自動チャージ設定管理。"
      ],
      "implementation": "課金ハンドラーはserver/src/handlers/billing/にあります。クレジットサービスはservices/credit_service.rs。Stripe統合はservices/stripe_service.rs経由でwebhook_handlers.rsでwebhook処理。"
    },
    "devices": {
      "heading": "デバイス管理",
      "description": "デバイス登録とプッシュ通知：",
      "routes": [
        "/api/devices/register (POST)：device_idでデスクトップデバイスを登録。",
        "/api/devices/mobile/register (POST)：プラットフォーム情報付きでモバイルデバイスを登録。",
        "/api/devices/{device_id}/heartbeat (POST)：プレゼンス用のデバイスハートビート。",
        "/api/devices/{device_id}/push-token (POST)：プッシュ通知トークンを保存。",
        "/api/devices/{device_id}/connection-descriptor (GET)：デバイスリンク用のWebSocket接続情報。",
        "/api/notifications/job-completed (POST)：完了ジョブのプッシュ通知を送信。",
        "/api/notifications/job-progress (POST)：進捗通知を送信。"
      ]
    },
    "websockets": {
      "heading": "WebSocketエンドポイント",
      "description": "WebSocket経由のリアルタイム通信：",
      "endpoints": [
        "/ws/device-link：デスクトップ-モバイルデバイスリンク用のリレー。リンクされたデバイス間のターミナル出力ストリーミング、ジョブステータス更新、RPCコマンドを処理。",
        "/ws/events：リアルタイム更新用の汎用イベントストリーム。"
      ],
      "implementation": "デバイスリンクリレーはserver/src/handlers/device_link_ws.rsにあります。セッションはservices/relay_session_store.rsでハートビート監視と再接続サポート付きで管理。"
    },
    "serverStorage": {
      "heading": "サーバーサイド永続化",
      "description": "server/src/db/repositories/のリポジトリを持つPostgreSQLデータベース：",
      "repositories": [
        "user_repository.rs：Auth0 subにリンクされたユーザーアカウント。",
        "customer_billing_repository.rs：Stripeカスタマーとクレジット状態。",
        "credit_transaction_repository.rs：クレジット取引履歴。",
        "provider_repository.rs：LLMプロバイダー設定。",
        "system_prompts_repository.rs：システムプロンプトテンプレート。",
        "consent_repository.rs：法的同意追跡。",
        "audit_log_repository.rs：機密操作の監査証跡。",
        "revoked_token_repository.rs：JWT失効リスト。",
        "api_key_repository.rs：セキュアハッシング付きのAPIキー管理。"
      ]
    }
  },
  "backgroundJobs": {
    "meta": {
      "title": "バックグラウンドジョブ - PlanToCode",
      "description": "デスクトップジョブエンジンのジョブキューアーキテクチャ、プロセッサタイプ、状態機械、アーティファクトストレージ。"
    },
    "category": "アーキテクチャ",
    "date": "2025-09-25",
    "readTime": "14分",
    "title": "バックグラウンドジョブ",
    "description": "ジョブキュー、プロセッサ、状態機械、イベントストリーミング、アーティファクトストレージ。",
    "intro": "All LLM-backed work runs through the background job system in the desktop app. The job queue dispatches work to processors, streams progress events, and persists every prompt and response in SQLite for review and recovery. This architecture enables cancellation, retry, cost tracking, and real-time UI updates.",
    "visuals": {
      "stateMachine": {
        "title": "ジョブ状態機械",
        "description": "作成から完了または失敗までのジョブステータス遷移を示す図。",
        "imageSrc": "/images/docs/background-jobs/state-machine.svg",
        "imageAlt": "ジョブ状態機械図",
        "caption": "ジョブ状態機械図のプレースホルダー。"
      }
    },
    "jobRecord": {
      "heading": "ジョブレコード構造",
      "description": "各ジョブはSQLiteにこれらのフィールドを持つbackground_jobs行を作成します：",
      "fields": [
        "id (TEXT PRIMARY KEY)：ジョブのUUID。",
        "session_id (TEXT NOT NULL, FK)：CASCADE DELETEでsessions.idを参照。",
        "task_type (TEXT DEFAULT 'unknown')：プロセッサ識別子（例：implementation_plan、text_improvement、root_folder_selection）。",
        "status (TEXT)：有効な値のCHECK制約付きの現在の状態。",
        "prompt (TEXT NOT NULL): Full text sent to the LLM, stored for review and debugging.",
        "response (TEXT)：LLM出力またはエラーメッセージ。",
        "error_message (TEXT)：失敗時の詳細エラー情報。",
        "tokens_sent (INTEGER DEFAULT 0)：プロバイダーレスポンスからの入力トークン数。",
        "tokens_received (INTEGER DEFAULT 0)：出力トークン数。",
        "cache_read_tokens (INTEGER DEFAULT 0)：プロバイダーキャッシュから読み取られたトークン（Anthropic）。",
        "cache_write_tokens (INTEGER DEFAULT 0)：キャッシュに書き込まれたトークン。",
        "model_used (TEXT)：リクエストに使用されたモデル識別子。",
        "actual_cost (REAL)：トークン使用量とモデル価格に基づいて計算されたコスト。",
        "metadata (TEXT)：タスク固有データ、ワークフローID、ステージ名を含むJSON。",
        "system_prompt_template (TEXT)：システムプロンプトに使用されたテンプレート識別子。",
        "server_request_id (TEXT)：サーバーサイド使用量追跡へのリンク。",
        "created_at, updated_at, start_time, end_time (INTEGER)：タイムスタンプ。",
        "is_finalized (INTEGER DEFAULT 0)：最終コスト/使用量が記録されたかどうか。"
      ]
    },
    "statusValues": {
      "heading": "ステータス値と遷移",
      "description": "ジョブはデータベースで追跡される明確に定義されたステータスを遷移します：",
      "statuses": [
        "idle：処理開始前の初期状態。",
        "created：ジョブレコード作成済み、まだキューに入っていない。",
        "queued：ジョブキューに追加済み、プロセッサ待ち。",
        "acknowledged_by_worker：プロセッサがジョブをピックアップ。",
        "preparing：プロセッサが入力を収集中（ファイル、プロンプト）。",
        "preparing_input：LLMリクエストペイロードを構築中。",
        "running：LLMにリクエスト送信済み、レスポンス待ち。",
        "generating_stream：ストリーミングレスポンス進行中。",
        "processing_stream：ストリーミングチャンクを処理中。",
        "completed：ジョブが正常に完了。",
        "completed_by_tag：ストリーム終了タグ検出で完了。",
        "failed：error_messageが設定されジョブが失敗。",
        "canceled：ユーザーがキャンセルをリクエスト。"
      ],
      "transitions": "遷移はbackground_job_repository/worker.rsで強制されます。無効な遷移は拒否されます。ステータス変更はjob:status-changed Tauriイベントを発行します。"
    },
    "orchestrator": {
      "heading": "ワークフローオーケストレーター",
      "description": "複数ステージワークフローはdesktop/src-tauri/src/jobs/workflow_orchestrator/のWorkflowOrchestratorで管理されます：",
      "modules": [
        "mod.rs：メインオーケストレーター構造体とワークフロー実行エントリポイント。",
        "definition_loader.rs：ステージ順序とプロセッサタイプを指定するワークフローJSON定義（例：file_finder_workflow.json）をロード。",
        "stage_scheduler.rs：ステージを順次スケジュールし、上流の完了を待機。",
        "stage_job_manager.rs：各ステージのbackground_jobレコードを作成。",
        "payload_builder.rs：IntermediateDataからステージ入力を構築。",
        "data_extraction.rs：完了したステージジョブから出力を抽出。",
        "event_emitter.rs：workflow-statusとworkflow-stage Tauriイベントを発行。",
        "state_updater.rs：メモリとデータベースのワークフロー状態を更新。",
        "completion_handler.rs：ワークフロー完了とクリーンアップを処理。",
        "failure_handler.rs：ステージ失敗とリトライ決定を管理。",
        "retry_handler.rs：指数バックオフでリトライロジックを実装。"
      ],
      "dataFlow": "ワークフローはWorkflowIntermediateData（workflow_types.rsで定義）を使用してステージ間で出力を渡します：directoryTreeContent、selectedRoots、rawRegexPatterns、locallyFilteredFiles、aiFilteredFiles、verifiedPaths、unverifiedPaths。"
    },
    "processors": {
      "heading": "ジョブプロセッサ",
      "description": "各task_typeはdesktop/src-tauri/src/jobs/processors/のプロセッサにマッピングされます：",
      "implementations": [
        "implementation_plan_processor.rs：選択されたファイルコンテンツをロードし、ディレクトリツリー付きの構造化プロンプトを構築し、XML計画をUIにストリーミング。ストリーミングにgeneric_llm_stream_processorを使用。",
        "text_improvement_processor.rs：選択をXMLタグでラップし、非ストリーミングリクエストを送信し、改善されたテキストを返す。LlmTaskRunner経由で実行。",
        "root_folder_selection_processor.rs：ディレクトリツリーをLLMに送信し、選択されたディレクトリのJSON配列レスポンスをパース。",
        "RegexFileFilterProcessor（processors/mod.rs内）：タスクから正規表現パターンを生成し、gitファイルリストに適用し、バイナリをフィルター。",
        "FileRelevanceAssessmentProcessor：トークン制限でファイルコンテンツをチャンク化し、バッチで関連性をスコアリングし、関連パスを集約。",
        "ExtendedPathFinderProcessor（path_finder_types.rs）：インポート/依存関係を分析し、関連ファイルを提案し、パスの存在を検証。",
        "web_search_prompts_generator_processor.rs：ディープリサーチ用のresearch_task XMLブロックを生成。",
        "web_search_executor_processor.rs：サーバー検索API経由でリサーチプロンプトを並列実行。",
        "generic_llm_stream_processor.rs：チャンク蓄積、イベント発行、レスポンス最終化を処理する再利用可能なストリーミングプロセッサ。"
      ]
    },
    "events": {
      "heading": "イベントストリーミング",
      "description": "ジョブ進捗はReact UIが消費するTauriイベントを発行します：",
      "eventTypes": [
        "job:status-changed：ペイロード {jobId, status, error?}。すべてのステータス遷移で発行。",
        "job:stream-progress：ペイロード {jobId, content, tokensReceived}。各ストリーミングチャンクで発行。",
        "job:completed：ペイロード {jobId, response, tokensTotal, cost}。正常完了時に発行。",
        "workflow-status：ペイロード {workflowId, status, currentStage?}。ワークフローレベルのステータス更新。",
        "workflow-stage：ペイロード {workflowId, stageName, status}。個別ステージのステータス。"
      ],
      "reactConsumption": "Reactコンポーネントは@tauri-apps/api/eventのlisten()を使用してuseEffect経由でサブスクライブします。WorkflowTrackerがワークフローイベントを集約。JobStatusIndicatorがリアルタイムステータスを表示。"
    },
    "retry": {
      "heading": "リトライとキャンセル",
      "description": "ジョブのリトライとキャンセルメカニズム：",
      "retryLogic": "retry_handler.rsがリトライ回数と遅延を管理。リトライは設定可能な最大試行回数で指数バックオフを使用。リトライ状態はjob.metadata.retryCountに保存。",
      "cancellation": "キャンセルはgeneric_llm_stream_processor.rsでストリーミングチャンク間でチェックされるフラグを設定。サーバーサイドキャンセルはrequest_id付きで/api/llm/cancelを送信。",
      "cleanup": "workflow_cleanup.rsが不完全なワークフローのクリーンアップを処理。古いジョブ（アプリ再起動後のrunningステータス）は失敗としてマーク。"
    },
    "artifacts": {
      "heading": "アーティファクトストレージ",
      "description": "Job inputs and outputs are fully persisted for review:",
      "stored": [
        "prompt：システムプロンプトとユーザーコンテンツを含む完全なLLMプロンプト。",
        "response：完全なLLMレスポンステキストまたはストリーミング蓄積。",
        "metadata：タスク固有データ（改善用の元テキスト、ファイルリスト、ワークフローコンテキスト）を含むJSON。",
        "system_prompt_template：サーバーサイドプロンプトテンプレートバージョンにリンクする識別子。",
        "トークン数とコスト：課金と分析用にプロバイダーレスポンスからキャプチャ。"
      ],
      "access": "background_job_repositoryがクエリを提供：get_jobs_for_session、get_job_by_id、get_jobs_by_task_type、get_recent_jobs。ジョブ履歴はBackgroundJobsSidebarコンポーネントに表示。"
    },
    "costTracking": {
      "heading": "コスト追跡",
      "description": "ジョブごとのコスト追跡により予算管理が可能：",
      "calculation": "コストはserver/src/models/model_pricing.rsのモデル価格を使用して計算。式：(tokens_sent * input_price + tokens_received * output_price)にキャッシュ調整を適用。",
      "accumulation": "セッションレベルのコストはbackground_jobsから集約。UIはセッションヘッダーに累積コストを表示。",
      "serverSync": "server_request_idがデスクトップジョブをサーバーサイド使用量レコードにリンクし、課金照合を実現。"
    },
    "cta": {
      "heading": "データモデルを見る",
      "description": "Understand the SQLite schema that stores jobs, sessions, and terminal session logs.",
      "links": {
        "dataModel": "データモデル",
        "runtime": "ランタイムウォークスルー"
      }
    }
  },
  "buildYourOwn": {
    "meta": {
      "title": "独自パイプラインの構築 - PlanToCode",
      "description": "PlanToCodeに似たファイル検出と計画生成ワークフローを設計するための概念ガイド。"
    },
    "category": "リファレンス",
    "date": "2025-09-25",
    "readTime": "12分",
    "title": "独自パイプラインの構築",
    "description": "ファイル検出と計画生成ワークフローを設計するための概念ガイド。",
    "intro": "このガイドはPlanToCodeの主要なアーキテクチャパターンを概念的なブループリントに凝縮しています。類似システムを構築したい場合でも、特定の設計決定がなぜ行われたかを理解したい場合でも、このドキュメントは再利用または適応できる基本パターンをカバーしています。",
    "visuals": {
      "pipelineMap": {
        "title": "パイプラインアーキテクチャマップ",
        "description": "タスク入力から計画出力までの複数ステージパイプラインの概要。",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "パイプラインアーキテクチャ図",
        "caption": "パイプラインアーキテクチャ図のプレースホルダー。"
      }
    },
    "keyPatterns": {
      "heading": "主要なアーキテクチャパターン",
      "jobQueue": {
        "title": "ジョブキューパターン",
        "description": "すべてのLLMバックエンド操作はステータス追跡、キャンセルサポート、リトライロジックを持つバックグラウンドジョブとして実行されます。ジョブはSQLiteに永続化されるため、アプリ再起動後も状態が保持されます。",
        "benefits": [
          "UIの応答性をLLMレイテンシから分離",
          "ストリーミング中のキャンセルを可能に",
          "Provides job history of all operations",
          "指数バックオフでのリトライをサポート"
        ],
        "pitfalls": [
          "ジョブステータス管理が複雑さを追加",
          "再起動時の古いジョブの慎重な処理が必要",
          "大きなレスポンスでストリーム蓄積がメモリを消費する可能性"
        ]
      },
      "workflowOrchestrator": {
        "title": "ワークフローオーケストレーターパターン",
        "description": "複数ステージワークフローはオーケストレーターによって調整され、ステージを順次スケジュールし、中間データをステージ間で渡し、任意のステージでの失敗を処理します。",
        "components": [
          "定義ローダーがワークフローJSON仕様を読み込み",
          "ステージスケジューラーがステージを順番にディスパッチ",
          "ペイロードビルダーが前の出力から入力を構築",
          "イベントエミッターがUI更新用の進捗を発行"
        ]
      },
      "repositoryPattern": {
        "title": "リポジトリパターン",
        "description": "すべての永続化はSQLite操作を抽象化する型付きリポジトリを通じて行われます。これによりクリーンなAPI、テスト可能性、データベースアクセスの集中化が提供されます。",
        "benefits": [
          "型付きアクセスがSQLインジェクションを防止",
          "リポジトリをテスト用にモック可能",
          "集中化されたクエリ最適化",
          "一貫したエラー処理"
        ]
      }
    },
    "steps": {
      "step1": {
        "title": "1. タスクモデルを定義",
        "description": "システムでタスクを構成するものを定義することから始めます。PlanToCodeはタスク説明、ファイル選択、モデル設定を持つセッションを使用します。",
        "details": "履歴追跡用のバージョニング付きで専用テーブルにタスクメタデータを保存します。"
      },
      "step2": {
        "title": "2. ジョブキューを構築",
        "description": "ジョブをストレージに永続化し、ステータスイベントを発行し、キャンセルをサポートするジョブキューを作成します。ジョブはプロンプト、レスポンス、トークン、コストを追跡する必要があります。",
        "details": "並列LLMリクエストを制御するためにセマフォベースの同時実行制限を使用します。"
      },
      "step3": {
        "title": "3. プロセッサを実装",
        "description": "各ジョブタイプにはプロンプトを構築し、LLMを呼び出し、レスポンスをパースするプロセッサが必要です。長い出力にはストリーミングを使用します。",
        "details": "プロセッサはステートレスで、ジョブパラメータを通じてすべてのコンテキストを受け取る必要があります。"
      },
      "step4": {
        "title": "4. ワークフローオーケストレーターを作成",
        "description": "複数ステージワークフロー用に、ステージをスケジュールし、中間データを管理し、失敗を処理するオーケストレーターを構築します。",
        "details": "コード変更なしで簡単に修正できるよう、ワークフロー定義をJSONとして保存します。"
      },
      "step5": {
        "title": "5. ルーティングレイヤーを追加",
        "description": "ペイロードを正規化し、APIキーを管理し、使用量を追跡するサーバープロキシを通じてLLMリクエストをルーティングします。",
        "details": "プロバイダー認証情報はサーバーに保持し、デスクトップクライアントには埋め込まないでください。"
      }
    },
    "architectureDecisions": {
      "heading": "アーキテクチャ決定",
      "decisions": [
        {
          "question": "ローカルデータベースとサーバーサイドストレージのどちらを使用すべきか？",
          "recommendation": "ジョブ状態とアーティファクトにはローカルSQLiteを使用。これによりオフライン操作と高速クエリが可能に。課金とクロスデバイス状態のみサーバーに同期。"
        },
        {
          "question": "ストリーミングか非ストリーミングレスポンスか？",
          "recommendation": "計画生成と段階的に表示される出力にはストリーミングを使用。テキスト改善のような短い変換には非ストリーミングを使用。"
        },
        {
          "question": "LLMプロバイダー障害をどのように処理するか？",
          "recommendation": "指数バックオフで自動リトライを実装。レジリエンスのためにOpenRouterのようなフォールバックプロバイダーを検討。"
        },
        {
          "question": "ファイルコンテンツはどこでロードすべきか？",
          "recommendation": "プロンプト構築直前にプロセッサでファイルコンテンツをロード。これにより新鮮なコンテンツが確保され、ジョブレコードに大きなブロブを保存することを回避。"
        }
      ]
    },
    "customizeVsReuse": {
      "heading": "カスタマイズするものと再利用するもの",
      "customize": [
        "特定のユースケース用のプロンプトテンプレート",
        "プロジェクトタイプ用のファイル検出パターン",
        "出力フォーマット（XML、JSON、Markdown）",
        "タスクタイプごとのモデル選択"
      ],
      "reuse": [
        "ステータス追跡付きのジョブキューアーキテクチャ",
        "ワークフローオーケストレーターパターン",
        "永続化用のリポジトリパターン",
        "ストリーミングレスポンス処理",
        "プロバイダールーティングと正規化"
      ]
    },
    "commonPitfalls": {
      "heading": "避けるべき一般的な落とし穴",
      "items": [
        {
          "pitfall": "クライアントにAPIキーを埋め込む",
          "solution": "認証情報を安全に管理するサーバープロキシを通じてすべてのLLMリクエストをルーティング。"
        },
        {
          "pitfall": "ジョブ状態を永続化しない",
          "solution": "Store every job with full prompt and response for review and recovery."
        },
        {
          "pitfall": "LLMコールでUIをブロック",
          "solution": "レスポンシブなインターフェースのためにイベント駆動UI更新付きのバックグラウンドジョブを使用。"
        },
        {
          "pitfall": "トークン制限を無視",
          "solution": "送信前にトークンを見積もり、コンテキストウィンドウ内に収まるよう大きな入力をチャンク化。"
        },
        {
          "pitfall": "キャンセルサポートなし",
          "solution": "ストリーミングチャンク間でキャンセルフラグをチェックしサーバーに伝播。"
        }
      ]
    },
    "artifacts": {
      "heading": "永続化するアーティファクト",
      "items": [
        "Full prompt sent to the LLM (for debugging and review)",
        "ストリーミング蓄積を含む完全なレスポンス",
        "プロバイダーレスポンスからのトークン数",
        "モデル価格に基づいて計算されたコスト",
        "バージョニング用のシステムプロンプトテンプレート識別子",
        "複数ステージフロー用のワークフロー中間データ"
      ]
    },
    "implementationNotes": {
      "heading": "実装メモ",
      "items": [
        "同時読み書きアクセス用にWALモードでSQLiteを使用",
        "実行中のジョブを失敗としてマークするグレースフルシャットダウンを実装",
        "ジョブ処理前に外部依存関係のヘルスチェックを追加",
        "デバッグ用に完全なコンテキスト付きですべてのLLMエラーをログ記録",
        "冗長な読み取りを避けるため短いTTLでファイルコンテンツキャッシングを検討"
      ]
    }
  },
  "decisionsTradeoffs": {
    "meta": {
      "title": "技術的決定とトレードオフ - PlanToCode",
      "description": "Tauri、SQLite、専用LLMプロキシが選択された理由と、それらが生み出す運用上のトレードオフ。"
    },
    "category": "アーキテクチャ",
    "date": "2025-09-25",
    "readTime": "10分",
    "title": "技術的決定とトレードオフ",
    "description": "Tauri、SQLite、専用LLMプロキシが選択された理由とそのコスト。",
    "intro": "すべてのアーキテクチャにはトレードオフが伴います。このドキュメントはPlanToCodeの主要な技術選択、それらが提供する利点、導入されるコストや制限について説明します。",
    "visuals": {
      "tradeoffMatrix": {
        "title": "トレードオフマトリックス",
        "description": "技術選択とその利点・コストの視覚的比較。",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "技術トレードオフマトリックス",
        "caption": "技術スタック決定を示すシステムアーキテクチャ概要。"
      }
    },
    "sections": {
      "tauri": {
        "title": "デスクトップ向けTauri v2",
        "description": "TauriはRustバックエンドとWebベースのフロントエンドを提供し、ネイティブパフォーマンスと小さなバイナリサイズでクロスプラットフォームデスクトップアプリを実現します。",
        "benefits": [
          "小さなバイナリサイズ（Electronの200MB以上に対して約15MB）",
          "ファイル操作とジョブ処理のネイティブRustパフォーマンス",
          "きめ細かい権限を持つ機能ベースのセキュリティモデル",
          "macOS、Windows、Linux向けの単一コードベース",
          "システムAPIへのアクセス（PTY、キーチェーン、通知）"
        ],
        "tradeoffs": [
          "Electronより小さなエコシステム",
          "バックエンド開発のRust学習曲線",
          "プラットフォーム間のWebViewレンダリング差異",
          "IPCイシューのデバッグツールが未成熟"
        ],
        "implementation": "PlanToCodeはTauri 2.9.1を使用し、約35のコマンドモジュール、機能ベースの権限、シェル・ダイアログ・通知用のプラグインを備えています。"
      },
      "sqlite": {
        "title": "ローカル永続化向けSQLite",
        "description": "SQLiteはセッション、ジョブ、ターミナル出力、設定を含むすべてのローカル状態を保存します。これによりオフライン操作と高速クエリが可能になります。",
        "benefits": [
          "設定不要の組み込みデータベース",
          "ローカルデータへの高速クエリ",
          "オフライン操作を可能に",
          "単一ファイルのバックアップとリストア",
          "同時アクセス用のWALモード"
        ],
        "tradeoffs": [
          "組み込みのレプリケーションや同期なし",
          "大きなターミナルログがデータベースを肥大化",
          "手動のスキーママイグレーションが必要",
          "シングルライター制限（WALで軽減）"
        ],
        "implementation": "consolidated_schema.sqlに約10テーブルのスキーマ。リポジトリがrusqliteで型付きアクセスを提供。"
      },
      "llmProxy": {
        "title": "専用LLMプロキシサーバー",
        "description": "すべてのLLMリクエストはAPIキーを管理し、リクエストを正規化し、使用量を追跡し、課金を処理するサーバープロキシを経由します。",
        "benefits": [
          "APIキーがサーバーから離れない",
          "すべてのプロバイダーに単一リクエストフォーマット",
          "集中化された使用量追跡と課金",
          "クライアント更新なしでプロバイダーフェイルオーバー",
          "コンテンツフィルタリングとレート制限"
        ],
        "tradeoffs": [
          "サーバーインフラストラクチャが必要",
          "リクエストにネットワークレイテンシを追加",
          "サーバーが単一障害点に",
          "プロバイダー統合のメンテナンスが必要"
        ],
        "implementation": "server/src/handlers/proxy/のハンドラーを持つActix-Webサーバー。provider_transformers/のトランスフォーマーがリクエストを正規化。"
      },
      "websocket": {
        "title": "モバイル向けWebSocketリレー",
        "description": "デスクトップとモバイルクライアントはデバイスリンク、ターミナルストリーミング、ジョブ同期のためにWebSocketリレーを通じて接続します。",
        "benefits": [
          "リアルタイム双方向通信",
          "直接P2Pネットワーキング不要",
          "NATとファイアウォールを超えて動作",
          "複数のリンクされたデバイスをサポート"
        ],
        "tradeoffs": [
          "永続的なサーバー接続が必要",
          "リレーが大きなペイロードにレイテンシを追加",
          "接続管理の複雑さ",
          "再接続とハートビートロジックが必要"
        ],
        "implementation": "device_link_ws.rsがセッション追跡、ハートビート、ターミナル出力用のPTC1バイナリフレーミングを持つリレーを実装。"
      }
    },
    "operational": {
      "heading": "運用上の影響",
      "items": [
        "Tauri：各プラットフォーム用に別々のビルドが必要。CI/CDはクロスコンパイルまたはプラットフォーム固有のランナーを使用する必要あり。",
        "SQLite：データベースファイルがターミナル出力とともに増大。長時間実行インスタンスには定期的なクリーンアップが必要な場合あり。",
        "LLMプロキシ：サーバーダウンタイムがすべてのLLM操作をブロック。本番環境には監視と冗長性が必要。",
        "WebSocket：再接続ロジックが複雑さを追加。クライアントは接続切断を適切に処理する必要あり。"
      ]
    },
    "securityBoundaries": {
      "heading": "セキュリティ境界",
      "description": "アーキテクチャは露出を制限する明確なセキュリティ境界を作成します：",
      "items": [
        "APIキーはサーバーボールトに保存され、クライアントには送信されない",
        "JWTトークンはJWKSローテーション付きですべてのリクエストで検証",
        "機能ベースの権限がファイルシステムアクセスを制限",
        "LLMに送信されるコンテンツには明示的なユーザー承認が必要",
        "監査ログがユーザーコンテキスト付きですべてのLLMリクエストを追跡"
      ]
    },
    "whenToReconsider": {
      "heading": "再検討すべき時",
      "description": "要件が大幅に変更された場合、これらの決定は再検討が必要な場合があります：",
      "items": [
        "ブラウザのみのアクセスが必要な場合、TauriのWebベース代替を検討",
        "マルチデバイス同期が重要な場合、サーバーサイドジョブストレージを検討",
        "プロバイダーロックインが許容される場合、直接APIコールでレイテンシを削減可能",
        "モバイルが主要な場合、デバイスリンクの代わりにネイティブアプリを検討"
      ]
    }
  },
  "dataModel": {
    "meta": {
      "title": "データモデルとストレージ - PlanToCode",
      "description": "SQLiteエンティティ、リレーションシップ、アプリ再起動時の状態復元方法。"
    },
    "category": "アーキテクチャ",
    "date": "2025-09-25",
    "readTime": "10分",
    "title": "データモデル & ストレージ",
    "description": "SQLiteエンティティ、リレーションシップ、状態の復元方法。",
    "intro": "PlanToCodeはすべてのローカル状態にSQLiteを使用します。このドキュメントはスキーマ、エンティティリレーションシップ、アプリ再起動時の状態復元方法について説明します。",
    "sqlite": {
      "heading": "SQLite設定",
      "description": "データベースは同時読み書きアクセス用にWALモードを使用します。ファイルはTauriアプリデータディレクトリに保存されます（Linuxでは~/.local/share/plantocode、macOSでは~/Library/Application Support/plantocode）。",
      "migrations": "スキーママイグレーションはconsolidated_schema.sqlに統合されています。アプリは起動時にスキーマバージョンをチェックし、保留中のマイグレーションを実行します。"
    },
    "entities": {
      "heading": "コアエンティティ",
      "items": [
        "sessions：タスク説明、ファイル選択、モデル設定、検索設定、ビデオ/マージプロンプト、履歴インデックスを含むプロジェクトコンテキスト",
        "background_jobs：プロンプト、レスポンス、トークン、コスト、is_finalizedフラグ、error_messageを含むLLMバックエンド操作",
        "terminal_sessions：出力ログ、ステータス、プロセス情報を含むPTYセッション",
        "task_description_history：タスク説明のバージョン履歴",
        "file_selection_history：ファイル選択のバージョン履歴",
        "project_system_prompts：プロジェクトごとのプロンプトオーバーライド",
        "key_value_store：アプリ設定と構成",
        "error_logs：クライアントサイドエラー追跡",
        "migrations：タイムスタンプ付きで適用されたデータベースマイグレーションを追跡",
        "db_diagnostic_logs：データベース診断の問題とエラーを記録",
        "app_settings：説明付きのアプリケーション設定キーバリューペア"
      ]
    },
    "visuals": {
      "schema": {
        "title": "エンティティリレーションシップ図",
        "description": "SQLiteスキーマとリレーションシップの視覚的表現。",
        "imageSrc": "/images/docs/data-model/schema.svg",
        "imageAlt": "データベーススキーマ図",
        "caption": "データベーススキーマ図のプレースホルダー。"
      }
    },
    "relationships": {
      "heading": "エンティティリレーションシップ",
      "description": "エンティティはカスケード削除ルール付きの外部キーでリンクされています：",
      "links": [
        "sessions → background_jobs：1対多、カスケード削除",
        "background_jobs → terminal_sessions：job_id経由のオプション1対1リンク",
        "sessions → task_description_history：バージョン追跡用の1対多",
        "sessions → file_selection_history：バージョン追跡用の1対多"
      ]
    },
    "repositories": {
      "heading": "リポジトリレイヤー",
      "description": "すべてのデータベースアクセスはdesktop/src-tauri/src/db_utils/の型付きリポジトリを通じて行われます：",
      "examples": [
        "background_job_repository/：base.rs、worker.rs、metadata.rs、cleanup.rsでモジュール化",
        "session_repository.rs：履歴管理付きのセッションCRUD",
        "terminal_repository.rs：ターミナルセッション永続化と出力ログ",
        "settings_repository.rs：キーバリュー設定ストレージ"
      ]
    },
    "rehydration": {
      "heading": "状態の復元",
      "description": "アプリ起動時、状態はSQLiteから復元されます：",
      "sessions": "アクティブセッションはタスク説明、ファイル選択、モデル設定とともにロードされます。最近のセッションはセッションピッカーで利用可能です。"
    },
    "retention": {
      "heading": "データ保持",
      "description": "古いデータは設定可能な保持期間に基づいてクリーンアップされます：",
      "exports": "セッションとジョブはクリーンアップ前にバックアップ用にエクスポートできます。"
    },
    "cta": {
      "heading": "ジョブ処理を探索",
      "description": "バックグラウンドジョブがこのデータモデルをどのように使用するかを見てみましょう。",
      "links": {
        "jobs": "バックグラウンドジョブ",
        "terminals": "ターミナルセッション"
      }
    }
  },
  "serverSetup": {
    "meta": {
      "title": "専用サーバーセットアップ - PlanToCode",
      "description": "Ansibleベースのインフラストラクチャセットアップ：基本ハードニング、PostgreSQL、Redis、アプリケーションデプロイメント。"
    },
    "category": "デプロイメント",
    "date": "2025-09-25",
    "readTime": "12分",
    "title": "専用サーバーセットアップ",
    "description": "Ansibleベースのインフラストラクチャ：基本ハードニング、アプリデプロイメント、Vault管理シークレット。",
    "intro": "PlanToCodeはAnsible Playbookで管理される専用サーバーで稼働します。このドキュメントはインフラストラクチャセットアップ、セキュリティハードニング、デプロイメントプロセスをカバーします。",
    "layers": {
      "heading": "インフラストラクチャレイヤー",
      "description": "インフラストラクチャはレイヤーに整理され、それぞれ専用のPlaybookで管理されます：",
      "items": [
        "ベースレイヤー：OSハードニング、SSH設定、ファイアウォールルール",
        "データベースレイヤー：レプリケーションとバックアップ付きのPostgreSQL 17",
        "キャッシュレイヤー：セッション状態とジョブキュー用のRedis 7+",
        "アプリケーションレイヤー：systemdサービス付きのRustサーバーバイナリ",
        "プロキシレイヤー：SSL終端付きのNginxリバースプロキシ"
      ]
    },
    "servers": {
      "heading": "サーバーリージョン",
      "description": "PlanToCodeは地理的冗長性のために2つのリージョンで稼働しています：",
      "items": [
        "EUリージョン：Hetzner専用サーバー（api-eu.plantocode.com）",
        "USリージョン：InterServer専用サーバー（api-us.plantocode.com）"
      ]
    },
    "requirements": {
      "heading": "サーバー要件",
      "items": [
        "Debian 12またはUbuntu 22.04 LTS",
        "4+CPUコア、16GB以上RAM、200GB以上SSD",
        "ポート22、80、443へのファイアウォールアクセス付きパブリックIPv4",
        "Ansibleデプロイメント用のSSHキーアクセス"
      ]
    },
    "hardening": {
      "heading": "基本ハードニング",
      "description": "site-base.ymlがセキュリティハードニングを適用します：",
      "items": [
        "rootSSHログインを無効化、キー認証を必須に",
        "最小限のオープンポートでUFWファイアウォールを設定",
        "ブルートフォース保護用にfail2banをインストール",
        "自動セキュリティ更新を有効化",
        "監査ログを設定"
      ]
    },
    "postgresql": {
      "heading": "PostgreSQLセットアップ",
      "description": "PostgreSQL 17は本番環境用に設定されています：",
      "items": [
        "PgBouncerによる接続プーリング",
        "pg_dumpによる自動日次バックアップ",
        "ポイントインタイムリカバリ用のWALアーカイブ",
        "すべての接続にSSL必須",
        "マルチテナントデータ用の行レベルセキュリティ"
      ]
    },
    "redis": {
      "heading": "Redisセットアップ",
      "description": "Redis 7+がキャッシングとセッション状態を処理します：",
      "items": [
        "パスワード認証必須",
        "耐久性用のAOF永続化",
        "エビクションポリシー付きメモリ制限",
        "接続用のTLS暗号化"
      ]
    },
    "zeroDowntime": {
      "heading": "ゼロダウンタイムデプロイメント",
      "description": "デプロイメントはローリングアップデート戦略を使用します：",
      "items": [
        "新しいバイナリを実行中バージョンと並行でアップロード",
        "ヘルスチェックで新バージョンの準備完了を確認",
        "systemdがグレースフルシャットダウンで再起動",
        "ロードバランサーが切り替え中に接続をドレイン",
        "前のバイナリシンボリックリンク経由でロールバック可能"
      ]
    },
    "quickStart": {
      "heading": "クイックスタート",
      "steps": [
        "インフラストラクチャリポジトリをクローン",
        "inventory.exampleをinventoryにコピーしてホストを設定",
        ".vault_passにVaultパスワードを設定",
        "実行：ansible-playbook -i inventory site-base.yml",
        "実行：ansible-playbook -i inventory site-app.yml"
      ]
    },
    "vault": {
      "heading": "シークレット管理",
      "description": "機密設定はAnsible Vaultを使用します：",
      "items": [
        "データベース認証情報",
        "LLMプロバイダー用APIキー",
        "SSL証明書と秘密鍵",
        "Auth0クライアントシークレット",
        "Stripe Webhookシークレット"
      ]
    },
    "operations": {
      "heading": "一般的な操作",
      "items": [
        "ansible-playbook -i inventory site-app.yml --tags deploy",
        "ansible-playbook -i inventory site-base.yml --tags backup",
        "ansible-playbook -i inventory site-app.yml --tags rollback",
        "ansible-playbook -i inventory site-base.yml --tags logs"
      ]
    },
    "ssl": {
      "heading": "SSL/TLS設定",
      "description": "Let's Encryptが無料のSSL証明書を提供します：",
      "items": [
        "Nginxプラグイン付きでCertbotを設定",
        "cronジョブによる自動更新",
        "HSTSヘッダーを有効化",
        "TLS 1.2以上のみ、モダン暗号スイート"
      ]
    },
    "security": {
      "heading": "セキュリティチェックリスト",
      "items": [
        "すべてのデフォルトパスワードを変更",
        "SSHキーローテーションをスケジュール",
        "ファイアウォールルールを監査",
        "セキュリティ更新を自動化",
        "バックアップリストアをテスト"
      ]
    },
    "recovery": {
      "heading": "災害復旧",
      "description": "一般的な障害シナリオの復旧手順：",
      "items": [
        "データベース破損：最新のpg_dumpバックアップから復元",
        "サーバー障害：新しいサーバーをプロビジョニングしてPlaybookを実行",
        "SSL有効期限切れ：手動でcertbot renew --force-renewal",
        "セキュリティ侵害：すべての認証情報をローテーション、ログを監査"
      ]
    }
  },
  "tauriV2": {
    "meta": {
      "title": "Tauri v2開発ガイド - PlanToCode",
      "description": "Tauri v2のプロジェクトレイアウト、コマンド、機能、開発ワークフロー。"
    },
    "category": "デプロイメント",
    "date": "2025-09-25",
    "readTime": "10分",
    "title": "Tauri v2開発ガイド",
    "description": "Tauri v2のプロジェクトレイアウト、コマンド、機能ベース権限。",
    "intro": "PlanToCodeはデスクトップアプリケーションにTauri v2を使用しています。このガイドはプロジェクト構造、コマンドシステム、機能ベース権限、開発ワークフローをカバーします。",
    "projectLayout": {
      "heading": "プロジェクトレイアウト",
      "description": "デスクトップアプリケーションは標準的なTauri v2の慣例に従います：",
      "items": [
        "desktop/src/：コンポーネント、フック、プロバイダーを含むReactフロントエンド",
        "desktop/src-tauri/：コマンド、ジョブ、サービスを含むRustバックエンド",
        "desktop/src-tauri/src/lib.rs：アプリケーションエントリポイント",
        "desktop/src-tauri/src/commands/：Tauriコマンドハンドラー（約35モジュール）",
        "desktop/src-tauri/capabilities/：権限定義",
        "desktop/src-tauri/tauri.conf.json：Tauri設定"
      ]
    },
    "configuration": {
      "heading": "Tauri設定",
      "description": "tauri.conf.jsonがアプリケーションを設定します：",
      "items": [
        "productName、version、identifierでアプリメタデータ",
        "build.beforeDevCommandとbeforeBuildCommandでフロントエンド",
        "インストーラー（DMG、NSIS、AppImage）用のbundle設定",
        "Content Security Policy用のsecurity.csp",
        "公式プラグイン用のplugins設定"
      ]
    },
    "capabilities": {
      "heading": "機能ベース権限",
      "description": "Tauri v2は機能を使用してアプリがアクセスできるものを制御します：",
      "items": [
        "default.json：すべてのウィンドウの基本権限",
        "desktop-default.json：デスクトップ固有の権限",
        "plantocode-api.json：PlanToCodeコマンド用のカスタム権限",
        "権限が付与するアクセス：filesystem、shell、http、dialog、notification"
      ]
    },
    "plugins": {
      "heading": "Tauriプラグイン",
      "description": "PlanToCodeは複数の公式Tauriプラグインを使用します：",
      "items": [
        "tauri-plugin-http：APIコール用HTTPクライアント",
        "tauri-plugin-dialog：ネイティブファイル/フォルダーピッカー",
        "tauri-plugin-shell：シェルコマンド実行",
        "tauri-plugin-store：永続的キーバリューストレージ",
        "tauri-plugin-notification：デスクトップ通知",
        "tauri-plugin-updater：アプリ内更新",
        "tauri-plugin-single-instance：シングルインスタンス強制"
      ]
    },
    "appState": {
      "heading": "アプリケーション状態",
      "description": "Tauriの状態システムを通じて管理されるRust状態：",
      "items": [
        "AppState構造体が共有状態を保持",
        "サーバーURLとフィーチャーフラグ用のRuntimeConfig",
        "安全な認証情報ストレージ用のTokenManager",
        "AIモデル設定用のConfigCache"
      ]
    },
    "commands": {
      "heading": "コマンドの作成",
      "description": "TauriコマンドがRust関数をフロントエンドに公開します：",
      "items": [
        "async関数に#[tauri::command]属性を使用",
        "エラー処理にResult<T, String>を返す",
        "State<AppState>パラメータ経由で状態にアクセス",
        "lib.rsのinvoke_handlerに登録"
      ]
    },
    "singleInstance": {
      "heading": "シングルインスタンス",
      "description": "アプリはデータ競合を防ぐためにシングルインスタンスを強制します：",
      "items": [
        "tauri-plugin-single-instanceが検出を処理",
        "2回目の起動で既存ウィンドウにフォーカス",
        "ディープリンクが実行中インスタンスに転送"
      ]
    },
    "devWorkflow": {
      "heading": "開発ワークフロー",
      "description": "開発用の一般的なコマンド：",
      "items": [
        "pnpm tauri dev：ホットリロード付きで開発開始",
        "pnpm tauri build：本番リリースをビルド",
        "cargo test：Rustテストを実行",
        "cargo clippy：Rustコードをリント"
      ]
    },
    "mobile": {
      "heading": "モバイルの考慮事項",
      "description": "Tauri v2はモバイルをサポートしますが、PlanToCodeはネイティブSwiftを使用：",
      "items": [
        "iOSアプリはネイティブエクスペリエンス用にSwiftUIで構築",
        "デスクトップとモバイル間で共有APIコントラクト",
        "WebSocketリレー経由のデバイスリンク"
      ]
    },
    "distribution": {
      "heading": "配布",
      "description": "各プラットフォーム用のビルドアーティファクト：",
      "items": [
        "macOS：ユニバーサルバイナリ付き.dmg（Intel + Apple Silicon）",
        "Windows：NSISインストーラーとMSIXパッケージ",
        "Linux：広い互換性のためのAppImage"
      ]
    }
  },
  "distributionMacos": {
    "meta": {
      "title": "macOS配布 - PlanToCode",
      "description": "macOS向けのコード署名、公証、DMGパッケージング、アップデーター設定。"
    },
    "category": "デプロイメント",
    "date": "2025-09-25",
    "readTime": "10分",
    "title": "macOS配布",
    "description": "署名、公証、DMGパッケージング、アップデーターアーティファクト。",
    "intro": "macOSでの配布にはコード署名、公証、適切なパッケージングが必要です。このドキュメントはPlanToCodeの完全なプロセスをカバーします。",
    "signing": {
      "heading": "コード署名",
      "description": "すべてのバイナリはApple Developer IDで署名する必要があります：",
      "items": [
        "アプリ署名用のDeveloper ID Application証明書",
        "PKG署名用のDeveloper ID Installer証明書",
        "証明書はCIシークレットに保存、キーチェーンにインポート",
        "公証互換性のためにHardened runtimeを有効化"
      ]
    },
    "entitlements": {
      "heading": "エンタイトルメント",
      "description": "PlanToCode機能に必要なエンタイトルメント：",
      "items": [
        "com.apple.security.cs.allow-jit",
        "com.apple.security.cs.allow-unsigned-executable-memory",
        "com.apple.security.device.audio-input",
        "com.apple.security.network.client",
        "com.apple.security.files.user-selected.read-write"
      ]
    },
    "build": {
      "heading": "ビルドプロセス",
      "description": "署名済みリリースをビルドする手順：",
      "steps": [
        "pnpm tauri build --target universal-apple-darwinを実行",
        "Tauriが環境変数のAPPLE_SIGNING_IDENTITYで署名",
        "lipoでIntel + ARM用のユニバーサルバイナリを作成",
        "カスタム背景とレイアウトでDMGをパッケージ"
      ]
    },
    "universalBinaries": {
      "heading": "ユニバーサルバイナリ",
      "description": "PlanToCodeはユニバーサルバイナリとして配布されます：",
      "items": [
        "単一の.appがIntelとApple Siliconの両方をサポート",
        "--target universal-apple-darwinでビルド",
        "バイナリはやや大きいが配布がシンプル",
        "両アーキテクチャでネイティブパフォーマンス"
      ]
    },
    "notarization": {
      "heading": "公証",
      "description": "Gatekeeper承認にはApple公証が必要です：",
      "items": [
        "DMGをApple notaryサービスに提出",
        "App Store Connect認証情報でnotarytoolを使用",
        "ステープリングで公証チケットをDMGに添付",
        "プロセスは通常1-5分"
      ]
    },
    "updater": {
      "heading": "アプリ内更新",
      "description": "tauri-plugin-updaterが自動更新を処理します：",
      "items": [
        "起動時に更新エンドポイントをチェック",
        "バックグラウンドで新バージョンをダウンロード",
        "適用のためにユーザーに再起動を促す",
        "インストール前に署名検証"
      ]
    },
    "latestJson": {
      "heading": "更新マニフェスト",
      "description": "latest.jsonが利用可能な更新を記述します：",
      "items": [
        "version：セマンティックバージョン文字列",
        "platforms.darwin-universal：URLと署名",
        "notes：markdownでのリリースノート",
        "pub_date：ISO 8601公開タイムスタンプ"
      ]
    },
    "pitfalls": {
      "heading": "一般的な落とし穴",
      "description": "頻繁に発生する問題：",
      "items": [
        "CI中にキーチェーンがロック：署名前にアンロック",
        "公証タイムアウト：指数バックオフでリトライ",
        "無効な署名：エンタイトルメントが機能と一致するか確認",
        "Gatekeeper拒否：公証が正しくステープルされているか確認"
      ]
    },
    "verification": {
      "heading": "検証コマンド",
      "description": "署名と公証を検証するコマンド：",
      "items": [
        "codesign -dv --verbose=4 PlanToCode.app",
        "spctl --assess --verbose PlanToCode.app",
        "stapler validate PlanToCode.dmg",
        "xcrun notarytool log <submission-id>"
      ]
    }
  },
  "distributionWindows": {
    "meta": {
      "title": "Windows配布 - PlanToCode",
      "description": "Windows向けのNSISインストーラー、MSIXパッケージング、Microsoft Storeへの提出、コード署名。"
    },
    "category": "デプロイメント",
    "date": "2025-09-25",
    "readTime": "10分",
    "title": "Windows配布 & ストア",
    "description": "NSISビルド、MSIXパッケージング、Microsoft Store提出。",
    "intro": "PlanToCodeはWindowsで直接ダウンロード（NSISインストーラー）とMicrosoft Store（MSIXパッケージ）の両方を通じて配布されます。このドキュメントは両方の配布方法をカバーします。",
    "prereqs": {
      "heading": "前提条件",
      "description": "必要なツールと証明書：",
      "items": [
        "コード署名証明書（EVまたは標準）",
        "signtool用のWindows SDK",
        "インストーラービルド用のNSIS",
        "Store提出用のMSIX Packaging Tool"
      ]
    },
    "nsisBuild": {
      "heading": "NSISインストーラー",
      "description": "TauriはデフォルトでNSISインストーラーをビルドします：",
      "items": [
        "PlanToCodeブランディング付きのカスタムインストーラーUI",
        "ユーザーごとのインストール（管理者権限不要）",
        "スタートメニューとデスクトップショートカット",
        "クリーン削除付きのアンインストーラー"
      ]
    },
    "codeSigning": {
      "heading": "コード署名",
      "description": "Authenticodeを使用したWindowsコード署名：",
      "items": [
        "Windows SDKのsigntoolで署名",
        "信頼できるTSAサーバーからのタイムスタンプ",
        "EV証明書がSmartScreenレピュテーションを提供",
        "CIが証明書とパスワードのシークレットを使用"
      ]
    },
    "msixPackaging": {
      "heading": "Microsoft Store向けMSIX",
      "description": "MSIXがStore互換パッケージングを提供します：",
      "items": [
        "AppxManifest.xmlが機能を定義",
        "仮想ファイルシステム分離",
        "Store経由の自動更新",
        "サンドボックス実行環境"
      ]
    },
    "msixConfig": {
      "heading": "MSIX設定",
      "description": "主要なAppxManifest設定：",
      "items": [
        "Identity：Name、Publisher、Version",
        "Capabilities：internetClient、microphone",
        "Visual elements：タイル、スプラッシュスクリーン",
        "ファイル関連付けとプロトコルハンドラー"
      ]
    },
    "msixSteps": {
      "heading": "MSIXビルド手順",
      "description": "MSIXパッケージを作成するプロセス：",
      "steps": [
        "pnpm tauri buildでリリースをビルド",
        "正しいidentityでAppxManifest.xmlを作成",
        "MakeAppx.exeでパッケージ",
        "SignToolで署名",
        "Windows App Cert Kitで検証"
      ]
    },
    "store": {
      "heading": "Microsoft Store提出",
      "description": "Store提出プロセス：",
      "items": [
        "Partner Centerでアプリを作成",
        "MSIXパッケージをアップロード",
        "価格設定を構成（IAPクレジット付き無料）",
        "認定のために提出",
        "レビューは1-3営業日"
      ]
    },
    "updaterWindows": {
      "heading": "Windows更新",
      "description": "各配布の更新メカニズム：",
      "items": [
        "NSIS：GitHubリリース付きのtauri-plugin-updater",
        "MSIX/Store：Microsoft Store経由で自動",
        "両方とも起動時に更新をチェック"
      ]
    },
    "webview2": {
      "heading": "WebView2ランタイム",
      "description": "TauriはWindowsでWebView2を使用します：",
      "items": [
        "インストーラーにバンドルされたWebView2ブートストラッパー",
        "Evergreenバージョンが自動更新",
        "分離用の固定バージョンも利用可能",
        "Windows 10 1803以上が必要"
      ]
    },
    "troubleshooting": {
      "heading": "トラブルシューティング",
      "description": "一般的なWindows配布の問題：",
      "items": [
        "SmartScreen警告：EV証明書を使用するかレピュテーションを構築",
        "WebView2の欠落：ブートストラッパーが実行されることを確認",
        "Store拒否：認定レポートの詳細を確認",
        "更新失敗：署名とマニフェストバージョンを確認"
      ]
    }
  },
  "promptTypes": {
    "meta": {
      "title": "プロンプトタイプとテンプレート - PlanToCode",
      "description": "プロンプト駆動ジョブタイプのカタログとテンプレート組み立てプロセス。"
    },
    "category": "リファレンス",
    "date": "2025-09-25",
    "readTime": "8分",
    "title": "プロンプトタイプ & テンプレート",
    "description": "プロンプト駆動ジョブタイプのカタログとテンプレート組み立て。",
    "intro": "PlanToCodeのすべてのLLMバックエンドジョブは、テンプレートから構築された構造化プロンプトを使用します。このドキュメントはジョブタイプをカタログ化し、プロンプトがどのように組み立てられるかを説明します。",
    "catalog": {
      "heading": "ジョブタイプカタログ",
      "items": [
        {
          "job": "implementation_plan",
          "title": "実装計画",
          "description": "XML構造でファイルごとの実装計画を生成。段階的表示のためにストリーミングを使用。"
        },
        {
          "job": "implementation_plan_merge",
          "title": "計画マージ",
          "description": "ユーザー指示で複数の計画を結合。ソース計画はXMLタグでラップ。"
        },
        {
          "job": "text_improvement",
          "title": "テキスト改善",
          "description": "フォーマットを保持しながら選択テキストを洗練。迅速な結果のために非ストリーミング。"
        },
        {
          "job": "root_folder_selection",
          "title": "ルートフォルダー選択",
          "description": "関連するプロジェクトルートを選択するためにディレクトリツリーを分析。JSON配列を返す。"
        },
        {
          "job": "regex_file_filter",
          "title": "正規表現ファイルフィルター",
          "description": "タスク説明に基づいてファイルフィルタリング用の正規表現パターンを生成。"
        },
        {
          "job": "file_relevance_assessment",
          "title": "ファイル関連性評価",
          "description": "タスクへのファイルコンテンツの関連性をスコアリング。バッチで処理。"
        },
        {
          "job": "extended_path_finder",
          "title": "拡張パスファインダー",
          "description": "インポートと依存関係を通じて関連ファイルを検出。"
        },
        {
          "job": "web_search_prompts",
          "title": "Web検索プロンプト",
          "description": "ディープリサーチワークフロー用のリサーチクエリを生成。"
        },
        {
          "job": "video_analysis",
          "title": "ビデオ分析",
          "description": "UI状態とアクションシーケンスのために画面録画を分析。"
        }
      ]
    },
    "templateStructure": {
      "heading": "テンプレート構造",
      "description": "プロンプトはシステムテンプレートとユーザーコンテンツから組み立てられます：",
      "sampleLabel": "テンプレート構造の例：",
      "sample": "<system_prompt>\n  You are an AI assistant that generates implementation plans.\n  [template content from server]\n</system_prompt>\n\n<task>\n  [user's task description]\n</task>\n\n<files>\n  [selected file paths and content]\n</files>\n\n<directory_tree>\n  [project structure]\n</directory_tree>"
    },
    "visuals": {
      "template": {
        "title": "プロンプト組み立てフロー",
        "description": "テンプレートがユーザーコンテンツと結合して完全なプロンプトを形成する方法。",
        "imageSrc": "/images/docs/implementation-plans/structure.svg",
        "imageAlt": "プロンプトテンプレート組み立て図",
        "caption": "プロンプト組み立て図のプレースホルダー。"
      }
    },
    "assembly": {
      "heading": "組み立てプロセス",
      "steps": [
        "プロセッサがタスクモデル設定からテンプレートIDを取得",
        "システムプロンプトテンプレートがサーバーキャッシュからロード",
        "ユーザーコンテンツがセマンティックXMLタグでラップ",
        "ジョブタイプに基づいてコンテキスト（ファイル、ツリー）を追加",
        "送信前に完全なプロンプトをジョブレコードに保存"
      ]
    },
    "serverConfig": {
      "heading": "サーバーサイド設定",
      "description": "テンプレートとモデル設定はサーバーサイドで構成されます：",
      "fields": "task_model_configが定義：default_model、allowed_models、system_prompt_template_id、max_tokens、temperature"
    },
    "tokenGuards": {
      "heading": "トークンガードレール",
      "description": "各タスクタイプにはコンテキストオーバーフローを防ぐトークン制限があります：",
      "items": [
        "max_tokens_input：最大プロンプトサイズ",
        "max_tokens_output：最大レスポンスサイズ",
        "送信前の検証がAPIコールの無駄を防止",
        "UIがトークン数を表示し制限に近づくと警告"
      ]
    },
    "versioning": {
      "heading": "テンプレートバージョニング",
      "description": "System prompt templates are versioned for reproducibility. Each job records the template ID used, enabling traceability and comparison of results across template versions."
    },
    "designNotes": {
      "heading": "設計メモ",
      "items": [
        "XMLタグがLLMパーシング用の明確な境界を提供",
        "セマンティックな命名（task、files、context）がモデルの理解を支援",
        "テンプレートはユーザー入力をサニタイズしてインストラクションインジェクションを回避",
        "ストリーミングジョブは完了検出に終了タグを使用"
      ]
    },
    "cta": {
      "heading": "ジョブ処理の実際を見る",
      "description": "これらのプロンプトがジョブシステムをどのように流れるかを学びましょう。",
      "links": {
        "jobs": "バックグラウンドジョブ",
        "merge": "マージ指示"
      }
    }
  },
  "mergeInstructionsDoc": {
    "meta": {
      "title": "Merge instructions - PlanToCode",
      "description": "How multiple plan drafts are merged using XML-tagged source plans and user guidance."
    },
    "category": "Planning",
    "date": "2025-09-25",
    "readTime": "8 min",
    "title": "Merge Instructions",
    "description": "How multiple plan drafts are merged using XML-tagged source plans and user guidance.",
    "intro": "When you have multiple implementation plans that need to be combined, the merge workflow lets you select plans, provide guidance, and generate a unified plan that incorporates the best elements from each source.",
    "processor": {
      "heading": "ImplementationPlanMergeProcessor",
      "description": "The ImplementationPlanMergeProcessor fetches source plan responses, wraps them in XML-tagged sections, and streams the merged result through the LlmTaskRunner.",
      "payload": "Accepts source_job_ids array, optional merge_instructions string, and inherits model configuration from the session.",
      "storage": "Merged plan stored as JobResultData::Text with metadata including source_job_ids, merge_instructions, source_count, merged_at timestamp, and session context."
    },
    "inputs": {
      "heading": "Merge Inputs",
      "items": [
        "Source plans: 2-5 implementation plans selected from the plan list",
        "Merge instructions: User guidance on how to combine (prioritize, resolve conflicts)",
        "Model selection: LLM model for merge generation",
        "Task context: Original task description for reference"
      ]
    },
    "xmlFormat": {
      "heading": "XML-Tagged Source Plans",
      "description": "Source plans are wrapped in XML tags with sequential identifiers:",
      "example": "<task_description>\n  [original task from session]\n</task_description>\n\n<source_plans>\n  <implementation_plan_1>\n    [full plan content from first source]\n  </implementation_plan_1>\n  <implementation_plan_2>\n    [full plan content from second source]\n  </implementation_plan_2>\n</source_plans>\n\n<user_instructions>\n  Prioritize API structure from plan 1.\n  Use database schema from plan 2.\n  Resolve conflicts by preferring newer patterns.\n</user_instructions>"
    },
    "prompt": {
      "heading": "Merge Prompt Structure",
      "description": "The merge prompt includes all context needed for intelligent combination:",
      "sections": [
        "System prompt with merge guidelines",
        "Source plans in XML tags",
        "User's merge instructions",
        "Task description for context",
        "Output format requirements"
      ]
    },
    "visuals": {
      "mergeWalkthrough": {
        "title": "Merge workflow walkthrough",
        "description": "Video showing the complete merge process from selection to output.",
        "videoSrc": "/videos/docs/merge-instructions/walkthrough.mp4",
        "posterSrc": "/images/docs/merge-instructions/flow.svg",
        "caption": "Placeholder for merge walkthrough video."
      },
      "mergeFlow": {
        "title": "Merge instructions flow",
        "description": "Diagram showing multi-model merge workflow with XML-tagged source plans.",
        "imageSrc": "/images/docs/merge-instructions/flow.svg",
        "caption": "Merge flow showing source selection, instruction processing, and output generation"
      }
    },
    "rules": {
      "heading": "マージルール",
      "description": "LLMは計画をマージする際にこれらのルールに従います：",
      "examples": [
        "ソース計画で指定されたファイルパスを正確に保持",
        "すべてのソースからの競合しない変更を結合",
        "競合については明示的なユーザー指示に従う",
        "マージされたコンテンツ全体で一貫したコードスタイルを維持",
        "ソース計画を示す来歴コメントを含める"
      ]
    },
    "output": {
      "heading": "マージされた出力",
      "description": "マージされた計画は個別の計画と同じ柔軟なフォーマットに従って、LLMから生テキストとして返されます。",
      "provenance": "各セクションには、どのソース計画がコンテンツを提供したかを示すコメントが含まれます。",
      "metadata": "source_job_ids、merge_instructions、source_count、merged_atタイムスタンプ、planTitle、summary、isStructured（false）、sessionNameがジョブメタデータに保存されます。"
    },
    "ui": {
      "heading": "UI統合",
      "description": "実装計画パネルはマージワークフローをサポートします：",
      "audit": "Merged plans link back to source plans for traceability."
    },
    "cta": {
      "heading": "計画生成について学ぶ",
      "description": "マージ前に個別の計画がどのように作成されるかを理解しましょう。",
      "links": {
        "plans": "実装計画",
        "runtime": "ランタイムウォークスルー"
      }
    }
  },
  "meetingIngestionDoc": {
    "meta": {
      "title": "Meeting and recording ingestion - PlanToCode",
      "description": "How recordings are analyzed into task summaries through the video analysis pipeline."
    },
    "category": "Inputs",
    "date": "2025-09-25",
    "readTime": "8 min",
    "title": "Meeting & Recording Ingestion",
    "description": "How recordings become task summaries and planning inputs.",
    "intro": "PlanToCode can analyze meeting recordings and screen captures with the video analysis job. The model is guided by a system prompt that adapts to your goal, whether you are debugging, reviewing UI, or documenting a workflow.",
    "visuals": {
      "ingestionFlow": {
        "title": "Recording ingestion flow",
        "description": "How recordings flow through upload and analysis.",
        "imageSrc": "/images/docs/deep-research/workflow.svg",
        "imageAlt": "Recording ingestion flow diagram",
        "caption": "Placeholder for ingestion flow diagram."
      }
    },
    "inputs": {
      "heading": "Supported Inputs",
      "description": "The ingestion workflow accepts video recordings captured in the app or uploaded from other tools.",
      "items": [
        "Screen recordings captured in the desktop app",
        "Meeting recordings exported from Zoom, Meet, or Teams (video files)",
        "Design walkthroughs or bug reproductions recorded as video",
        "For audio-only notes, use voice transcription"
      ]
    },
    "uploadProcess": {
      "heading": "Upload Process",
      "description": "Recordings are uploaded to the server as multipart form data for analysis.",
      "stepsHeading": "Processing Steps",
      "steps": [
        "Desktop saves the recording locally and calculates duration",
        "Video file and analysis prompt are uploaded to /api/llm/video/analyze",
        "Server stores the file temporarily and routes it to Gemini video models",
        "Long recordings are split into 2-minute chunks by the desktop and processed in parallel",
        "Analysis summary is returned and stored in the job response"
      ]
    },
    "normalization": {
      "heading": "Format Normalization",
      "description": "Recordings are sent mostly as-is. WebM recordings are remuxed to fix container metadata before analysis.",
      "outputs": "No separate transcript or frame artifacts are generated; the output is a text analysis summary."
    },
    "multimodalAnalysis": {
      "heading": "Multimodal Analysis",
      "description": "Recordings are analyzed with {code} video models, which accept video and audio in a single request.",
      "combined": "The default video analysis system prompt adapts the output to your goal rather than forcing a fixed schema."
    },
    "transcription": {
      "heading": "Audio context",
      "description": "Audio is analyzed as part of the video; the app does not generate a standalone transcript.",
      "attribution": "If spoken content is unclear, the model may mark it as partially visible rather than guessing.",
      "featuresHeading": "Audio analysis notes",
      "features": [
        "Narration steers the summary",
        "Spoken intent and errors can be quoted",
        "No diarization or timestamped transcript"
      ]
    },
    "frames": {
      "heading": "Frame rate hint",
      "description": "FPS is a sampling hint sent with the analysis request. For large files the provider may ignore it.",
      "timestamps": "Long recordings can be chunked to keep analysis responsive."
    },
    "structuredExtraction": {
      "heading": "Structured Extraction",
      "description": "The analysis output is freeform and adapts to your prompt. Typical outputs include:",
      "extractedHeading": "Extracted Elements",
      "items": [
        "Bug reproduction steps and observed errors",
        "UI walkthrough notes and navigation paths",
        "Design feedback or UX issues shown on screen",
        "Suggested fixes or follow-up tasks"
      ]
    },
    "artifacts": {
      "heading": "Analysis Artifacts",
      "description": "Video analysis produces artifacts stored with the job:",
      "items": [
        "analysis_summary: Text summary stored in background_jobs.response",
        "job_metadata: durationMs, framerate, videoPath",
        "chunk_info: chunk boundaries for long recordings (when applicable)"
      ]
    },
    "keyFiles": {
      "heading": "Key Source Files",
      "items": [
        "desktop/src/app/components/generate-prompt/_components/video-recording-dialog.tsx",
        "desktop/src/contexts/screen-recording/Provider.tsx",
        "desktop/src-tauri/src/jobs/processors/video_analysis_processor.rs",
        "server/src/handlers/proxy/specialized/video_analysis.rs",
        "server/src/utils/multipart_utils.rs",
        "server/src/clients/google_client.rs"
      ]
    },
    "handoff": {
      "heading": "Planning Handoff",
      "description": "Video analysis summaries can be incorporated into the task description for planning.",
      "pipeline": "The summary can be refined with text_improvement and task_refinement before file discovery."
    },
    "cta": {
      "heading": "Continue to video analysis",
      "description": "Learn more about how video frames are analyzed.",
      "links": {
        "video": "Video analysis",
        "textImprovement": "Text improvement"
      }
    }
  },
  "videoAnalysisDoc": {
    "meta": {
      "title": "Video analysis - PlanToCode",
      "description": "Adaptive analysis of screen recordings with Gemini video models."
    },
    "category": "Inputs",
    "date": "2025-09-25",
    "readTime": "6 min",
    "title": "Video Analysis",
    "description": "Adaptive analysis and prompts for screen recordings.",
    "intro": "Video analysis sends the recording to Gemini video models with a system prompt that adapts to your goal. The output is a text summary, not a frame-by-frame export or separate transcript.",
    "visuals": {
      "frameNotes": {
        "title": "Video analysis pipeline",
        "description": "How recordings flow through the analysis model.",
        "imageSrc": "/assets/images/demo-video-analysis.jpg",
        "imageAlt": "Video analysis interface",
        "caption": "The video analysis interface showing analysis options."
      }
    },
    "apiEndpoint": {
      "heading": "API Endpoint",
      "endpoint": "Video analysis is handled by {code} on the server. The endpoint accepts multipart form data with the video file and analysis parameters.",
      "payloadHeading": "Payload Fields",
      "payloadFields": [
        "video: The video file",
        "model: Model identifier for analysis (google/* required)",
        "prompt: Task description and optional focus prompt (wrapped in <description> and <video_attention_prompt>)",
        "temperature: Sampling temperature from task settings",
        "durationMs: Recording duration in milliseconds",
        "framerate: Sampling hint (0.1-20 from the UI)",
        "systemPrompt: Composed system prompt (server-generated)"
      ]
    },
    "inputs": {
      "heading": "Supported Input Formats",
      "items": [
        "MP4, WebM, MOV, and AVI are common inputs",
        "Large files may be uploaded with the provider File API",
        "Long recordings are chunked by the desktop app before analysis"
      ]
    },
    "sampling": {
      "heading": "Frame rate hint",
      "description": "FPS is a hint for how densely to sample the video. For large files the provider may ignore it; for long recordings the desktop may downsample when chunking.",
      "fps": "Default recorder rate is 5 FPS. Lower rates reduce cost but may miss rapid UI changes.",
      "parametersHeading": "Sampling Parameters",
      "parameters": [
        "framerate: 0.1-20 selection in the UI (provider requests are clamped to 1-20)",
        "chunking: long recordings split into 2-minute segments",
        "audio: include narration when \"Include dictation\" is enabled"
      ]
    },
    "modelRequirements": {
      "heading": "Model Requirements",
      "format": "Video analysis requires Gemini video models. Model identifiers follow {code} format; only {code} models are supported.",
      "reasoning": "The server restricts video analysis to Google Gemini models that accept video inputs."
    },
    "analysis": {
      "heading": "Analysis Process",
      "description": "The model analyzes the full video (and audio if present) and produces a goal-oriented summary.",
      "prompting": "The default system prompt (default_video_analysis) tells the model to adapt to your goal, quote visible text when relevant, and mark unclear content instead of guessing.",
      "promptElementsHeading": "Prompt Elements",
      "promptElements": [
        "Goal alignment: focus on the user's stated intent",
        "Evidence: quote visible errors, logs, or UI text when relevant",
        "Sequence: describe the order of events or steps shown",
        "Next steps: suggest fixes or follow-up tasks"
      ]
    },
    "outputs": {
      "heading": "Analysis Outputs",
      "items": [
        "Analysis summary text tailored to the prompt",
        "Quoted errors or UI text when visible",
        "Workflow notes describing what happened on screen",
        "Suggested fixes or follow-up tasks"
      ]
    },
    "billing": {
      "heading": "Token Usage & Billing",
      "description": "Video analysis usage and cost are tracked per job using provider-reported tokens or duration-based estimates.",
      "tracked": [
        "tokens_sent: Prompt + video tokens",
        "tokens_received: Analysis response tokens",
        "actual_cost: Computed from model pricing"
      ]
    },
    "storage": {
      "heading": "Result Storage",
      "description": "Analysis results are stored in background_jobs.response with task_type \"video_analysis\". Long recordings may include chunk metadata.",
      "reuse": "Results can be incorporated into task descriptions or used directly in the planning workflow."
    },
    "keyFiles": {
      "heading": "Key Source Files",
      "items": [
        "desktop/src/app/components/generate-prompt/_components/video-recording-dialog.tsx",
        "desktop/src/contexts/screen-recording/Provider.tsx",
        "desktop/src-tauri/src/jobs/processors/video_analysis_processor.rs",
        "server/src/handlers/proxy/specialized/video_analysis.rs",
        "server/src/clients/google_client.rs"
      ]
    },
    "integration": {
      "heading": "Integration with Planning",
      "description": "Video analysis summaries can be appended to the task description for context-aware planning.",
      "followup": "Use text_improvement or task_refinement to polish the summary before file discovery."
    },
    "cta": {
      "heading": "See meeting ingestion",
      "description": "Learn more about how video analysis works.",
      "links": {
        "meeting": "Meeting ingestion",
        "runtime": "Runtime walkthrough"
      }
    }
  },
  "mobileIos": {
    "meta": {
      "title": "iOSクライアントアーキテクチャ - PlanToCode",
      "description": "iOSコンパニオンアプリのSwiftワークフロー、Auth0ログインフロー、デバイスリンクセッション管理。"
    },
    "category": "アーキテクチャ",
    "date": "2025-09-25",
    "readTime": "12分",
    "title": "iOSクライアントアーキテクチャ",
    "description": "Swiftワークフロー、Auth0ログインフロー、デバイスリンクセッション管理。",
    "intro": "PlanToCode iOSアプリは、リンクされたデスクトップセッションに接続するコンパニオンクライアントです。デスクトップをプライマリプランニングワークスペースとして維持しながら、ターミナル出力、ジョブステータス、音声文字起こしへのモバイルアクセスを提供します。",
    "visuals": {
      "app": {
        "title": "iOSアプリインターフェース",
        "description": "デバイスリンクとターミナルビューを表示するiOSアプリのスクリーンショット。",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "PlanToCode iOSアプリのスクリーンショット",
        "caption": "iOSアプリスクリーンショットのプレースホルダー。"
      }
    },
    "packageStructure": {
      "heading": "Swiftパッケージ構造",
      "description": "iOSアプリはSwiftパッケージに整理されています：",
      "packages": [
        {
          "name": "Core",
          "path": "mobile/ios/Core/",
          "description": "ビジネスロジックとAPIクライアント",
          "components": [
            "WorkflowManager",
            "APIClient",
            "MobileSessionManager",
            "DeviceLinkClient"
          ]
        },
        {
          "name": "Security",
          "path": "mobile/ios/Security/",
          "description": "認証と資格情報ストレージ",
          "components": [
            "Auth0Manager",
            "KeychainHelper",
            "TokenStore"
          ]
        },
        {
          "name": "VibeUI",
          "path": "mobile/ios/VibeUI/",
          "description": "SwiftUIコンポーネントとデザインシステム",
          "components": [
            "TerminalView",
            "JobListView",
            "SettingsView",
            "DeviceLinkView"
          ]
        }
      ]
    },
    "auth": {
      "heading": "Auth0 PKCE統合",
      "description": "iOSアプリはセキュアな認証のためにAuth0とPKCEフローを使用します：",
      "flow": [
        "ユーザーがサインインをタップ、アプリがコード検証子とチャレンジを生成",
        "ASWebAuthenticationSessionがAuth0ログインページを開く",
        "ユーザーが認証、Auth0が認可コードでリダイレクト",
        "アプリがコード検証子を使用してコードをトークンに交換",
        "トークンはiOS Keychainに安全に保存"
      ],
      "tokenManagement": {
        "heading": "トークン管理",
        "items": [
          "アクセストークンはAPIリクエストに使用",
          "リフレッシュトークンはサイレント更新用に保存",
          "有効期限前にトークン更新がトリガー",
          "ログアウト時にKeychainからすべてのトークンをクリア"
        ]
      }
    },
    "deviceLink": {
      "heading": "WebSocketリレー経由のデバイスリンク",
      "description": "iOSはサーバーのWebSocketリレーを通じてデスクトップセッションに接続します：",
      "protocol": {
        "heading": "リンクプロトコル",
        "steps": [
          "デスクトップがリンクコードを生成しQRを表示",
          "iOSがQRをスキャンまたはコードを手動入力",
          "両方が資格情報で/ws/device-linkに接続",
          "サーバーが検証しリレーを確立",
          "双方向通信が有効化"
        ]
      },
      "messageTypes": {
        "heading": "メッセージタイプ",
        "items": [
          "terminal_output: デスクトップターミナルからのPTY出力",
          "job_status: バックグラウンドジョブステータス更新",
          "session_sync: セッション状態同期",
          "rpc_command: モバイルからデスクトップへのコマンド"
        ]
      },
      "reconnection": {
        "heading": "再接続処理",
        "description": "WebSocket接続は自動再接続、指数バックオフ、セッション状態回復でネットワーク中断を処理します。"
      }
    },
    "rpcRouting": {
      "heading": "RPCコマンドルーティング",
      "description": "iOSはリンクされたデスクトップにコマンドを送信できます：",
      "commands": {
        "heading": "サポートされるコマンド",
        "items": [
          "send_terminal_input: ターミナルにキーストロークを送信",
          "request_job_status: 特定ジョブのステータスを取得",
          "start_voice_transcription: モバイルで録音を開始",
          "sync_session: 完全なセッション状態をリクエスト"
        ]
      },
      "implementation": {
        "heading": "実装",
        "description": "コマンドはWebSocket経由で送信されるJSON-RPCメッセージです。デスクトップはコマンドを検証し、結果を非同期で返します。"
      }
    },
    "offlineQueue": {
      "heading": "オフラインアクションキュー",
      "description": "切断中に実行されたアクションは同期用にキューに入れられます：",
      "architecture": {
        "heading": "キューアーキテクチャ",
        "items": [
          "アクションはローカルSQLiteデータベースに保存",
          "再接続時にキューを処理",
          "サーバータイムスタンプで競合を解決",
          "失敗したアクションをユーザーに報告"
        ]
      },
      "supportedActions": {
        "heading": "サポートされるオフラインアクション",
        "items": [
          "音声文字起こし録音（ローカルに保存）",
          "セッションメモと注釈",
          "設定変更"
        ]
      }
    },
    "localStorage": {
      "heading": "SQLiteローカルストレージ",
      "description": "iOSはローカル永続化にSQLiteを使用します：",
      "database": {
        "heading": "データベーススキーマ",
        "path": "~/Documents/plantocode.sqlite",
        "tables": [
          "linked_devices: デスクトップ接続",
          "offline_queue: 保留中の同期アクション",
          "cached_sessions: 最近のセッションデータ",
          "transcriptions: ローカル音声録音"
        ]
      },
      "migrations": {
        "heading": "マイグレーション",
        "description": "スキーマバージョンはuser_version pragmaで追跡。マイグレーションはアプリ起動時に実行されます。"
      }
    },
    "sessions": {
      "heading": "モバイルセッション",
      "description": "MobileSessionManagerがセッション状態を調整します：",
      "lifecycle": [
        "起動時に最後のアクティブセッションをロード",
        "利用可能な場合はリンクされたデスクトップに接続",
        "WebSocket経由でセッション更新をサブスクライブ",
        "オフラインアクセス用にセッションデータをキャッシュ"
      ]
    },
    "workflows": {
      "heading": "ワークフローエントリーポイント",
      "description": "モバイルからアクセス可能な主要ワークフロー：",
      "items": [
        "ターミナル監視: 出力を表示、入力を送信",
        "ジョブステータス: バックグラウンドジョブの進行状況を追跡",
        "音声キャプチャ: モバイルで録音と文字起こし",
        "セッションブラウジング: プランと履歴を確認"
      ]
    },
    "region": {
      "heading": "リージョン設定",
      "description": "iOSはAPIルーティングのユーザーリージョン設定を尊重します：",
      "implementation": "リージョンはUserDefaultsに保存され、すべてのリクエストでapi-eu.plantocode.comまたはapi-us.plantocode.comの選択に使用されます。"
    }
  },
  "providerRouting": {
    "meta": {
      "title": "プロバイダールーティングとストリーミング - PlanToCode",
      "description": "PlanToCodeがプロキシ経由でLLMリクエストをルーティングし、レスポンスを正規化し、デスクトップクライアントにトークンをストリーミングする方法。"
    },
    "category": "リサーチ＆モデル",
    "date": "2025-09-24",
    "readTime": "10分",
    "title": "プロバイダールーティングとストリーミング",
    "description": "正規化、ストリーミング、使用量追跡を備えたすべての外部LLMリクエストを仲介するルーティングレイヤー。",
    "visuals": {
      "routingMap": {
        "title": "プロバイダールーティングマップ",
        "description": "デスクトップアプリからプロキシ経由でプロバイダーへリクエストがフローする図。",
        "imageSrc": "/images/docs/provider-routing/routing-map.svg",
        "imageAlt": "デスクトップから外部プロバイダーへのプロバイダールーティングフロー図",
        "caption": "プロバイダールーティング図のプレースホルダー。"
      }
    },
    "cta": {
      "heading": "モデル設定へ続く",
      "description": "モデル設定では、許可リストとトークンガードレールがUIにどのように公開されるかを説明します。",
      "links": {
        "modelConfiguration": "モデル設定",
        "runtimeWalkthrough": "ランタイムウォークスルー"
      }
    }
  }
}
