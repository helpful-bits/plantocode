{
  "architecture": {
    "meta": {
      "title": "PlanToCodeアーキテクチャ概要",
      "description": "実装プラン、ワークフロー、ターミナルセッションを支えるデスクトップ、オーケストレーション、永続化レイヤー。"
    },
    "category": "アーキテクチャ",
    "date": "2025-09-19",
    "description": "デスクトップシェル、バックグラウンドワークフロー、共有サービスの構成について説明します。",
    "frontend": {
      "heading": "フロントエンドサーフェス",
      "providers": "共有プロバイダーは通知、ランタイム設定、プラン状態を処理します。実装プランパネルはプランメタデータを保持し、モーダルの表示を管理し、必要に応じてトークン推定やプロンプトコンテンツを要求します。",
      "ui": "デスクトップUIはReactコンポーネントで構築されています。実装プランのコンテンツはMonacoベースのビューアーを通じて表示され、大きなプランを仮想化し、言語を検出し、コピーアクションをサポートすることで、レビュー担当者がパフォーマンスの問題なくプランテキストを確認できます。ターミナルセッションはバッファリングされたビューの中でレンダリングされ、PTY出力に接続し、接続ステータスの更新を表示します。"
    },
    "intro": "PlanToCodeは、Reactフロントエンドを備えたTauriデスクトップアプリケーションです。UIは実装プラン、ターミナル、設定コントロールをレンダリングし、Rustバックエンドはワークフロー、トークン推定、永続的なターミナルセッションのためのコマンドを公開します。この概要では、これらの要素がどのように組み合わさるかをまとめています。",
    "metaDescription": "実装プラン、ワークフロー、ターミナルセッションを支えるデスクトップ、オーケストレーション、永続化レイヤー。",
    "metaTitle": "PlanToCodeアーキテクチャ概要",
    "ogDescription": "Reactフロントエンド、Tauriコマンド、バックグラウンドサービスがデスクトップアプリ内でどのように連携するかを学びます。",
    "ogTitle": "PlanToCodeアーキテクチャ概要",
    "persistence": {
      "database": "ターミナル出力とセッションメタデータは、ターミナルセッションリポジトリを介してSQLiteに保存されます。各レコードには識別子、タイムスタンプ、作業ディレクトリ、環境変数、累積ログが含まれており、再起動時に以前の出力を回復できます。同じリポジトリはセッション状態が変更されたときにイベントを発行します。",
      "heading": "永続化と設定",
      "modelConfig": "モデルのデフォルト設定はアプリケーション設定テーブルに保存されます。各タスクはデフォルトモデル、許可された代替モデルのリスト、トークン予算、オプションのコピーボタンプリセットを定義します。Reactレイヤーはこれらの設定を読み取り、モデルセレクターとガードレールに反映します。"
    },
    "readTime": "7分",
    "tauriCommands": {
      "commands": "アプリケーションのRust側は、ワークフロー、ターミナルセッション、モデルツールのコマンドを公開します。ワークフローコマンドはWorkflow Orchestratorを通じてバックグラウンドジョブを開始し、入力を検証し、ファイル検出パイプラインの実行中に進行状況イベントを発行します。トークン推定コマンドは現在選択されているモデルのプロンプトサイズを計算します。",
      "heading": "Tauriコマンドとサービス",
      "terminal": "ターミナルコマンドはPTYプロセスを管理し、リモートクライアントを追跡し、セッションを起動する前にサポートされているCLIバイナリが利用可能かどうかを検証します。ヘルスチェックはPTYステータスとデータベースレコードを組み合わせて、セッションがまだ有効かどうかを報告します。"
    },
    "title": "PlanToCodeアーキテクチャ",
    "voicePipeline": {
      "description": "音声文字起こしは、メディアの許可、マイクの選択、ストリーミング文字起こしリクエストを調整するReactフックとして実装されています。このフックはプランターミナルとプロンプトエディターと統合され、認識されたテキストを直接アクティブなコンポーネントに挿入し、文字起こしが失敗した場合は通知を表示します。",
      "heading": "音声文字起こしパイプライン"
    }
  },
  "deepResearch": {
    "meta": {
      "title": "詳細調査 - PlanToCode",
      "description": "Web検索ワークフローの技術ドキュメント:API統合、クエリ最適化、結果処理、開発ワークフロー統合。"
    },
    "apiIntegration": {
      "heading": "API統合の詳細",
      "pipeline": {
        "description": "取得されたコンテンツは、フォーマットとコンテキストを保持しながら意味のある情報を抽出する標準化された処理パイプラインを通過します。このパイプラインは、ドキュメント、コードリポジトリ、技術的な議論など、さまざまなコンテンツタイプを処理します。",
        "heading": "コンテンツ処理パイプライン"
      },
      "providerConfig": {
        "description": "システムは複数の検索プロバイダーと統合して、包括的なカバレッジと冗長性を確保します。プロバイダーの選択は、クエリタイプ、地理的制限、可用性に基づいて自動的に行われます。APIキーとレート制限は、アプリケーション設定内で透過的に管理されます。",
        "heading": "検索プロバイダー設定"
      }
    },
    "architecture": {
      "description": "Web検索システムはパイプラインとして動作します:クエリ生成、検索実行、結果処理、統合。各段階は信頼性、コスト効率、コンテキストの関連性のために設計されています。このアーキテクチャは、独立した調査タスクと統合された開発ワークフローの両方をサポートします。",
      "heading": "アーキテクチャ概要"
    },
    "bestPractices": {
      "examples": {
        "description": "一般的な統合パターンは、特定のエラーのデバッグから馴染みのないAPIを使用した新機能の実装まで、Web検索結果がさまざまな開発シナリオをどのように強化するかを示しています。",
        "heading": "統合例"
      },
      "heading": "ベストプラクティスと例",
      "strategies": {
        "description": "Web検索統合の価値を最大化するために、クエリの作成、結果の解釈、発見事項を開発ワークフローに統合するための実証済みの戦略に従ってください。",
        "heading": "効果的な検索戦略",
        "queryFormulation": {
          "constraints": "プラットフォームまたは環境の制約を含める",
          "errors": "ライブラリ名と特定のエラーメッセージを組み合わせる",
          "heading": "クエリの作成",
          "practices": "パターン検索には「ベストプラクティス」または「推奨アプローチ」を使用する",
          "versions": "関連する場合は特定のバージョン番号を含める"
        },
        "resultEvaluation": {
          "crossReference": "複数のソース間でソリューションを相互参照する",
          "dates": "時間に敏感な情報の公開日を確認する",
          "heading": "結果の評価",
          "official": "サードパーティのソースよりも公式ドキュメントを優先する",
          "verify": "開発環境でコード例を検証する"
        }
      }
    },
    "category": "技術リファレンス",
    "configuration": {
      "heading": "設定とカスタマイズ",
      "preferences": {
        "description": "ユーザーは、結果のフィルタリング、ソースの優先順位付け、統合の深さを制御する設定を通じて検索動作をカスタマイズできます。これらの設定はプロジェクト対応で、チームの設定とプロジェクト要件に合わせてワークスペースごとに設定できます。",
        "filters": "言語とフレームワーク固有の検索フィルター",
        "heading": "検索設定",
        "limits": "結果数と処理の深さの制限",
        "optionsHeading": "設定可能なオプション",
        "patterns": "異なるファイルタイプの統合パターン",
        "sources": "優先ドキュメントソースと権威",
        "triggers": "自動対手動検索トリガーモード"
      },
      "projectSettings": {
        "description": "検索設定は特定のプロジェクトとテクノロジーに合わせて調整できます。システムはプロジェクトのフレームワーク、言語、依存関係を自動的に検出して検索パラメータを最適化します。カスタムドメインフィルターとソース設定をプロジェクトごとに設定して、関連する結果を確保できます。",
        "heading": "プロジェクト固有の設定"
      }
    },
    "costs": {
      "heading": "コストの考慮事項と制限",
      "optimization": {
        "description": "機能を損なうことなく検索コストを最適化するために、複数の戦略が採用されています。これには、インテリジェントなクエリバッチ処理、結果のキャッシュ、プロバイダーフォールバック、効率的な検索パターンに関するユーザー教育が含まれます。コスト監視とアラートにより、チームは予算制限内に留まることができます。",
        "heading": "コスト最適化"
      },
      "rateLimiting": {
        "cacheFirst": "APIコールを最小限に抑えるキャッシュ優先応答",
        "description": "システムはインテリジェントなレート制限を実装して、必要なときに検索機能が利用可能であることを保証しながらAPIコストを管理します。レート制限はユーザーごと、プロジェクトごと、グローバルに適用され、制限に近づいたときにキャッシュされた結果への自動フォールバックが行われます。",
        "guidelinesHeading": "レート制限ガイドライン",
        "heading": "レート制限とクォータ",
        "personal": "個人使用:1時間あたり100回の検索、1日あたり1000回",
        "team": "チームワークスペース:サブスクリプション階層に基づく共有クォータ",
        "throttling": "制限に近づいたときの自動スロットリング"
      }
    },
    "cta": {
      "description": "Deep ResearchとWeb Search機能はPlanToCodeデスクトップアプリケーションで利用できます。プラットフォーム用のビルドをダウンロードして、Web調査を開発ワークフローに統合し始めましょう。",
      "heading": "Deep Researchを使用する準備はできましたか?"
    },
    "date": "2025-09-20",
    "description": "PlanToCodeがWeb検索を実行し、結果を処理し、発見事項を開発ワークフローに統合する方法について説明します。",
    "devIntegration": {
      "caching": {
        "description": "検索結果はパフォーマンスを向上させ、APIコストを削減するためにインテリジェントにキャッシュされます。キャッシュシステムは、コンテンツの鮮度、クエリの類似性、使用パターンを考慮して、情報の正確性を保証しながら高速な応答を提供します。キャッシュの無効化は、コンテンツの経過時間と関連性の減衰に基づいて自動的に行われます。",
        "heading": "キャッシングとパフォーマンス"
      },
      "contextAware": {
        "description": "調査リクエストは、現在の開発セッションのコンテキストで自動的に強化されます。システムは開いているファイル、最近の変更、エラーメッセージ、プロジェクトの依存関係を分析して、よりターゲットを絞った検索クエリを作成し、最大の関連性のために結果をフィルタリングします。",
        "heading": "コンテキスト対応の調査"
      },
      "heading": "開発ワークフローの統合",
      "resultIntegration": {
        "description": "検索結果は開発ワークフローにシームレスに統合されます。コードスニペットは直接挿入でき、ドキュメントリンクは参照用に保持され、主要な発見事項はコンテキストに適した形式で要約されます。統合は既存のコードスタイルとプロジェクトの規約を尊重します。",
        "heading": "結果の統合"
      }
    },
    "intro": "Deep Research機能により、PlanToCodeはインテリジェントなWeb検索を実行し、最新情報を収集し、発見事項を開発ワークフローに直接統合できます。このシステムは、クエリの最適化、結果の処理、コンテキスト統合を組み合わせて、コード生成と問題解決の能力を強化します。",
    "metaDescription": "Web検索ワークフローの技術ドキュメント:API統合、クエリ最適化、結果処理、開発ワークフローの統合。",
    "metaTitle": "Deep research - PlanToCode",
    "ogDescription": "PlanToCode内でWeb検索がどのように動作するかを理解する:クエリ生成から結果処理、開発ワークフローとの統合まで。",
    "ogTitle": "Deep research - PlanToCode",
    "readTime": "8分",
    "title": "Deep Research & Web Search",
    "troubleshooting": {
      "commonIssues": {
        "description": "ほとんどのWeb検索の問題は、接続の問題、レート制限、または過度に広範なクエリから発生します。システムは、一般的な失敗シナリオに対して明確なエラーメッセージと推奨される修正手順を提供します。",
        "geographic": "地理的制限",
        "geographicSolution": "サポートされている地域に限定された検索機能",
        "heading": "一般的な問題",
        "noResults": "結果が見つかりません",
        "noResultsSolution": "クエリ用語を広げるか、スペルを確認してください",
        "rateLimit": "レート制限超過",
        "rateLimitSolution": "リセット期間を待つか、キャッシュされた結果を試してください"
      },
      "heading": "トラブルシューティングとサポート",
      "performance": {
        "description": "最適なパフォーマンスのために、システムは検索パターンを監視し、最適化を提案します。これには、クエリの洗練に関する推奨事項、キャッシュヒット率の改善、統合効率メトリックが含まれます。",
        "heading": "パフォーマンス最適化"
      }
    },
    "workflow": {
      "execution": {
        "blogs": "認められた技術的権威からのブログ投稿",
        "description": "Web検索は、開発者向けコンテンツを優先する統合検索APIを通じて実行されます。システムは自動的に結果をフィルタリングして、GitHub、Stack Overflow、公式プロジェクトドキュメントなどのプラットフォームからの技術ドキュメント、公式ソース、コミュニティディスカッションに焦点を当てます。",
        "documentation": "公式プロジェクトドキュメントとwiki",
        "forums": "技術フォーラムとコミュニティQ&Aサイト",
        "github": "GitHubリポジトリ、問題、ディスカッション",
        "heading": "検索実行",
        "releases": "リリースノートと変更履歴",
        "sourcesHeading": "検索ソース"
      },
      "heading": "検索ワークフローの段階",
      "processing": {
        "deduplication": "重複検出とコンテンツの重複排除",
        "description": "検索結果はインテリジェントな処理を受けて、関連情報を抽出し、ノイズを除去し、新しさ、権威、コンテキストの関連性に基づいてコンテンツを優先します。システムはWebコンテンツを、開発ワークフローに効率的に統合できる構造化データに変換します。",
        "extraction": "コンテンツ抽出とHTMLからMarkdownへの変換",
        "heading": "結果処理とフィルタリング",
        "scoring": "クエリマッチとソース権威に基づく関連性スコアリング",
        "snippets": "コードスニペット抽出と構文検証",
        "stepsHeading": "処理ステップ",
        "timestamp": "コンテンツの鮮度のタイムスタンプ分析"
      },
      "queryGeneration": {
        "api": "特定のライブラリまたはフレームワークのAPIドキュメント検索",
        "compatibility": "バージョン互換性と移行情報",
        "description": "検索クエリは、現在の開発コンテキスト、ユーザーの意図、タスク要件に基づいて自動的に生成されます。システムはプロジェクトファイル、アクティブなディスカッション、エラーメッセージを分析して、最近のドキュメント、技術的なディスカッション、権威あるソースを優先するターゲットを絞った検索クエリを作成します。",
        "errors": "エラーメッセージの解決とトラブルシューティングガイド",
        "heading": "クエリ生成と最適化",
        "practices": "ベストプラクティスと実装パターン",
        "security": "セキュリティアドバイザリと脆弱性レポート",
        "typesHeading": "クエリタイプ"
      }
    }
  },
  "fileDiscovery": {
    "apiUsage": {
      "heading": "API使用例",
      "monitoring": "進行状況の監視",
      "retrieving": "結果の取得",
      "starting": "ワークフローの開始"
    },
    "architecture": {
      "caching": "パフォーマンス最適化のための中間結果のキャッシュ",
      "costTracking": "AI操作のコスト追跡とタイムアウト管理",
      "distributed": "システムは分散ジョブアーキテクチャを使用し、各段階が独立したバックグラウンドジョブとして実行され、キャンセル、再試行ロジック、詳細な進行状況追跡が可能です。実行中にリアルタイムイベントが公開され、ユーザーインターフェースに即座にフィードバックを提供します。",
      "errorHandling": "自動再試行メカニズムを備えた包括的なエラーハンドリング",
      "eventDriven": "WebSocketのような更新によるイベント駆動の進行状況報告",
      "featuresHeading": "主要なアーキテクチャ機能:",
      "gitIntegration": "ディレクトリトラバーサルへのフォールバックを伴うGit統合",
      "heading": "ワークフローアーキテクチャ",
      "overview": "ワークフローは、順次実行される5つの異なる段階を持つオーケストレーションされたバックグラウンドジョブシステムとして動作します。各段階は前の段階の出力に基づいて構築され、タスク要件に基づいてファイル選択を徐々に洗練します。"
    },
    "category": "技術ガイド",
    "configuration": {
      "exclusion": {
        "description": "検出プロセスから除外するディレクトリとファイルパターンを定義します。",
        "heading": "除外パターン"
      },
      "heading": "設定オプション",
      "retry": {
        "description": "失敗した段階の最大再試行回数を指数バックオフで設定します。",
        "heading": "再試行設定"
      },
      "timeout": {
        "description": "ワークフロー全体または個別の段階の最大実行時間を設定して、無期限のハングを防ぎます。",
        "heading": "タイムアウト管理"
      },
      "workflowConfig": "ワークフロー設定"
    },
    "cta": {
      "description": "ファイル検出ワークフローは、実装計画とターミナルセッションとともにデスクトップクライアント内で実行されます。",
      "heading": "デスクトップアプリが必要ですか?"
    },
    "date": "2025-09-21",
    "description": "タスク実行のための関連ファイルを識別しフィルタリングする5段階AIワークフローの包括的な技術ガイド。",
    "errorHandling": {
      "commonIssues": {
        "binaryDetection": "バイナリファイル検出:拡張子ベースとコンテンツベースの両方のバイナリ検出を使用",
        "gitNotFound": "Gitリポジトリが見つかりません:標準除外を使用したディレクトリトラバーサルにフォールバック",
        "heading": "一般的な問題",
        "networkTimeout": "ネットワークタイムアウト:一時的な障害に対する指数バックオフによる自動再試行",
        "tokenLimit": "トークン制限超過:インテリジェントなバッチ処理を実装し、明確なエラーメッセージを提供"
      },
      "debugging": {
        "description": "ワークフローは包括的なロギング、パフォーマンスメトリックのエクスポート、段階情報、再試行回数、トラブルシューティング用の中間データを含む詳細なエラーコンテキストを提供します。",
        "heading": "デバッグツール"
      },
      "errorCategories": {
        "billing": "請求エラー:アクション可能なガイダンス付きの不十分なクレジットまたは支払い失敗",
        "heading": "エラーカテゴリ",
        "system": "システムエラー:ファイルシステムアクセス、gitコマンドの失敗、またはメモリ制約",
        "validation": "検証エラー:無効なセッションID、タスクの説明の欠落、または無効なプロジェクトディレクトリ",
        "workflow": "ワークフローエラー:詳細なコンテキストと再試行の提案を含む段階固有の失敗"
      },
      "heading": "エラーハンドリングとトラブルシューティング"
    },
    "integration": {
      "desktop": {
        "description": "ワークフローはTauriコマンドを通じてデスクトップアプリケーションとシームレスに統合され、ネイティブファイルシステムアクセスとWorkflowTrackerクラスを介したイベント駆動の更新を提供します。",
        "heading": "デスクトップアプリケーション"
      },
      "heading": "統合パターン",
      "implementationPlans": {
        "description": "選択されたファイルは自動的に実装プランパネルに送られ、検出ワークフローを再実行することなく、プラン生成が同じ最適化されたファイルコンテキストを使用することを保証します。",
        "heading": "実装プラン統合"
      },
      "sessionManagement": {
        "description": "ワークフローの結果はセッションごとにキャッシュされ、同じセッション内の複数の操作が検出されたファイルコンテキストを再利用できるため、反復的な開発ワークフローのパフォーマンスが大幅に向上します。",
        "heading": "セッション管理"
      }
    },
    "intro": "PlanToCodeは、プランを立てたりコマンドを実行したりする前に、適切なファイルを識別します。5段階のワークフローは範囲を絞り込み、コンテキストを簡潔に保ちます。",
    "metaDescription": "タスク実行のための関連ファイルを識別しフィルタリングする5段階AIワークフローの包括的な技術ガイド。",
    "metaTitle": "ファイル検出ワークフロー - PlanToCode",
    "ogDescription": "マルチステージファイル検出ワークフローアーキテクチャの技術ドキュメント。",
    "ogTitle": "ファイル検出ワークフロー - PlanToCode",
    "performance": {
      "costOptimization": {
        "description": "AI段階はAPIレスポンスから実際のコストを追跡し、トークン使用量を最小限に抑えるインテリジェントなバッチ処理を実装し、実行前にコスト見積もりを提供して経費管理を支援します。",
        "heading": "コスト最適化"
      },
      "heading": "パフォーマンスの考慮事項",
      "memory": {
        "description": "ワークフローは、ファイルキャッシュ(30秒TTL)、バッチ処理(バッチあたり100ファイル)、中間データの自動クリーンアップを備えたインテリジェントなメモリ管理を実装して、メモリ枯渇を防ぎます。",
        "heading": "メモリ管理"
      },
      "monitoring": {
        "description": "組み込みのパフォーマンストラッキングは、実行時間、メモリ使用量、スループットメトリックを監視し、過去のデータ分析に基づいて最適化のための推奨事項を提供します。",
        "heading": "パフォーマンス監視"
      }
    },
    "readTime": "12分",
    "stages": {
      "heading": "5段階ワークフロープロセス",
      "stage1": {
        "description": "プロジェクトのルートディレクトリを決定し、gitリポジトリのステータスを検証します。この段階は、すべての後続のファイル操作のベースディレクトリを確立し、除外パターンを設定します。",
        "heading": "段階1:ルートフォルダの選択",
        "technical": "技術的詳細:ディレクトリ検証へのフォールバックを備えたgit検出を使用し、ユーザー定義の除外パターンを適用し、ワークフロー全体の作業ディレクトリコンテキストを確立します。"
      },
      "stage2": {
        "binaryDetection": "バイナリ検出:バイナリ拡張子(.jpg、.png、.pdf、.exeなど)を持つファイルをフィルタリングし、ヌルバイトと非印字文字の比率によるコンテンツ分析を使用してバイナリファイルを検出します。",
        "description": "タスクの説明に基づいてインテリジェントな正規表現パターンを生成し、初期ファイルフィルタリングを実行します。この段階では、git ls-files出力とバイナリファイル検出を組み合わせて、予備的なファイルリストを作成します。",
        "gitIntegration": "Git統合:`git ls-files --cached --others --exclude-standard`を実行して、追跡されたファイルと未追跡のファイルの両方を含めながら.gitignoreルールを尊重します。",
        "heading": "段階2:正規表現ファイルフィルター"
      },
      "stage3": {
        "aiProcessing": "AI処理:大規模言語モデルを使用してタスク要件に対してファイルコンテンツを評価し、トークン制限とコスト最適化を管理するためのインテリジェントなバッチ処理を使用します。",
        "description": "AIモデルを使用してファイルコンテンツを分析し、特定のタスクの説明との関連性を評価します。この段階では、特定のタスクに最も役立つ可能性が高いファイルを識別するために、深いコンテンツ分析を実行します。",
        "heading": "段階3:AIファイル関連性評価"
      },
      "stage4": {
        "description": "関係分析と依存関係追跡を通じて、追加の関連ファイルを発見します。この段階では、初期パターンに一致しない可能性があるが、コンテキスト的に重要なファイルを識別します。",
        "heading": "段階4:拡張パスファインダー",
        "relationship": "関係分析:インポートステートメント、設定ファイル、プロジェクト構造を分析して、特定のタスクのコンテキストを強化する関連ファイルを見つけます。"
      }
    },
    "stateManagement": {
      "eventDriven": {
        "description": "システムは、ワークフローステータスの変更、段階の完了、エラー条件に対してリアルタイムイベントを公開します。これらのイベントにより、応答性の高いユーザーインターフェースと外部監視システムとの統合が可能になります。",
        "heading": "イベント駆動の更新"
      },
      "heading": "ワークフロー状態管理",
      "intermediateData": {
        "description": "各段階は、ディレクトリツリーコンテンツ、正規表現パターン、フィルタリングされたファイルリスト、パス修正結果を含む構造化された中間データ形式で出力を保存します。このデータはデバッグのためにアクセス可能であり、特定の段階からワークフローを再開するために使用できます。",
        "heading": "中間データストレージ"
      },
      "transitions": {
        "description": "ワークフローは明確に定義された状態を経て進行します:作成済み→実行中→一時停止(オプション)→完了/失敗/キャンセル。各状態遷移は、リアルタイム更新のために監視できるイベントを公開します。",
        "heading": "状態遷移"
      }
    },
    "title": "ファイル検出ワークフロー",
    "meta": {
      "title": "ファイル検出ワークフロー - PlanToCode",
      "description": "コードベース全体の関連ファイルを識別する5段階のAIワークフローに関する包括的な技術ガイド。"
    }
  },
  "hub": {
    "ctaDescription": "PlanToCodeをダウンロードして、このドキュメントで説明されている実装プランナー、モデルガードレール、ターミナルセッション、文字起こし機能にアクセスしてください。",
    "ctaHeading": "これらのワークフローを試す準備はできましたか?",
    "description": "PlanToCodeでコード変更を計画および出荷する方法を学びます:ファイル検出、実装プラン、ターミナルセッション、モデルガードレール、音声。",
    "exploreHeading": "ドキュメントを探索",
    "learnMore": "詳細を見る",
    "searchAriaLabel": "ドキュメントを検索",
    "searchPlaceholder": "ドキュメントを検索...",
    "searchShortcut": "⌘K",
    "title": "PlanToCodeドキュメント"
  },
  "onThisPage": {
    "title": "このページの内容"
  },
  "sidebar": {
    "title": "ドキュメント"
  },
  "sections": {
    "planning": {
      "title": "計画とコンテキスト"
    },
    "execution": {
      "title": "実行サーフェス"
    },
    "architecture": {
      "title": "アーキテクチャ"
    }
  },
  "items": {
    "text-improvement": {
      "title": "テキスト改善",
      "description": "プロンプトのクリーンアップのための選択ポップオーバー、ジョブキュー、統合。"
    },
    "implementation-plans": {
      "title": "実装プラン",
      "description": "プランがMonacoビューアにストリーミングされ、プラン履歴にリンクされる方法。"
    },
    "file-discovery": {
      "title": "ファイル検出ワークフロー",
      "description": "各タスクの関連パスを収集するバックグラウンドワークフロー。"
    },
    "deep-research": {
      "title": "Deep Researchとウェブ検索",
      "description": "ウェブ検索ワークフロー、API統合、クエリ最適化、開発ワークフロー統合。"
    },
    "model-configuration": {
      "title": "モデル構成",
      "description": "タスクごとに許可されたモデルとセレクタートグルのトークンガードレール。"
    },
    "terminal-sessions": {
      "title": "ターミナルセッション",
      "description": "永続的なPTYセッション、CLI検出、復旧動作。"
    },
    "voice-transcription": {
      "title": "音声文字起こし",
      "description": "録音ライフサイクル、プロジェクト対応設定、デバイス管理。"
    },
    "architecture": {
      "title": "アーキテクチャ概要",
      "description": "Reactフロントエンド、Tauriコマンド、永続性がどのように連携するか。"
    }
  },
  "implementationPlans": {
    "category": "製品ガイド",
    "context": {
      "audit": "すべてのメタデータは監査目的でプランとともに保持されます。企業チームは、どの関係者がどのプランをレビューし、どのような変更が要求され、初期タスクの説明からファイル検出、最終承認されたプランまでの完全な推論チェーンを追跡できます。",
      "heading": "企業ガバナンスのためのコンテキストとメタデータ",
      "storage": "パネルは、ファイル検出ワークフロー中に選択されたリポジトリルートを保存し、フォローアップアクションが同じスコープを再利用できるようにします。また、プロジェクトディレクトリや準備されたプロンプトコンテンツなどのプラン固有のメタデータも記録するため、ワークフローを再計算することなく、ダウンストリームプロンプトを生成またはコピーできます。",
      "tokenEstimation": "トークン推定はプロンプトがコピーされる前に実行されます。パネルは、プロジェクトディレクトリ、選択されたファイル、現在選択されているモデルを使用してトークン推定コマンドを呼び出し、チームがモデル制限内に収まるように、システムプロンプトとユーザープロンプトの両方の合計を表示します。"
    },
    "cta": {
      "claudeCodeLink": "Claudeプランモードワークフローを見る",
      "codexLink": "Codexプランモードワークフローを見る",
      "cursorLink": "Cursorプランモードワークフローを見る",
      "description": "ヒューマンインザループ実装プランは、PlanToCodeデスクトップアプリケーション内で利用できます。プラットフォーム用のビルドをダウンロードして、安全で管理されたAI支援開発を体験してください。",
      "heading": "AIコーディングエージェントを安全に導入する準備はできましたか?"
    },
    "date": "2025-09-19",
    "description": "PlanToCodeがヒューマンインザループガバナンス、詳細なファイル単位のプラン、包括的なレビューワークフローを通じて、AIコーディングエージェントの自信を持った導入を可能にする方法について説明します。",
    "fileGranularity": {
      "created": "作成(完全なファイルパスと初期コンテンツ構造を含む)",
      "declaredFiles": "プラン内の各ステップは、どのファイルが次のようになるかを明示的に宣言します:",
      "deleted": "削除(正当化と依存関係分析を含む)",
      "heading": "ファイル単位の詳細度",
      "impact": "この詳細レベルにより、コードに触れる前に提案された変更の影響が非常に明確になります。チームリードは、重要なレガシーコードが変更されるかどうか、破壊的変更が提案されているかどうか、または追加の精査を必要とするファイルにプランが触れているかどうかをすぐに識別できます。",
      "intro": "実装プランは、プロジェクトのリポジトリ構造に対応する正確なファイルパスを使用して、ファイル単位で開発タスクを分解する非常に詳細な構造を使用します。この詳細度は、リグレッションを防ぎ、企業環境でAIコーディングエージェントを自信を持って導入するための基本です。",
      "modified": "変更(特定の行範囲と記述された変更を含む)",
      "referenced": "参照(コンテキスト用だが変更されない)",
      "transmission": "ファイル単位のアプローチにより、承認されたプランをコーディングエージェントに正確に送信することもできます。「認証システムを更新する」などの曖昧な指示の代わりに、エージェントは正確な仕様を受け取ります:「src/auth/session_manager.rsの45〜67行目を変更してトークンローテーションを追加し、次の構造でsrc/auth/token_store.rsを作成します...」"
    },
    "hitl": {
      "approve": "承認:",
      "approveDesc": "明示的な承認の後にのみ、プランは選択されたコーディングエージェントまたは割り当てられたソフトウェア開発者に実行のために安全に送信できます。",
      "conclusion": "このワークフローは、すべての開発努力が企業の製品要件、チームワークフロー、ビジネス目標と一致することを保証します。明示的な人間の承認なしにコード変更は発生しません。",
      "edit": "編集:",
      "editDesc": "関係者は、VS Code編集機能を使用して、ステップを直接変更し、アプローチを調整し、制約を追加し、またはリスクのある操作を削除できます。",
      "heading": "ヒューマンインザループガバナンス",
      "intro": "PlanToCodeは、チームリードと関係者がAI生成実装プランのすべての側面を完全に制御できるようにする包括的なヒューマンインザループ(HITL)ワークフローを実装しています。このガバナンスモデルは、AIコーディングエージェントが自律的に動作するときに発生する可能性のあるリグレッション、バグ、意図しない変更を防ぎます。",
      "reject": "却下:",
      "rejectDesc": "要件を満たさないプランは完全に却下できます。コンプライアンスと学習のために完全な監査証跡が維持されます。",
      "requestChanges": "変更を要求:",
      "requestChangesDesc": "チームはAIシステムに変更を要求し、代替アプローチを生成したり、カスタム指示で複数のプランを統合したりできます。",
      "review": "レビュー:",
      "reviewDesc": "プランはMonacoエディターで開き、レビュー担当者は完全な構文ハイライトとプロフェッショナルな編集ツールを使用して、提案されたすべての変更を確認できます。",
      "workflow": "コード変更が開始される前に、すべてのプランは構造化されたレビューワークフローを通過する必要があります:"
    },
    "intro": "実行前にすべてのプランをレビューおよび承認します。ファイル単位の詳細度を持つヒューマンインザループガバナンスにより、AI生成の変更が企業要件とチームワークフローに確実に一致します。",
    "metaDescription": "AI実装計画ガイド。実行前にファイル単位のプランを生成、レビュー、承認します。重複と間違ったパスを防ぎます。",
    "metaTitle": "実装プラン - AIの変更をレビュー",
    "multiplePlans": {
      "description": "プランは統合、削除、または後で再開できます。パネルは選択されたプラン識別子のリストを保持し、プランに関連付けられたターミナル出力専用のモーダルを管理し、レビュー担当者がビューアーを閉じずに以前のプランをページングできるようにナビゲーションヘルパーを公開します。ターミナルアクセス、プロンプトコピーコントロール、統合指示はすべて同じジョブ識別子を共有するため、監査履歴の一貫性が保たれます。",
      "heading": "複数のプランの操作"
    },
    "ogDescription": "ヒューマンインザループガバナンスとファイル単位のレビューワークフローが、コード変更の完全な制御を伴う安全なAI開発をどのように保証するかを理解します。",
    "ogTitle": "PlanToCodeのヒューマンインザループ実装プラン",
    "plansOrigin": {
      "description": "各プランは、現在のセッションのバックグラウンドジョブに対応します。パネルはプランデータをサブスクライブし、現在開いているプランを追跡し、以前と新しいジョブ間のナビゲーションを公開します。この動作は{code}と周囲のパネルコンポーネント内に存在します。",
      "heading": "プランの出所"
    },
    "readTime": "6分",
    "reviewingPlans": {
      "description": "プランコンテンツは、Monaco Editorをラップする共有{code}を通じてレンダリングされます。ビューアーは一般的な言語を自動的に検出し、クリップボードへのコピーアクションをサポートし、非常に大きなプランを仮想化し、文字数や構文対応ハイライトなどのオプションメトリックを提供します。",
      "heading": "Monacoでのプランのレビュー",
      "opening": "プランが開かれると、パネルはジョブ識別子によってアクティブなプランを解決し、コンテンツをMonacoに渡し、レビュー担当者が現在開いているモーダルを失うことなく隣接するジョブ間を移動できるようにします。"
    },
    "title": "実装プラン",
    "meta": {
      "title": "Implementation Plans - Review AI Changes",
      "description": "Guide to AI implementation planning. Generate, review, and approve file-by-file plans before execution. Prevent duplicates and wrong paths."
    }
  },
  "modelConfiguration": {
    "category": "製品ガイド",
    "date": "2025-09-20",
    "description": "デスクトップクライアントのタスクレベルモデルリスト、セレクターコントロール、トークンガードレール。",
    "intro": "PlanToCodeはモデル選択をタスクレベルの決定として扱います。各ワークフローにはデフォルトモデルと許可リストが付属しており、デスクトップクライアントはアクティブなコンテキストウィンドウを超えるプロンプトの送信を防ぐトグルを通じてこれらのオプションを公開します。",
    "metaDescription": "PlanToCodeがタスクごとに許可されたモデルを選択し、プロンプトをアクティブなコンテキストウィンドウ内に保つ方法。",
    "metaTitle": "モデル設定とガードレール - PlanToCode",
    "ogDescription": "タスクレベルのモデル設定、セレクタートグル、トークン推定がどのように連携するかを学びます。",
    "ogTitle": "モデル設定とガードレール - PlanToCode",
    "promptEstimation": {
      "description": "トークンカウントはトークン推定コマンドを通じて計算されます。パネルはセッションID、タスクの説明、関連ファイル、選択されたモデルを送信し、バックエンドがシステム、ユーザー、合計トークン値を返すことができるようにします。これらの数値はセレクターガードレールに直接供給され、チームが別のツールにコピーする前に制限を超えたプロンプトを発見できるようにします。",
      "heading": "プロンプト推定"
    },
    "readTime": "5分",
    "selectorToggle": {
      "description": "実装プランパネルは{code}で許可されたモデルをレンダリングします。トグルは各許可されたモデルを表示し、アクティブな選択を追跡し、スイッチを許可する前に、推定されたプロンプトと計画された出力トークンがモデルのアドバタイズされたコンテキストウィンドウ内に収まるかどうかをチェックします。",
      "guardrails": "モデルが合計トークン要件をサポートできない場合、トグルはボタンを無効にし、計算された超過量を含むツールチップを表示して、レビュー担当者がエージェントに作業を送信する前に安全な制限内に収まるようにします。",
      "heading": "クライアントのセレクタートグル"
    },
    "taskDefaults": {
      "description": "デフォルトモデルと許可された代替モデルは、アプリケーション設定にサーバー側で保存されます。実装プラン、統合、プロンプト生成、音声文字起こしなどの各タスクタイプは、優先モデル、許可されたオプションのリスト、デスクトップアプリが実行時に読み取るトークン制限を定義します。",
      "heading": "タスク駆動のデフォルト"
    },
    "title": "モデル設定",
    "meta": {
      "title": "モデル設定 - PlanToCode",
      "description": "How PlanToCode lets you pick allowed models per task and keeps prompts within the active context window."
    }
  },
  "terminalSessions": {
    "meta": {
      "title": "ターミナルセッション - PlanToCode",
      "description": "Technical guide to PTY terminal implementation in PlanToCode. Learn how sessions persist, agent inactivity detection works, and recovery mechanisms."
    },
    "attentionDetection": {
      "conclusion": "このアプローチにより、エージェントが停止した理由を推測することなく、タスクを完了したかガイダンスが必要かどうかを追跡できます。注意インジケーターは、新しい出力を受信すると自動的にクリアされます。",
      "heading": "エージェント注意検出",
      "intro": "ターミナルは2レベルの非アクティブ検出システムを通じてエージェントのアクティビティを監視します。エージェントが出力の生成を停止すると、システムは何が起こったかを確認するように徐々にアラートを出します:",
      "level1": "レベル1(30秒):「エージェントアイドル - タスクが完了した可能性があります」黄色インジケーター付き",
      "level2": "レベル2(2分):「エージェントの注意が必要 - ターミナルを確認してください」赤色インジケーターとデスクトップ通知付き"
    },
    "category": "製品ガイド",
    "date": "2025-09-22",
    "dependencyChecks": {
      "description": "コマンドを起動する前に、ターミナルはclaude、cursor、codex、geminiなどのサポートされているCLIツールの存在をチェックします。同じコマンドはデフォルトシェルも報告するため、ユーザーはどの環境が実行されるかを知ることができます。これにより、必要なバイナリを見つけられないセッションへの起動を防ぎます。",
      "heading": "依存関係チェック"
    },
    "description": "実装プランターミナルでの永続的なPTYセッション、エージェント注意検出、回復動作。",
    "intro": "ヘルスチェックとロギングを備えた永続的なPTYでコマンドを実行します。必要なときに音声文字起こしが利用可能です。",
    "lifecycle": {
      "description": "ターミナルが開くと、UIコンポーネントはPTYセッションを作成し、バッファリングされたビューを通じて出力をストリームします。コンポーネントは即座に接続ステータスを表示し、キーストロークをPTYに転送し、セッションが失敗した場合は自動的に再試行します。セッションメタデータは、タイムスタンプ、終了コード、作業ディレクトリ、完全な出力ログとともにSQLiteに保存されるため、再起動時に以前のコンテキストを再開できます。",
      "heading": "セッションライフサイクル"
    },
    "metaDescription": "PlanToCodeでのPTYターミナル実装の技術ガイド。セッションの永続化、エージェント非アクティブ検出の動作、回復メカニズムを学びます。",
    "metaTitle": "ターミナルセッション - PlanToCode",
    "ogDescription": "プランターミナルでのセッション永続化、エージェント注意検出、回復を理解します。",
    "ogTitle": "ターミナルセッション - PlanToCode",
    "readTime": "6分",
    "title": "ターミナルセッション",
    "voiceRecovery": {
      "heading": "音声文字起こしと回復",
      "recovery": "PTYセッションが切断された場合、ターミナルサーフェスは回復コントロールを表示し、指数バックオフで接続を再試行します。ヘルスチェックはセッション状態を継続的に監視し、接続の問題が検出されたときに自動回復アクションを提供します。",
      "voice": "ターミナルモーダル内で、音声文字起こしは音声をキャプチャし、ターミナル入力エリアに貼り付けることができます。録音フックはプロジェクトレベルの文字起こし設定を検索し、録音状態を追跡し、認識されたテキストをアクティブなプランセッションにストリームします。"
    }
  },
  "textImprovement": {
    "category": "製品ガイド",
    "cta": {
      "description": "PlanToCodeをダウンロードして、実装プランを生成する前に音声キャプチャ、ビデオコンテキスト、インライン書き換えを組み合わせてください。",
      "heading": "デスクトップアプリでテキスト改善を試す"
    },
    "date": "2025-09-21",
    "description": "PlanToCodeがフォーマットを変更せずにハイライトされたテキストを書き換え、結果をワークスペースにリンクする方法について説明します。",
    "intro": "AIコンテキストでテキストを洗練します。任意のエディターでテキストを選択し、バックグラウンドジョブをトリガーし、フォーマットをそのままにした改善されたコンテンツを取得します。",
    "metaDescription": "デスクトップワークスペースがハイライトされたテキストを書き換え、フォーマットを保持し、機能を音声とビデオ入力にリンクする方法。",
    "metaTitle": "テキスト改善 - PlanToCode",
    "ogDescription": "テキスト改善を支える選択ポップオーバー、ジョブキュー、モデル設定、統合を理解します。",
    "ogTitle": "テキスト改善 - PlanToCode",
    "readTime": "7分",
    "selectionPopover": {
      "component": "ポップオーバー自体は{code}によってレンダリングされる最小限のコンポーネントで、単にプロバイダーフックをトリガーし、書き換えの実行中にローディングインジケーターを表示します。プロバイダーがグローバルリスナーを登録しているため、ポップオーバーは追加の配線なしでMonacoプランビューアー、プランターミナル口述フィールド、任意のタスク説明入力に表示されます。",
      "heading": "選択ポップオーバーの動作",
      "provider": "{code}は標準入力とMonacoエディターの選択イベントをリッスンします。空でないテキストをハイライトすると、カーソルの近くにポップオーバーを配置し、選択された範囲を保存し、ポップオーバーを表示するかどうかを追跡します。ボタンをクリックするとジョブが開始され、結果が返されるまでコントロールが無効になります。ジョブが完了すると、プロバイダーは改善されたテキストを同じ選択に適用し、保留中の保存をフラッシュしてセッション状態を同期します。"
    },
    "title": "テキスト改善",
    "triggerImprovement": {
      "action": "ポップオーバーボタンを押すと{code}が呼び出されます。アクションは選択を検証し、セッション識別子が存在することを確認し、Tauriを介してRustコマンド{code}を呼び出します。コマンドは元のテキストを含む{code}を構築し、アクティブなセッションに対してバックグラウンドジョブをキューに入れます。",
      "backend": "バックエンドでは、{code}が{code}タスク用に設定されたモデルを解決し、選択をXMLタグでラップし、ストリーミングなしで{code}を通じてリクエストを実行します。モデルレスポンスが返されると、UIに改善されたテキストを送信する前に、トークン使用量、コスト、システムプロンプトテンプレートを記録します。デフォルト設定はClaude Sonnet 4とGemini 2.5 Flashを承認されたモデルとして、温度0.7で4,096トークンを上限としています。",
      "heading": "改善をトリガーしたときに何が起こるか",
      "metadata": "バックグラウンドジョブサイドバーは、ジョブメタデータに元のテキストを記録するため、書き換えられたコピーと一緒に送信された内容をレビューできます。ジョブの実行中に選択が変更された場合、プロバイダーは手動編集を上書きしないようにテキストの置き換えをスキップします。"
    },
    "videoCapture": {
      "dialog": "画面録画はビデオ分析ダイアログを通過し、Geminiビデオ分析ジョブにリクエストを送信する前に、セマンティックXMLタグでラップされたオプションのプロンプトブロックと現在のタスクの説明を組み合わせます。録音中に口述したメモは、分析が完了するとテキストとして利用可能になるため、結果の要約を改善ポップオーバーにフィードバックして、計画前に指示を引き締めることができます。",
      "features": "ビデオジョブには、フレームレートコントロール、オーディオキャプチャトグル、コストレポートが含まれます。結果はテキスト改善と同じバックグラウンドジョブサイドバーに表示され、すべてのプロンプト準備アーティファクトが1か所に保持されます。",
      "heading": "ビデオキャプチャとプロンプトスキャフォールディング"
    },
    "voiceIntegration": {
      "heading": "音声文字起こし統合",
      "hook": "音声録音は{code}フックを使用します。プロジェクトごとの文字起こしデフォルトを読み込み、マイクアクセスを要求し、タスクの説明またはターミナル口述バッファー内のカーソルにトランスクリプトを挿入します。挿入されたテキストは即座にハイライトされ、同じ改善ポップオーバーを通過でき、元の文字起こしジョブ識別子は監査のために改善ペイロードとともに保存されます。",
      "preferences": "言語、モデル、温度設定はプロジェクトレベルで保持されるため、チームはコピーを洗練する前に一貫した文字起こし品質を得られます。沈黙検出は悪いオーディオレベルについて警告し、10分の上限は大きなペイロードで改善ジョブをブロックすることを防ぎます。"
    },
    "meta": {
      "title": "テキスト改善 - PlanToCode",
      "description": "How the desktop workspace rewrites highlighted text, preserves formatting, and links the feature to voice and video inputs."
    }
  },
  "voiceTranscription": {
    "category": "製品ガイド",
    "date": "2025-09-22",
    "description": "音声駆動プロンプトのための録音ライフサイクル、デバイス管理、ストリーミング動作。",
    "deviceManagement": {
      "description": "この機能はマイクの許可を要求し、利用可能なオーディオ入力を列挙し、ユーザーがセッション中にデバイスを切り替えられるようにします。オーディオレベルはリアルタイムで監視されるため、マイクがミュートまたは切断されている場合、UIは沈黙警告を表示できます。",
      "heading": "デバイス管理"
    },
    "intro": "音声文字起こしは、プランターミナルやプロンプトエディターを含む、デスクトップアプリが口述コントロールを公開する場所ならどこでも利用可能です。この機能はオーディオをローカルで録音し、文字起こしサービスにチャンクを送信し、手動入力をブロックすることなく認識されたテキストをアクティブな入力フィールドに挿入します。",
    "metaDescription": "PlanToCodeがgpt-4o-transcribeを使用してオーディオを録音し、リアルタイムトランスクリプトをストリームし、許可、プロジェクト設定を管理する方法。",
    "metaTitle": "音声文字起こし - PlanToCode",
    "ogDescription": "録音フックがデバイス、許可、ストリーミングテキストをどのように管理するかを学びます。",
    "ogTitle": "音声文字起こし - PlanToCode",
    "projectSettings": {
      "description": "録音セッションが開始されると、フックはアクティブなプロジェクトの文字起こし設定を検索します。言語コード、優先モデル、その他の設定は、オーディオをキャプチャする前に取得されるため、録音はプロジェクトの設定に従います。",
      "heading": "プロジェクト対応設定"
    },
    "readTime": "5分",
    "recordingWorkflow": {
      "description": "録音フックは、アイドル、録音、処理、エラー状態を持つ状態マシンを保持します。期間を追跡し、沈黙検出を管理し、10分後に自動的に録音を停止します。チャンクはバッファリングされ、文字起こしアクションに転送され、挿入のために認識されたテキストを返します。",
      "heading": "録音ワークフロー"
    },
    "title": "音声文字起こし",
    "meta": {
      "title": "音声文字起こし - PlanToCode",
      "description": "How PlanToCode records audio, streams real-time transcripts using gpt-4o-transcribe, manages permissions, project settings."
    }
  }
}
