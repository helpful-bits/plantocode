{
  "meta": {
    "title": "ドキュメント - PlanToCode",
    "description": "PlanToCodeでコード変更を計画・実装する方法を学びましょう：ファイル検出、実装計画、ターミナルセッション、モデルガードレール、音声機能について解説します。"
  },
  "architecture": {
    "meta": {
      "title": "PlanToCodeアーキテクチャ概要",
      "description": "実装計画、ワークフロー、ターミナルセッションを支えるデスクトップ、オーケストレーション、永続化レイヤー。"
    },
    "category": "アーキテクチャ",
    "date": "2025-09-19",
    "description": "デスクトップシェル、バックグラウンドワークフロー、共有サービスの構成について。",
    "frontend": {
      "heading": "フロントエンド層",
      "providers": "共有プロバイダーは通知、ランタイム設定、プラン状態を管理します。実装計画パネルはプランのメタデータを保持し、モーダルの表示を管理し、必要に応じてトークン見積もりやプロンプト内容をリクエストします。",
      "ui": "デスクトップUIはReactコンポーネントで構築されています。実装計画の内容は、大規模なプランを仮想化し、言語を検出し、コピー操作をサポートするMonacoベースのビューアで表示されるため、レビュアーはパフォーマンスの問題なくプランテキストを確認できます。ターミナルセッションは、PTY出力に接続し接続状態の更新を表示するバッファ付きビュー内でレンダリングされます。"
    },
    "intro": "PlanToCodeはReactフロントエンドを持つTauriデスクトップアプリケーションです。UIは実装計画、ターミナル、設定コントロールをレンダリングし、Rustバックエンドはワークフロー、トークン見積もり、永続的なターミナルセッション用のコマンドを公開します。この概要では、これらの要素がどのように連携するかを説明します。",
    "metaDescription": "実装計画、ワークフロー、ターミナルセッションを支えるデスクトップ、オーケストレーション、永続化レイヤー。",
    "metaTitle": "PlanToCodeアーキテクチャ概要",
    "ogDescription": "デスクトップアプリ内でReactフロントエンド、Tauriコマンド、バックグラウンドサービスがどのように連携するかを学びます。",
    "ogTitle": "PlanToCodeアーキテクチャ概要",
    "persistence": {
      "database": "ターミナル出力とセッションメタデータは、ターミナルセッションリポジトリを介してSQLiteに保存されます。各レコードには識別子、タイムスタンプ、作業ディレクトリ、環境変数、蓄積されたログが含まれ、再起動時に以前の出力を復元できます。同じリポジトリがセッション状態の変更時にイベントを発行します。",
      "heading": "永続化と設定",
      "modelConfig": "モデルのデフォルト設定はアプリケーション設定テーブルに保存されます。各タスクはデフォルトモデル、許可された代替モデルのリスト、トークン予算、オプションのコピーボタンプリセットを定義します。Reactレイヤーはこれらの設定を読み取り、モデルセレクターとガードレールを設定します。"
    },
    "readTime": "7分",
    "tauriCommands": {
      "commands": "アプリケーションのRust側は、ワークフロー、ターミナルセッション、モデルツール用のコマンドを公開します。ワークフローコマンドはWorkflow Orchestratorを通じてバックグラウンドジョブを開始し、入力を検証し、ファイル検出パイプラインの実行中に進行状況イベントを発行します。トークン見積もりコマンドは、現在選択されているモデルのプロンプトサイズを計算します。",
      "heading": "Tauriコマンドとサービス",
      "terminal": "ターミナルコマンドはPTYプロセスを管理し、リモートクライアントを追跡し、セッションを起動する前にサポートされているCLIバイナリが利用可能かどうかを確認します。ヘルスチェックはPTYステータスとデータベースレコードを組み合わせて、セッションがまだ稼働しているかどうかを報告します。"
    },
    "title": "PlanToCodeアーキテクチャ",
    "voicePipeline": {
      "description": "音声文字起こしは、メディア権限、マイク選択、ストリーミング文字起こしリクエストを調整するReactフックとして実装されています。このフックはプランターミナルとプロンプトエディタと統合され、認識されたテキストをアクティブなコンポーネントに直接挿入し、文字起こしが失敗した場合は通知を表示します。",
      "heading": "音声文字起こしパイプライン"
    },
    "server": {
      "heading": "サーバーレイヤー",
      "description": "サーバーはプロバイダー設定（暗号化されたボールトのAPIキー、レート制限、OpenAI、Anthropic、Google向けのルーティングルール）、モデルルーティング（リクエストプロキシ、自動フェイルオーバー、負荷分散、ユーザー/プロジェクトごとのコスト追跡）、課金（サブスクリプション管理、使用量計測、クォータ適用、コストアラート）、およびWeb検索API（30日/7日TTLの結果キャッシュ、地理的制限、JWT認証）を処理します。"
    },
    "dataFlows": {
      "heading": "データフロー",
      "description": "タスク、プラン、ジョブ、セッションはコンポーネント間を流れます：(1) タスク改善：React UI → TextImprovementPopover → Tauriコマンド → WorkflowOrchestrator → text_improvementプロンプト → SQLite → Reactプロバイダーがテキストを置換。(2) ファイル検出：実装計画パネル → Tauriコマンド → 4つの連続ジョブ → 進行状況イベント → SQLite → UI表示。(3) 実装計画：ファイル検出 → プラン生成 → Tauriコマンド → LLMストリーミング → SQLite → Monacoビューア → レビュー/承認 → エクスポート。(4) ターミナル実行：PTYセッション → SQLite → コマンド実行 → 出力ストリーミング → 音声文字起こし挿入 → エージェント注意検出 → 監査ログ。"
    }
  },
  "deepResearch": {
    "meta": {
      "title": "ディープリサーチ - PlanToCode",
      "description": "Web検索ワークフローの技術ドキュメント：API統合、クエリ最適化、結果処理、開発ワークフロー統合。"
    },
    "apiIntegration": {
      "heading": "API統合の詳細",
      "pipeline": {
        "description": "調査結果は、フォーマットとコンテキストを保持しながら意味のある情報を抽出する標準化された処理パイプラインを通過します。パイプラインはさまざまなコンテンツタイプを処理し、開発ワークフロー向けの実用的なインサイトに統合します。",
        "heading": "コンテンツ処理パイプライン"
      },
      "providerConfig": {
        "description": "システムはOpenRouterを介してAI言語モデルを使用し、インテリジェントなWeb調査を実行します。LLMはタスクコンテキストに基づいて的を絞った調査クエリを生成し、トレーニングデータとWeb検索機能から得た知見を統合します。モデルの選択と設定はアプリケーション設定で管理されます。",
        "heading": "AI調査設定"
      }
    },
    "architecture": {
      "description": "ディープリサーチシステムは2段階のワークフローとして動作します：(1) WebSearchPromptsGeneration - AIがタスクとプロジェクトコンテキストを分析し、的を絞った調査クエリを生成、(2) WebSearchExecution - LLMが調査プロンプトを並列実行し、結果を統合します。各段階は信頼性、コスト効率、コンテキストの関連性を考慮して設計されています。",
      "heading": "アーキテクチャ概要"
    },
    "bestPractices": {
      "examples": {
        "description": "一般的な統合パターンは、特定のエラーのデバッグから不慣れなAPIを使用した新機能の実装まで、Web検索結果がさまざまな開発シナリオをどのように強化するかを示しています。",
        "heading": "統合例"
      },
      "heading": "ベストプラクティスと例",
      "strategies": {
        "description": "Web検索統合の価値を最大化するには、クエリの作成、結果の解釈、開発ワークフローへの統合に関するこれらの実証済みの戦略に従ってください。",
        "heading": "効果的な検索戦略",
        "queryFormulation": {
          "constraints": "プラットフォームや環境の制約を含める",
          "errors": "ライブラリ名と特定のエラーメッセージを組み合わせる",
          "heading": "クエリの作成",
          "practices": "パターン検索には「ベストプラクティス」や「推奨アプローチ」を使用",
          "versions": "関連する場合は特定のバージョン番号を含める"
        },
        "resultEvaluation": {
          "crossReference": "複数のソース間でソリューションを相互参照",
          "dates": "時間に敏感な情報については公開日を確認",
          "heading": "結果の評価",
          "official": "サードパーティソースより公式ドキュメントを優先",
          "verify": "開発環境でコード例を検証"
        }
      }
    },
    "category": "技術リファレンス",
    "configuration": {
      "heading": "設定とカスタマイズ",
      "preferences": {
        "description": "調査動作はモデル選択とタスク設定で設定されます。調査タスクに使用するAIモデルを選択し、タイムアウトを設定し、コンテキストに含めるファイルを選択します。",
        "filters": "モデル選択が調査の品質とコストを決定",
        "heading": "調査設定",
        "limits": "タスクごとに最大12個の調査プロンプトを生成",
        "optionsHeading": "設定可能なオプション",
        "patterns": "より良いコンテキストのために関連するプロジェクトファイルを含める",
        "sources": "コンテキスト用のプロジェクトディレクトリとファイル選択",
        "triggers": "ワークフローコマンドで手動で調査を開始"
      },
      "projectSettings": {
        "description": "調査設定はセッション対応です。システムは現在のセッションのプロジェクトディレクトリと含まれるファイルを使用してコンテキストを提供します。除外パス（node_modules、distなど）はAIに表示されるディレクトリツリーから自動的にフィルタリングされます。",
        "heading": "プロジェクト固有の設定"
      }
    },
    "costs": {
      "heading": "コストの考慮事項",
      "optimization": {
        "description": "調査コストはインテリジェントなプロンプト生成で管理されます - システムは調査プロンプトをタスクごとに最大12個に制限します。並列実行により実行時間を最小化します。各ジョブはメタデータでトークン使用量と推定コストを追跡し、完全な透明性を提供します。",
        "heading": "コスト最適化"
      },
      "rateLimiting": {
        "cacheFirst": "調査結果はセッションごとにキャッシュされ、冗長なクエリを回避",
        "description": "ディープリサーチはOpenRouterを介して設定されたAIクレジットを使用します。各調査タスクは複数の並列LLM呼び出しを生成するため、コストは生成される調査プロンプトの数に応じてスケールします。システムは透明性のためにジョブごとのトークン使用量とコストを追跡します。",
        "guidelinesHeading": "コスト管理のヒント",
        "heading": "使用量とコスト",
        "personal": "調査ジョブごとに詳細なコスト内訳でトークン使用量を追跡",
        "team": "コストはOpenRouterまたはPlanToCodeサブスクリプションクレジットで管理",
        "throttling": "ジョブメタデータでトークン数と推定コストを監視"
      }
    },
    "cta": {
      "description": "ディープリサーチとWeb検索機能はPlanToCodeデスクトップアプリケーションで利用できます。プラットフォーム用のビルドをダウンロードして、Web調査を開発ワークフローに統合しましょう。",
      "heading": "ディープリサーチを使う準備はできましたか？",
      "links": {
        "architecture": "システムアーキテクチャを見る",
        "buildYourOwn": "独自の統合を構築"
      }
    },
    "date": "2025-09-20",
    "description": "PlanToCodeがWeb検索を実行し、結果を処理し、開発ワークフローに統合する方法。",
    "devIntegration": {
      "caching": {
        "description": "調査結果はジョブメタデータに保存され、ジョブ詳細パネルからアクセスできます。結果はセッション期間中保持され、実装計画の作成やコーディングの決定を行う際に参照できます。",
        "heading": "結果の保存"
      },
      "contextAware": {
        "description": "調査リクエストは現在のセッションからのコンテキストで自動的に強化されます。システムはプロンプト生成フェーズでプロジェクトのディレクトリツリーと選択したファイルの内容を含め、AIがコードベースに固有の調査クエリを作成できるようにします。",
        "heading": "コンテキスト対応の調査"
      },
      "heading": "開発ワークフロー統合",
      "resultIntegration": {
        "description": "調査結果は実装計画の情報として使用できます。調査タスクが完了すると、結果はresearch_findingタグとしてフォーマットされ、後続の計画タスクに組み込むことができ、実装が最新のベストプラクティスと正確なドキュメントに基づいて行われることを保証します。",
        "heading": "結果の統合"
      }
    },
    "intro": "ディープリサーチ機能により、PlanToCodeはインテリジェントなAI駆動の調査を実行し、関連情報を収集し、開発ワークフローに直接統合できます。このシステムは大規模言語モデルを使用して、プロジェクトコンテキストに基づいた的を絞った調査クエリを生成し、並列調査タスクを実行し、コード生成と問題解決能力を強化する実用的なインサイトを統合します。",
    "metaDescription": "Web検索ワークフローの技術ドキュメント：API統合、クエリ最適化、結果処理、開発ワークフロー統合。",
    "metaTitle": "ディープリサーチ - PlanToCode",
    "ogDescription": "PlanToCode内でWeb検索がどのように動作するかを理解する：クエリ生成から結果処理、開発ワークフローとの統合まで。",
    "ogTitle": "ディープリサーチ - PlanToCode",
    "readTime": "8分",
    "title": "ディープリサーチとWeb検索",
    "troubleshooting": {
      "commonIssues": {
        "description": "ほとんどの調査の問題は、LLM API接続、クレジット不足、または広すぎるプロンプトに起因します。システムはトラブルシューティング用に明確なエラーメッセージとジョブステータス追跡を提供します。",
        "geographic": "モデルの可用性",
        "geographicSolution": "一部のモデルはOpenRouter経由で地域制限がある場合があります",
        "heading": "よくある問題",
        "noResults": "調査プロンプトが生成されない",
        "noResultsSolution": "より具体的なタスク説明を提供するか、コンテキスト用の関連ファイルを含めてください",
        "rateLimit": "APIエラー",
        "rateLimitSolution": "OpenRouter APIのステータスとクレジット残高を確認してください"
      },
      "heading": "トラブルシューティングとサポート",
      "performance": {
        "description": "最適なパフォーマンスを得るには、明確で具体的なタスク説明を提供してください。AIにより良いコンテキストを与えるために関連するプロジェクトファイルを含めてください。システムは総実行時間を最小化するために調査プロンプトを並列実行します。",
        "heading": "パフォーマンス最適化"
      }
    },
    "workflow": {
      "execution": {
        "blogs": "ベストプラクティスと実装パターン",
        "description": "調査プロンプトはAI言語モデルによって並列実行されます。各プロンプトは独立して処理され、システムがタスクの複数の側面に関する情報を同時に収集できます。結果はタイトルと実用的なインサイトを含む構造化された知見に統合されます。",
        "documentation": "APIドキュメントと技術仕様",
        "forums": "エラー解決とトラブルシューティングのアプローチ",
        "github": "コード例と実装パターン",
        "heading": "調査の実行",
        "releases": "バージョン互換性と移行ガイダンス",
        "sourcesHeading": "調査フォーカスエリア"
      },
      "heading": "調査ワークフローの段階",
      "processing": {
        "deduplication": "複数の調査プロンプトにわたって知見を統合",
        "description": "調査結果はタイトルと詳細な知見を含むJSON形式に構造化されます。システムは並列調査タスクからの結果を集約し、成功と失敗のカウントを追跡し、調査結果のサマリーを提供します。結果は簡単にアクセスできるようにジョブメタデータに保存されます。",
        "extraction": "主要な知見を抽出し統合用にフォーマット",
        "heading": "結果の処理と統合",
        "scoring": "調査トピックと関連性で結果を整理",
        "snippets": "実用的なインサイトと推奨事項を強調",
        "stepsHeading": "処理ステップ",
        "timestamp": "タイミングメトリクスで調査実行を追跡"
      },
      "queryGeneration": {
        "api": "APIドキュメントとライブラリ固有の調査",
        "compatibility": "バージョン互換性と移行パス",
        "description": "調査プロンプトは、タスクの説明、プロジェクトコンテキスト、含まれるファイルに基づいてAIによって自動生成されます。システムはディレクトリツリーとファイル内容を通じてコードベース構造を分析し、的を絞った調査クエリを作成します。タスクごとに最大12個のフォーカスされた調査プロンプトが生成されます。",
        "errors": "エラー解決とデバッグアプローチ",
        "heading": "プロンプト生成",
        "practices": "ベストプラクティスと推奨パターン",
        "security": "セキュリティの考慮事項と脆弱性への認識",
        "typesHeading": "調査トピック"
      }
    },
    "visuals": {
      "pipeline": {
        "title": "ディープリサーチパイプライン",
        "description": "2段階のワークフロー：プロンプト生成と並列調査実行。",
        "imageSrc": "/images/docs/deep-research/workflow.svg",
        "imageAlt": "プロンプト生成と実行段階を示すディープリサーチパイプライン図",
        "caption": "プロンプト生成と並列実行段階を示すディープリサーチワークフロー"
      },
      "workflow": {
        "title": "ディープリサーチワークフロー",
        "description": "2段階のワークフロー：プロンプト生成と並列調査実行。",
        "imageSrc": "/images/docs/deep-research/workflow.svg",
        "caption": "すべての処理段階を示すディープリサーチワークフロー"
      }
    }
  },
  "fileDiscovery": {
    "meta": {
      "title": "ファイル検出ワークフロー - PlanToCode",
      "description": "タスク実行に関連するファイルを特定・フィルタリングする4段階AIワークフローの包括的な技術ガイド。"
    },
    "apiUsage": {
      "heading": "API使用例",
      "monitoring": "進行状況の監視",
      "retrieving": "結果の取得",
      "starting": "ワークフローの開始"
    },
    "architecture": {
      "caching": "パフォーマンス最適化のための中間結果のキャッシング",
      "costTracking": "AI操作のコスト追跡とタイムアウト管理",
      "distributed": "システムは分散ジョブアーキテクチャを使用し、各段階が独立したバックグラウンドジョブとして実行され、キャンセル、リトライロジック、詳細な進行状況追跡が可能です。実行中を通じてリアルタイムイベントが発行され、ユーザーインターフェースに即座にフィードバックを提供します。",
      "errorHandling": "自動リトライメカニズムを備えた包括的なエラー処理",
      "eventDriven": "WebSocketライクな更新によるイベント駆動の進行状況レポート",
      "featuresHeading": "主要アーキテクチャ機能：",
      "gitIntegration": "ディレクトリトラバーサルへのフォールバックを備えたGit統合",
      "heading": "ワークフローアーキテクチャ",
      "overview": "ワークフローは、順次実行される4つの異なる段階を持つオーケストレーションされたバックグラウンドジョブシステムとして動作します。各段階は前の段階の出力を基に構築され、タスク要件に基づいてファイル選択を段階的に絞り込みます。"
    },
    "category": "技術ガイド",
    "configuration": {
      "exclusion": {
        "description": "検出プロセスから除外するディレクトリとファイルパターンを定義します。",
        "heading": "除外パターン"
      },
      "heading": "設定オプション",
      "retry": {
        "description": "指数バックオフを使用した失敗ステージの最大リトライ回数を設定します。",
        "heading": "リトライ設定"
      },
      "timeout": {
        "description": "無期限のハングを防ぐために、ワークフロー全体または個別のステージの最大実行時間を設定します。",
        "heading": "タイムアウト管理"
      },
      "workflowConfig": "ワークフロー設定"
    },
    "cta": {
      "description": "ファイル検出ワークフローは、実装計画とターミナルセッションと共にデスクトップクライアント内で実行されます。",
      "heading": "デスクトップアプリが必要ですか？",
      "links": {
        "architecture": "アーキテクチャについて学ぶ",
        "buildYourOwn": "独自のパイプラインを構築"
      }
    },
    "date": "2025-09-21",
    "description": "タスク実行に関連するファイルを特定・フィルタリングする4段階AIワークフローの包括的な技術ガイド。",
    "errorHandling": {
      "commonIssues": {
        "binaryDetection": "バイナリファイル検出：拡張子ベースとコンテンツベースの両方のバイナリ検出を使用",
        "gitNotFound": "Gitリポジトリが見つからない：標準的な除外を使用してディレクトリトラバーサルにフォールバック",
        "heading": "よくある問題",
        "networkTimeout": "ネットワークタイムアウト：一時的な障害に対する指数バックオフによる自動リトライ",
        "tokenLimit": "トークン制限超過：インテリジェントなバッチ処理を実装し、明確なエラーメッセージを提供"
      },
      "debugging": {
        "description": "ワークフローは包括的なログ、パフォーマンスメトリクスのエクスポート、およびトラブルシューティング用のステージ情報、リトライ試行、中間データを含む詳細なエラーコンテキストを提供します。",
        "heading": "デバッグツール"
      },
      "errorCategories": {
        "billing": "課金エラー：クレジット不足または支払い失敗（対処方法のガイダンス付き）",
        "heading": "エラーカテゴリ",
        "system": "システムエラー：ファイルシステムアクセス、gitコマンドの失敗、またはメモリ制約",
        "validation": "検証エラー：無効なセッションID、タスク説明の欠落、または無効なプロジェクトディレクトリ",
        "workflow": "ワークフローエラー：詳細なコンテキストとリトライ提案を含むステージ固有の失敗"
      },
      "heading": "エラー処理とトラブルシューティング"
    },
    "integration": {
      "desktop": {
        "description": "ワークフローはTauriコマンドを通じてデスクトップアプリケーションとシームレスに統合され、ネイティブファイルシステムアクセスとWorkflowTrackerクラスを介したイベント駆動の更新を提供します。",
        "heading": "デスクトップアプリケーション"
      },
      "heading": "統合パターン",
      "implementationPlans": {
        "description": "選択されたファイルは自動的に実装計画パネルに送られ、検出ワークフローの再実行を必要とせずに、プラン生成が同じ最適化されたファイルコンテキストを使用することを保証します。",
        "heading": "実装計画との統合"
      },
      "sessionManagement": {
        "description": "ワークフロー結果はセッションごとにキャッシュされ、同じセッション内の複数の操作が検出されたファイルコンテキストを再利用でき、反復的な開発ワークフローのパフォーマンスを大幅に向上させます。",
        "heading": "セッション管理"
      }
    },
    "intro": "PlanToCodeは計画やコマンド実行の前に適切なファイルを特定します。4段階のワークフローがスコープを絞り込み、コンテキストを最適に保ちます。",
    "metaDescription": "タスク実行に関連するファイルを特定・フィルタリングする4段階AIワークフローの包括的な技術ガイド。",
    "metaTitle": "ファイル検出ワークフロー - PlanToCode",
    "ogDescription": "多段階ファイル検出ワークフローアーキテクチャの技術ドキュメント。",
    "ogTitle": "ファイル検出ワークフロー - PlanToCode",
    "performance": {
      "costOptimization": {
        "description": "AIステージはAPIレスポンスから実際のコストを追跡し、トークン使用量を最小化するインテリジェントなバッチ処理を実装し、経費管理を支援するために実行前にコスト見積もりを提供します。",
        "heading": "コスト最適化"
      },
      "heading": "パフォーマンスの考慮事項",
      "memory": {
        "description": "ワークフローはファイルキャッシング（30秒TTL）、バッチ処理（バッチあたり100ファイル）、およびメモリ枯渇を防ぐための中間データの自動クリーンアップによるインテリジェントなメモリ管理を実装します。",
        "heading": "メモリ管理"
      },
      "monitoring": {
        "description": "組み込みのパフォーマンス追跡は実行時間、メモリ使用量、スループットメトリクスを監視し、履歴データ分析に基づく最適化の推奨事項を提供します。",
        "heading": "パフォーマンス監視"
      }
    },
    "readTime": "12分",
    "stages": {
      "heading": "4段階ワークフロープロセス",
      "stage1": {
        "description": "AIを使用して、タスクの説明に基づいて候補パスのリストから最も関連性の高いルートディレクトリをインテリジェントに選択します。LLMはプライマリプロジェクトディレクトリと候補ルートを分析し、タスクに関連するファイルを含む可能性が最も高いディレクトリを決定します。",
        "heading": "ステージ1：ルートフォルダ選択",
        "technical": "技術的詳細：候補ルートディレクトリ（深さ2まで）とタスクの説明を受け取ります。LLMは各パスをタスクコンテキストに対して評価し、後続のステージで検索されるルートディレクトリのフィルタリングされたリストを返します。",
        "inputOutput": "入出力：candidate_roots配列とtask_descriptionを受け取ります。タスクに最も関連性の高いAI選択ディレクトリを含むroot_directories配列を返します。"
      },
      "stage2": {
        "binaryDetection": "バイナリ検出：バイナリ拡張子（.jpg、.png、.pdf、.exeなど）を持つファイルをフィルタリングし、ヌルバイトと非印刷文字の比率によるコンテンツ分析を使用してバイナリファイルを検出します。",
        "description": "AIを使用して、タスクの説明とディレクトリ構造に基づいてインテリジェントな正規表現パターングループを生成します。各パターングループにはパスパターン（正と負）とコンテンツパターンを含めることができます。プロセッサはこれらのパターンを適用して、選択された各ルートディレクトリからファイルをフィルタリングします。",
        "gitIntegration": "Git統合：選択された各ディレクトリのgitリポジトリルートを見つけ、git_utilsを使用して.gitignoreルールを尊重しながら、追跡されたファイルと追跡されていないファイルの両方を含むすべての非無視ファイルを取得します。",
        "heading": "ステージ2：正規表現ファイルフィルター",
        "technical": "技術的詳細：各ルートのディレクトリツリーを生成し、LLMを呼び出してpath_pattern、content_pattern、negative_path_patternフィールドを持つpatternGroupsを生成します。先読み/後読みサポートのためにfancy-regexを使用します。設定可能な並行性でルートを並列処理します。"
      },
      "stage3": {
        "aiProcessing": "AI処理：大規模言語モデルを使用してファイル内容をタスク要件に対して評価し、コンテキストウィンドウを効率的に管理するために実際のファイルサイズとトークン見積もりに基づいたインテリジェントなチャンキングを行います。",
        "description": "AIモデルを使用してファイル内容を分析し、特定のタスクの説明との関連性を評価します。このステージはファイル内容を読み取り、LLMにタスクに最も関連性の高いファイルを特定させることで、深いコンテンツ分析を実行します。",
        "heading": "ステージ3：AIファイル関連性評価",
        "technical": "技術的詳細：ファイルタイプ対応のヒューリスティックを使用してファイルごとのトークンを推定します（コード～3文字/トークン、構造化データ～5文字/トークン）。90kトークンしきい値以下に収めるためにコンテンツ対応のチャンクを作成します。タイムアウトを回避するためにストリーミングでチャンクを並列処理します。すべてのLLM提案パスをファイルシステムに対して検証します。"
      },
      "stage4": {
        "description": "以前に特定されたファイルとその内容、およびディレクトリツリーをLLMに提供することで、追加の関連ファイルを発見します。AIはインポート、依存関係、プロジェクト構造を分析して、タスクのコンテキストを強化する関連ファイルを見つけます。",
        "heading": "ステージ4：拡張パスファインダー",
        "relationship": "関係分析：以前に特定されたすべてのファイルの内容を読み取り、ディレクトリツリー（利用可能な場合は選択されたルートにスコープ）と共にLLMに提供します。AIはインポート、参照、構造的関係に基づいて追加のファイルを特定します。",
        "technical": "技術的詳細：選択されたルートディレクトリの結合ディレクトリツリーを生成します。すべてのinitial_pathsファイルの内容を読み取ります。Cloudflareタイムアウトを回避するためにストリーミングLLM呼び出しを使用します。発見されたパスをファイルシステムに対して検証し、プロジェクト内の相対パスに正規化します。"
      }
    },
    "stateManagement": {
      "eventDriven": {
        "description": "システムはワークフローステータスの変更、ステージ完了、およびエラー条件に対してリアルタイムイベントを発行します。これらのイベントにより、レスポンシブなユーザーインターフェースと外部監視システムとの統合が可能になります。",
        "heading": "イベント駆動の更新"
      },
      "heading": "ワークフロー状態管理",
      "intermediateData": {
        "description": "各ステージはディレクトリツリー内容、正規表現パターン、フィルタリングされたファイルリスト結果を含む構造化された中間データ形式で出力を保存します。このデータはデバッグにアクセス可能で、特定のステージからワークフローを再開するために使用できます。",
        "heading": "中間データストレージ"
      },
      "transitions": {
        "description": "ワークフローは明確に定義された状態を進行します：作成済み → 実行中 → 一時停止（オプション） → 完了/失敗/キャンセル。各状態遷移はリアルタイム更新のために監視できるイベントを発行します。",
        "heading": "状態遷移"
      }
    },
    "visuals": {
      "pipeline": {
        "title": "ファイル検出パイプライン",
        "description": "4段階のワークフロー：ルートフォルダ選択、正規表現フィルタリング、AI関連性評価、拡張パス検出。",
        "imageSrc": "/images/docs/file-discovery/pipeline.svg",
        "caption": "4つのステージすべてを示すファイル検出パイプライン",
        "imageAlt": "4段階のファイル検出ワークフローを示す図：ルートフォルダ選択、正規表現ファイルフィルター、AIファイル関連性評価、拡張パスファインダー"
      }
    },
    "title": "ファイル検出ワークフロー",
    "sqliteStorage": {
      "heading": "SQLiteストレージ",
      "description": "すべてのワークフロー状態、中間結果、およびジョブメタデータはSQLiteに永続化されます。各ステージはbackground_jobsテーブルに出力を保存し、ワークフローの再開、デバッグ、監査証跡を可能にします。ジョブレコードには、各AIステージのトークン使用量、コスト追跡、システムプロンプトテンプレートが含まれます。"
    }
  },
  "hub": {
    "ctaDescription": "PlanToCodeをダウンロードして、このドキュメントで説明されている実装プランナー、モデルガードレール、ターミナルセッション、文字起こし機能にアクセスしましょう。",
    "ctaHeading": "これらのワークフローを試す準備はできましたか？",
    "ctaLinks": {
      "overview": "概要から始める",
      "runtime": "ランタイムウォークスルー"
    },
    "description": "PlanToCodeでコード変更を計画・実装する方法を学びましょう：ファイル検出、実装計画、ターミナルセッション、モデルガードレール、音声機能について。",
    "exploreHeading": "ドキュメントを探索",
    "learnMore": "詳細を見る",
    "searchAriaLabel": "ドキュメントを検索",
    "searchPlaceholder": "ドキュメントを検索...",
    "searchShortcut": "⌘K",
    "title": "PlanToCodeドキュメント"
  },
  "onThisPage": {
    "title": "このページの内容"
  },
  "sidebar": {
    "title": "ドキュメント"
  },
  "sections": {
    "architecture": {
      "title": "アーキテクチャと内部構造"
    },
    "inputs": {
      "title": "入力とキャプチャ"
    },
    "planning": {
      "title": "計画パイプライン"
    },
    "execution": {
      "title": "実行と自動化"
    },
    "research": {
      "title": "調査とモデル"
    },
    "platform": {
      "title": "ビルドとデプロイ"
    }
  },
  "items": {
    "overview": {
      "title": "システム概要",
      "description": "ここから始めましょう：システムの機能、コアループの仕組み、各コンポーネントの配置について。"
    },
    "runtime-walkthrough": {
      "title": "ランタイムウォークスルー",
      "description": "タスク入力から実行までの一連の流れ。"
    },
    "architecture": {
      "title": "システムアーキテクチャ",
      "description": "デスクトップシェル、Rustサービス、サーバーAPI、永続化レイヤーの連携方法。"
    },
    "desktop-app": {
      "title": "デスクトップアプリの内部構造",
      "description": "Tauri v2シェル、Rustコマンドレイヤー、PTYセッション、UI状態管理。"
    },
    "server-api": {
      "title": "サーバーAPIとLLMプロキシ",
      "description": "認証、プロバイダールーティング、モデル設定、WebSocketエンドポイント。"
    },
    "mobile-ios": {
      "title": "iOSクライアントアーキテクチャ",
      "description": "Swiftワークフロー、Auth0ログインフロー、デバイスリンクセッション管理。"
    },
    "background-jobs": {
      "title": "バックグラウンドジョブとオーケストレーション",
      "description": "ジョブレコード、ワークフローオーケストレーション、プロセッサ、イベントストリーミング。"
    },
    "data-model": {
      "title": "データモデルとストレージ",
      "description": "SQLiteエンティティ、リレーションシップ、状態の再水和方法。"
    },
    "decisions-tradeoffs": {
      "title": "技術的決定とトレードオフ",
      "description": "Tauri、SQLite、専用LLMプロキシを選択した理由とそのコスト。"
    },
    "build-your-own": {
      "title": "独自のパイプラインを構築",
      "description": "ファイル検出とプラン生成ワークフローを設計するための概念ガイド。"
    },
    "meeting-ingestion": {
      "title": "会議と録音の取り込み",
      "description": "録音が構造化されたタスク入力とアーティファクトになる仕組み。"
    },
    "video-analysis": {
      "title": "動画分析",
      "description": "フレームサンプリング、プロンプト、録音からの分析アーティファクト。"
    },
    "voice-transcription": {
      "title": "音声文字起こし",
      "description": "録音ライフサイクル、プロジェクト対応設定、デバイス管理。"
    },
    "text-improvement": {
      "title": "テキスト改善",
      "description": "選択ポップオーバー、ジョブキュー、プロンプトクリーンアップの統合。"
    },
    "file-discovery": {
      "title": "ファイル検出ワークフロー",
      "description": "各タスクに関連するパスを収集するバックグラウンドワークフロー。"
    },
    "implementation-plans": {
      "title": "実装計画",
      "description": "プランがMonacoビューアにストリーミングされ、プラン履歴とリンクされる仕組み。"
    },
    "merge-instructions": {
      "title": "マージ指示",
      "description": "XMLタグ付きソースプランとユーザーガイダンスを使用して複数のプランドラフトをマージする方法。"
    },
    "prompt-types": {
      "title": "プロンプトタイプとテンプレート",
      "description": "プロンプト駆動ジョブタイプとテンプレートアセンブリのカタログ。"
    },
    "terminal-sessions": {
      "title": "ターミナルセッション",
      "description": "永続的なPTYセッション、CLI検出、リカバリ動作。"
    },
    "copy-buttons": {
      "title": "コピーボタン",
      "description": "プランからターミナルおよび外部ツールへのテンプレートハンドオフ。"
    },
    "deep-research": {
      "title": "ディープリサーチとWeb検索",
      "description": "Web検索ワークフロー、API統合、クエリ最適化、開発ワークフロー統合。"
    },
    "provider-routing": {
      "title": "プロバイダールーティングとストリーミング",
      "description": "プロバイダーリクエストの正規化、ストリーミング、追跡方法。"
    },
    "model-configuration": {
      "title": "モデル設定",
      "description": "タスクごとの許可モデルとセレクタートグルのトークンガードレール。"
    },
    "server-setup": {
      "title": "専用サーバーセットアップ",
      "description": "Ansibleベースのインフラ：ベース強化、アプリデプロイ、ボールト管理シークレット。"
    },
    "tauri-v2": {
      "title": "Tauri v2開発ガイド",
      "description": "プロジェクトレイアウト、コマンド、Tauri v2の機能ベースのパーミッション。"
    },
    "distribution-macos": {
      "title": "macOS配布",
      "description": "署名、公証、DMGパッケージング、アップデーターアーティファクト。"
    },
    "distribution-windows": {
      "title": "Windows配布とストア",
      "description": "NSISビルド、MSIXパッケージング、Microsoft Store提出。"
    }
  },
  "implementationPlans": {
    "meta": {
      "title": "実装計画 - AI変更のレビュー",
      "description": "AI実装計画のガイド。実行前にファイル単位のプランを生成、レビュー、承認します。重複や誤ったパスを防止します。"
    },
    "category": "製品ガイド",
    "context": {
      "audit": "すべてのメタデータは監査目的でプランと共に保持されます。企業チームは、どのステークホルダーがどのプランをレビューしたか、どのような変更が要求されたか、最初のタスク説明からファイル検出、最終承認済みプランまでの完全な推論チェーンを追跡できます。",
      "heading": "企業ガバナンスのためのコンテキストとメタデータ",
      "storage": "パネルは、ファイル検出ワークフロー中に選択されたリポジトリルートを保存し、フォローアップアクションが同じスコープを再利用できるようにします。また、プロジェクトディレクトリや準備されたプロンプトコンテンツなどのプラン固有のメタデータも記録し、ワークフローを再計算せずにダウンストリームプロンプトを生成またはコピーできます。",
      "tokenEstimation": "トークン見積もりはプロンプトがコピーされる前に実行されます。パネルはプロジェクトディレクトリ、選択されたファイル、現在選択されているモデルでトークン見積もりコマンドを呼び出し、チームがモデル制限内に収まるようにシステムプロンプトとユーザープロンプトの両方の合計を表示します。"
    },
    "cta": {
      "claudeCodeLink": "Claudeプランモードワークフローを見る",
      "codexLink": "Codexプランモードワークフローを見る",
      "cursorLink": "Cursorプランモードワークフローを見る",
      "description": "ヒューマンインザループ実装計画はPlanToCodeデスクトップアプリケーション内で利用できます。プラットフォーム用のビルドをダウンロードして、安全でガバナンスの効いたAI支援開発を体験しましょう。",
      "heading": "AIコーディングエージェントを安全に採用する準備はできましたか？",
      "links": {
        "architecture": "システムアーキテクチャ",
        "decisions": "決定とトレードオフ",
        "buildYourOwn": "独自のパイプラインを構築",
        "fileDiscovery": "ファイル検出ワークフロー"
      }
    },
    "date": "2025-09-19",
    "description": "PlanToCodeがヒューマンインザループガバナンス、詳細なファイル単位のプラン、包括的なレビューワークフローを通じて、AIコーディングエージェントの自信を持った採用をどのように可能にするか。",
    "fileGranularity": {
      "created": "作成（完全なファイルパスと初期コンテンツ構造付き）",
      "declaredFiles": "プランの各ステップは、どのファイルが対象になるかを明示的に宣言します：",
      "deleted": "削除（正当性と依存関係分析付き）",
      "heading": "ファイル単位の詳細度",
      "impact": "このレベルの詳細により、コードに触れる前に提案された変更の影響が明確になります。チームリーダーは、重要なレガシーコードが変更されるか、破壊的変更が提案されているか、追加の精査が必要なファイルにプランが触れているかをすぐに特定できます。",
      "intro": "実装計画は、プロジェクトのリポジトリ構造に対応する正確なファイルパスを使用して、開発タスクをファイル単位で分解する非常に詳細な構造を使用します。この詳細度は、リグレッションを防ぎ、企業環境でのAIコーディングエージェントの自信を持った採用を可能にするための基本です。",
      "modified": "変更（特定の行範囲と変更内容の説明付き）",
      "referenced": "参照（コンテキスト用だが変更なし）",
      "transmission": "ファイル単位のアプローチは、承認されたプランをコーディングエージェントに正確に伝達することも可能にします。「認証システムを更新」のような曖昧な指示の代わりに、エージェントは正確な仕様を受け取ります：「src/auth/session_manager.rsの45-67行目を変更してトークンローテーションを追加、次の構造でsrc/auth/token_store.rsを作成...」"
    },
    "hitl": {
      "approve": "承認：",
      "approveDesc": "明示的な承認後にのみ、プランは選択されたコーディングエージェントまたは割り当てられたソフトウェア開発者に安全に送信され、実行されます。",
      "conclusion": "このワークフローにより、すべての開発作業が企業の製品要件、チームワークフロー、ビジネス目標に沿うことが保証されます。明示的な人間の承認なしにコード変更は行われません。",
      "edit": "編集：",
      "editDesc": "ステークホルダーはVS Code編集機能を使用して、ステップを直接変更したり、アプローチを調整したり、制約を追加したり、リスクのある操作を削除したりできます。",
      "heading": "ヒューマンインザループガバナンス",
      "intro": "PlanToCodeは、チームリーダーとステークホルダーがAI生成の実装計画のあらゆる側面を完全に制御できる包括的なヒューマンインザループ（HITL）ワークフローを実装しています。このガバナンスモデルは、AIコーディングエージェントが自律的に動作する際に発生する可能性のあるリグレッション、バグ、意図しない変更を防止します。",
      "reject": "却下：",
      "rejectDesc": "要件を満たさないプランは完全に却下でき、コンプライアンスと学習のために完全な監査証跡が維持されます。",
      "requestChanges": "変更をリクエスト：",
      "requestChangesDesc": "チームはAIシステムに変更をリクエストし、代替アプローチを生成したり、カスタム指示で複数のプランをマージしたりできます。",
      "review": "レビュー：",
      "reviewDesc": "プランはMonacoエディタで開き、レビュアーは完全なシンタックスハイライトとプロフェッショナルな編集ツールですべての提案された変更を確認できます。",
      "workflow": "すべてのプランは、コード変更が開始される前に構造化されたレビューワークフローを通過する必要があります："
    },
    "intro": "実行前にすべてのプランをレビューし承認します。ファイル単位の詳細度を持つヒューマンインザループガバナンスにより、AI生成の変更が企業要件とチームワークフローに沿うことを保証します。",
    "metaDescription": "AI実装計画のガイド。実行前にファイル単位のプランを生成、レビュー、承認します。重複や誤ったパスを防止します。",
    "metaTitle": "実装計画 - AI変更のレビュー",
    "multiplePlans": {
      "description": "プランはマージ、削除、または後で再開できます。パネルは選択されたプラン識別子のリストを保持し、プランに関連付けられたターミナル出力用の専用モーダルを管理し、レビュアーがビューアを閉じずに以前のプランをページングできるナビゲーションヘルパーを公開します。ターミナルアクセス、プロンプトコピーコントロール、マージ指示はすべて同じジョブ識別子を共有するため、監査履歴の一貫性が保たれます。",
      "heading": "複数のプランでの作業"
    },
    "ogDescription": "ヒューマンインザループガバナンスとファイル単位のレビューワークフローが、コード変更を完全に制御しながら安全なAI開発をどのように保証するかを理解します。",
    "ogTitle": "PlanToCodeにおけるヒューマンインザループ実装計画",
    "plansOrigin": {
      "description": "各プランは現在のセッションのバックグラウンドジョブに対応しています。パネルはプランデータを購読し、現在開いているプランを追跡し、以前のジョブと新しいジョブ間のナビゲーションを公開します。この動作は{code}と周囲のパネルコンポーネント内にあります。",
      "heading": "プランの由来",
      "processor": "ImplementationPlanProcessorがプラン生成を処理します。関連ファイルを読み取り、オプションで選択されたルートディレクトリに基づいてディレクトリツリーを生成し、LLM用の統一プロンプトを組み立てます。",
      "storage": "プランレスポンスは、planTitle、summary、sessionName、トークン使用量を含むメタデータと共にジョブテーブルに保存されます。生のLLMレスポンスは監査のために保存されます。",
      "streaming": "プランはリアルタイム進行状況イベントと共にLlmTaskRunnerを介してストリーミングされます。100kトークンを超えるプロンプトにはトークン警告がログに記録されますが、処理は完全なコンテンツで続行されます。"
    },
    "readTime": "6分",
    "reviewingPlans": {
      "description": "プランコンテンツは、Monaco Editorをラップする共有{code}を通じてレンダリングされます。ビューアは一般的な言語を自動検出し、クリップボードへのコピーアクションをサポートし、非常に大きなプランを仮想化し、文字数やシンタックス対応のハイライトなどのオプションメトリクスを提供します。",
      "heading": "Monacoでプランをレビュー",
      "opening": "プランが開かれると、パネルはジョブ識別子でアクティブなプランを解決し、コンテンツをMonacoに渡し、レビュアーが現在開いているモーダルを失わずに隣接するジョブ間を移動できるようにします。"
    },
    "visuals": {
      "structure": {
        "title": "実装計画の構造",
        "description": "ファイル単位の詳細度とメタデータを持つ実装計画のXML形式。",
        "imageSrc": "/images/docs/implementation-plans/structure.svg",
        "caption": "ステップ、ファイル、依存関係追跡を示すプラン構造"
      }
    },
    "title": "実装計画",
    "planProcessor": {
      "heading": "プラン生成パイプライン",
      "description": "ImplementationPlanProcessorは、ファイル内容のロード、コンテキストの構築、LLMタスクランナーを通じた結果のストリーミングによってプラン生成をオーケストレーションします。",
      "inputs": "セッションコンテキスト、タスク説明、選択された関連ファイル、オプションのディレクトリツリー（include_project_structureフラグで設定可能）、外部調査用のWeb検索フラグ。",
      "prompt": "prompt_utils::build_unified_promptを使用して、タスクの説明、完全なファイル内容（切り捨てなし）、ディレクトリツリーを推定トークン数と共にモデル固有の形式に組み合わせます。",
      "output": "生のLLMレスポンスはJobResultData::Textとして保存されます。メタデータにはplanTitle、summary、トークン使用量、キャッシュ統計、実際のコストが含まれます。",
      "display": "レスポンスは進行状況イベントを介してUIにストリーミングされます。プランはシンタックスハイライトとコピーアクションをサポートするMonacoベースのVirtualizedCodeViewerでレンダリングされます。"
    },
    "schema": {
      "heading": "プランデータ構造",
      "description": "実装計画は、関連するメタデータと共に生のLLMレスポンスとして保存されます。レスポンステキストは生成されたまま正確に保存され、構造化されたメタデータはプランのコンテキストと使用状況を追跡します。",
      "fieldsHeading": "メタデータフィールド",
      "fields": [
        "planTitle - プランの生成またはユーザー提供のタイトル",
        "summary - プランの人間が読める要約",
        "sessionName - プランを生成したセッションの名前",
        "isStructured - 完了したプランでは常にtrue",
        "isStreaming - 完了したプランではfalse（生成中はtrue）",
        "planData - agent_instructions（オプション）とsteps配列を含む"
      ],
      "exampleHeading": "メタデータ例",
      "example": "{\n  \"planTitle\": \"Authentication System Refactor\",\n  \"summary\": \"Implementation plan generated\",\n  \"sessionName\": \"my-project\",\n  \"isStructured\": true,\n  \"isStreaming\": false,\n  \"planData\": {\n    \"agent_instructions\": null,\n    \"steps\": []\n  }\n}"
    }
  },
  "modelConfiguration": {
    "meta": {
      "title": "モデル設定とガードレール - PlanToCode",
      "description": "PlanToCodeでタスクごとに許可されたモデルを選択し、プロンプトをアクティブなコンテキストウィンドウ内に収める方法。"
    },
    "category": "製品ガイド",
    "date": "2025-09-20",
    "description": "デスクトップクライアントでのタスクレベルのモデルリスト、セレクターコントロール、トークンガードレール。",
    "intro": "PlanToCodeはモデル選択をタスクレベルの決定として扱います。各ワークフローにはデフォルトモデルと許可リストが付属し、デスクトップクライアントはアクティブなコンテキストウィンドウを超えるプロンプトの送信を防ぐトグルを通じてこれらのオプションを公開します。",
    "metaDescription": "PlanToCodeでタスクごとに許可されたモデルを選択し、プロンプトをアクティブなコンテキストウィンドウ内に収める方法。",
    "metaTitle": "モデル設定とガードレール - PlanToCode",
    "ogDescription": "タスクレベルのモデル設定、セレクタートグル、トークン見積もりがどのように連携するかを学びます。",
    "ogTitle": "モデル設定とガードレール - PlanToCode",
    "promptEstimation": {
      "description": "トークン数はトークン見積もりコマンドを通じて計算されます。パネルはセッションID、タスクの説明、関連ファイル、選択されたモデルを送信し、バックエンドがシステム、ユーザー、合計トークン値を返すことができます。これらの数値はセレクターガードレールに直接フィードされ、チームが別のツールにコピーする前に制限超過のプロンプトを特定できます。",
      "heading": "プロンプト見積もり"
    },
    "readTime": "5分",
    "selectorToggle": {
      "description": "実装計画パネルは{code}で許可されたモデルをレンダリングします。トグルは各許可モデルを表示し、アクティブな選択を追跡し、推定プロンプトと計画された出力トークンがモデルの公表されたコンテキストウィンドウ内に収まるかどうかを切り替えを許可する前に確認します。",
      "guardrails": "モデルが合計トークン要件をサポートできない場合、トグルはボタンを無効にし、計算された超過分を含むツールチップを表示し、レビュアーがエージェントに作業を送信する前に安全な制限内に収めます。",
      "heading": "クライアントでのセレクタートグル"
    },
    "taskDefaults": {
      "description": "デフォルトモデルと許可された代替モデルはサーバー側のアプリケーション設定に保存されます。実装計画、マージ、プロンプト生成、音声文字起こしなどの各タスクタイプは、優先モデル、許可されたオプションのリスト、デスクトップアプリがランタイムで読み取るトークン制限を定義します。",
      "heading": "タスク駆動のデフォルト"
    },
    "title": "モデル設定"
  },
  "terminalSessions": {
    "meta": {
      "title": "ターミナルセッション - PlanToCode",
      "description": "PlanToCodeでのPTYターミナル実装の技術ガイド。セッションの永続化、エージェント非アクティブ検出の仕組み、リカバリメカニズムについて学びます。"
    },
    "attentionDetection": {
      "conclusion": "このアプローチは、エージェントが停止した理由を推測することなく、タスクを完了したか、ガイダンスが必要かを追跡するのに役立ちます。注意インジケーターは新しい出力を受信すると自動的にクリアされます。",
      "heading": "エージェント注意検出",
      "intro": "ターミナルは2段階の非アクティブ検出システムを通じてエージェントのアクティビティを監視します。エージェントが出力を停止すると、システムは段階的に何が起こったかを確認するよう警告します：",
      "level1": "レベル1（30秒）：黄色のインジケーターで「エージェントがアイドル状態 - タスクを完了した可能性があります」",
      "level2": "レベル2（2分）：赤いインジケーターとデスクトップ通知で「エージェントに注意が必要 - ターミナルを確認してください」"
    },
    "category": "製品ガイド",
    "date": "2025-09-22",
    "dependencyChecks": {
      "description": "コマンドを起動する前に、ターミナルはclaude、cursor、codex、geminiなどのサポートされているCLIツールの存在を確認します。同じコマンドはデフォルトシェルも報告するため、ユーザーはどの環境で実行されるかを知ることができます。これにより、必要なバイナリが見つからないセッションへの起動を防ぎます。",
      "heading": "依存関係チェック"
    },
    "description": "実装計画ターミナルでの永続的なPTYセッション、エージェント注意検出、リカバリ動作。",
    "intro": "ヘルスチェックとログを備えた永続的なPTYでコマンドを実行します。必要なときに音声文字起こしが利用可能です。",
    "lifecycle": {
      "description": "ターミナルが開くと、UIコンポーネントはPTYセッションを作成し、バッファ付きビューを通じて出力をストリーミングします。コンポーネントは即座に接続ステータスを表示し、キーストロークをPTYに転送し、セッションが失敗した場合は自動的にリトライします。セッションメタデータは、タイムスタンプ、終了コード、作業ディレクトリ、完全な出力ログと共にSQLiteに保存され、再起動時に以前のコンテキストを再開できます。",
      "heading": "セッションライフサイクル"
    },
    "metaDescription": "PlanToCodeでのPTYターミナル実装の技術ガイド。セッションの永続化、エージェント非アクティブ検出の仕組み、リカバリメカニズムについて学びます。",
    "metaTitle": "ターミナルセッション - PlanToCode",
    "ogDescription": "プランターミナルでのセッション永続化、エージェント注意検出、リカバリを理解します。",
    "ogTitle": "ターミナルセッション - PlanToCode",
    "readTime": "6分",
    "title": "ターミナルセッション",
    "voiceRecovery": {
      "heading": "音声文字起こしとリカバリ",
      "recovery": "PTYセッションが切断された場合、ターミナル画面はリカバリコントロールを表示し、指数バックオフで接続を再試行します。ヘルスチェックはセッション状態の監視を継続し、接続の問題が検出されたときに自動リカバリアクションを提供します。",
      "voice": "ターミナルモーダル内で、音声文字起こしは音声をキャプチャし、ターミナル入力エリアに貼り付けることができます。録音フックはプロジェクトレベルの文字起こし設定を検索し、録音状態を追跡し、認識されたテキストをアクティブなプランセッションにストリーミングします。"
    }
  },
  "copyButtons": {
    "meta": {
      "title": "コピーボタン - PlanToCode",
      "description": "テンプレート駆動のコピーボタンがプランに対してプレースホルダーを解決し、エージェント実行のためにターミナルまたはクリップボードに渡す方法。"
    },
    "category": "実行",
    "date": "2025-09-23",
    "readTime": "10分",
    "title": "コピーボタン",
    "description": "実装計画からPTYターミナルと外部ツールへのテンプレート駆動のハンドオフ。",
    "intro": "コピーボタンは、アクティブなプランに対してテンプレートプレースホルダーを解決し、結果をPTYセッションまたはシステムクリップボードに配信することで、計画と実行を橋渡しします。各アクションは完全な監査証跡のためにジョブメタデータに関連付けられ、チームはエージェントに送信された内容を正確に追跡できます。",
    "metaTitle": "コピーボタン - PlanToCode",
    "metaDescription": "テンプレート駆動のコピーボタンがプランに対してプレースホルダーを解決し、エージェント実行のためにターミナルまたはクリップボードに渡す方法。",
    "ogTitle": "コピーボタン - PlanToCode",
    "ogDescription": "コピーボタンテンプレート、プレースホルダー解決、ターミナルハンドオフの技術ガイド。",
    "visuals": {
      "templateFlow": {
        "title": "テンプレート解決フロー",
        "description": "この図はコピーボタン実行パイプラインを示しています。ステージ1「ボタンクリック」：ユーザーがプランビューアまたはターミナルヘッダーでコピーボタンをクリックします。ボタン設定にはラベル、テンプレート文字列、ターゲット（ターミナルまたはクリップボード）が含まれます。ステージ2「プレースホルダー抽出」：テンプレートプロセッサは{{IMPLEMENTATION_PLAN}}、{{STEP_CONTENT}}、{{TASK_DESCRIPTION}}のような二重中括弧パターンをスキャンします。ステージ3「コンテキスト解決」：リゾルバはプラン内容のジョブメタデータ、次にタスクの説明と選択されたファイルのセッション状態をクエリします。欠落しているプレースホルダーはデバッグのために出力に保持されます。ステージ4「ターゲット配信」：ターミナルターゲットの場合、コンテンツはmaster.take_writer()を介してPTY入力バッファに書き込まれます。クリップボードターゲットの場合、コンテンツはTauriクリップボードAPIを介してコピーされます。トースト通知がコンテンツプレビューと共にアクションを確認します。",
        "imageSrc": "/images/docs/copy-buttons/templates.svg",
        "imageAlt": "コピーボタンテンプレート解決を示すフロー",
        "caption": "テンプレート解決フロー図のプレースホルダー。"
      }
    },
    "templateConfiguration": {
      "heading": "テンプレート設定ソース",
      "description": "コピーボタンテンプレートは階層化された設定モデルに従います。サーバーデフォルトはベースラインテンプレートを提供し、プロジェクトレベルのオーバーライドはチームワークフロー用にカスタマイズし、タスク固有の設定は一回限りのシナリオを処理します。",
      "serverDefaults": {
        "heading": "サーバーデフォルト",
        "description": "/api/config/desktop-runtime-configからの共有テンプレート。ボタンラベル、テンプレート文字列、ターゲット（ターミナルまたはクリップボード）、表示条件を含みます。"
      },
      "projectOverrides": {
        "heading": "プロジェクトオーバーライド",
        "description": "SQLite project_settingsテーブルに保存されたテンプレート。チーム標準に合わせてカスタマイズするためにランタイムでサーバーデフォルトとマージされます。"
      },
      "taskSpecific": {
        "heading": "タスク固有",
        "description": "特殊なワークフロー用のtask_model_configごとのテンプレート。グローバル設定を変更せずにカスタムハンドオフパターンを有効にします。"
      }
    },
    "placeholderResolution": {
      "heading": "プレースホルダー解決",
      "description": "テンプレートはクリック時にアクティブなプランとセッションコンテキストに対して解決される二重中括弧プレースホルダーを使用します。主要なプレースホルダーは{{IMPLEMENTATION_PLAN}}と{{TASK_DESCRIPTION}}です。",
      "placeholdersHeading": "利用可能なプレースホルダー",
      "placeholders": [
        {
          "placeholder": "{{IMPLEMENTATION_PLAN}}",
          "description": "LLMによって生成された完全な実装計画内容"
        },
        {
          "placeholder": "{{TASK_DESCRIPTION}}",
          "description": "現在のセッションからのタスクの説明"
        }
      ],
      "resolutionOrder": "解決順序：最初にジョブメタデータ、次にプラン内容、次にセッションコンテキスト。未定義のプレースホルダーはデバッグのために出力に保持されます。",
      "exampleTemplate": "テンプレート例：\n\n{{IMPLEMENTATION_PLAN}}\n\n上記の実装計画を完全に理解してください。アーキテクチャ、データフロー、イベントのシーケンスを分析してください。\n\nタスク：{{TASK_DESCRIPTION}}"
    },
    "processingPipeline": {
      "heading": "テンプレート処理パイプライン",
      "description": "ボタンがクリックされると、テンプレートプロセッサは複数ステップのパイプラインを実行します：プレースホルダー抽出、コンテキスト検索、値置換、出力フォーマット。",
      "steps": [
        {
          "number": 1,
          "title": "プレースホルダー抽出",
          "description": "テンプレート文字列内の{{...}}パターンの正規表現スキャン"
        },
        {
          "number": 2,
          "title": "コンテキスト検索",
          "description": "ジョブメタデータ、プラン内容、セッション状態から値をクエリ"
        },
        {
          "number": 3,
          "title": "値置換",
          "description": "フォーマットを保持しながらプレースホルダーを解決された値に置換"
        },
        {
          "number": 4,
          "title": "出力フォーマット",
          "description": "ターゲット固有のエスケープを適用（ターミナル用シェル、クリップボード用プレーン）"
        }
      ],
      "chunking": {
        "heading": "大きなプランのチャンキング",
        "description": "100KBを超えるプランは、ターミナルバッファやクリップボード制限の過負荷を避けるために、明確な境界を持つ連続したセグメントに自動的にチャンキングされます。各チャンクにはその位置（例：'[Part 1/3]'）がプレフィックスとして付けられます。"
      }
    },
    "terminalHandoff": {
      "heading": "PTYターミナルハンドオフ",
      "description": "ターミナルハンドオフ用に設定されたボタンは、PTYセッション入力バッファに直接書き込みます。解決されたテンプレートはユーザーが入力したかのように表示され、即座にエージェント実行をトリガーします。",
      "detailsHeading": "ハンドオフの詳細",
      "details": [
        "コンテンツはmaster.take_writer()を介してPTY入力バッファに書き込まれます",
        "複数行入力とエスケープシーケンスをサポート",
        "バッファオーバーフローを避けるために大きなコンテンツは4KBセグメントにチャンキング",
        "UIは確認プレビューとして最初の100文字を表示"
      ],
      "codeExample": "// Terminal handoff implementation\nasync fn handoff_to_terminal(\n    session_id: &str,\n    content: &str,\n    template_id: &str,\n) -> Result<HandoffResult> {\n    // Get PTY writer for session\n    let writer = terminal_manager.get_writer(session_id)?;\n\n    // Write content to PTY input buffer\n    writer.write_all(content.as_bytes()).await?;\n\n    // Log the action for audit\n    copy_button_actions.insert(CopyButtonAction {\n        session_id: session_id.to_string(),\n        template_id: template_id.to_string(),\n        content_hash: sha256(content),\n        created_at: Utc::now(),\n    })?;\n\n    Ok(HandoffResult::Terminal { session_id })\n}"
    },
    "clipboardHandoff": {
      "heading": "クリップボードハンドオフ",
      "description": "クリップボード用に設定されたボタンは、Tauriクリップボードを使用して解決されたテンプレートをシステムクリップボードにコピーします。これにより、IDEターミナルやWebベースのエージェントなどの外部ツールへのハンドオフが可能になります。",
      "crossPlatform": {
        "heading": "クロスプラットフォームAPI",
        "description": "macOS、Windows、Linux間で一貫したクリップボードアクセスのためにtauri::api::clipboard::set_text()を使用します。"
      },
      "feedback": {
        "heading": "ユーザーフィードバック",
        "description": "トースト通知がコンテンツのプレビューとターゲットモデルのトークン数見積もりと共にコピーを確認します。"
      }
    },
    "defaultButtons": {
      "heading": "デフォルトコピーボタン",
      "description": "PlanToCodeには一般的なワークフローをカバーするいくつかのデフォルトコピーボタンが付属しています。これらはプロジェクト設定を通じてカスタマイズまたは拡張できます。",
      "buttonsHeading": "組み込みボタン",
      "buttons": [
        {
          "id": "parallel-agents",
          "label": "並列Claudeコーディングエージェント",
          "description": "同時に実行される並列Claudeコーディングエージェントを起動します。各エージェントは責任について明示的な指示を受け取ります。廃止された機能を完全に削除する指示が含まれます。"
        },
        {
          "id": "investigate-results",
          "label": "結果を調査",
          "description": "起動されたエージェントからの結果をレビューし、完全な実装を検証します。追加のエージェントを起動せずに、変更されたファイルを読み取り、変更を分析することでセルフチェックを実行します。"
        },
        {
          "id": "task-only",
          "label": "タスク",
          "description": "コンテキスト用にタスクの説明のみをコピーします。{{TASK_DESCRIPTION}}プレースホルダーを使用します。"
        },
        {
          "id": "task-and-plan",
          "label": "タスク + プラン",
          "description": "タスクの説明と実装計画を組み合わせます。エージェントが目標と実行戦略の両方を必要とする場合に完全なコンテキストを提供するのに便利です。"
        },
        {
          "id": "plan-only",
          "label": "プラン",
          "description": "実装計画の内容のみをコピーします。すでにタスクコンテキストを持ち、実行指示のみが必要なエージェントに最適です。"
        }
      ]
    },
    "customization": {
      "heading": "コピーボタンのカスタマイズ",
      "description": "コピーボタンは複数のレベルでカスタマイズできます：グローバルデフォルト、プロジェクトレベルのオーバーライド、タスクごとの設定。",
      "globalDefaults": {
        "heading": "グローバルデフォルト",
        "description": "/api/config/desktop-runtime-configのサーバー側設定がコピーボタンの基本セットを定義します。これらはデスクトップアプリの起動時にロードされ、オフライン使用のためにキャッシュされます。"
      },
      "projectSettings": {
        "heading": "プロジェクトレベルのカスタマイズ",
        "description": "各プロジェクトは設定パネルを通じてデフォルトボタンをオーバーライドできます。プロジェクト固有のボタンはSQLiteに保存され、ランタイムでサーバーデフォルトとマージされます。"
      },
      "taskSettings": {
        "heading": "タスクレベルの設定",
        "description": "個々のタスクは独自のコピーボタン設定を持つことができます。これにより、実装計画、コードレビュー、ドキュメントタスクに対して異なるボタンセットを使用できます。"
      },
      "editorDescription": "設定のコピーボタンエディタでは、ドラッグアンドドロップによる並べ替え、インラインラベル編集、テンプレート内容の変更が可能です。変更はデバウンスされ、自動的に永続化されます。"
    },
    "uiIntegration": {
      "heading": "UI統合と安全性",
      "description": "コピーボタンはプランビューアとターミナルヘッダーに表示されます。各ボタンは実行前に解決されたコンテンツとトークン見積もりを含むプレビューポップオーバーを表示します。",
      "tokenEstimation": {
        "heading": "トークン見積もり",
        "description": "トークン見積もりは、レビュアーがハンドオフ前にプロンプトがターゲットモデルのコンテキストウィンドウ内に収まることを検証するのに役立ちます。プレビューと共に表示されます。"
      },
      "previewModal": {
        "heading": "フルプレビューモーダル",
        "description": "プレビューアイコンをクリックすると、完全に解決されたテンプレート、シンタックスハイライト、前回の使用以降にテンプレートが変更された場合のdiffビューを含むモーダルが開きます。"
      },
      "disabledState": {
        "heading": "無効状態",
        "description": "必要なコンテキストが不足している場合（例：アクティブなプランがない、セッションがない）、ボタンは無効になります。ツールチップがボタンを有効にするために必要なコンテキストを説明します。"
      }
    },
    "auditTrail": {
      "heading": "ジョブメタデータと監査証跡",
      "description": "すべてのコピーボタンアクションは完全なトレーサビリティのためにジョブメタデータにリンクされます。監査レコードにはソースプラン、ターゲットセッション、解決されたコンテンツハッシュ、ユーザーコンテキストが含まれます。",
      "schemaHeading": "監査スキーマ",
      "schema": "-- copy_button_actions table schema\nCREATE TABLE copy_button_actions (\n    action_id    TEXT PRIMARY KEY,\n    plan_id      TEXT NOT NULL REFERENCES implementation_plans(id),\n    job_id       TEXT REFERENCES background_jobs(id),\n    session_id   TEXT REFERENCES terminal_sessions(session_id),\n    template_id  TEXT NOT NULL,\n    content_hash TEXT NOT NULL,  -- SHA-256 for integrity verification\n    created_at   TEXT NOT NULL\n);\n\n-- Query to trace plan handoffs\nSELECT * FROM copy_button_actions\nWHERE plan_id = ?\nORDER BY created_at DESC;",
      "fieldsHeading": "監査レコードフィールド",
      "fields": [
        {
          "field": "action_id",
          "description": "このハンドオフアクションの一意の識別子"
        },
        {
          "field": "plan_id",
          "description": "ソース実装計画の参照"
        },
        {
          "field": "job_id",
          "description": "該当する場合、関連するバックグラウンドジョブ"
        },
        {
          "field": "session_id",
          "description": "ターゲットターミナルセッション、またはクリップボードの場合はnull"
        },
        {
          "field": "template_id",
          "description": "使用されたテンプレート設定"
        },
        {
          "field": "content_hash",
          "description": "整合性のための解決されたコンテンツのSHA-256"
        },
        {
          "field": "created_at",
          "description": "アクションのタイムスタンプ"
        }
      ],
      "retention": "保持：監査レコードはデフォルトで90日間保持され、プロジェクト設定で変更可能です。"
    },
    "mobileIntegration": {
      "heading": "モバイル統合",
      "description": "コピーボタンはデスクトップとモバイルクライアント間で一貫した動作で機能します。iOSクライアントは同じプレースホルダー解決ロジックを使用し、リンクされたターミナルにコンテンツを送信できます。",
      "deviceLink": {
        "heading": "デバイスリンクサポート",
        "description": "モバイルデバイスがデスクトップセッションにリンクされている場合、コピーボタンはデスクトップターミナルを直接ターゲットにできます。解決されたコンテンツはデバイスリンクWebSocket接続を通じて送信されます。"
      },
      "mobileButtons": {
        "heading": "モバイル固有のボタン",
        "description": "モバイルクライアントはデスクトップと同じボタンカスタマイズをサポートします。ボタン設定はサーバーを通じて同期され、デバイス間の一貫性を維持します。"
      }
    },
    "cta": {
      "heading": "ハンドオフから実行まで追跡",
      "description": "ターミナルセッションはコピーボタン出力がどこに着地し、どのようにログされるかを表示します。",
      "terminalLink": "ターミナルセッション",
      "plansLink": "実装計画"
    }
  },
  "textImprovement": {
    "meta": {
      "title": "テキスト改善 - PlanToCode",
      "description": "デスクトップワークスペースがハイライトされたテキストを書き換え、フォーマットを保持し、音声およびビデオ入力と機能をリンクする方法。"
    },
    "category": "製品ガイド",
    "cta": {
      "description": "PlanToCodeをダウンロードして、実装計画を生成する前に音声キャプチャ、ビデオコンテキスト、インライン書き換えを組み合わせましょう。",
      "heading": "デスクトップアプリでテキスト改善を試す"
    },
    "date": "2025-09-21",
    "description": "PlanToCodeがハイライトされたテキストをフォーマットを変更せずに書き換え、結果をワークスペースにリンクする方法。",
    "intro": "AIコンテキストでテキストを洗練します。任意のエディタでテキストを選択し、バックグラウンドジョブをトリガーし、フォーマットを維持した改善されたコンテンツを取得します。",
    "metaDescription": "デスクトップワークスペースがハイライトされたテキストを書き換え、フォーマットを保持し、音声およびビデオ入力と機能をリンクする方法。",
    "metaTitle": "テキスト改善 - PlanToCode",
    "ogDescription": "テキスト改善を支える選択ポップオーバー、ジョブキュー、モデル設定、統合を理解します。",
    "ogTitle": "テキスト改善 - PlanToCode",
    "readTime": "7分",
    "selectionPopover": {
      "component": "ポップオーバー自体は{code}によってレンダリングされる最小限のコンポーネントで、プロバイダーフックをトリガーし、書き換え中はローディングインジケーターを表示します。プロバイダーがグローバルリスナーを登録するため、ポップオーバーはMonacoプランビューア、プランターミナルの音声入力フィールド、およびタスクの説明入力に追加の配線なしで表示されます。",
      "heading": "選択ポップオーバーの動作",
      "provider": "{code}は標準入力とMonacoエディタの選択イベントをリッスンします。空でないテキストをハイライトすると、カーソルの近くにポップオーバーを配置し、選択範囲を保存し、ポップオーバーを表示すべきかどうかを追跡します。ボタンをクリックするとジョブが開始され、結果が返されるまでコントロールが無効になります。ジョブが完了すると、プロバイダーは改善されたテキストを同じ選択に適用し、セッション状態を同期するために保留中の保存をフラッシュします。"
    },
    "title": "テキスト改善",
    "triggerImprovement": {
      "action": "ポップオーバーボタンを押すと{code}が呼び出されます。アクションは選択を検証し、セッション識別子が存在することを確認し、Tauriを介してRustコマンド{code}を呼び出します。コマンドは元のテキストを含む{code}を構築し、アクティブなセッションに対してバックグラウンドジョブをキューに入れます。",
      "backend": "バックエンドでは、{code}が{code}タスク用に設定されたモデルを解決し、選択をXMLタグでラップし、ストリーミングなしで{code}を通じてリクエストを実行します。モデルレスポンスが返されると、改善されたテキストをUIに発行する前にトークン使用量、コスト、システムプロンプトテンプレートを記録します。デフォルト設定ではClaude Sonnet 4.5とGemini 3 Proが承認されたモデルとして付属し、4,096トークン上限、温度0.7です。",
      "heading": "改善をトリガーしたときに何が起こるか",
      "metadata": "バックグラウンドジョブサイドバーはジョブメタデータに元のテキストを記録するので、書き換えられたコピーと一緒に送信された内容をレビューできます。ジョブの実行中に選択が変更された場合、プロバイダーは手動編集を上書きしないようにテキストの置換をスキップします。"
    },
    "videoCapture": {
      "dialog": "画面録画はビデオ分析ダイアログを通過し、現在のタスクの説明とオプションのプロンプトブロックをセマンティックXMLタグでラップしてからGeminiビデオ分析ジョブにリクエストを送信します。録画中に音声入力したメモは分析完了後にテキストとして利用でき、計画前に指示を締めるために改善ポップオーバーを通じて結果のサマリーをフィードバックできます。",
      "features": "ビデオジョブにはフレームレートコントロール、オーディオキャプチャトグル、コストレポートが含まれます。結果はテキスト改善と同じバックグラウンドジョブサイドバーに表示され、すべてのプロンプト準備アーティファクトを一箇所に保持します。",
      "heading": "ビデオキャプチャとプロンプトスキャフォールディング"
    },
    "voiceIntegration": {
      "heading": "音声文字起こし統合",
      "hook": "音声録音は{code}フックを使用します。プロジェクトごとの文字起こしデフォルトをロードし、マイクアクセスをリクエストし、タスクの説明またはターミナル音声入力バッファ内のカーソル位置にトランスクリプトを挿入します。挿入されたテキストはすぐにハイライトして同じ改善ポップオーバーを通過でき、元の文字起こしジョブ識別子は監査のために改善ペイロードと共に保存されます。",
      "preferences": "言語、モデル、温度の設定はプロジェクトレベルで永続化されるため、チームはコピーを洗練する前に一貫した文字起こし品質を得られます。無音検出は悪いオーディオレベルについて警告し、10分の上限により大きなペイロードで改善ジョブをブロックする過大な録音を防ぎます。"
    },
    "visuals": {
      "popoverFlow": {
        "title": "テキスト改善フロー",
        "description": "選択ポップオーバーが改善ジョブをトリガーし、強化されたテキストを返します。",
        "imageSrc": "/images/docs/text-improvement/flow.svg",
        "imageAlt": "テキスト改善フロー図"
      }
    }
  },
  "voiceTranscription": {
    "meta": {
      "title": "音声文字起こし - PlanToCode",
      "description": "PlanToCodeがオーディオを録音し、gpt-4o-transcribeを使用してリアルタイムトランスクリプトをストリーミングし、権限とプロジェクト設定を管理する方法。"
    },
    "category": "製品ガイド",
    "date": "2025-09-22",
    "description": "音声駆動プロンプトの録音ライフサイクル、デバイス管理、ストリーミング動作。",
    "deviceManagement": {
      "description": "機能はマイク権限をリクエストし、利用可能なオーディオ入力を列挙し、セッション中にデバイスを切り替えることができます。オーディオレベルはライブで監視され、マイクがミュートまたは切断されている場合にUIが無音警告を表示できます。",
      "heading": "デバイス管理",
      "monitoring": "リアルタイムオーディオレベル監視は録音中に視覚的フィードバックを表示します。システムは無音期間を検出し、マイクがミュートまたは切断されているように見える場合にユーザーに警告し、オーディオが文字起こしに送信される前に録音の失敗を防ぎます。"
    },
    "intro": "音声文字起こしは、プランターミナルとプロンプトエディタを含む、デスクトップアプリが音声入力コントロールを公開するどこでも利用できます。機能はオーディオをローカルで録音し、チャンクを文字起こしサービスに送信し、手動入力をブロックせずに認識されたテキストをアクティブな入力フィールドに挿入します。",
    "metaDescription": "PlanToCodeがオーディオを録音し、gpt-4o-transcribeを使用してリアルタイムトランスクリプトをストリーミングし、権限とプロジェクト設定を管理する方法。",
    "metaTitle": "音声文字起こし - PlanToCode",
    "ogDescription": "録音フックがデバイス、権限、ストリーミングテキストをどのように管理するかを学びます。",
    "ogTitle": "音声文字起こし - PlanToCode",
    "projectSettings": {
      "description": "録音セッションが開始すると、フックはアクティブなプロジェクトの文字起こし設定を検索します。言語コード、優先モデル、その他の設定はオーディオをキャプチャする前に取得され、録音がプロジェクトの設定に従うようにします。",
      "heading": "プロジェクト対応設定",
      "storage": "プロジェクト固有の文字起こし設定はSQLiteに保存され、優先モデル（gpt-4o-transcribeまたはgpt-4o-mini-transcribe）、言語コード、温度設定が含まれます。これらの設定はセッション間で永続化され、課金目的でサーバーと同期されます。"
    },
    "readTime": "5分",
    "recordingWorkflow": {
      "description": "録音フックは、アイドル、録音中、処理中、エラーの状態を持つ状態マシンを保持します。期間を追跡し、無音検出を管理し、10分後に録音が自動的に停止することを保証します。チャンクはバッファリングされ、挿入用の認識されたテキストを返す文字起こしアクションに転送されます。",
      "heading": "録音ワークフロー",
      "statesHeading": "録音状態",
      "states": [
        "idle：録音が進行中でなく、マイク権限が付与されているかどうかは不明",
        "recording：MediaRecorderを介してオーディオをアクティブにキャプチャ中、期間を追跡、視覚的フィードバックを表示",
        "processing：オーディオチャンクがサーバーに送信され、gpt-4o-transcribeからの文字起こしレスポンスを待機中",
        "error：権限拒否、デバイス切断、または文字起こしAPIエラーにより録音が失敗"
      ]
    },
    "routingBehavior": {
      "heading": "マルチデスティネーションルーティング",
      "description": "文字起こしされたテキストはアクティブなコンテキストに基づいて複数の宛先にルーティングできます。insertTranscriptコールバックは結合なしで柔軟なルーティングを可能にします。ルーティング先は監査証跡のためにジョブメタデータに保存されます。",
      "destinations": [
        "タスク説明エディタ：オプションの即時text_improvement改善付きカーソル挿入",
        "ターミナル音声入力バッファ：コマンド実行（例：'run npm test'がPTYに入力される）",
        "会議メモモード：アクション可能なタスクを生成するtask_refinementと共にSQLiteに自動保存される蓄積バッファ",
        "プロンプトエディタ：アプリケーション全体の任意のテキスト入力フィールドへの直接挿入"
      ]
    },
    "pipeline": {
      "heading": "文字起こしパイプライン",
      "hook": "{code} Reactフックは完全な録音ライフサイクルを管理します。Opusコーデック付きWebM形式でのオーディオキャプチャ用に{code}を初期化し、オーディオレベルを監視し、デバイス切り替えを処理します。",
      "command": "デスクトップアプリは{code}を呼び出してオーディオデータをサーバーエンドポイント{code}に送信します。コマンドはオーディオサイズ（最小1KB、最大25MB）、期間、温度（0.0-1.0）、プロンプト長（最大1000文字）を検証します。",
      "constraints": "オーディオファイルは1KBから25MBの間である必要があります。サポートされる形式：WAV、MP3、M4A、OGG、WebM、FLAC、AAC、MP4。文字起こしモデルは明示的に指定する必要があります - サポートされるモデルはOpenAIのgpt-4o-transcribeとgpt-4o-mini-transcribeです。"
    },
    "serverProcessing": {
      "heading": "サーバー側処理",
      "endpoint": "サーバーはマルチパートフォームデータを受け入れる{code}を公開します。モデルのプロバイダー設定に基づいてリクエストをOpenAIまたはGoogleにルーティングし、ユーザークレジットを検証し、オーディオ期間に基づいて課金を計算します。",
      "parametersHeading": "リクエストパラメータ",
      "parameters": [
        "file：オーディオファイルデータ（必須）- WAV、MP3、M4A、OGG、WebM、FLAC、AAC、またはMP4",
        "model：文字起こしモデルID（必須）- openai/gpt-4o-transcribeまたはopenai/gpt-4o-mini-transcribe",
        "duration_ms：ミリ秒単位の録音期間（課金計算に必須）",
        "language：ISO 639-1言語コード（オプション）- 特定の言語の精度を向上",
        "prompt：文字起こしのコンテキストヒント（オプション、最大1000文字）- ドメイン固有の語彙に役立つ",
        "temperature：サンプリング温度0.0-1.0（オプション、デフォルト0.0）- 低い値はより決定論的な出力を生成"
      ]
    },
    "dataFlow": {
      "heading": "データフロー",
      "description": "オーディオデータはブラウザからTauriコマンドレイヤーを通じてサーバーに流れ、サーバーは適切な文字起こしプロバイダーにリクエストをプロキシします。",
      "stepsHeading": "処理ステップ",
      "steps": [
        "ブラウザMediaRecorderがWebM/Opus形式でオーディオチャンクをキャプチャ",
        "useVoiceTranscriptionフックがチャンクをバッファリングし期間を監視",
        "停止時、オーディオblobがバイトに変換されtranscribe_audio_commandを介して送信",
        "Tauriコマンドがオーディオサイズ、期間、パラメータを検証",
        "リクエストが認証トークンと共にサーバー/api/audio/transcriptionsエンドポイントに送信",
        "サーバーがユーザークレジットを検証しOpenAIまたはGoogleプロバイダーにルーティング",
        "プロバイダーが文字起こしテキストを返し、サーバーが使用量をログしクレジットを差し引く",
        "文字起こしテキストがデスクトップに返されコールバックを介して挿入"
      ]
    },
    "keyFiles": {
      "heading": "主要な実装ファイル",
      "items": [
        "desktop/src/hooks/useVoiceTranscription.ts",
        "desktop/src-tauri/src/commands/audio_commands.rs",
        "server/src/handlers/proxy/specialized/transcription.rs",
        "server/src/clients/openai/transcription.rs",
        "server/src/clients/google/transcription.rs"
      ]
    },
    "examples": {
      "heading": "使用例",
      "description": "一般的な音声文字起こしワークフローはシステムの柔軟性を示しています：",
      "items": [
        "スプリント計画：タスク説明を生成するためにtask_refinementにパイプされた文字起こし付きの会議録音",
        "ターミナルコマンド：音声入力が文字起こしされ、実行のためにPTYに直接入力",
        "バグレポート：口頭での説明がキャプチャされ、text_improvementで洗練され、task_refinementで処理",
        "アーキテクチャディスカッション：文字起こし用にオーディオトラックが抽出されたビデオ録画、ビジョン分析と組み合わせ"
      ]
    },
    "cta": {
      "heading": "探索を続ける",
      "description": "文字起こしされたテキストをどのように洗練し、会議録音がアクション可能なタスクに処理されるかを学びます。",
      "links": {
        "textImprovement": "テキスト改善",
        "meetingIngestion": "会議の取り込み"
      }
    },
    "title": "音声文字起こし",
    "visuals": {
      "recordingFlow": {
        "title": "音声文字起こしパイプライン",
        "description": "オーディオキャプチャ、GPT-4o文字起こし処理、テキストルーティングフロー。",
        "imageSrc": "/images/docs/voice-transcription/pipeline.svg",
        "imageAlt": "音声文字起こしパイプライン図",
        "caption": "オーディオはブラウザキャプチャからTauriコマンドを通じてサーバー側GPT-4o文字起こしに流れます。"
      }
    }
  },
  "overview": {
    "meta": {
      "title": "システム概要 - PlanToCode",
      "description": "ここから始めましょう：PlanToCodeの機能、コアループの仕組み、リポジトリ内の各コンポーネントの配置。"
    },
    "category": "概要",
    "date": "2025-09-25",
    "readTime": "15分",
    "title": "システム概要",
    "description": "システム、コアループ、必要な依存関係の簡潔なマップ。",
    "intro": "PlanToCodeは、実行前にコード変更を計画・検証するデスクトップワークスペースです。ローカルのRustジョブエンジン、React UI、LLM呼び出し用のサーバープロキシを調整します。システムはオフラインファーストアーキテクチャに従い、デスクトップアプリはローカル状態にSQLiteを使用して独立して動作し、サーバーは認証、LLMプロバイダールーティング、課金を処理します。外部LLMプロバイダーがAPIキーで設定されていない場合、計画と分析パイプラインは実行されません。",
    "visuals": {
      "systemMap": {
        "title": "システムマップ",
        "description": "デスクトップアプリ、Rustコア、ローカルSQLiteストレージ、サーバープロキシのマップ。",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "PlanToCodeシステムマップ図",
        "caption": "データが下に流れ、イベントが上にストリーミングされる4層アーキテクチャ。"
      }
    },
    "systemLayers": {
      "heading": "システムレイヤー",
      "description": "システムは、明確に定義されたインターフェースを通じて通信する4つの異なるレイヤーに編成されています：",
      "items": [
        "プレゼンテーションレイヤー：Monacoエディタ、ターミナルパネル、ワークフローコントロールを備えたReact UI（desktop/src/）",
        "コマンドレイヤー：ReactとRustを橋渡しし、IPCと状態管理を処理するTauriコマンド（desktop/src-tauri/src/commands/）",
        "処理レイヤー：Rustでのジョブプロセッサ、ワークフローオーケストレーター、ビジネスロジック（desktop/src-tauri/src/jobs/）",
        "永続化レイヤー：ローカル状態用のSQLiteリポジトリと認証/課金用のサーバーPostgreSQL（desktop/src-tauri/src/db_utils/）"
      ]
    },
    "coreLoop": {
      "heading": "実践におけるコアループ",
      "description": "すべてのタスクはキャプチャから実行まで明確に定義されたライフサイクルを流れます：",
      "steps": [
        "テキスト、音声文字起こし（useVoiceTranscriptionフック経由）、またはビデオ録画分析からタスクをキャプチャ。",
        "TextImprovementProcessorを通じてtext_improvementジョブでタスクの説明と目標を洗練。",
        "ファイル検出ワークフローを実行：RootFolderSelectionProcessorがディレクトリを選択、RegexFileFilterProcessorがパターンを適用、FileRelevanceAssessmentProcessorが内容をスコアリング、ExtendedPathFinderProcessorがコンテキストを拡張。",
        "ImplementationPlanProcessorを介して実装計画を生成し、XML形式のプランをMonacoビューアにストリーミング。",
        "オプションで、XMLタグ付きソースプランを使用してImplementationPlanMergeProcessorで複数のプランドラフトをマージ。",
        "PTYターミナルセッションまたは外部エージェント用のコピーボタンテンプレートを通じて承認されたプランを実行またはエクスポート。",
        "監査可能性のためにすべてのジョブ、アーティファクト、ターミナルログをSQLite（background_jobs、terminal_sessionsテーブル）に永続化。"
      ]
    },
    "components": {
      "heading": "主要コンポーネント",
      "description": "各コンポーネントには特定の責任があり、型付きインターフェースを通じて通信します：",
      "items": [
        "デスクトップUI（React）：desktop/src/内にMonacoプランビュー、ターミナルパネル、プロバイダー（SessionProvider、TextImprovementProvider）。",
        "Rustコア（Tauri v2）：desktop/src-tauri/内でコマンド、ジョブ、永続化を機能ベースのパーミッションで処理。",
        "ローカルSQLiteスキーマ：並行アクセス用のWALモードを持つdesktop/src-tauri/migrations/consolidated_schema.sql。",
        "サーバープロキシ（Actix-Web）：認証、プロバイダールーティング、ストリーミングレスポンス、Stripe経由の課金用にserver/src/内。",
        "モバイルiOSクライアント：SwiftUIインターフェース、Auth0 PKCE、WebSocketデバイスリンクを持つmobile/ios/Core/内。",
        "インフラ自動化：Hetzner（EU）とInterServer（US）専用サーバー用のinfrastructure/ansible/内。"
      ]
    },
    "dependencies": {
      "heading": "必要な依存関係",
      "description": "システムには以下の外部サービスとリソースが必要です：",
      "items": [
        "プラン生成、文字起こし、分析用の外部LLMプロバイダー（OpenAI、Anthropic、Google、X.AI、OpenRouter）。",
        "デスクトップとモバイルセッション用のPKCEフローを持つAuth0ベースの認証。",
        "サーバー側のユーザーアカウント、課金状態、ジョブキュー用のPostgreSQL 17とRedis 7+（セルフホストデプロイメント）。",
        "ファイル検出ワークフロー用のgit ls-filesまたはディレクトリトラバーサルによるローカルファイルシステムアクセス。",
        "音声入力処理用のWhisper互換文字起こしエンドポイント。"
      ]
    },
    "codeMap": {
      "heading": "リポジトリ内の動作の場所",
      "description": "主要なディレクトリとファイルへのクイックリファレンス：",
      "items": [
        "Tauriコマンド：desktop/src-tauri/src/commands/（35以上のコマンドモジュール：job_commands.rs、workflow_commands.rs、terminal_commands.rs、session_commands.rs、auth0_commands.rs）",
        "ワークフローオーケストレーション：desktop/src-tauri/src/jobs/workflow_orchestrator/（definition_loader.rs、stage_scheduler.rs、event_emitter.rs、payload_builder.rs）",
        "ジョブプロセッサ：desktop/src-tauri/src/jobs/processors/（implementation_plan_processor.rs、text_improvement_processor.rs、root_folder_selection_processor.rs）",
        "SQLiteリポジトリ：desktop/src-tauri/src/db_utils/（background_job_repository/、session_repository.rs、terminal_repository.rs）",
        "サーバールート：server/src/routes.rs（configure_routes、configure_public_auth_routes、configure_webhook_routes）",
        "LLMプロキシハンドラー：server/src/handlers/proxy_handlers.rsとserver/src/handlers/proxy/（router.rs、providers/）",
        "プロバイダートランスフォーマー：server/src/handlers/provider_transformers/（openai.rs、google.rs、anthropic.rs、xai.rs）",
        "iOSワークフロー：MobileSessionManagerとAPIClientを持つmobile/ios/Core/Sources/Workflows/WorkflowManager.swift",
        "インフラプレイブック：infrastructure/ansible/site-base.yml（強化、PostgreSQL、Redis）とsite-app.yml（デプロイメント）"
      ]
    },
    "keyAbstractions": {
      "heading": "主要な抽象化",
      "description": "これらのコア概念を理解することでコードベースのナビゲーションが容易になります：",
      "items": [
        "セッション：task_description、included_files、モデル設定を持つsessionsテーブルに保存されたプロジェクトコンテキスト。UUIDで識別。",
        "バックグラウンドジョブ：task_type、プロンプト、レスポンス、トークン追跡、コストを持つbackground_jobsテーブルに保存されたLLMバックアップ操作。",
        "ワークフロー：ステージ間でIntermediateDataを渡すWorkflowOrchestratorによって調整される多段階オーケストレーションプロセス（例：file_finder_workflow）。",
        "ターミナルセッション：監査用のオプションのjob_idリンクを持つoutput_log、statusを含むterminal_sessionsに保存されたPTYプロセス。",
        "プロバイダー：リクエスト変換とレスポンス正規化を持つserver/src/handlers/proxy/providers/内のLLMサービス抽象化。"
      ]
    },
    "dataFlowSummary": {
      "heading": "データフローサマリー",
      "description": "典型的な計画タスクでデータがシステムをどのように移動するか：",
      "items": [
        "ユーザー入力はReactコンポーネントを通じて入り、@tauri-apps/api/core invoke()を介してTauriコマンドに流れます。",
        "コマンドはbackground_jobsレコードを作成し、ジョブキューを介してジョブプロセッサにディスパッチします。",
        "プロセッサはプロンプトを構築し、サーバーLLMプロキシを通じてリクエストを送信し、Tauriイベントを介してレスポンスをストリーミングします。",
        "レスポンスはSQLiteに保存され、UI状態を更新するReactプロバイダーに発行されます。",
        "ターミナル実行はPTY出力をUIにストリーミングし、セッションリカバリ用にログを永続化します。"
      ]
    }
  },
  "runtimeWalkthrough": {
    "meta": {
      "title": "ランタイムウォークスルー - PlanToCode",
      "description": "入力からプラン出力までのタスクのエンドツーエンドタイムライン、ジョブタイプとアーティファクトフローを含む。"
    },
    "category": "アーキテクチャ",
    "date": "2025-09-25",
    "readTime": "12分",
    "title": "ランタイムウォークスルー",
    "description": "タスク入力からプラン出力までのエンドツーエンドランタイムタイムライン。",
    "intro": "このウォークスルーは、初期キャプチャからファイル検出、プラン生成、ターミナル実行までの単一タスクを追跡します。各ステージは特定のジョブタイプにマップされ、SQLiteに保存されるアーティファクトを生成します。",
    "visuals": {
      "timeline": {
        "title": "ランタイムタイムライン",
        "description": "タスク入力、ワークフローステージ、プラン出力を示すビジュアルタイムライン。",
        "imageSrc": "/images/docs/runtime-walkthrough/timeline.svg",
        "imageAlt": "ランタイムタイムライン図",
        "caption": "タスク実行は6つのステージを流れ、すべてのアーティファクトはSQLiteに永続化されます。"
      },
      "walkthroughVideo": {
        "title": "ランタイムウォークスルービデオ",
        "description": "入力からプラン出力までの完全なタスク実行のビデオデモンストレーション。",
        "videoSrc": "",
        "posterSrc": "",
        "caption": "ビデオウォークスルーのプレースホルダー - 完全な計画ワークフローのデモンストレーションを録画してください。"
      }
    },
    "timeline": {
      "heading": "ハイレベルランタイムシーケンス",
      "description": "完全なタスク実行は次の操作シーケンスに従います：",
      "steps": [
        "ユーザーがTaskDescriptionEditorコンポーネントを介してデスクトップUIでタスクの説明を入力または音声入力。",
        "オプション：text_improvementジョブがTextImprovementProcessorを通じて生の入力を洗練。",
        "ユーザーが実装計画パネルのstart_file_finder_workflowコマンドを介してファイル検出ワークフローをトリガー。",
        "desktop/src-tauri/src/jobs/workflow_orchestrator/のWorkflowOrchestratorがワークフローレコードを作成しステージ1をスケジュール。",
        "ステージ1（root_folder_selection）：RootFolderSelectionProcessorがディレクトリツリーをLLMに送信、選択されたルートをIntermediateData.selectedRootsに保存。",
        "ステージ2（regex_file_filter）：RegexFileFilterProcessorがパターンを生成、git ls-filesを実行、マッチをIntermediateData.locallyFilteredFilesに保存。",
        "ステージ3（file_relevance_assessment）：FileRelevanceAssessmentProcessorがファイル内容をチャンキング、関連性をスコアリング、IntermediateData.aiFilteredFilesに保存。",
        "ステージ4（extended_path_finder）：ExtendedPathFinderProcessorがインポートと依存関係でコンテキストを拡張、IntermediateData.verifiedPathsに保存。",
        "UIがevent_emitter.rs経由でworkflow-completedイベントを受信、ファイル選択表示を更新。",
        "ユーザーがgenerate_implementation_planコマンドを介して選択されたファイルでプラン生成をトリガー。",
        "desktop/src-tauri/src/jobs/processors/implementation_plan_processor.rsのImplementationPlanProcessorがjob:stream-progressイベントを介してXMLプラン内容をMonacoビューアにストリーミング。",
        "ユーザーがVirtualizedCodeViewerコンポーネントでプランをレビュー、直接編集またはマージをリクエスト可能。",
        "承認されたプランがコピーボタンテンプレートを介してターミナルにコピーされるか、外部エージェント用にエクスポート。",
        "terminal_commands.rsのターミナルセッションがPTY出力をキャプチャし、エージェント注意状態を検出。",
        "すべてのアーティファクトが監査とセッションリカバリのためにSQLiteのbackground_jobsとterminal_sessionsテーブルに永続化。"
      ]
    },
    "jobTypes": {
      "heading": "ランタイムでのジョブタイプ",
      "description": "各task_typeは特定のプロセッサにマップされ、異なるアーティファクトを生成します：",
      "items": [
        "text_improvement：TextImprovementProcessorがテキストをXMLでラップし、LLMに送信、洗練されたテキストを返す。background_jobs.responseに保存。",
        "root_folder_selection：RootFolderSelectionProcessorがディレクトリツリーを受信、選択されたディレクトリのJSON配列を返す。",
        "regex_file_filter：RegexFileFilterProcessorがタスクの説明からパターンを生成、gitファイルリストに適用。",
        "file_relevance_assessment：FileRelevanceAssessmentProcessorがファイル内容をロード、トークン制限でチャンキング、関連性をスコアリング。",
        "extended_path_finder：ExtendedPathFinderProcessorがインポート/依存関係を分析、関連ファイルでコンテキストを拡張。",
        "implementation_plan：ImplementationPlanProcessorがplan_step要素を持つXML形式のプランをストリーミング。",
        "implementation_plan_merge：ImplementationPlanMergeProcessorがsource_plans XMLタグとユーザー指示を使用してプランを結合。",
        "video_analysis：フレームサンプリングを使用して/api/llm/video/analyzeエンドポイント経由で画面録画を処理。",
        "web_search_prompts_generation：ディープリサーチワークフロー用のresearch_task XMLブロックを生成。",
        "web_search_execution：調査プロンプトを並列実行、結果を集約。"
      ]
    },
    "inputCapture": {
      "heading": "タスク入力のキャプチャ",
      "description": "タスクは複数の入力サーフェスからシステムに入ります：",
      "text": "タスク説明はTaskDescriptionEditorに入力または貼り付けされ、sessions.task_descriptionに永続化され、マルチデバイス同期用のdevice_idを含むtask_description_historyテーブルに履歴エントリが作成されます。",
      "voice": "音声入力はuseVoiceTranscriptionフックを使用し、MediaRecorder APIで録音し、/api/audio/transcriptionsに送信し、カーソル位置に挿入します。",
      "video": "ビデオ分析はVideoAnalysisDialogを使用して画面録画をキャプチャし、/api/llm/video/analyzeにアップロードし、UI状態の観察を抽出します。"
    },
    "workflowExecution": {
      "heading": "ワークフロー実行の詳細",
      "description": "WorkflowOrchestratorが複数ステージのワークフローを調整します：",
      "scheduling": "workflow_lifecycle_manager.rsがワークフローレコードを作成し、stage_scheduler.rsがワークフローJSON定義に基づいてステージを順次ディスパッチします。",
      "data": "workflow_types.rsのIntermediateData構造体がステージ間で出力を渡します：selectedRoots、rawRegexPatterns、locallyFilteredFiles、aiFilteredFiles、verifiedPaths。",
      "events": "event_emitter.rsがworkflow-statusとworkflow-stage Tauriイベントを発行し、React UIのWorkflowTrackerが消費します。"
    },
    "persistence": {
      "heading": "状態の永続化",
      "description": "すべてのアーティファクトは監査とリカバリのために永続化されます：",
      "jobs": "background_job_repository/がsession_id、task_type、status、prompt、response、tokens_sent/received、actual_costを含むジョブレコードを保存します。",
      "sessions": "session_repository.rsがtask_description、included_files、model_used、履歴バージョンを含むsessionsテーブルを管理します。",
      "terminals": "terminal_repository.rsがセッションリカバリ用のoutput_log、status、exit_code、working_directoryを含むterminal_sessionsを永続化します。",
      "rehydration": "アプリ再起動時、Rustコアがsqliteからセッション状態を復元し、古い実行中ジョブを失敗としてマークし、ターミナル出力ログを復元します。"
    },
    "inputs": {
      "heading": "タスク入力のキャプチャ",
      "capture": "タスクは複数の入力サーフェスからシステムに入ります：TaskDescriptionEditorでの入力テキスト、useVoiceTranscriptionフック経由の音声ディクテーション、またはVideoAnalysisDialog経由のビデオ分析。",
      "artifacts": "各入力タイプはSQLiteに保存されるアーティファクトを生成します - sessionsテーブルのtask_description、background_jobsの文字起こし結果、関連するジョブメタデータのビデオフレーム。"
    },
    "refinement": {
      "heading": "入力の洗練",
      "jobs": "text_improvementジョブタイプはTextImprovementProcessorを通じて生の入力を洗練し、テキストをXMLでラップしてLLMに送信し、文法、明確さ、構造の改善を行います。",
      "storage": "洗練されたテキストはbackground_jobs.responseに保存され、Reactプロバイダー経由でsessions.task_descriptionを更新できます。"
    },
    "discovery": {
      "heading": "ファイル検出ワークフロー",
      "workflow": "FileFinderWorkflowは4つの連続ステージを実行します：root_folder_selectionがディレクトリを絞り込み、regex_file_filterがパターンを適用し、file_relevance_assessmentがコンテンツをスコアリングし、extended_path_finderが依存関係で拡張します。",
      "outputs": "各ステージは結果をプロセッサ間で渡されるIntermediateData構造体に保存し、最終的なファイル選択はsessions.included_filesに永続化されます。"
    },
    "planGeneration": {
      "heading": "計画生成",
      "jobs": "implementation_planジョブタイプはImplementationPlanProcessorを使用して、ファイルパス、操作タイプ、コード変更を含むplan_step要素を持つXMLフォーマットの計画を生成します。",
      "streaming": "計画コンテンツはjob:stream-progress Tauriイベント経由でUIにストリーミングされ、シンタックスハイライト付きでVirtualizedCodeViewer Monacoコンポーネントに表示されます。"
    },
    "merge": {
      "heading": "計画のマージ",
      "instructions": "implementation_plan_mergeジョブはsource_plans XMLタグとユーザー提供のマージ指示を使用して複数の計画を結合し、競合を解決して変更を統合します。",
      "outputs": "マージされた計画はソース計画へのトレーサビリティを維持し、最終的なbackground_jobsレコードにmerged_fromメタデータを含みます。"
    },
    "review": {
      "heading": "計画のレビュー",
      "editor": "計画はレビュー用にMonacoベースのVirtualizedCodeViewerで開きます。ユーザーは計画テキストを直接編集し、修正をリクエストし、実行を承認できます。",
      "audit": "すべてのレビューアクションはタイムスタンプとユーザーコンテキスト付きでログに記録され、計画の進化の監査証跡を提供します。"
    },
    "execution": {
      "heading": "実行ハンドオフ",
      "terminal": "承認された計画はコピーボタンテンプレート経由で統合ターミナルにコピーされるか、Claude Code、Cursor、Codexなどの外部エージェント用にエクスポートされます。",
      "logging": "terminal_commands.rsのターミナルセッションはPTY出力をキャプチャし、エージェント注意状態を検出し、すべての実行アクティビティをterminal_sessionsテーブルにログ記録します。"
    },
    "state": {
      "heading": "状態の永続化",
      "jobs": "すべてのジョブアーティファクトはsession_id、task_type、status、prompt、response、トークン数、コスト追跡を含むbackground_jobsテーブルに永続化されます。",
      "rehydration": "アプリ再起動時、RustコアがSQLiteからセッション状態を復元し、古い実行中ジョブを失敗としてマークし、ターミナル出力ログを復元します。"
    },
    "jobMap": {
      "heading": "ジョブタイプマッピング",
      "items": [
        "text_improvement → TextImprovementProcessor → 洗練されたタスク説明",
        "root_folder_selection → RootFolderSelectionProcessor → 選択されたディレクトリ",
        "regex_file_filter → RegexFileFilterProcessor → パターンマッチしたファイル",
        "file_relevance_assessment → FileRelevanceAssessmentProcessor → スコアリングされたファイル",
        "extended_path_finder → ExtendedPathFinderProcessor → 拡張されたコンテキスト",
        "implementation_plan → ImplementationPlanProcessor → XML計画ドキュメント",
        "implementation_plan_merge → ImplementationPlanMergeProcessor → マージされた計画"
      ]
    },
    "cta": {
      "heading": "アーキテクチャを探索",
      "description": "コンポーネントがどのように組み合わさっているかを詳細に理解しましょう。",
      "links": {
        "architecture": "アーキテクチャ概要",
        "jobs": "バックグラウンドジョブ",
        "desktop": "デスクトップアプリの内部",
        "dataModel": "データモデル",
        "plans": "実装計画"
      }
    }
  },
  "desktopApp": {
    "meta": {
      "title": "デスクトップアプリの内部 - PlanToCode",
      "description": "Tauriデスクトップシェル、Rustコマンドレイヤー、SQLite永続化、PTYセッションがどのように連携するかを解説します。"
    },
    "category": "デスクトップ",
    "date": "2025-09-25",
    "readTime": "14分",
    "title": "デスクトップアプリの内部",
    "description": "Tauri v2シェル、Rustコマンドレイヤー、PTYセッション、UI状態管理。",
    "intro": "デスクトップアプリはReact UIを実行するTauri v2シェル（バージョン2.9.1）です。Rustサービスがワークフロー、ターミナルセッション、設定用のコマンドを公開し、SQLiteにローカルで状態を永続化します。機能ベースの権限モデルが、ファイルシステムアクセス、HTTPリクエスト、シェル実行、システム通知に対するきめ細かいセキュリティ制御を提供します。",
    "visuals": {
      "shell": {
        "title": "デスクトップシェル概要",
        "description": "計画エディター、ターミナルタブ、ジョブステータスサイドバーを示すスクリーンショット。",
        "imageSrc": "/assets/images/demo-implementation-plans.jpg",
        "imageAlt": "PlanToCodeデスクトップシェル",
        "caption": "実装計画パネルとサイドバーを表示するデスクトップアプリ。"
      }
    },
    "projectLayout": {
      "heading": "プロジェクトレイアウト",
      "description": "デスクトップアプリケーションは標準的なTauri v2構造に従います：",
      "items": [
        "desktop/src/：React UIコンポーネント、フック、プロバイダー、デスクトップ固有のアダプター。",
        "desktop/src-tauri/：コマンド、ジョブ、リポジトリ、サービスを含むRustコア。",
        "desktop/src-tauri/src/lib.rs：プラグイン登録とAppState管理を含むアプリケーションエントリポイント。",
        "desktop/src-tauri/src/commands/：ドメイン別に整理された35以上のTauriコマンドハンドラーモジュール。",
        "desktop/src-tauri/src/jobs/：バックグラウンドジョブプロセッサ、ワークフローオーケストレーション、キュー管理。",
        "desktop/src-tauri/capabilities/：セキュリティ権限用のJSON機能定義（default.json、desktop-default.json、plantocode-api.json）。",
        "desktop/src-tauri/migrations/：consolidated_schema.sqlのSQLiteスキーママイグレーション。"
      ]
    },
    "ui": {
      "heading": "React UIとサーフェスエリア",
      "description": "React UIはタスク説明エディター、計画ビューア、ターミナルパネルをレンダリングします：",
      "components": [
        "TaskDescriptionEditor：音声文字起こし統合とテキスト改善ポップオーバーを備えた複数行入力。",
        "VirtualizedCodeViewer：シンタックスハイライトとコピーアクションを備えたMonacoベースの計画表示。",
        "TerminalSurface：接続ステータス、エージェント注意インジケーター、音声入力を備えたPTY出力バッファ。",
        "SessionProvider：アクティブセッション、ファイル選択、モデル設定のグローバル状態管理。",
        "TextImprovementProvider：インラインリライト用の選択リスナーとポップオーバー配置。",
        "WorkflowTracker：複数ステージワークフローのリアルタイム進捗表示。"
      ]
    },
    "commands": {
      "heading": "Tauriコマンド",
      "description": "desktop/src-tauri/src/commands/のコマンドがRust機能をReact UIに公開します。主要モジュール：",
      "modules": [
        "job_commands.rs：create_job、get_job、cancel_job、get_jobs_for_session、clear_job_history。",
        "workflow_commands.rs：start_file_finder_workflow、get_workflow_status、retry_workflow、pause_workflow、resume_workflow。",
        "terminal_commands.rs：create_terminal_session、send_terminal_input、resize_terminal、get_terminal_output、check_cli_availability。",
        "session_commands.rs：create_session、get_session、update_session、sync_task_description_history、sync_file_selection_history。",
        "auth0_commands.rs：initiate_login、complete_login、refresh_token、logout、get_user_info。",
        "implementation_plan_commands.rs：generate_implementation_plan、merge_implementation_plans、estimate_tokens。",
        "config_commands.rs：get_runtime_config、get_model_config、get_system_prompts、refresh_config_cache。",
        "settings_commands.rs：get_setting、set_setting、get_project_system_prompt、set_project_system_prompt。"
      ]
    },
    "appState": {
      "heading": "AppState管理",
      "description": "RustコアがTauriの状態システムを通じてアプリケーション状態を管理します：",
      "structure": "lib.rsのAppState構造体が保持：config_load_error (Option<String>)、HTTPクライアント (reqwest::Client)、Mutex背後のRuntimeConfig（サーバーURL、オンボーディングステータス）、認証用のAuth0State。",
      "config": "RuntimeConfigにはserver_url、onboarding_completeフラグが含まれ、set_runtime_configコマンドで更新されます。ConfigCacheはプロジェクトごとのオーバーライド付きでランタイムAI設定を保存します。",
      "tokens": "TokenManagerはOSキーリング（keyringクレート経由）を使用してaccess_token、refresh_token、jwtを安全に保存し、有効期限前に自動更新します。"
    },
    "jobs": {
      "heading": "ジョブプロセッサとワークフロー",
      "description": "desktop/src-tauri/src/jobs/のジョブ処理アーキテクチャ：",
      "queue": "queue.rsがインメモリの保留ジョブとSQLite永続化でジョブキューを管理。ジョブは次のステータスを遷移：idle、created、queued、acknowledged_by_worker、preparing、preparing_input、running、generating_stream、processing_stream、completed、failed、canceled。",
      "processors": "processors/ディレクトリにタスク固有のプロセッサを含む：ImplementationPlanProcessor（ストリーミング計画）、TextImprovementProcessor（インラインリライト）、RootFolderSelectionProcessor、RegexFileFilterProcessor、FileRelevanceAssessmentProcessor、ExtendedPathFinderProcessor。",
      "orchestrator": "workflow_orchestrator/が複数ステージワークフローを調整：definition_loader.rsがJSONワークフロー定義をロード、stage_scheduler.rsがステージをディスパッチ、payload_builder.rsが入力を構築、event_emitter.rsが進捗イベントを発行。",
      "streaming": "processors/generic_llm_stream_processor.rsがストリーミングLLMレスポンスを処理し、job:stream-progressイベントを発行してbackground_jobs.responseにコンテンツを蓄積。"
    },
    "persistence": {
      "heading": "ローカル永続化",
      "description": "desktop/src-tauri/migrations/consolidated_schema.sqlのSQLiteストレージ：",
      "tables": [
        "sessions：id (UUID)、name、project_directory、project_hash、task_description、included_files、force_excluded_files、model_used、履歴バージョン。",
        "background_jobs：id (UUID)、session_id (FK)、task_type、status、prompt、response、tokens_sent/received、cache_read/write_tokens、actual_cost、metadata (JSON)、server_request_id。",
        "terminal_sessions：id、job_id (nullable FK)、session_id、status、process_pid、output_log、working_directory、environment_vars、last_output_at。",
        "task_description_history：session_id (FK)、description、device_id、sequence_number、マルチデバイス同期用のversion。",
        "file_selection_history：session_id (FK)、included_files、force_excluded_files、device_id、sequence_number。",
        "project_system_prompts：project_hash、task_type、プロジェクトごとのプロンプトオーバーライド用のsystem_prompt。",
        "key_value_store：key、value (JSON)、アプリ設定用のupdated_at。",
        "error_logs：timestamp、level、error_type、message、context、stack、クライアントサイドエラー追跡用のmetadata。"
      ],
      "repositories": "db_utils/のリポジトリが型付きアクセスを提供：background_job_repository/（base.rs、worker.rs、metadata.rs、cleanup.rsでモジュール化）、session_repository.rs、terminal_repository.rs、settings_repository.rs、error_log_repository.rs。"
    },
    "terminal": {
      "heading": "ターミナルセッション",
      "description": "PTYターミナル実装：",
      "commands": "terminal_commands.rsがセッションライフサイクルを管理：create_terminal_sessionがportable-ptyクレート経由でPTYを生成、send_terminal_inputがキーストロークを転送、resize_terminalがサイズを調整、check_cli_availabilityがツールの存在を確認（claude、cursor、codex、gemini）。",
      "persistence": "terminal_repository.rsがoutput_log（蓄積されたターミナル出力）、status（idle/running/completed/failed/agent_requires_attention）、exit_code、working_directoryを含むセッションを永続化。アプリ再起動後にセッションを復元可能。",
      "attention": "エージェント注意検出がlast_output_atタイムスタンプを監視。レベル1（30秒アイドル）：黄色インジケーター。レベル2（2分アイドル）：デスクトップ通知付きの赤インジケーター。"
    },
    "inputStability": {
      "heading": "タスク説明の安定性",
      "description": "タスク説明エディターにはカーソルジャンプを防ぐセーフガードが含まれます：",
      "items": [
        "ユーザー入力中はリモート更新がキューに入れられ、アイドルまたはブラー時にフラッシュされます。",
        "選択状態はReact再レンダリング後に追跡および復元されます。",
        "バックグラウンドライターはsessionActions.updateCurrentSessionFieldsを呼び出して更新を調整します。",
        "マルチデバイス同期はsequence_numberとversionフィールドを使用して競合を解決します。"
      ]
    },
    "plugins": {
      "heading": "Tauriプラグイン",
      "description": "PlanToCodeはTauri v2プラグインエコシステムを使用します：",
      "list": [
        "tauri-plugin-http (2.5.2)：APIコール用のCSP対応フェッチを備えたHTTPクライアント。",
        "tauri-plugin-dialog (2.4.2)：ネイティブファイル/フォルダーピッカーとメッセージダイアログ。",
        "tauri-plugin-shell (2.3.3)：外部CLIツール用のシェルコマンド実行。",
        "tauri-plugin-store (2.4.1)：アプリ設定用の永続的キーバリューストレージ。",
        "tauri-plugin-notification (2.3.0)：エージェント注意用のデスクトップ通知。",
        "tauri-plugin-updater (2.9.0)：署名検証付きのアプリ内更新。",
        "tauri-plugin-single-instance (2.3.4)：シングルインスタンス強制。",
        "tauri-plugin-process (2.3.1)：プロセス再起動機能。"
      ]
    }
  },
  "serverApi": {
    "meta": {
      "title": "サーバーAPIとLLMプロキシ - PlanToCode",
      "description": "デスクトップおよびモバイルクライアントが使用する認証、プロバイダールーティング、モデル設定、WebSocketエンドポイント。"
    },
    "category": "サーバー",
    "date": "2025-09-25",
    "readTime": "12分",
    "title": "サーバーAPI & LLMプロキシ",
    "description": "認証、プロバイダールーティング、モデル設定、課金、WebSocketエンドポイント。",
    "intro": "サーバーは認証、モデル設定、LLMプロキシ、課金を提供するRustで書かれたActix-Webサービスです。デスクトップおよびモバイルクライアントは、安全なプロバイダールーティングとストリーミングレスポンスのためにこれに依存しています。サーバーは2つのリージョンの専用インフラストラクチャで稼働しています：Hetzner（EU）はapi-eu.plantocode.com、InterServer（US）はapi-us.plantocode.com。",
    "visuals": {
      "flow": {
        "title": "サーバーリクエストフロー",
        "description": "クライアント、APIルート、LLMプロキシを示す図。",
        "imageSrc": "/images/docs/provider-routing/routing-map.svg",
        "imageAlt": "サーバーリクエストフロー図",
        "caption": "サーバーリクエストフローのプレースホルダー。"
      }
    },
    "routeOrganization": {
      "heading": "ルート構成",
      "description": "ルートはserver/src/routes.rsで3つの設定関数で整理されています：",
      "functions": [
        "configure_routes()：/apiスコープ下のJWT認証ルート。auth、billing、config、providers、models、llm proxy、audio、system-prompts、consent、devices、notificationsを含む。",
        "configure_public_auth_routes()：/authスコープ下のブラウザベース認証フロー。Auth0 initiate-login、callback、logged-outルートを含む。",
        "configure_webhook_routes()：/webhooksスコープ下の未認証webhookエンドポイント。現在Stripe webhooksを処理。"
      ]
    },
    "auth": {
      "heading": "認証エンドポイント",
      "description": "認証はAuth0とPKCEフローを使用します：",
      "routes": [
        "/auth/auth0/initiate-login (GET)：code_challengeでOAuthフローを開始し、Auth0にリダイレクト。",
        "/auth/auth0/callback (GET)：Auth0リダイレクトを処理し、コードをトークンと交換。",
        "/api/auth/userinfo (GET)：Auth0から認証済みユーザー情報を返す。",
        "/api/auth/logout (POST)：トークンを取り消しセッションをクリア。",
        "/api/auth/account (DELETE)：カスケードクリーンアップ付きのアカウント削除。",
        "/api/auth0/refresh-app-token (POST)：リフレッシュトークンを使用してアクセストークンを更新。"
      ],
      "implementation": "認証ハンドラーはserver/src/handlers/auth0_handlers.rsとserver/src/handlers/auth/にあります。JWT検証はJWKSローテーション付きでservices/auth/jwt.rsを使用。失効トークンはrevoked_token_repository.rsで追跡。"
    },
    "llmProxy": {
      "heading": "LLMプロキシとストリーミング",
      "description": "LLMプロキシはプロバイダー間でリクエストを正規化し、レスポンスをストリーミングします：",
      "routes": [
        "/api/llm/chat/completions (POST)：メインチャット完了エンドポイント。モデルIDに基づいてOpenAI、Anthropic、Google、X.AI、またはOpenRouterにルーティング。",
        "/api/llm/video/analyze (POST)：フレーム分析用のマルチパートビデオアップロード。ビデオ機能を持つgoogle/*モデルが必要。",
        "/api/llm/cancel (POST)：request_idで進行中のストリーミングリクエストをキャンセル。",
        "/api/llm/status/{request_id} (GET)：リクエストのステータスを返す（active、completed、cancelled）。",
        "/api/audio/transcriptions (POST)：Whisper互換の文字起こし。オーディオファイルとパラメータのマルチパートアップロード。"
      ],
      "routing": "server/src/handlers/proxy/router.rsのルーターがモデルIDプレフィックス（openai/、anthropic/、google/、xai/、openrouter/）に基づいてプロバイダーを選択。server/src/handlers/proxy/providers/のプロバイダー固有ハンドラーがリクエストを変換しレスポンスを正規化。",
      "streaming": "ストリーミングレスポンスはstreaming/sse_adapter.rs経由でServer-Sent Events（SSE）を使用。プロキシはプロバイダーからチャンクを転送し、共通フォーマットに変換し、リアルタイムでトークン使用量を追跡。"
    },
    "providers": {
      "heading": "プロバイダールーティング",
      "description": "server/src/handlers/proxy/providers/のプロバイダーハンドラー：",
      "handlers": [
        "openai.rs：OpenAIおよびOpenAI互換API（GPT-4、o1、o3）。",
        "anthropic.rs：プロンプトキャッシングサポート付きのAnthropic Claudeモデル。",
        "google.rs：ビデオ分析機能を含むGoogle Geminiモデル。",
        "xai.rs：X.AI Grokモデル。",
        "openrouter.rs：モデルルーティング用のOpenRouterアグリゲーション。"
      ],
      "transformers": "server/src/handlers/provider_transformers/のリクエスト/レスポンストランスフォーマーがAPI差異を正規化。各トランスフォーマーが処理：リクエストボディフォーマット、認証ヘッダー、ストリーミングチャンクフォーマット、使用量抽出、エラー正規化。"
    },
    "config": {
      "heading": "設定エンドポイント",
      "description": "設定とモデルメタデータエンドポイント：",
      "routes": [
        "/api/config/all-configurations (GET)：タスクタイプごとのモデル設定を含むすべてのアプリケーション設定を返す。",
        "/api/config/desktop-runtime-config (GET)：デスクトップ固有のランタイム設定。",
        "/api/config/billing (GET/PUT)：課金設定管理。",
        "/api/providers (GET)：機能付きの利用可能なLLMプロバイダーリスト。",
        "/api/providers/with-counts (GET)：モデル数付きのプロバイダー。",
        "/api/providers/by-capability/{capability} (GET)：機能でプロバイダーをフィルター。",
        "/api/models (GET)：価格付きのすべての利用可能なモデル。",
        "/api/models/{id} (GET)：単一モデルの詳細。",
        "/api/models/by-provider/{provider_code} (GET)：特定プロバイダーのモデル。",
        "/api/models/estimate-cost (POST)：リクエストのコスト見積もり。",
        "/api/models/estimate-tokens (POST)：トークン数見積もり。",
        "/api/system-prompts/defaults (GET)：タスクタイプ別のデフォルトシステムプロンプト。"
      ]
    },
    "billing": {
      "heading": "課金エンドポイント",
      "description": "Stripeと統合されたクレジットベースの課金システム：",
      "routes": [
        "/api/billing/dashboard (GET)：ユーザー課金ダッシュボードデータ。",
        "/api/billing/usage-summary (GET)：コスト内訳付きの詳細使用量。",
        "/api/billing/credits/balance (GET)：現在のクレジット残高。",
        "/api/billing/credits/details (GET)：付与と購入を含むクレジット詳細。",
        "/api/billing/credits/unified-history (GET)：取引履歴。",
        "/api/billing/checkout/credit-purchase (POST)：クレジット用のStripeチェックアウトを作成。",
        "/api/billing/checkout/setup (POST)：支払い方法用のStripeセットアップセッションを作成。",
        "/api/billing/auto-top-off (GET/PUT)：自動チャージ設定管理。"
      ],
      "implementation": "課金ハンドラーはserver/src/handlers/billing/にあります。クレジットサービスはservices/credit_service.rs。Stripe統合はservices/stripe_service.rs経由でwebhook_handlers.rsでwebhook処理。"
    },
    "devices": {
      "heading": "デバイス管理",
      "description": "デバイス登録とプッシュ通知：",
      "routes": [
        "/api/devices/register (POST)：device_idでデスクトップデバイスを登録。",
        "/api/devices/mobile/register (POST)：プラットフォーム情報付きでモバイルデバイスを登録。",
        "/api/devices/{device_id}/heartbeat (POST)：プレゼンス用のデバイスハートビート。",
        "/api/devices/{device_id}/push-token (POST)：プッシュ通知トークンを保存。",
        "/api/devices/{device_id}/connection-descriptor (GET)：デバイスリンク用のWebSocket接続情報。",
        "/api/notifications/job-completed (POST)：完了ジョブのプッシュ通知を送信。",
        "/api/notifications/job-progress (POST)：進捗通知を送信。"
      ]
    },
    "websockets": {
      "heading": "WebSocketエンドポイント",
      "description": "WebSocket経由のリアルタイム通信：",
      "endpoints": [
        "/ws/device-link：デスクトップ-モバイルデバイスリンク用のリレー。リンクされたデバイス間のターミナル出力ストリーミング、ジョブステータス更新、RPCコマンドを処理。",
        "/ws/events：リアルタイム更新用の汎用イベントストリーム。"
      ],
      "implementation": "デバイスリンクリレーはserver/src/handlers/device_link_ws.rsにあります。セッションはservices/relay_session_store.rsでハートビート監視と再接続サポート付きで管理。"
    },
    "serverStorage": {
      "heading": "サーバーサイド永続化",
      "description": "server/src/db/repositories/のリポジトリを持つPostgreSQLデータベース：",
      "repositories": [
        "user_repository.rs：Auth0 subにリンクされたユーザーアカウント。",
        "customer_billing_repository.rs：Stripeカスタマーとクレジット状態。",
        "credit_transaction_repository.rs：クレジット取引履歴。",
        "provider_repository.rs：LLMプロバイダー設定。",
        "system_prompts_repository.rs：システムプロンプトテンプレート。",
        "consent_repository.rs：法的同意追跡。",
        "audit_log_repository.rs：機密操作の監査証跡。",
        "revoked_token_repository.rs：JWT失効リスト。",
        "api_key_repository.rs：セキュアハッシング付きのAPIキー管理。"
      ]
    }
  },
  "backgroundJobs": {
    "meta": {
      "title": "バックグラウンドジョブ - PlanToCode",
      "description": "デスクトップジョブエンジンのジョブキューアーキテクチャ、プロセッサタイプ、状態機械、アーティファクトストレージ。"
    },
    "category": "アーキテクチャ",
    "date": "2025-09-25",
    "readTime": "14分",
    "title": "バックグラウンドジョブ",
    "description": "ジョブキュー、プロセッサ、状態機械、イベントストリーミング、アーティファクトストレージ。",
    "intro": "すべてのLLMバックエンド作業はデスクトップアプリのバックグラウンドジョブシステムを通じて実行されます。ジョブキューがプロセッサに作業をディスパッチし、進捗イベントをストリーミングし、監査とリカバリのためにすべてのプロンプトとレスポンスをSQLiteに永続化します。このアーキテクチャにより、キャンセル、リトライ、コスト追跡、リアルタイムUI更新が可能になります。",
    "visuals": {
      "stateMachine": {
        "title": "ジョブ状態機械",
        "description": "作成から完了または失敗までのジョブステータス遷移を示す図。",
        "imageSrc": "/images/docs/background-jobs/state-machine.svg",
        "imageAlt": "ジョブ状態機械図",
        "caption": "ジョブ状態機械図のプレースホルダー。"
      }
    },
    "jobRecord": {
      "heading": "ジョブレコード構造",
      "description": "各ジョブはSQLiteにこれらのフィールドを持つbackground_jobs行を作成します：",
      "fields": [
        "id (TEXT PRIMARY KEY)：ジョブのUUID。",
        "session_id (TEXT NOT NULL, FK)：CASCADE DELETEでsessions.idを参照。",
        "task_type (TEXT DEFAULT 'unknown')：プロセッサ識別子（例：implementation_plan、text_improvement、root_folder_selection）。",
        "status (TEXT)：有効な値のCHECK制約付きの現在の状態。",
        "prompt (TEXT NOT NULL)：監査用に保存されたLLMに送信された完全なテキスト。",
        "response (TEXT)：LLM出力またはエラーメッセージ。",
        "error_message (TEXT)：失敗時の詳細エラー情報。",
        "tokens_sent (INTEGER DEFAULT 0)：プロバイダーレスポンスからの入力トークン数。",
        "tokens_received (INTEGER DEFAULT 0)：出力トークン数。",
        "cache_read_tokens (INTEGER DEFAULT 0)：プロバイダーキャッシュから読み取られたトークン（Anthropic）。",
        "cache_write_tokens (INTEGER DEFAULT 0)：キャッシュに書き込まれたトークン。",
        "model_used (TEXT)：リクエストに使用されたモデル識別子。",
        "actual_cost (REAL)：トークン使用量とモデル価格に基づいて計算されたコスト。",
        "metadata (TEXT)：タスク固有データ、ワークフローID、ステージ名を含むJSON。",
        "system_prompt_template (TEXT)：システムプロンプトに使用されたテンプレート識別子。",
        "server_request_id (TEXT)：サーバーサイド使用量追跡へのリンク。",
        "created_at, updated_at, start_time, end_time (INTEGER)：タイムスタンプ。",
        "is_finalized (INTEGER DEFAULT 0)：最終コスト/使用量が記録されたかどうか。"
      ]
    },
    "statusValues": {
      "heading": "ステータス値と遷移",
      "description": "ジョブはデータベースで追跡される明確に定義されたステータスを遷移します：",
      "statuses": [
        "idle：処理開始前の初期状態。",
        "created：ジョブレコード作成済み、まだキューに入っていない。",
        "queued：ジョブキューに追加済み、プロセッサ待ち。",
        "acknowledged_by_worker：プロセッサがジョブをピックアップ。",
        "preparing：プロセッサが入力を収集中（ファイル、プロンプト）。",
        "preparing_input：LLMリクエストペイロードを構築中。",
        "running：LLMにリクエスト送信済み、レスポンス待ち。",
        "generating_stream：ストリーミングレスポンス進行中。",
        "processing_stream：ストリーミングチャンクを処理中。",
        "completed：ジョブが正常に完了。",
        "completed_by_tag：ストリーム終了タグ検出で完了。",
        "failed：error_messageが設定されジョブが失敗。",
        "canceled：ユーザーがキャンセルをリクエスト。"
      ],
      "transitions": "遷移はbackground_job_repository/worker.rsで強制されます。無効な遷移は拒否されます。ステータス変更はjob:status-changed Tauriイベントを発行します。"
    },
    "orchestrator": {
      "heading": "ワークフローオーケストレーター",
      "description": "複数ステージワークフローはdesktop/src-tauri/src/jobs/workflow_orchestrator/のWorkflowOrchestratorで管理されます：",
      "modules": [
        "mod.rs：メインオーケストレーター構造体とワークフロー実行エントリポイント。",
        "definition_loader.rs：ステージ順序とプロセッサタイプを指定するワークフローJSON定義（例：file_finder_workflow.json）をロード。",
        "stage_scheduler.rs：ステージを順次スケジュールし、上流の完了を待機。",
        "stage_job_manager.rs：各ステージのbackground_jobレコードを作成。",
        "payload_builder.rs：IntermediateDataからステージ入力を構築。",
        "data_extraction.rs：完了したステージジョブから出力を抽出。",
        "event_emitter.rs：workflow-statusとworkflow-stage Tauriイベントを発行。",
        "state_updater.rs：メモリとデータベースのワークフロー状態を更新。",
        "completion_handler.rs：ワークフロー完了とクリーンアップを処理。",
        "failure_handler.rs：ステージ失敗とリトライ決定を管理。",
        "retry_handler.rs：指数バックオフでリトライロジックを実装。"
      ],
      "dataFlow": "ワークフローはWorkflowIntermediateData（workflow_types.rsで定義）を使用してステージ間で出力を渡します：directoryTreeContent、selectedRoots、rawRegexPatterns、locallyFilteredFiles、aiFilteredFiles、verifiedPaths、unverifiedPaths。"
    },
    "processors": {
      "heading": "ジョブプロセッサ",
      "description": "各task_typeはdesktop/src-tauri/src/jobs/processors/のプロセッサにマッピングされます：",
      "implementations": [
        "implementation_plan_processor.rs：選択されたファイルコンテンツをロードし、ディレクトリツリー付きの構造化プロンプトを構築し、XML計画をUIにストリーミング。ストリーミングにgeneric_llm_stream_processorを使用。",
        "text_improvement_processor.rs：選択をXMLタグでラップし、非ストリーミングリクエストを送信し、改善されたテキストを返す。LlmTaskRunner経由で実行。",
        "root_folder_selection_processor.rs：ディレクトリツリーをLLMに送信し、選択されたディレクトリのJSON配列レスポンスをパース。",
        "RegexFileFilterProcessor（processors/mod.rs内）：タスクから正規表現パターンを生成し、gitファイルリストに適用し、バイナリをフィルター。",
        "FileRelevanceAssessmentProcessor：トークン制限でファイルコンテンツをチャンク化し、バッチで関連性をスコアリングし、関連パスを集約。",
        "ExtendedPathFinderProcessor（path_finder_types.rs）：インポート/依存関係を分析し、関連ファイルを提案し、パスの存在を検証。",
        "web_search_prompts_generator_processor.rs：ディープリサーチ用のresearch_task XMLブロックを生成。",
        "web_search_executor_processor.rs：サーバー検索API経由でリサーチプロンプトを並列実行。",
        "generic_llm_stream_processor.rs：チャンク蓄積、イベント発行、レスポンス最終化を処理する再利用可能なストリーミングプロセッサ。"
      ]
    },
    "events": {
      "heading": "イベントストリーミング",
      "description": "ジョブ進捗はReact UIが消費するTauriイベントを発行します：",
      "eventTypes": [
        "job:status-changed：ペイロード {jobId, status, error?}。すべてのステータス遷移で発行。",
        "job:stream-progress：ペイロード {jobId, content, tokensReceived}。各ストリーミングチャンクで発行。",
        "job:completed：ペイロード {jobId, response, tokensTotal, cost}。正常完了時に発行。",
        "workflow-status：ペイロード {workflowId, status, currentStage?}。ワークフローレベルのステータス更新。",
        "workflow-stage：ペイロード {workflowId, stageName, status}。個別ステージのステータス。"
      ],
      "reactConsumption": "Reactコンポーネントは@tauri-apps/api/eventのlisten()を使用してuseEffect経由でサブスクライブします。WorkflowTrackerがワークフローイベントを集約。JobStatusIndicatorがリアルタイムステータスを表示。"
    },
    "retry": {
      "heading": "リトライとキャンセル",
      "description": "ジョブのリトライとキャンセルメカニズム：",
      "retryLogic": "retry_handler.rsがリトライ回数と遅延を管理。リトライは設定可能な最大試行回数で指数バックオフを使用。リトライ状態はjob.metadata.retryCountに保存。",
      "cancellation": "キャンセルはgeneric_llm_stream_processor.rsでストリーミングチャンク間でチェックされるフラグを設定。サーバーサイドキャンセルはrequest_id付きで/api/llm/cancelを送信。",
      "cleanup": "workflow_cleanup.rsが不完全なワークフローのクリーンアップを処理。古いジョブ（アプリ再起動後のrunningステータス）は失敗としてマーク。"
    },
    "artifacts": {
      "heading": "アーティファクトストレージ",
      "description": "ジョブの入力と出力は監査のために完全に永続化されます：",
      "stored": [
        "prompt：システムプロンプトとユーザーコンテンツを含む完全なLLMプロンプト。",
        "response：完全なLLMレスポンステキストまたはストリーミング蓄積。",
        "metadata：タスク固有データ（改善用の元テキスト、ファイルリスト、ワークフローコンテキスト）を含むJSON。",
        "system_prompt_template：サーバーサイドプロンプトテンプレートバージョンにリンクする識別子。",
        "トークン数とコスト：課金と分析用にプロバイダーレスポンスからキャプチャ。"
      ],
      "access": "background_job_repositoryがクエリを提供：get_jobs_for_session、get_job_by_id、get_jobs_by_task_type、get_recent_jobs。ジョブ履歴はBackgroundJobsSidebarコンポーネントに表示。"
    },
    "costTracking": {
      "heading": "コスト追跡",
      "description": "ジョブごとのコスト追跡により予算管理が可能：",
      "calculation": "コストはserver/src/models/model_pricing.rsのモデル価格を使用して計算。式：(tokens_sent * input_price + tokens_received * output_price)にキャッシュ調整を適用。",
      "accumulation": "セッションレベルのコストはbackground_jobsから集約。UIはセッションヘッダーに累積コストを表示。",
      "serverSync": "server_request_idがデスクトップジョブをサーバーサイド使用量レコードにリンクし、課金照合を実現。"
    },
    "cta": {
      "heading": "データモデルを見る",
      "description": "ジョブ、セッション、ターミナル出力を保存するSQLiteスキーマを理解しましょう。",
      "links": {
        "dataModel": "データモデル",
        "runtime": "ランタイムウォークスルー"
      }
    }
  },
  "buildYourOwn": {
    "meta": {
      "title": "独自パイプラインの構築 - PlanToCode",
      "description": "PlanToCodeに似たファイル検出と計画生成ワークフローを設計するための概念ガイド。"
    },
    "category": "リファレンス",
    "date": "2025-09-25",
    "readTime": "12分",
    "title": "独自パイプラインの構築",
    "description": "ファイル検出と計画生成ワークフローを設計するための概念ガイド。",
    "intro": "このガイドはPlanToCodeの主要なアーキテクチャパターンを概念的なブループリントに凝縮しています。類似システムを構築したい場合でも、特定の設計決定がなぜ行われたかを理解したい場合でも、このドキュメントは再利用または適応できる基本パターンをカバーしています。",
    "visuals": {
      "pipelineMap": {
        "title": "パイプラインアーキテクチャマップ",
        "description": "タスク入力から計画出力までの複数ステージパイプラインの概要。",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "パイプラインアーキテクチャ図",
        "caption": "パイプラインアーキテクチャ図のプレースホルダー。"
      }
    },
    "keyPatterns": {
      "heading": "主要なアーキテクチャパターン",
      "jobQueue": {
        "title": "ジョブキューパターン",
        "description": "すべてのLLMバックエンド操作はステータス追跡、キャンセルサポート、リトライロジックを持つバックグラウンドジョブとして実行されます。ジョブはSQLiteに永続化されるため、アプリ再起動後も状態が保持されます。",
        "benefits": [
          "UIの応答性をLLMレイテンシから分離",
          "ストリーミング中のキャンセルを可能に",
          "すべての操作の監査証跡を提供",
          "指数バックオフでのリトライをサポート"
        ],
        "pitfalls": [
          "ジョブステータス管理が複雑さを追加",
          "再起動時の古いジョブの慎重な処理が必要",
          "大きなレスポンスでストリーム蓄積がメモリを消費する可能性"
        ]
      },
      "workflowOrchestrator": {
        "title": "ワークフローオーケストレーターパターン",
        "description": "複数ステージワークフローはオーケストレーターによって調整され、ステージを順次スケジュールし、中間データをステージ間で渡し、任意のステージでの失敗を処理します。",
        "components": [
          "定義ローダーがワークフローJSON仕様を読み込み",
          "ステージスケジューラーがステージを順番にディスパッチ",
          "ペイロードビルダーが前の出力から入力を構築",
          "イベントエミッターがUI更新用の進捗を発行"
        ]
      },
      "repositoryPattern": {
        "title": "リポジトリパターン",
        "description": "すべての永続化はSQLite操作を抽象化する型付きリポジトリを通じて行われます。これによりクリーンなAPI、テスト可能性、データベースアクセスの集中化が提供されます。",
        "benefits": [
          "型付きアクセスがSQLインジェクションを防止",
          "リポジトリをテスト用にモック可能",
          "集中化されたクエリ最適化",
          "一貫したエラー処理"
        ]
      }
    },
    "steps": {
      "step1": {
        "title": "1. タスクモデルを定義",
        "description": "システムでタスクを構成するものを定義することから始めます。PlanToCodeはタスク説明、ファイル選択、モデル設定を持つセッションを使用します。",
        "details": "履歴追跡用のバージョニング付きで専用テーブルにタスクメタデータを保存します。"
      },
      "step2": {
        "title": "2. ジョブキューを構築",
        "description": "ジョブをストレージに永続化し、ステータスイベントを発行し、キャンセルをサポートするジョブキューを作成します。ジョブはプロンプト、レスポンス、トークン、コストを追跡する必要があります。",
        "details": "並列LLMリクエストを制御するためにセマフォベースの同時実行制限を使用します。"
      },
      "step3": {
        "title": "3. プロセッサを実装",
        "description": "各ジョブタイプにはプロンプトを構築し、LLMを呼び出し、レスポンスをパースするプロセッサが必要です。長い出力にはストリーミングを使用します。",
        "details": "プロセッサはステートレスで、ジョブパラメータを通じてすべてのコンテキストを受け取る必要があります。"
      },
      "step4": {
        "title": "4. ワークフローオーケストレーターを作成",
        "description": "複数ステージワークフロー用に、ステージをスケジュールし、中間データを管理し、失敗を処理するオーケストレーターを構築します。",
        "details": "コード変更なしで簡単に修正できるよう、ワークフロー定義をJSONとして保存します。"
      },
      "step5": {
        "title": "5. ルーティングレイヤーを追加",
        "description": "ペイロードを正規化し、APIキーを管理し、使用量を追跡するサーバープロキシを通じてLLMリクエストをルーティングします。",
        "details": "プロバイダー認証情報はサーバーに保持し、デスクトップクライアントには埋め込まないでください。"
      }
    },
    "architectureDecisions": {
      "heading": "アーキテクチャ決定",
      "decisions": [
        {
          "question": "ローカルデータベースとサーバーサイドストレージのどちらを使用すべきか？",
          "recommendation": "ジョブ状態とアーティファクトにはローカルSQLiteを使用。これによりオフライン操作と高速クエリが可能に。課金とクロスデバイス状態のみサーバーに同期。"
        },
        {
          "question": "ストリーミングか非ストリーミングレスポンスか？",
          "recommendation": "計画生成と段階的に表示される出力にはストリーミングを使用。テキスト改善のような短い変換には非ストリーミングを使用。"
        },
        {
          "question": "LLMプロバイダー障害をどのように処理するか？",
          "recommendation": "指数バックオフで自動リトライを実装。レジリエンスのためにOpenRouterのようなフォールバックプロバイダーを検討。"
        },
        {
          "question": "ファイルコンテンツはどこでロードすべきか？",
          "recommendation": "プロンプト構築直前にプロセッサでファイルコンテンツをロード。これにより新鮮なコンテンツが確保され、ジョブレコードに大きなブロブを保存することを回避。"
        }
      ]
    },
    "customizeVsReuse": {
      "heading": "カスタマイズするものと再利用するもの",
      "customize": [
        "特定のユースケース用のプロンプトテンプレート",
        "プロジェクトタイプ用のファイル検出パターン",
        "出力フォーマット（XML、JSON、Markdown）",
        "タスクタイプごとのモデル選択"
      ],
      "reuse": [
        "ステータス追跡付きのジョブキューアーキテクチャ",
        "ワークフローオーケストレーターパターン",
        "永続化用のリポジトリパターン",
        "ストリーミングレスポンス処理",
        "プロバイダールーティングと正規化"
      ]
    },
    "commonPitfalls": {
      "heading": "避けるべき一般的な落とし穴",
      "items": [
        {
          "pitfall": "クライアントにAPIキーを埋め込む",
          "solution": "認証情報を安全に管理するサーバープロキシを通じてすべてのLLMリクエストをルーティング。"
        },
        {
          "pitfall": "ジョブ状態を永続化しない",
          "solution": "監査とリカバリのために完全なプロンプトとレスポンス付きですべてのジョブを保存。"
        },
        {
          "pitfall": "LLMコールでUIをブロック",
          "solution": "レスポンシブなインターフェースのためにイベント駆動UI更新付きのバックグラウンドジョブを使用。"
        },
        {
          "pitfall": "トークン制限を無視",
          "solution": "送信前にトークンを見積もり、コンテキストウィンドウ内に収まるよう大きな入力をチャンク化。"
        },
        {
          "pitfall": "キャンセルサポートなし",
          "solution": "ストリーミングチャンク間でキャンセルフラグをチェックしサーバーに伝播。"
        }
      ]
    },
    "artifacts": {
      "heading": "永続化するアーティファクト",
      "items": [
        "LLMに送信された完全なプロンプト（デバッグと監査用）",
        "ストリーミング蓄積を含む完全なレスポンス",
        "プロバイダーレスポンスからのトークン数",
        "モデル価格に基づいて計算されたコスト",
        "バージョニング用のシステムプロンプトテンプレート識別子",
        "複数ステージフロー用のワークフロー中間データ"
      ]
    },
    "implementationNotes": {
      "heading": "実装メモ",
      "items": [
        "同時読み書きアクセス用にWALモードでSQLiteを使用",
        "実行中のジョブを失敗としてマークするグレースフルシャットダウンを実装",
        "ジョブ処理前に外部依存関係のヘルスチェックを追加",
        "デバッグ用に完全なコンテキスト付きですべてのLLMエラーをログ記録",
        "冗長な読み取りを避けるため短いTTLでファイルコンテンツキャッシングを検討"
      ]
    }
  },
  "decisionsTradeoffs": {
    "meta": {
      "title": "技術的決定とトレードオフ - PlanToCode",
      "description": "Tauri、SQLite、専用LLMプロキシが選択された理由と、それらが生み出す運用上のトレードオフ。"
    },
    "category": "アーキテクチャ",
    "date": "2025-09-25",
    "readTime": "10分",
    "title": "技術的決定とトレードオフ",
    "description": "Tauri、SQLite、専用LLMプロキシが選択された理由とそのコスト。",
    "intro": "すべてのアーキテクチャにはトレードオフが伴います。このドキュメントはPlanToCodeの主要な技術選択、それらが提供する利点、導入されるコストや制限について説明します。",
    "visuals": {
      "tradeoffMatrix": {
        "title": "トレードオフマトリックス",
        "description": "技術選択とその利点・コストの視覚的比較。",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "技術トレードオフマトリックス",
        "caption": "技術スタック決定を示すシステムアーキテクチャ概要。"
      }
    },
    "sections": {
      "tauri": {
        "title": "デスクトップ向けTauri v2",
        "description": "TauriはRustバックエンドとWebベースのフロントエンドを提供し、ネイティブパフォーマンスと小さなバイナリサイズでクロスプラットフォームデスクトップアプリを実現します。",
        "benefits": [
          "小さなバイナリサイズ（Electronの200MB以上に対して約15MB）",
          "ファイル操作とジョブ処理のネイティブRustパフォーマンス",
          "きめ細かい権限を持つ機能ベースのセキュリティモデル",
          "macOS、Windows、Linux向けの単一コードベース",
          "システムAPIへのアクセス（PTY、キーチェーン、通知）"
        ],
        "tradeoffs": [
          "Electronより小さなエコシステム",
          "バックエンド開発のRust学習曲線",
          "プラットフォーム間のWebViewレンダリング差異",
          "IPCイシューのデバッグツールが未成熟"
        ],
        "implementation": "PlanToCodeはTauri 2.9.1を使用し、約35のコマンドモジュール、機能ベースの権限、シェル・ダイアログ・通知用のプラグインを備えています。"
      },
      "sqlite": {
        "title": "ローカル永続化向けSQLite",
        "description": "SQLiteはセッション、ジョブ、ターミナル出力、設定を含むすべてのローカル状態を保存します。これによりオフライン操作と高速クエリが可能になります。",
        "benefits": [
          "設定不要の組み込みデータベース",
          "ローカルデータへの高速クエリ",
          "オフライン操作を可能に",
          "単一ファイルのバックアップとリストア",
          "同時アクセス用のWALモード"
        ],
        "tradeoffs": [
          "組み込みのレプリケーションや同期なし",
          "大きなターミナルログがデータベースを肥大化",
          "手動のスキーママイグレーションが必要",
          "シングルライター制限（WALで軽減）"
        ],
        "implementation": "consolidated_schema.sqlに約10テーブルのスキーマ。リポジトリがrusqliteで型付きアクセスを提供。"
      },
      "llmProxy": {
        "title": "専用LLMプロキシサーバー",
        "description": "すべてのLLMリクエストはAPIキーを管理し、リクエストを正規化し、使用量を追跡し、課金を処理するサーバープロキシを経由します。",
        "benefits": [
          "APIキーがサーバーから離れない",
          "すべてのプロバイダーに単一リクエストフォーマット",
          "集中化された使用量追跡と課金",
          "クライアント更新なしでプロバイダーフェイルオーバー",
          "コンテンツフィルタリングとレート制限"
        ],
        "tradeoffs": [
          "サーバーインフラストラクチャが必要",
          "リクエストにネットワークレイテンシを追加",
          "サーバーが単一障害点に",
          "プロバイダー統合のメンテナンスが必要"
        ],
        "implementation": "server/src/handlers/proxy/のハンドラーを持つActix-Webサーバー。provider_transformers/のトランスフォーマーがリクエストを正規化。"
      },
      "websocket": {
        "title": "モバイル向けWebSocketリレー",
        "description": "デスクトップとモバイルクライアントはデバイスリンク、ターミナルストリーミング、ジョブ同期のためにWebSocketリレーを通じて接続します。",
        "benefits": [
          "リアルタイム双方向通信",
          "直接P2Pネットワーキング不要",
          "NATとファイアウォールを超えて動作",
          "複数のリンクされたデバイスをサポート"
        ],
        "tradeoffs": [
          "永続的なサーバー接続が必要",
          "リレーが大きなペイロードにレイテンシを追加",
          "接続管理の複雑さ",
          "再接続とハートビートロジックが必要"
        ],
        "implementation": "device_link_ws.rsがセッション追跡、ハートビート、ターミナル出力用のPTC1バイナリフレーミングを持つリレーを実装。"
      }
    },
    "operational": {
      "heading": "運用上の影響",
      "items": [
        "Tauri：各プラットフォーム用に別々のビルドが必要。CI/CDはクロスコンパイルまたはプラットフォーム固有のランナーを使用する必要あり。",
        "SQLite：データベースファイルがターミナル出力とともに増大。長時間実行インスタンスには定期的なクリーンアップが必要な場合あり。",
        "LLMプロキシ：サーバーダウンタイムがすべてのLLM操作をブロック。本番環境には監視と冗長性が必要。",
        "WebSocket：再接続ロジックが複雑さを追加。クライアントは接続切断を適切に処理する必要あり。"
      ]
    },
    "securityBoundaries": {
      "heading": "セキュリティ境界",
      "description": "アーキテクチャは露出を制限する明確なセキュリティ境界を作成します：",
      "items": [
        "APIキーはサーバーボールトに保存され、クライアントには送信されない",
        "JWTトークンはJWKSローテーション付きですべてのリクエストで検証",
        "機能ベースの権限がファイルシステムアクセスを制限",
        "LLMに送信されるコンテンツには明示的なユーザー承認が必要",
        "監査ログがユーザーコンテキスト付きですべてのLLMリクエストを追跡"
      ]
    },
    "whenToReconsider": {
      "heading": "再検討すべき時",
      "description": "要件が大幅に変更された場合、これらの決定は再検討が必要な場合があります：",
      "items": [
        "ブラウザのみのアクセスが必要な場合、TauriのWebベース代替を検討",
        "マルチデバイス同期が重要な場合、サーバーサイドジョブストレージを検討",
        "プロバイダーロックインが許容される場合、直接APIコールでレイテンシを削減可能",
        "モバイルが主要な場合、デバイスリンクの代わりにネイティブアプリを検討"
      ]
    }
  },
  "dataModel": {
    "meta": {
      "title": "データモデルとストレージ - PlanToCode",
      "description": "SQLiteエンティティ、リレーションシップ、アプリ再起動時の状態復元方法。"
    },
    "category": "アーキテクチャ",
    "date": "2025-09-25",
    "readTime": "10分",
    "title": "データモデル & ストレージ",
    "description": "SQLiteエンティティ、リレーションシップ、状態の復元方法。",
    "intro": "PlanToCodeはすべてのローカル状態にSQLiteを使用します。このドキュメントはスキーマ、エンティティリレーションシップ、アプリ再起動時の状態復元方法について説明します。",
    "sqlite": {
      "heading": "SQLite設定",
      "description": "データベースは同時読み書きアクセス用にWALモードを使用します。ファイルはTauriアプリデータディレクトリに保存されます（Linuxでは~/.local/share/plantocode、macOSでは~/Library/Application Support/plantocode）。",
      "migrations": "スキーママイグレーションはconsolidated_schema.sqlに統合されています。アプリは起動時にスキーマバージョンをチェックし、保留中のマイグレーションを実行します。"
    },
    "entities": {
      "heading": "コアエンティティ",
      "items": [
        "sessions：タスク説明、ファイル選択、モデル設定、検索設定、ビデオ/マージプロンプト、履歴インデックスを含むプロジェクトコンテキスト",
        "background_jobs：プロンプト、レスポンス、トークン、コスト、is_finalizedフラグ、error_messageを含むLLMバックエンド操作",
        "terminal_sessions：出力ログ、ステータス、プロセス情報を含むPTYセッション",
        "task_description_history：タスク説明のバージョン履歴",
        "file_selection_history：ファイル選択のバージョン履歴",
        "project_system_prompts：プロジェクトごとのプロンプトオーバーライド",
        "key_value_store：アプリ設定と構成",
        "error_logs：クライアントサイドエラー追跡",
        "migrations：タイムスタンプ付きで適用されたデータベースマイグレーションを追跡",
        "db_diagnostic_logs：データベース診断の問題とエラーを記録",
        "app_settings：説明付きのアプリケーション設定キーバリューペア"
      ]
    },
    "visuals": {
      "schema": {
        "title": "エンティティリレーションシップ図",
        "description": "SQLiteスキーマとリレーションシップの視覚的表現。",
        "imageSrc": "/images/docs/data-model/schema.svg",
        "imageAlt": "データベーススキーマ図",
        "caption": "データベーススキーマ図のプレースホルダー。"
      }
    },
    "relationships": {
      "heading": "エンティティリレーションシップ",
      "description": "エンティティはカスケード削除ルール付きの外部キーでリンクされています：",
      "links": [
        "sessions → background_jobs：1対多、カスケード削除",
        "background_jobs → terminal_sessions：job_id経由のオプション1対1リンク",
        "sessions → task_description_history：バージョン追跡用の1対多",
        "sessions → file_selection_history：バージョン追跡用の1対多"
      ]
    },
    "repositories": {
      "heading": "リポジトリレイヤー",
      "description": "すべてのデータベースアクセスはdesktop/src-tauri/src/db_utils/の型付きリポジトリを通じて行われます：",
      "examples": [
        "background_job_repository/：base.rs、worker.rs、metadata.rs、cleanup.rsでモジュール化",
        "session_repository.rs：履歴管理付きのセッションCRUD",
        "terminal_repository.rs：ターミナルセッション永続化と出力ログ",
        "settings_repository.rs：キーバリュー設定ストレージ"
      ]
    },
    "rehydration": {
      "heading": "状態の復元",
      "description": "アプリ起動時、状態はSQLiteから復元されます：",
      "sessions": "アクティブセッションはタスク説明、ファイル選択、モデル設定とともにロードされます。最近のセッションはセッションピッカーで利用可能です。"
    },
    "retention": {
      "heading": "データ保持",
      "description": "古いデータは設定可能な保持期間に基づいてクリーンアップされます：",
      "exports": "セッションとジョブはクリーンアップ前にバックアップ用にエクスポートできます。"
    },
    "cta": {
      "heading": "ジョブ処理を探索",
      "description": "バックグラウンドジョブがこのデータモデルをどのように使用するかを見てみましょう。",
      "links": {
        "jobs": "バックグラウンドジョブ",
        "terminals": "ターミナルセッション"
      }
    }
  },
  "serverSetup": {
    "meta": {
      "title": "専用サーバーセットアップ - PlanToCode",
      "description": "Ansibleベースのインフラストラクチャセットアップ：基本ハードニング、PostgreSQL、Redis、アプリケーションデプロイメント。"
    },
    "category": "デプロイメント",
    "date": "2025-09-25",
    "readTime": "12分",
    "title": "専用サーバーセットアップ",
    "description": "Ansibleベースのインフラストラクチャ：基本ハードニング、アプリデプロイメント、Vault管理シークレット。",
    "intro": "PlanToCodeはAnsible Playbookで管理される専用サーバーで稼働します。このドキュメントはインフラストラクチャセットアップ、セキュリティハードニング、デプロイメントプロセスをカバーします。",
    "layers": {
      "heading": "インフラストラクチャレイヤー",
      "description": "インフラストラクチャはレイヤーに整理され、それぞれ専用のPlaybookで管理されます：",
      "items": [
        "ベースレイヤー：OSハードニング、SSH設定、ファイアウォールルール",
        "データベースレイヤー：レプリケーションとバックアップ付きのPostgreSQL 17",
        "キャッシュレイヤー：セッション状態とジョブキュー用のRedis 7+",
        "アプリケーションレイヤー：systemdサービス付きのRustサーバーバイナリ",
        "プロキシレイヤー：SSL終端付きのNginxリバースプロキシ"
      ]
    },
    "servers": {
      "heading": "サーバーリージョン",
      "description": "PlanToCodeは地理的冗長性のために2つのリージョンで稼働しています：",
      "items": [
        "EUリージョン：Hetzner専用サーバー（api-eu.plantocode.com）",
        "USリージョン：InterServer専用サーバー（api-us.plantocode.com）"
      ]
    },
    "requirements": {
      "heading": "サーバー要件",
      "items": [
        "Debian 12またはUbuntu 22.04 LTS",
        "4+CPUコア、16GB以上RAM、200GB以上SSD",
        "ポート22、80、443へのファイアウォールアクセス付きパブリックIPv4",
        "Ansibleデプロイメント用のSSHキーアクセス"
      ]
    },
    "hardening": {
      "heading": "基本ハードニング",
      "description": "site-base.ymlがセキュリティハードニングを適用します：",
      "items": [
        "rootSSHログインを無効化、キー認証を必須に",
        "最小限のオープンポートでUFWファイアウォールを設定",
        "ブルートフォース保護用にfail2banをインストール",
        "自動セキュリティ更新を有効化",
        "監査ログを設定"
      ]
    },
    "postgresql": {
      "heading": "PostgreSQLセットアップ",
      "description": "PostgreSQL 17は本番環境用に設定されています：",
      "items": [
        "PgBouncerによる接続プーリング",
        "pg_dumpによる自動日次バックアップ",
        "ポイントインタイムリカバリ用のWALアーカイブ",
        "すべての接続にSSL必須",
        "マルチテナントデータ用の行レベルセキュリティ"
      ]
    },
    "redis": {
      "heading": "Redisセットアップ",
      "description": "Redis 7+がキャッシングとセッション状態を処理します：",
      "items": [
        "パスワード認証必須",
        "耐久性用のAOF永続化",
        "エビクションポリシー付きメモリ制限",
        "接続用のTLS暗号化"
      ]
    },
    "zeroDowntime": {
      "heading": "ゼロダウンタイムデプロイメント",
      "description": "デプロイメントはローリングアップデート戦略を使用します：",
      "items": [
        "新しいバイナリを実行中バージョンと並行でアップロード",
        "ヘルスチェックで新バージョンの準備完了を確認",
        "systemdがグレースフルシャットダウンで再起動",
        "ロードバランサーが切り替え中に接続をドレイン",
        "前のバイナリシンボリックリンク経由でロールバック可能"
      ]
    },
    "quickStart": {
      "heading": "クイックスタート",
      "steps": [
        "インフラストラクチャリポジトリをクローン",
        "inventory.exampleをinventoryにコピーしてホストを設定",
        ".vault_passにVaultパスワードを設定",
        "実行：ansible-playbook -i inventory site-base.yml",
        "実行：ansible-playbook -i inventory site-app.yml"
      ]
    },
    "vault": {
      "heading": "シークレット管理",
      "description": "機密設定はAnsible Vaultを使用します：",
      "items": [
        "データベース認証情報",
        "LLMプロバイダー用APIキー",
        "SSL証明書と秘密鍵",
        "Auth0クライアントシークレット",
        "Stripe Webhookシークレット"
      ]
    },
    "operations": {
      "heading": "一般的な操作",
      "items": [
        "ansible-playbook -i inventory site-app.yml --tags deploy",
        "ansible-playbook -i inventory site-base.yml --tags backup",
        "ansible-playbook -i inventory site-app.yml --tags rollback",
        "ansible-playbook -i inventory site-base.yml --tags logs"
      ]
    },
    "ssl": {
      "heading": "SSL/TLS設定",
      "description": "Let's Encryptが無料のSSL証明書を提供します：",
      "items": [
        "Nginxプラグイン付きでCertbotを設定",
        "cronジョブによる自動更新",
        "HSTSヘッダーを有効化",
        "TLS 1.2以上のみ、モダン暗号スイート"
      ]
    },
    "security": {
      "heading": "セキュリティチェックリスト",
      "items": [
        "すべてのデフォルトパスワードを変更",
        "SSHキーローテーションをスケジュール",
        "ファイアウォールルールを監査",
        "セキュリティ更新を自動化",
        "バックアップリストアをテスト"
      ]
    },
    "recovery": {
      "heading": "災害復旧",
      "description": "一般的な障害シナリオの復旧手順：",
      "items": [
        "データベース破損：最新のpg_dumpバックアップから復元",
        "サーバー障害：新しいサーバーをプロビジョニングしてPlaybookを実行",
        "SSL有効期限切れ：手動でcertbot renew --force-renewal",
        "セキュリティ侵害：すべての認証情報をローテーション、ログを監査"
      ]
    }
  },
  "tauriV2": {
    "meta": {
      "title": "Tauri v2開発ガイド - PlanToCode",
      "description": "Tauri v2のプロジェクトレイアウト、コマンド、機能、開発ワークフロー。"
    },
    "category": "デプロイメント",
    "date": "2025-09-25",
    "readTime": "10分",
    "title": "Tauri v2開発ガイド",
    "description": "Tauri v2のプロジェクトレイアウト、コマンド、機能ベース権限。",
    "intro": "PlanToCodeはデスクトップアプリケーションにTauri v2を使用しています。このガイドはプロジェクト構造、コマンドシステム、機能ベース権限、開発ワークフローをカバーします。",
    "projectLayout": {
      "heading": "プロジェクトレイアウト",
      "description": "デスクトップアプリケーションは標準的なTauri v2の慣例に従います：",
      "items": [
        "desktop/src/：コンポーネント、フック、プロバイダーを含むReactフロントエンド",
        "desktop/src-tauri/：コマンド、ジョブ、サービスを含むRustバックエンド",
        "desktop/src-tauri/src/lib.rs：アプリケーションエントリポイント",
        "desktop/src-tauri/src/commands/：Tauriコマンドハンドラー（約35モジュール）",
        "desktop/src-tauri/capabilities/：権限定義",
        "desktop/src-tauri/tauri.conf.json：Tauri設定"
      ]
    },
    "configuration": {
      "heading": "Tauri設定",
      "description": "tauri.conf.jsonがアプリケーションを設定します：",
      "items": [
        "productName、version、identifierでアプリメタデータ",
        "build.beforeDevCommandとbeforeBuildCommandでフロントエンド",
        "インストーラー（DMG、NSIS、AppImage）用のbundle設定",
        "Content Security Policy用のsecurity.csp",
        "公式プラグイン用のplugins設定"
      ]
    },
    "capabilities": {
      "heading": "機能ベース権限",
      "description": "Tauri v2は機能を使用してアプリがアクセスできるものを制御します：",
      "items": [
        "default.json：すべてのウィンドウの基本権限",
        "desktop-default.json：デスクトップ固有の権限",
        "plantocode-api.json：PlanToCodeコマンド用のカスタム権限",
        "権限が付与するアクセス：filesystem、shell、http、dialog、notification"
      ]
    },
    "plugins": {
      "heading": "Tauriプラグイン",
      "description": "PlanToCodeは複数の公式Tauriプラグインを使用します：",
      "items": [
        "tauri-plugin-http：APIコール用HTTPクライアント",
        "tauri-plugin-dialog：ネイティブファイル/フォルダーピッカー",
        "tauri-plugin-shell：シェルコマンド実行",
        "tauri-plugin-store：永続的キーバリューストレージ",
        "tauri-plugin-notification：デスクトップ通知",
        "tauri-plugin-updater：アプリ内更新",
        "tauri-plugin-single-instance：シングルインスタンス強制"
      ]
    },
    "appState": {
      "heading": "アプリケーション状態",
      "description": "Tauriの状態システムを通じて管理されるRust状態：",
      "items": [
        "AppState構造体が共有状態を保持",
        "サーバーURLとフィーチャーフラグ用のRuntimeConfig",
        "安全な認証情報ストレージ用のTokenManager",
        "AIモデル設定用のConfigCache"
      ]
    },
    "commands": {
      "heading": "コマンドの作成",
      "description": "TauriコマンドがRust関数をフロントエンドに公開します：",
      "items": [
        "async関数に#[tauri::command]属性を使用",
        "エラー処理にResult<T, String>を返す",
        "State<AppState>パラメータ経由で状態にアクセス",
        "lib.rsのinvoke_handlerに登録"
      ]
    },
    "singleInstance": {
      "heading": "シングルインスタンス",
      "description": "アプリはデータ競合を防ぐためにシングルインスタンスを強制します：",
      "items": [
        "tauri-plugin-single-instanceが検出を処理",
        "2回目の起動で既存ウィンドウにフォーカス",
        "ディープリンクが実行中インスタンスに転送"
      ]
    },
    "devWorkflow": {
      "heading": "開発ワークフロー",
      "description": "開発用の一般的なコマンド：",
      "items": [
        "pnpm tauri dev：ホットリロード付きで開発開始",
        "pnpm tauri build：本番リリースをビルド",
        "cargo test：Rustテストを実行",
        "cargo clippy：Rustコードをリント"
      ]
    },
    "mobile": {
      "heading": "モバイルの考慮事項",
      "description": "Tauri v2はモバイルをサポートしますが、PlanToCodeはネイティブSwiftを使用：",
      "items": [
        "iOSアプリはネイティブエクスペリエンス用にSwiftUIで構築",
        "デスクトップとモバイル間で共有APIコントラクト",
        "WebSocketリレー経由のデバイスリンク"
      ]
    },
    "distribution": {
      "heading": "配布",
      "description": "各プラットフォーム用のビルドアーティファクト：",
      "items": [
        "macOS：ユニバーサルバイナリ付き.dmg（Intel + Apple Silicon）",
        "Windows：NSISインストーラーとMSIXパッケージ",
        "Linux：広い互換性のためのAppImage"
      ]
    }
  },
  "distributionMacos": {
    "meta": {
      "title": "macOS配布 - PlanToCode",
      "description": "macOS向けのコード署名、公証、DMGパッケージング、アップデーター設定。"
    },
    "category": "デプロイメント",
    "date": "2025-09-25",
    "readTime": "10分",
    "title": "macOS配布",
    "description": "署名、公証、DMGパッケージング、アップデーターアーティファクト。",
    "intro": "macOSでの配布にはコード署名、公証、適切なパッケージングが必要です。このドキュメントはPlanToCodeの完全なプロセスをカバーします。",
    "signing": {
      "heading": "コード署名",
      "description": "すべてのバイナリはApple Developer IDで署名する必要があります：",
      "items": [
        "アプリ署名用のDeveloper ID Application証明書",
        "PKG署名用のDeveloper ID Installer証明書",
        "証明書はCIシークレットに保存、キーチェーンにインポート",
        "公証互換性のためにHardened runtimeを有効化"
      ]
    },
    "entitlements": {
      "heading": "エンタイトルメント",
      "description": "PlanToCode機能に必要なエンタイトルメント：",
      "items": [
        "com.apple.security.cs.allow-jit",
        "com.apple.security.cs.allow-unsigned-executable-memory",
        "com.apple.security.device.audio-input",
        "com.apple.security.network.client",
        "com.apple.security.files.user-selected.read-write"
      ]
    },
    "build": {
      "heading": "ビルドプロセス",
      "description": "署名済みリリースをビルドする手順：",
      "steps": [
        "pnpm tauri build --target universal-apple-darwinを実行",
        "Tauriが環境変数のAPPLE_SIGNING_IDENTITYで署名",
        "lipoでIntel + ARM用のユニバーサルバイナリを作成",
        "カスタム背景とレイアウトでDMGをパッケージ"
      ]
    },
    "universalBinaries": {
      "heading": "ユニバーサルバイナリ",
      "description": "PlanToCodeはユニバーサルバイナリとして配布されます：",
      "items": [
        "単一の.appがIntelとApple Siliconの両方をサポート",
        "--target universal-apple-darwinでビルド",
        "バイナリはやや大きいが配布がシンプル",
        "両アーキテクチャでネイティブパフォーマンス"
      ]
    },
    "notarization": {
      "heading": "公証",
      "description": "Gatekeeper承認にはApple公証が必要です：",
      "items": [
        "DMGをApple notaryサービスに提出",
        "App Store Connect認証情報でnotarytoolを使用",
        "ステープリングで公証チケットをDMGに添付",
        "プロセスは通常1-5分"
      ]
    },
    "updater": {
      "heading": "アプリ内更新",
      "description": "tauri-plugin-updaterが自動更新を処理します：",
      "items": [
        "起動時に更新エンドポイントをチェック",
        "バックグラウンドで新バージョンをダウンロード",
        "適用のためにユーザーに再起動を促す",
        "インストール前に署名検証"
      ]
    },
    "latestJson": {
      "heading": "更新マニフェスト",
      "description": "latest.jsonが利用可能な更新を記述します：",
      "items": [
        "version：セマンティックバージョン文字列",
        "platforms.darwin-universal：URLと署名",
        "notes：markdownでのリリースノート",
        "pub_date：ISO 8601公開タイムスタンプ"
      ]
    },
    "pitfalls": {
      "heading": "一般的な落とし穴",
      "description": "頻繁に発生する問題：",
      "items": [
        "CI中にキーチェーンがロック：署名前にアンロック",
        "公証タイムアウト：指数バックオフでリトライ",
        "無効な署名：エンタイトルメントが機能と一致するか確認",
        "Gatekeeper拒否：公証が正しくステープルされているか確認"
      ]
    },
    "verification": {
      "heading": "検証コマンド",
      "description": "署名と公証を検証するコマンド：",
      "items": [
        "codesign -dv --verbose=4 PlanToCode.app",
        "spctl --assess --verbose PlanToCode.app",
        "stapler validate PlanToCode.dmg",
        "xcrun notarytool log <submission-id>"
      ]
    }
  },
  "distributionWindows": {
    "meta": {
      "title": "Windows配布 - PlanToCode",
      "description": "Windows向けのNSISインストーラー、MSIXパッケージング、Microsoft Storeへの提出、コード署名。"
    },
    "category": "デプロイメント",
    "date": "2025-09-25",
    "readTime": "10分",
    "title": "Windows配布 & ストア",
    "description": "NSISビルド、MSIXパッケージング、Microsoft Store提出。",
    "intro": "PlanToCodeはWindowsで直接ダウンロード（NSISインストーラー）とMicrosoft Store（MSIXパッケージ）の両方を通じて配布されます。このドキュメントは両方の配布方法をカバーします。",
    "prereqs": {
      "heading": "前提条件",
      "description": "必要なツールと証明書：",
      "items": [
        "コード署名証明書（EVまたは標準）",
        "signtool用のWindows SDK",
        "インストーラービルド用のNSIS",
        "Store提出用のMSIX Packaging Tool"
      ]
    },
    "nsisBuild": {
      "heading": "NSISインストーラー",
      "description": "TauriはデフォルトでNSISインストーラーをビルドします：",
      "items": [
        "PlanToCodeブランディング付きのカスタムインストーラーUI",
        "ユーザーごとのインストール（管理者権限不要）",
        "スタートメニューとデスクトップショートカット",
        "クリーン削除付きのアンインストーラー"
      ]
    },
    "codeSigning": {
      "heading": "コード署名",
      "description": "Authenticodeを使用したWindowsコード署名：",
      "items": [
        "Windows SDKのsigntoolで署名",
        "信頼できるTSAサーバーからのタイムスタンプ",
        "EV証明書がSmartScreenレピュテーションを提供",
        "CIが証明書とパスワードのシークレットを使用"
      ]
    },
    "msixPackaging": {
      "heading": "Microsoft Store向けMSIX",
      "description": "MSIXがStore互換パッケージングを提供します：",
      "items": [
        "AppxManifest.xmlが機能を定義",
        "仮想ファイルシステム分離",
        "Store経由の自動更新",
        "サンドボックス実行環境"
      ]
    },
    "msixConfig": {
      "heading": "MSIX設定",
      "description": "主要なAppxManifest設定：",
      "items": [
        "Identity：Name、Publisher、Version",
        "Capabilities：internetClient、microphone",
        "Visual elements：タイル、スプラッシュスクリーン",
        "ファイル関連付けとプロトコルハンドラー"
      ]
    },
    "msixSteps": {
      "heading": "MSIXビルド手順",
      "description": "MSIXパッケージを作成するプロセス：",
      "steps": [
        "pnpm tauri buildでリリースをビルド",
        "正しいidentityでAppxManifest.xmlを作成",
        "MakeAppx.exeでパッケージ",
        "SignToolで署名",
        "Windows App Cert Kitで検証"
      ]
    },
    "store": {
      "heading": "Microsoft Store提出",
      "description": "Store提出プロセス：",
      "items": [
        "Partner Centerでアプリを作成",
        "MSIXパッケージをアップロード",
        "価格設定を構成（IAPクレジット付き無料）",
        "認定のために提出",
        "レビューは1-3営業日"
      ]
    },
    "updaterWindows": {
      "heading": "Windows更新",
      "description": "各配布の更新メカニズム：",
      "items": [
        "NSIS：GitHubリリース付きのtauri-plugin-updater",
        "MSIX/Store：Microsoft Store経由で自動",
        "両方とも起動時に更新をチェック"
      ]
    },
    "webview2": {
      "heading": "WebView2ランタイム",
      "description": "TauriはWindowsでWebView2を使用します：",
      "items": [
        "インストーラーにバンドルされたWebView2ブートストラッパー",
        "Evergreenバージョンが自動更新",
        "分離用の固定バージョンも利用可能",
        "Windows 10 1803以上が必要"
      ]
    },
    "troubleshooting": {
      "heading": "トラブルシューティング",
      "description": "一般的なWindows配布の問題：",
      "items": [
        "SmartScreen警告：EV証明書を使用するかレピュテーションを構築",
        "WebView2の欠落：ブートストラッパーが実行されることを確認",
        "Store拒否：認定レポートの詳細を確認",
        "更新失敗：署名とマニフェストバージョンを確認"
      ]
    }
  },
  "promptTypes": {
    "meta": {
      "title": "プロンプトタイプとテンプレート - PlanToCode",
      "description": "プロンプト駆動ジョブタイプのカタログとテンプレート組み立てプロセス。"
    },
    "category": "リファレンス",
    "date": "2025-09-25",
    "readTime": "8分",
    "title": "プロンプトタイプ & テンプレート",
    "description": "プロンプト駆動ジョブタイプのカタログとテンプレート組み立て。",
    "intro": "PlanToCodeのすべてのLLMバックエンドジョブは、テンプレートから構築された構造化プロンプトを使用します。このドキュメントはジョブタイプをカタログ化し、プロンプトがどのように組み立てられるかを説明します。",
    "catalog": {
      "heading": "ジョブタイプカタログ",
      "items": [
        {
          "job": "implementation_plan",
          "title": "実装計画",
          "description": "XML構造でファイルごとの実装計画を生成。段階的表示のためにストリーミングを使用。"
        },
        {
          "job": "implementation_plan_merge",
          "title": "計画マージ",
          "description": "ユーザー指示で複数の計画を結合。ソース計画はXMLタグでラップ。"
        },
        {
          "job": "text_improvement",
          "title": "テキスト改善",
          "description": "フォーマットを保持しながら選択テキストを洗練。迅速な結果のために非ストリーミング。"
        },
        {
          "job": "root_folder_selection",
          "title": "ルートフォルダー選択",
          "description": "関連するプロジェクトルートを選択するためにディレクトリツリーを分析。JSON配列を返す。"
        },
        {
          "job": "regex_file_filter",
          "title": "正規表現ファイルフィルター",
          "description": "タスク説明に基づいてファイルフィルタリング用の正規表現パターンを生成。"
        },
        {
          "job": "file_relevance_assessment",
          "title": "ファイル関連性評価",
          "description": "タスクへのファイルコンテンツの関連性をスコアリング。バッチで処理。"
        },
        {
          "job": "extended_path_finder",
          "title": "拡張パスファインダー",
          "description": "インポートと依存関係を通じて関連ファイルを検出。"
        },
        {
          "job": "web_search_prompts",
          "title": "Web検索プロンプト",
          "description": "ディープリサーチワークフロー用のリサーチクエリを生成。"
        },
        {
          "job": "video_analysis",
          "title": "ビデオ分析",
          "description": "UI状態とアクションシーケンスのために画面録画を分析。"
        }
      ]
    },
    "templateStructure": {
      "heading": "テンプレート構造",
      "description": "プロンプトはシステムテンプレートとユーザーコンテンツから組み立てられます：",
      "sampleLabel": "テンプレート構造の例：",
      "sample": "<system_prompt>\n  You are an AI assistant that generates implementation plans.\n  [template content from server]\n</system_prompt>\n\n<task>\n  [user's task description]\n</task>\n\n<files>\n  [selected file paths and content]\n</files>\n\n<directory_tree>\n  [project structure]\n</directory_tree>"
    },
    "visuals": {
      "template": {
        "title": "プロンプト組み立てフロー",
        "description": "テンプレートがユーザーコンテンツと結合して完全なプロンプトを形成する方法。",
        "imageSrc": "/images/docs/implementation-plans/structure.svg",
        "imageAlt": "プロンプトテンプレート組み立て図",
        "caption": "プロンプト組み立て図のプレースホルダー。"
      }
    },
    "assembly": {
      "heading": "組み立てプロセス",
      "steps": [
        "プロセッサがタスクモデル設定からテンプレートIDを取得",
        "システムプロンプトテンプレートがサーバーキャッシュからロード",
        "ユーザーコンテンツがセマンティックXMLタグでラップ",
        "ジョブタイプに基づいてコンテキスト（ファイル、ツリー）を追加",
        "送信前に完全なプロンプトをジョブレコードに保存"
      ]
    },
    "serverConfig": {
      "heading": "サーバーサイド設定",
      "description": "テンプレートとモデル設定はサーバーサイドで構成されます：",
      "fields": "task_model_configが定義：default_model、allowed_models、system_prompt_template_id、max_tokens、temperature"
    },
    "tokenGuards": {
      "heading": "トークンガードレール",
      "description": "各タスクタイプにはコンテキストオーバーフローを防ぐトークン制限があります：",
      "items": [
        "max_tokens_input：最大プロンプトサイズ",
        "max_tokens_output：最大レスポンスサイズ",
        "送信前の検証がAPIコールの無駄を防止",
        "UIがトークン数を表示し制限に近づくと警告"
      ]
    },
    "versioning": {
      "heading": "テンプレートバージョニング",
      "description": "システムプロンプトテンプレートは再現性のためにバージョン管理されます。各ジョブは使用されたテンプレートIDを記録し、テンプレートバージョン間での結果の監査と比較を可能にします。"
    },
    "designNotes": {
      "heading": "設計メモ",
      "items": [
        "XMLタグがLLMパーシング用の明確な境界を提供",
        "セマンティックな命名（task、files、context）がモデルの理解を支援",
        "テンプレートはユーザー入力をサニタイズしてインストラクションインジェクションを回避",
        "ストリーミングジョブは完了検出に終了タグを使用"
      ]
    },
    "cta": {
      "heading": "ジョブ処理の実際を見る",
      "description": "これらのプロンプトがジョブシステムをどのように流れるかを学びましょう。",
      "links": {
        "jobs": "バックグラウンドジョブ",
        "merge": "マージ指示"
      }
    }
  },
  "mergeInstructionsDoc": {
    "meta": {
      "title": "Merge instructions - PlanToCode",
      "description": "How multiple plan drafts are merged using XML-tagged source plans and user guidance."
    },
    "category": "Planning",
    "date": "2025-09-25",
    "readTime": "8 min",
    "title": "Merge Instructions",
    "description": "How multiple plan drafts are merged using XML-tagged source plans and user guidance.",
    "intro": "When you have multiple implementation plans that need to be combined, the merge workflow lets you select plans, provide guidance, and generate a unified plan that incorporates the best elements from each source.",
    "processor": {
      "heading": "ImplementationPlanMergeProcessor",
      "description": "The ImplementationPlanMergeProcessor fetches source plan responses, wraps them in XML-tagged sections, and streams the merged result through the LlmTaskRunner.",
      "payload": "Accepts source_job_ids array, optional merge_instructions string, and inherits model configuration from the session.",
      "storage": "Merged plan stored as JobResultData::Text with metadata including source_job_ids, merge_instructions, source_count, merged_at timestamp, and session context."
    },
    "inputs": {
      "heading": "Merge Inputs",
      "items": [
        "Source plans: 2-5 implementation plans selected from the plan list",
        "Merge instructions: User guidance on how to combine (prioritize, resolve conflicts)",
        "Model selection: LLM model for merge generation",
        "Task context: Original task description for reference"
      ]
    },
    "xmlFormat": {
      "heading": "XML-Tagged Source Plans",
      "description": "Source plans are wrapped in XML tags with sequential identifiers:",
      "example": "<task_description>\n  [original task from session]\n</task_description>\n\n<source_plans>\n  <implementation_plan_1>\n    [full plan content from first source]\n  </implementation_plan_1>\n  <implementation_plan_2>\n    [full plan content from second source]\n  </implementation_plan_2>\n</source_plans>\n\n<user_instructions>\n  Prioritize API structure from plan 1.\n  Use database schema from plan 2.\n  Resolve conflicts by preferring newer patterns.\n</user_instructions>"
    },
    "prompt": {
      "heading": "Merge Prompt Structure",
      "description": "The merge prompt includes all context needed for intelligent combination:",
      "sections": [
        "System prompt with merge guidelines",
        "Source plans in XML tags",
        "User's merge instructions",
        "Task description for context",
        "Output format requirements"
      ]
    },
    "visuals": {
      "mergeWalkthrough": {
        "title": "Merge workflow walkthrough",
        "description": "Video showing the complete merge process from selection to output.",
        "videoSrc": "/videos/docs/merge-instructions/walkthrough.mp4",
        "posterSrc": "/images/docs/merge-instructions/flow.svg",
        "caption": "Placeholder for merge walkthrough video."
      },
      "mergeFlow": {
        "title": "Merge instructions flow",
        "description": "Diagram showing multi-model merge workflow with XML-tagged source plans.",
        "imageSrc": "/images/docs/merge-instructions/flow.svg",
        "caption": "Merge flow showing source selection, instruction processing, and output generation"
      }
    },
    "rules": {
      "heading": "マージルール",
      "description": "LLMは計画をマージする際にこれらのルールに従います：",
      "examples": [
        "ソース計画で指定されたファイルパスを正確に保持",
        "すべてのソースからの競合しない変更を結合",
        "競合については明示的なユーザー指示に従う",
        "マージされたコンテンツ全体で一貫したコードスタイルを維持",
        "ソース計画を示す来歴コメントを含める"
      ]
    },
    "output": {
      "heading": "マージされた出力",
      "description": "マージされた計画は個別の計画と同じ柔軟なフォーマットに従って、LLMから生テキストとして返されます。",
      "provenance": "各セクションには、どのソース計画がコンテンツを提供したかを示すコメントが含まれます。",
      "metadata": "source_job_ids、merge_instructions、source_count、merged_atタイムスタンプ、planTitle、summary、isStructured（false）、sessionNameがジョブメタデータに保存されます。"
    },
    "ui": {
      "heading": "UI統合",
      "description": "実装計画パネルはマージワークフローをサポートします：",
      "audit": "マージされた計画は完全な監査証跡のためにソース計画にリンクバックします。"
    },
    "cta": {
      "heading": "計画生成について学ぶ",
      "description": "マージ前に個別の計画がどのように作成されるかを理解しましょう。",
      "links": {
        "plans": "実装計画",
        "runtime": "ランタイムウォークスルー"
      }
    }
  },
  "meetingIngestionDoc": {
    "meta": {
      "title": "ミーティングと録画の取り込み - PlanToCode",
      "description": "録画がビデオ分析を通じて構造化されたタスク入力とアーティファクトになる方法。"
    },
    "category": "入力",
    "date": "2025-09-25",
    "readTime": "8分",
    "title": "ミーティング & 録画取り込み",
    "description": "録画が構造化されたタスク入力とアーティファクトになる方法。",
    "intro": "PlanToCodeはミーティング録画と画面キャプチャを処理してタスク関連情報を抽出できます。このドキュメントは録画から構造化アーティファクトまでの取り込みワークフローを説明します。",
    "visuals": {
      "ingestionFlow": {
        "title": "録画取り込みフロー",
        "description": "録画が文字起こしと分析をどのように流れるか。",
        "imageSrc": "/images/docs/deep-research/workflow.svg",
        "imageAlt": "録画取り込みフロー図",
        "caption": "取り込みフロー図のプレースホルダー。"
      }
    },
    "inputs": {
      "heading": "サポートされる入力",
      "description": "ミーティング取り込みパイプラインは様々な録画フォーマットを受け付けます：",
      "items": [
        "画面録画（MP4、WebM、MOV）",
        "Zoom、Meet、Teamsからのミーティング録画",
        "音声のみのファイル（MP3、WAV、M4A）",
        "デスクトップからの直接画面キャプチャ"
      ]
    },
    "uploadProcess": {
      "heading": "アップロードプロセス",
      "description": "録画はマルチパートフォームデータでサーバーにアップロードされます：",
      "stepsHeading": "処理ステップ",
      "steps": [
        "ファイルをサーバー一時ストレージにアップロード",
        "メタデータを抽出（長さ、フォーマット、解像度）",
        "文字起こし用にオーディオトラックを分離",
        "視覚分析用にビデオフレームをサンプリング",
        "結果を結合してクライアントに返す"
      ]
    },
    "normalization": {
      "heading": "フォーマット正規化",
      "description": "様々な入力フォーマットは処理前に正規化されます。オーディオはWhisper互換性のために16kHzモノラルWAVに変換されます。ビデオは設定可能なフレームサンプリングでネイティブ解像度で処理されます。",
      "outputs": "正規化された出力により、入力フォーマットに関係なく一貫したダウンストリーム処理が保証されます。"
    },
    "multimodalAnalysis": {
      "heading": "マルチモーダル分析",
      "description": "オーディオとビデオの両方を持つ録画はマルチモーダルモデルを使用して分析されます。{code}プレフィックスを持つモデルはネイティブビデオ理解をサポートします。",
      "combined": "オーディオ文字起こしと視覚分析が結合され、録画コンテンツの包括的な理解が生成されます。"
    },
    "transcription": {
      "heading": "オーディオ文字起こし",
      "description": "オーディオトラックはサーバーAPI経由でOpenAI Whisperを使用して文字起こしされます。",
      "attribution": "スピーカーダイアリゼーションは複数の声が検出された場合にテキストを異なるスピーカーに帰属させようとします。",
      "featuresHeading": "文字起こし機能",
      "features": [
        "自動検出による複数言語サポート",
        "アラインメント用の単語レベルタイムスタンプ",
        "スピーカーダイアリゼーション（マルチスピーカー）",
        "句読点とフォーマットの復元"
      ]
    },
    "frames": {
      "heading": "フレームサンプリング",
      "description": "ビデオフレームはUI状態の変化とユーザーアクションをキャプチャするために設定可能な間隔でサンプリングされます。",
      "timestamps": "各フレームにはオーディオトランスクリプトとの相関のためにタイムスタンプが含まれます。"
    },
    "structuredExtraction": {
      "heading": "構造化抽出",
      "description": "結合された分析は計画に適した構造化出力を生成します：",
      "extractedHeading": "抽出された要素",
      "items": [
        "言及されたアクションアイテムと決定",
        "表示されたUI要素とナビゲーションパス",
        "デモンストレーションされたエラー状態と問題",
        "実装のための技術コンテキスト"
      ]
    },
    "artifacts": {
      "heading": "分析アーティファクト",
      "description": "ミーティング分析はセッションに保存されるいくつかのアーティファクトを生成します：",
      "items": [
        "meeting_transcript：タイムスタンプ付きの完全なテキスト",
        "action_items：抽出されたタスクと決定",
        "ui_observations：視覚的状態変化",
        "combined_context：マージされた分析サマリー"
      ]
    },
    "keyFiles": {
      "heading": "主要ソースファイル",
      "items": [
        "desktop/src/components/meeting/MeetingUploader.tsx",
        "server/src/handlers/proxy/video_handler.rs",
        "server/src/services/video_processor.rs"
      ]
    },
    "handoff": {
      "heading": "計画へのハンドオフ",
      "description": "ミーティング分析アーティファクトはタスク説明に組み込むことができます：",
      "pipeline": "結合されたコンテキストはファイル検出と計画生成パイプラインに流れ、実装計画のための豊富なコンテキストを提供します。"
    },
    "cta": {
      "heading": "ビデオ分析へ続く",
      "description": "ビデオフレームがどのように分析されるかについてもっと学びましょう。",
      "links": {
        "video": "ビデオ分析",
        "textImprovement": "テキスト改善"
      }
    }
  },
  "videoAnalysisDoc": {
    "meta": {
      "title": "ビデオ分析 - PlanToCode",
      "description": "画面録画からのフレームサンプリング、プロンプト、分析アーティファクト。"
    },
    "category": "入力",
    "date": "2025-09-25",
    "readTime": "6分",
    "title": "ビデオ分析",
    "description": "録画からのフレームサンプリング、プロンプト、分析アーティファクト。",
    "intro": "ビデオ分析は画面録画からUI状態とアクションシーケンスを抽出します。これによりユーザーワークフローとバグ再現コンテキストの理解が可能になります。",
    "visuals": {
      "frameNotes": {
        "title": "ビデオ分析パイプライン",
        "description": "フレームが分析モデルをどのように流れるか。",
        "imageSrc": "/assets/images/demo-video-analysis.jpg",
        "imageAlt": "ビデオ分析インターフェース",
        "caption": "フレームキャプチャと分析オプションを表示するビデオ分析インターフェース。"
      }
    },
    "apiEndpoint": {
      "heading": "APIエンドポイント",
      "endpoint": "ビデオ分析はサーバーの{code}で処理されます。エンドポイントはビデオファイルと分析パラメータを含むマルチパートフォームデータを受け付けます。",
      "payloadHeading": "ペイロードフィールド",
      "payloadFields": [
        "video：ビデオファイル（MP4、WebM、MOV）",
        "model：分析用のモデル識別子",
        "prompt：オプションのカスタム分析プロンプト",
        "max_frames：サンプリングする最大フレーム数",
        "fps：フレームサンプリングレート"
      ]
    },
    "inputs": {
      "heading": "サポートされる入力フォーマット",
      "items": [
        "H.264またはH.265コーデック付きMP4",
        "VP8またはVP9コーデック付きWebM",
        "画面録画ツールからのMOV",
        "最大ファイルサイズ：100MB"
      ]
    },
    "sampling": {
      "heading": "フレームサンプリング",
      "description": "フレームはカバレッジとAPIコストのバランスを取るために設定可能な間隔で抽出されます。低いフレームレートはトークン使用量を削減しますが、急速な変化を見逃す可能性があります。",
      "fps": "デフォルトレートは毎秒1フレームです。詳細なUI分析には2-3 FPSが必要な場合があります。",
      "parametersHeading": "サンプリングパラメータ",
      "parameters": [
        "fps：抽出する秒あたりのフレーム数（0.5-5）",
        "max_frames：最大総フレーム数（10-100）",
        "start_time：サンプリング開始オフセット",
        "end_time：サンプリング停止オフセット"
      ]
    },
    "modelRequirements": {
      "heading": "モデル要件",
      "format": "ビデオ分析にはビジョン対応モデルが必要です。モデル識別子は{code}フォーマットに従います。現在、{code}モデルのみがネイティブビデオ分析をサポートしています。",
      "reasoning": "Google Geminiモデルはビデオをネイティブで処理できますが、他のビジョンモデルはフレームごとの画像分析が必要です。"
    },
    "analysis": {
      "heading": "分析プロセス",
      "description": "サンプリングされたフレームは分析プロンプトとともにビジョンモデルに送信されます。モデルはUI状態とユーザーアクションに関する構造化された観察を生成します。",
      "prompting": "システムプロンプトがモデルを録画の特定の側面に焦点を当てるようガイドします。",
      "promptElementsHeading": "プロンプト要素",
      "promptElements": [
        "UIインベントリ：可視要素とコントロールをリスト",
        "アクションシーケンス：ユーザーアクションを順序で説明",
        "エラー検出：エラー状態とメッセージを特定",
        "ナビゲーションパス：画面遷移を追跡"
      ]
    },
    "outputs": {
      "heading": "分析出力",
      "items": [
        "frame_observations：フレームごとのUI説明",
        "action_timeline：ユーザーアクションの順序付きリスト",
        "error_summary：観察されたエラーまたは問題",
        "context_summary：ハイレベルワークフロー説明"
      ]
    },
    "billing": {
      "heading": "トークン使用量 & 課金",
      "description": "ビデオ分析はフレーム数と解像度に基づいてトークンを消費します。各フレームは画像トークンとして処理されます。",
      "tracked": [
        "tokens_sent：プロンプト + 画像トークン",
        "tokens_received：分析レスポンストークン",
        "actual_cost：モデル価格から計算"
      ]
    },
    "storage": {
      "heading": "結果ストレージ",
      "description": "分析結果はtask_type 'video_analysis'でbackground_jobsテーブルに保存されます。レスポンスにはJSONフォーマットの完全な分析が含まれます。",
      "reuse": "結果はタスク説明に組み込むか、計画ワークフローで直接使用できます。"
    },
    "keyFiles": {
      "heading": "主要ソースファイル",
      "items": [
        "server/src/handlers/proxy/video_handler.rs",
        "server/src/services/video_processor.rs",
        "desktop/src/components/video/VideoAnalyzer.tsx"
      ]
    },
    "integration": {
      "heading": "計画との統合",
      "description": "ビデオ分析出力はコンテキスト対応計画のためにタスク説明に直接フィードできます。",
      "followup": "context_summaryは実装計画の出発点として特に有用です。"
    },
    "cta": {
      "heading": "ミーティング取り込みを見る",
      "description": "ビデオ分析がより広いミーティング取り込みワークフローにどのように適合するかを学びましょう。",
      "links": {
        "meeting": "ミーティング取り込み",
        "runtime": "ランタイムウォークスルー"
      }
    }
  },
  "mobileIos": {
    "meta": {
      "title": "iOSクライアントアーキテクチャ - PlanToCode",
      "description": "iOSコンパニオンアプリのSwiftワークフロー、Auth0ログインフロー、デバイスリンクセッション管理。"
    },
    "category": "アーキテクチャ",
    "date": "2025-09-25",
    "readTime": "12分",
    "title": "iOSクライアントアーキテクチャ",
    "description": "Swiftワークフロー、Auth0ログインフロー、デバイスリンクセッション管理。",
    "intro": "PlanToCode iOSアプリは、リンクされたデスクトップセッションに接続するコンパニオンクライアントです。デスクトップをプライマリプランニングワークスペースとして維持しながら、ターミナル出力、ジョブステータス、音声文字起こしへのモバイルアクセスを提供します。",
    "visuals": {
      "app": {
        "title": "iOSアプリインターフェース",
        "description": "デバイスリンクとターミナルビューを表示するiOSアプリのスクリーンショット。",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "PlanToCode iOSアプリのスクリーンショット",
        "caption": "iOSアプリスクリーンショットのプレースホルダー。"
      }
    },
    "packageStructure": {
      "heading": "Swiftパッケージ構造",
      "description": "iOSアプリはSwiftパッケージに整理されています：",
      "packages": [
        {
          "name": "Core",
          "path": "mobile/ios/Core/",
          "description": "ビジネスロジックとAPIクライアント",
          "components": [
            "WorkflowManager",
            "APIClient",
            "MobileSessionManager",
            "DeviceLinkClient"
          ]
        },
        {
          "name": "Security",
          "path": "mobile/ios/Security/",
          "description": "認証と資格情報ストレージ",
          "components": [
            "Auth0Manager",
            "KeychainHelper",
            "TokenStore"
          ]
        },
        {
          "name": "VibeUI",
          "path": "mobile/ios/VibeUI/",
          "description": "SwiftUIコンポーネントとデザインシステム",
          "components": [
            "TerminalView",
            "JobListView",
            "SettingsView",
            "DeviceLinkView"
          ]
        }
      ]
    },
    "auth": {
      "heading": "Auth0 PKCE統合",
      "description": "iOSアプリはセキュアな認証のためにAuth0とPKCEフローを使用します：",
      "flow": [
        "ユーザーがサインインをタップ、アプリがコード検証子とチャレンジを生成",
        "ASWebAuthenticationSessionがAuth0ログインページを開く",
        "ユーザーが認証、Auth0が認可コードでリダイレクト",
        "アプリがコード検証子を使用してコードをトークンに交換",
        "トークンはiOS Keychainに安全に保存"
      ],
      "tokenManagement": {
        "heading": "トークン管理",
        "items": [
          "アクセストークンはAPIリクエストに使用",
          "リフレッシュトークンはサイレント更新用に保存",
          "有効期限前にトークン更新がトリガー",
          "ログアウト時にKeychainからすべてのトークンをクリア"
        ]
      }
    },
    "deviceLink": {
      "heading": "WebSocketリレー経由のデバイスリンク",
      "description": "iOSはサーバーのWebSocketリレーを通じてデスクトップセッションに接続します：",
      "protocol": {
        "heading": "リンクプロトコル",
        "steps": [
          "デスクトップがリンクコードを生成しQRを表示",
          "iOSがQRをスキャンまたはコードを手動入力",
          "両方が資格情報で/ws/device-linkに接続",
          "サーバーが検証しリレーを確立",
          "双方向通信が有効化"
        ]
      },
      "messageTypes": {
        "heading": "メッセージタイプ",
        "items": [
          "terminal_output: デスクトップターミナルからのPTY出力",
          "job_status: バックグラウンドジョブステータス更新",
          "session_sync: セッション状態同期",
          "rpc_command: モバイルからデスクトップへのコマンド"
        ]
      },
      "reconnection": {
        "heading": "再接続処理",
        "description": "WebSocket接続は自動再接続、指数バックオフ、セッション状態回復でネットワーク中断を処理します。"
      }
    },
    "rpcRouting": {
      "heading": "RPCコマンドルーティング",
      "description": "iOSはリンクされたデスクトップにコマンドを送信できます：",
      "commands": {
        "heading": "サポートされるコマンド",
        "items": [
          "send_terminal_input: ターミナルにキーストロークを送信",
          "request_job_status: 特定ジョブのステータスを取得",
          "start_voice_transcription: モバイルで録音を開始",
          "sync_session: 完全なセッション状態をリクエスト"
        ]
      },
      "implementation": {
        "heading": "実装",
        "description": "コマンドはWebSocket経由で送信されるJSON-RPCメッセージです。デスクトップはコマンドを検証し、結果を非同期で返します。"
      }
    },
    "offlineQueue": {
      "heading": "オフラインアクションキュー",
      "description": "切断中に実行されたアクションは同期用にキューに入れられます：",
      "architecture": {
        "heading": "キューアーキテクチャ",
        "items": [
          "アクションはローカルSQLiteデータベースに保存",
          "再接続時にキューを処理",
          "サーバータイムスタンプで競合を解決",
          "失敗したアクションをユーザーに報告"
        ]
      },
      "supportedActions": {
        "heading": "サポートされるオフラインアクション",
        "items": [
          "音声文字起こし録音（ローカルに保存）",
          "セッションメモと注釈",
          "設定変更"
        ]
      }
    },
    "localStorage": {
      "heading": "SQLiteローカルストレージ",
      "description": "iOSはローカル永続化にSQLiteを使用します：",
      "database": {
        "heading": "データベーススキーマ",
        "path": "~/Documents/plantocode.sqlite",
        "tables": [
          "linked_devices: デスクトップ接続",
          "offline_queue: 保留中の同期アクション",
          "cached_sessions: 最近のセッションデータ",
          "transcriptions: ローカル音声録音"
        ]
      },
      "migrations": {
        "heading": "マイグレーション",
        "description": "スキーマバージョンはuser_version pragmaで追跡。マイグレーションはアプリ起動時に実行されます。"
      }
    },
    "sessions": {
      "heading": "モバイルセッション",
      "description": "MobileSessionManagerがセッション状態を調整します：",
      "lifecycle": [
        "起動時に最後のアクティブセッションをロード",
        "利用可能な場合はリンクされたデスクトップに接続",
        "WebSocket経由でセッション更新をサブスクライブ",
        "オフラインアクセス用にセッションデータをキャッシュ"
      ]
    },
    "workflows": {
      "heading": "ワークフローエントリーポイント",
      "description": "モバイルからアクセス可能な主要ワークフロー：",
      "items": [
        "ターミナル監視: 出力を表示、入力を送信",
        "ジョブステータス: バックグラウンドジョブの進行状況を追跡",
        "音声キャプチャ: モバイルで録音と文字起こし",
        "セッションブラウジング: プランと履歴を確認"
      ]
    },
    "region": {
      "heading": "リージョン設定",
      "description": "iOSはAPIルーティングのユーザーリージョン設定を尊重します：",
      "implementation": "リージョンはUserDefaultsに保存され、すべてのリクエストでapi-eu.plantocode.comまたはapi-us.plantocode.comの選択に使用されます。"
    }
  },
  "providerRouting": {
    "meta": {
      "title": "プロバイダールーティングとストリーミング - PlanToCode",
      "description": "PlanToCodeがプロキシ経由でLLMリクエストをルーティングし、レスポンスを正規化し、デスクトップクライアントにトークンをストリーミングする方法。"
    },
    "category": "リサーチ＆モデル",
    "date": "2025-09-24",
    "readTime": "10分",
    "title": "プロバイダールーティングとストリーミング",
    "description": "正規化、ストリーミング、使用量追跡を備えたすべての外部LLMリクエストを仲介するルーティングレイヤー。",
    "visuals": {
      "routingMap": {
        "title": "プロバイダールーティングマップ",
        "description": "デスクトップアプリからプロキシ経由でプロバイダーへリクエストがフローする図。",
        "imageSrc": "/images/docs/provider-routing/routing-map.svg",
        "imageAlt": "デスクトップから外部プロバイダーへのプロバイダールーティングフロー図",
        "caption": "プロバイダールーティング図のプレースホルダー。"
      }
    },
    "cta": {
      "heading": "モデル設定へ続く",
      "description": "モデル設定では、許可リストとトークンガードレールがUIにどのように公開されるかを説明します。",
      "links": {
        "modelConfiguration": "モデル設定",
        "runtimeWalkthrough": "ランタイムウォークスルー"
      }
    }
  }
}
