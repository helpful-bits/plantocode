{
  "hub": {
    "meta": {
      "title": "PlanToCode Funktionen - KI-Entwicklungsplanungswerkzeuge",
      "description": "Entdecken Sie leistungsstarke Funktionen: Dateisuche, Multi-Modell-Planung, Sprachtranskription, Videoanalyse, Merge-Anweisungen und integrierte Terminal-Ausführung."
    },
    "badge": "Component docs",
    "cta": {
      "description": "Use these component docs to trace each subsystem to the processors, prompts, and UI surfaces that implement it.",
      "title": "Trace the implementation",
      "links": {
        "docs": "Open docs",
        "architecture": "Architecture overview"
      }
    }
  },
  "fileDiscovery": {
    "benefits": {
      "costEffective": {
        "description": "Token-aware batching with cost tracking at each stage.",
        "title": "Token budgeting"
      },
      "multiStage": {
        "description": "Four-stage workflow with regex filtering, relevance assessment, and relationship analysis to identify relevant files.",
        "title": "Multi-stage pipeline"
      },
      "realTimeProgress": {
        "description": "Stage-by-stage progress updates emitted by background jobs.",
        "title": "Progress visibility"
      }
    },
    "capabilities": {
      "git": {
        "description": "Executes `git ls-files --cached --others --exclude-standard` to respect .gitignore rules. Falls back to git2 library if command fails.",
        "features": [
          "Git ls-files with .gitignore respect",
          "Binary file detection and filtering",
          "Extension-based exclusion list for common binary types",
          "Content analysis for binary detection"
        ],
        "title": "Git Repository Integration"
      },
      "planIntegration": {
        "description": "Discovered files feed directly into the implementation planning system. Context is preserved and reused across sessions.",
        "features": [
          "Plan generation handoff",
          "Context preservation across sessions",
          "Multiple plan drafts per task",
          "Structured plan inputs"
        ],
        "title": "Implementation Plan Integration"
      },
      "title": "Advanced Discovery Capabilities",
      "tokenManagement": {
        "description": "Content-aware token estimation drives batching. Ratios for JSON/XML (5 chars/token), code (3 chars/token), and text (4 chars/token) guide chunking.",
        "features": [
          "Dynamic chunk sizing per file type",
          "2000-token prompt overhead reservation",
          "Token-budgeted batching (size varies by content and limits)",
          "Chunking based on estimated tokens, not fixed file counts"
        ],
        "title": "Smart Token Management"
      },
      "workflow": {
        "description": "WorkflowOrchestrator manages lifecycle with lazy initialization, dependency scheduling, and orphaned job recovery. Each stage runs as an independent background job.",
        "features": [
          "Stage dependency management",
          "Event-driven progress updates via Tauri",
          "WorkflowIntermediateData persistence",
          "Exponential backoff retry logic"
        ],
        "title": "Distributed Workflow Orchestration"
      }
    },
    "cta": {
      "links": {
        "docs": "Read file discovery docs"
      },
      "title": "Explore the internals"
    },
    "hero": {
      "badge": "File discovery workflow",
      "description": "PlanToCode stages file discovery as a Rust workflow that narrows, scores, and persists context before any plan generation.",
      "title": "File Discovery Pipeline"
    },
    "pipeline": {
      "title": "How the File Discovery Pipeline Works",
      "description": "Before any LLM call, the system builds a candidate index, applies deterministic filters, then uses relevance scoring to minimize tokens and noise.",
      "cards": {
        "index": {
          "title": "Index",
          "description": "Scan Git-tracked paths and build a local candidate set with directory hierarchy context."
        },
        "filter": {
          "title": "Filter",
          "description": "Apply regex patterns, ignore rules, and file-type heuristics to reduce the candidate pool."
        },
        "score": {
          "title": "Score",
          "description": "Run LLM-assisted relevance scoring and persist ranked results for later plan generation."
        }
      }
    },
    "performance": {
      "accuracy": {
        "description": "Multi-stage refinement with relevance assessment and relationship analysis captured per job.",
        "title": "Relevance Quality",
        "value": "Traceable"
      },
      "cost": {
        "description": "Token estimation and batching keep prompts small before LLM scoring.",
        "title": "Token Budgeting",
        "value": "Token-aware"
      },
      "speed": {
        "description": "Stage-by-stage jobs stream updates without blocking the UI.",
        "title": "Job Scheduling",
        "value": "Staged"
      },
      "title": "Operational Characteristics"
    },
    "workflow": {
      "stage1": {
        "description": "Analyzes the directory structure (up to 2 levels deep) to identify candidate project areas and select parent folders vs. subdirectories.",
        "features": [
          "Hierarchical directory analysis",
          "Parent/subdirectory selection heuristics",
          "Avoids redundant nested selections"
        ],
        "title": "Root Folder Selection"
      },
      "stage2": {
        "description": "Generates regex patterns and performs initial file filtering. Integrates with git to respect .gitignore rules and filter binary files.",
        "features": [
          "Dynamic regex pattern creation",
          "Git ls-files integration",
          "Binary file detection and exclusion"
        ],
        "title": "Regex Pattern Generation & Filtering"
      },
      "stage3": {
        "description": "LLM-based relevance scoring to assess file relevance to the task. Uses token-aware batching with content-aware estimation.",
        "features": [
          "Content-based relevance scoring",
          "Token-aware batching",
          "2000-token overhead management"
        ],
        "title": "File Relevance Assessment"
      },
      "stage4": {
        "description": "Discovers additional contextually relevant files through relationship analysis. Analyzes imports, configurations, and project structure to find related files.",
        "features": [
          "Import statement analysis",
          "Dependency graph traversal",
          "Configuration file discovery"
        ],
        "title": "Extended Path Discovery"
      },
      "title": "The 4-Stage Discovery Workflow"
    }
  },
  "mergeInstructions": {
    "capabilities": {
      "instructionControl": {
        "examples": [
          {
            "type": "Priorisierung",
            "example": "\"Fokus auf Plan 2s Sicherheit\""
          },
          {
            "type": "Struktur",
            "example": "\"Nach Komponente organisieren\""
          },
          {
            "type": "Ansatz",
            "example": "\"Verwende Plan 1s Datenbankstrategie\""
          },
          {
            "type": "Qualität",
            "example": "\"Umfassendes Testen einschließen\""
          },
          {
            "type": "Umfang",
            "example": "\"Deployment-Schritte ausschließen\""
          },
          {
            "type": "Integration",
            "example": "\"Beispiel aus Dokumentation verwenden\""
          },
          {
            "type": "Auflösung",
            "example": "\"Bevorzuge Microservices statt Monolith\""
          }
        ],
        "title": "Wie Anweisungen die Synthese steuern"
      },
      "title": "Tatsächliche Systemfähigkeiten",
      "whatAIDoes": {
        "items": [
          "Studiert alle Quellpläne zur Identifizierung einzigartiger Erkenntnisse",
          "Löst architektonische Konflikte mit SOLID-Prinzipien",
          "Erstellt emergente Lösungen jenseits einfacher Kombination",
          "Fügt Inline-Quellen-Markierungen für jede Entscheidung hinzu",
          "Validiert architektonische Kohärenz durchgehend",
          "Behandelt externe Beispielintegration",
          "Erhält Relevanz zur ursprünglichen Aufgabe"
        ],
        "title": "Was die KI tatsächlich tut"
      }
    },
    "cta": {
      "description": "Jenseits von Zusammenführung – intelligente architektonische Analyse mit SOLID-Prinzipien. So sollte Plansynthese funktionieren – intelligent, nachverfolgbar, emergent.",
      "links": {
        "docs": "Implementation plan docs",
        "planMode": "Plangenerierung erkunden",
        "demo": "In Aktion sehen"
      },
      "title": "Erleben Sie echte architektonische Synthese"
    },
    "features": {
      "architecturalAnalysis": {
        "description": "Nicht nur Verkettung. KI analysiert tiefgehend die Architektur jedes Plans und identifiziert einzigartige Erkenntnisse und Ansätze.",
        "title": "Echte architektonische Analyse"
      },
      "solidResolution": {
        "description": "Konflikte werden mit Software-Engineering-Best-Practices gelöst. Erstellt architektonisch solide Lösungen.",
        "title": "SOLID-Prinzip-Auflösung"
      },
      "sourceTraceability": {
        "description": "Jedes zusammengeführte Element enthält Inline-Attributionsmarkierungen, die genau zeigen, aus welchem Quellplan es stammt.",
        "title": "Quellen-Nachverfolgbarkeit [src:P1]"
      }
    },
    "hero": {
      "badge": "Architektonische Synthese mit Quellen-Nachverfolgbarkeit",
      "description": "KI führt tiefgehende architektonische Analyse mehrerer Pläne durch, löst Konflikte mit SOLID-Prinzipien und synthetisiert emergente Lösungen. Jede Entscheidung enthält Quellenattribution [src:P1 step 2] für vollständige Nachverfolgbarkeit.",
      "title": "Jenseits einfacher Zusammenführung: Architektonische Synthese"
    },
    "example": {
      "heading": "Example merged output with source traceability:",
      "steps": [
        "Step 1: Set up database schema [src:P1 step 3]",
        "Step 2: Implement authentication [src:P2 step 1, P3 step 2]",
        "Step 3: Create API endpoints [src:P3 step 4 - cleaner approach]",
        "Step 4: Add error handling [src:EMERGENT - combining P1, P2 patterns]",
        "Step 5: Implement caching [src:P1 step 7, optimized with P2 insights]"
      ]
    },
    "implementation": {
      "aiPrompt": {
        "description": "Ausgefeilter Prompt erzwingt Qualität und Nachverfolgbarkeit.",
        "features": [
          "Experten-Software-Architekten-Persona",
          "SOLID-Prinzip-Konfliktlösung",
          "Obligatorische Quellenattribution",
          "Emergente Lösungserstellung",
          "Qualitäts-Validierungs-Gates"
        ],
        "title": "KI-System-Prompt"
      },
      "backend": {
        "description": "ImplementationPlanMergeProcessor orchestriert die gesamte Synthese.",
        "features": [
          "Holt rohes XML aus Quellplänen",
          "Extrahiert relevante Dateikontexte",
          "Generiert Projektstrukturbaum",
          "Baut umfassenden LLM-Prompt",
          "Streamt Antwort mit Echtzeit-Updates"
        ],
        "title": "Backend-Verarbeitung"
      },
      "frontend": {
        "description": "Reichhaltiges UI für Planauswahl und Anweisungseingabe.",
        "features": [
          "MergePlansSection mit klappbarem UI",
          "FloatingMergeInstructions (verschiebbar)",
          "Echtzeit-Textverbesserungs-Unterstützung",
          "Debounced State-Management",
          "Sitzungs-Persistenz für Anweisungen"
        ],
        "title": "Frontend-Komponenten"
      },
      "metadata": {
        "description": "Full job history for traceability and debugging.",
        "features": [
          "Quell-Job-IDs bewahrt",
          "Vollständiger Prompt für Debugging gespeichert",
          "Merge-Anweisungen verfolgt",
          "Dateioperationen extrahiert",
          "Priorität 2 Job-Planung"
        ],
        "title": "Metadaten & Speicherung"
      },
      "title": "Technische Implementierungsdetails"
    },
    "process": {
      "deepAnalysis": {
        "description": "KI führt umfassende Analyse vor Synthese durch, keine einfache Verkettung.",
        "features": [
          "Identifiziert einzigartige Erkenntnisse aus jedem Plan",
          "Löst Konflikte mit SOLID-Prinzipien",
          "Bewahrt wertvolle architektonische Entscheidungen",
          "Erstellt emergente Lösungen jenseits der Quellen"
        ],
        "title": "Tiefgehende architektonische Analyse"
      },
      "instructions": {
        "description": "Ihre Anweisungen steuern die Synthese direkt. KI versteht komplexe architektonische Anweisungen.",
        "examples": [
          "Priorisierung: \"Fokus auf Sicherheit aus Plan 2\"",
          "Struktur: \"Chronologisch organisieren\"",
          "Ansatz: \"Verwende Plan 1s Datenbankstrategie\"",
          "Umfang: \"Schließe Tests aus, fokussiere auf Kern\""
        ],
        "title": "Intelligente Anweisungsverarbeitung"
      },
      "multiModel": {
        "description": "Führen Sie GPT-5.2 und Gemini mehrfach aus. Jeder Durchlauf geht unterschiedlich mit großem Kontext um und bringt komplementäre Implementierungsdetails hervor.",
        "features": [
          "Jeder Plan mit vollständigen Metadaten gespeichert",
          "Relevante Dateien automatisch extrahiert",
          "Projektstrukturkontext enthalten",
          "Temperaturvariationen für Vielfalt"
        ],
        "title": "Multi-Modell-Plangenerierung"
      },
      "synthesis": {
        "description": "Erstellt umfassende Lösung mit vollständiger Quellenattribution für jede Entscheidung.",
        "features": [
          "Inline-Markierungen: [src:P1 step 2, P3 step 5]",
          "Unterstützung externer Beispielintegration",
          "Qualitäts-Validierungs-Checkpoints",
          "Architektonische Kohärenz beibehalten"
        ],
        "title": "Synthese mit voller Nachverfolgbarkeit"
      },
      "title": "Der architektonische Syntheseprozess"
    },
    "value": {
      "architecturalSynthesis": {
        "description": "Keine Verkettung. KI führt tiefgehende architektonische Analyse durch und erstellt emergente Lösungen, die jenseits einzelner Quellpläne gehen.",
        "title": "Architektonische Synthese"
      },
      "completeTraceability": {
        "description": "Jede Entscheidung enthält [src:P1 step 2] Markierungen. Wissen Sie genau, woher jede architektonische Wahl stammt.",
        "title": "Vollständige Nachverfolgbarkeit"
      },
      "solidPractices": {
        "description": "Konflikte werden mit Software-Engineering-Prinzipien gelöst, nicht willkürlichen Entscheidungen. Architektonisch solide Ergebnisse.",
        "title": "SOLID-Engineering-Praktiken"
      },
      "title": "Der wahre Wert: Jenseits einfacher Zusammenführung"
    }
  },
  "planMode": {
    "copyButtons": {
      "examples": {
        "serverConfigured": {
          "button": "Button: \"Parallel Claude Coding Agents\"",
          "hint": "+ Custom instructions...",
          "template": "Template: \"{{IMPLEMENTATION_PLAN}}\""
        },
        "stepExtraction": {
          "copyAll": "Copy All Steps",
          "copyStep": "Copy Step 3",
          "copyWithInstructions": "Copy with Instructions"
        }
      },
      "serverConfigured": {
        "description": "Server-configured copy buttons with template placeholders.",
        "title": "Server-Configured Buttons"
      },
      "stepExtraction": {
        "description": "Copy individual steps or full plans using the structured plan format.",
        "title": "Structured Step Extraction"
      },
      "title": "Configurable Copy Button System"
    },
    "cta": {
      "description": "Follow how plans are generated, reviewed, merged, and handed off to execution, with job history for each step.",
      "links": {
        "mergePlans": "Merge pipeline",
        "terminal": "Terminal sessions"
      },
      "title": "Trace the plan pipeline"
    },
    "editing": {
      "monaco": {
        "description": "Vollständige VS Code-Editor-Erfahrung. Kein Textbereich – ein professioneller Code-Editor mit allen Features.",
        "features": [
          "XML-Syntax-Highlighting",
          "Suchen & Ersetzen mit Regex",
          "Multi-Cursor-Bearbeitung",
          "Auto-Save in Datenbank"
        ],
        "title": "Monaco-Editor-Integration"
      },
      "terminal": {
        "description": "Führen Sie Pläne direkt in persistenten Terminal-Sitzungen aus. Spracheingabe, Zustandsüberwachung, volle Kontrolle.",
        "features": [
          "Persistente Terminal-Sitzungen",
          "Sprachtranskriptions-Eingabe",
          "Plan/Schritte ins Terminal kopieren",
          "Sitzungs-Zustandsüberwachung"
        ],
        "title": "Integrierte Terminal-Ausführung"
      },
      "title": "Professionelle Bearbeitung & Ausführung"
    },
    "features": {
      "intelligentGeneration": {
        "description": "Vollständiges Laden von Dateiinhalten (keine Kürzung). Intelligente Verzeichnisbäume. Multi-Modell-Unterstützung mit Projektkonfigurationen.",
        "title": "Intelligente Generierung"
      },
      "monacoEditor": {
        "description": "VS Codes Editor mit XML-Syntax-Highlighting. Echtzeit-Bearbeitung mit Auto-Save in Datenbank.",
        "title": "Monaco-Editor"
      },
      "terminalExecution": {
        "description": "Führen Sie Pläne direkt im integrierten Terminal aus. Kopieren Sie Schritte oder vollständige Pläne. Sprachtranskriptions-Unterstützung.",
        "title": "Terminal-Ausführung"
      }
    },
    "fileByFile": {
      "description": "Pläne gliedern Entwicklungsaufgaben mit exakten Dateipfaden entsprechend Ihrer Projekt-Repository-Struktur. Diese Granularität macht die Auswirkung von Änderungen kristallklar und verhindert Regressionen, Bugs und unbeabsichtigte Modifikationen, die bei autonomen Coding-Agents auftreten können.",
      "exactPaths": {
        "description": "Jeder Schritt spezifiziert exakte Dateipfade aus Ihrem Repository. Keine Mehrdeutigkeit darüber, welche Dateien modifiziert, erstellt oder gelöscht werden.",
        "title": "Exakte Dateipfade"
      },
      "preventRegressions": {
        "description": "Sehen Sie genau, welcher Legacy-Code berührt wird. Identifizieren Sie potenzielle Breaking Changes, bevor sie passieren. Selbstbewusste Adoption von KI-Coding-Agents.",
        "features": [
          "Klare Auswirkungsbewertung",
          "Breaking-Change-Erkennung",
          "Legacy-Code-Schutz"
        ],
        "title": "Regressionen verhindern"
      },
      "title": "Datei-für-Datei-Granularität für maximale Sicherheit"
    },
    "generation": {
      "fullContext": {
        "description": "Anders als andere Systeme laden wir vollständige Dateiinhalte. Keine präventive Kürzung – nur intelligente Warnungen.",
        "features": [
          "Vollständiger Dateiinhalt, keine Kürzung",
          "Paralleles Dateiladen für Geschwindigkeit",
          "Token-Warnungen bei >100k Tokens",
          "Intelligente Verzeichnisbaum-Generierung"
        ],
        "title": "Vollständiges Kontext-Laden"
      },
      "multiModel": {
        "description": "Wählen Sie aus mehreren KI-Modellen mit projektspezifischen Konfigurationen und Temperatureinstellungen.",
        "features": [
          "GPT-5.2, Claude Sonnet 4, Gemini 3 Pro",
          "Projektspezifische Modelleinstellungen",
          "Echtzeit-Token-Schätzung",
          "Kontextfenster-Validierung"
        ],
        "title": "Multi-Modell-Architektur"
      },
      "streaming": {
        "description": "Beobachten Sie Pläne in Echtzeit mit Live-Fortschrittsbalken und Streaming-Content-Updates.",
        "features": [
          "Live-Streaming mit Fortschrittsbalken",
          "Echtzeit-Syntax-Highlighting",
          "Token-Zähler-Updates während Generierung",
          "Hintergrund-Job-Status-Verfolgung"
        ],
        "title": "Echtzeit-Streaming"
      },
      "title": "KI-gestützte Plangenerierung mit vollem Kontext",
      "xmlFormat": {
        "description": "Pläne verwenden strukturiertes XML mit nummerierten Schritten, was programmatische Manipulation und Extraktion ermöglicht.",
        "features": [
          "<step number=\"X\"> Organisation",
          "Titel und Beschreibung pro Schritt",
          "Dateioperations-Tracking",
          "Schritt-für-Schritt-Extraktions-Unterstützung"
        ],
        "title": "Strukturiertes XML-Format"
      }
    },
    "guides": {
      "claudeCode": {
        "description": "Verbessern Sie Claude Codes nativen Plan-Modus mit Multi-Modell-Synthese und Dateisuche.",
        "link": "Öffnen Sie die Anleitung zum Claude Code Planungs-Workflow",
        "name": "Claude Code Planungs-Workflow"
      },
      "codex": {
        "description": "Vorplanen von Codex-Durchläufen mit Dateisuche, Multi-Modell-Merges und Genehmigungsmodi.",
        "link": "Öffnen Sie die Anleitung zum Codex CLI Planungs-Workflow",
        "name": "Codex CLI Planungs-Workflow"
      },
      "cursor": {
        "description": "Geben Sie Cursor Composer vollständiges architektonisches Bewusstsein, einschließlich WSL-sicherer Ausführung.",
        "link": "Öffnen Sie die Anleitung zum Cursor Plan-Workflow",
        "name": "Cursor Plan-Workflow"
      },
      "title": "Anleitungen für Ihren IDE-Planmodus"
    },
    "hero": {
      "badge": "Vollständiges Implementierungsplanungssystem",
      "description": "Human-in-the-Loop-Governance mit dateispezifischer Granularität für sichere KI-gestützte Entwicklung",
      "title": "Implementierungspläne: generieren - bearbeiten - ausführen"
    },
    "humanInLoop": {
      "approve": {
        "description": "Wenn Sie zufrieden sind, übertragen Sie den genehmigten Plan sicher an Ihren gewählten Coding-Agent oder zugewiesenen Entwickler. Vollständiger Audit-Trail wird gepflegt.",
        "title": "Genehmigen & übertragen"
      },
      "description": "Teamleiter und Stakeholder behalten die volle Kontrolle zur Überprüfung, Bearbeitung und Genehmigung jedes Aspekts von Implementierungsplänen, bevor Code-Änderungen beginnen. Dies stellt sicher, dass alle Entwicklungsbemühungen mit Unternehmensproduktanforderungen, Team-Workflows und Geschäftszielen übereinstimmen.",
      "edit": {
        "description": "Volle Bearbeitungsmöglichkeiten mit VS Code-Features. Passen Sie Ansätze an, fügen Sie Einschränkungen hinzu, entfernen Sie riskante Schritte. Der Plan gehört Ihnen zur Perfektionierung.",
        "title": "Pläne bearbeiten & modifizieren"
      },
      "review": {
        "description": "Jeder KI-generierte Plan öffnet sich im Monaco-Editor zur gründlichen Überprüfung. Keine autonome Ausführung – Sie sehen und genehmigen jede vorgeschlagene Änderung.",
        "title": "Überprüfung vor Ausführung"
      },
      "title": "Human-in-the-Loop-Governance"
    },
    "technical": {
      "noTruncation": {
        "description": "Vollständiger Dateiinhalt geladen. Warnt bei >100k Tokens, kürzt aber nicht. Sie erhalten vollständigen Kontext.",
        "title": "Keine-Kürzungs-Richtlinie"
      },
      "persistence": {
        "description": "Pläne gespeichert mit Metadaten, Kostenverfolgung und vollständiger Prompt-Historie. Alles ist auditierbar.",
        "title": "Datenbank-Persistenz"
      },
      "templates": {
        "description": "Serverseitige Prompts mit Projekt-Overrides. Einheitlicher Prompt-Prozessor mit intelligenten Platzhaltern.",
        "title": "Template-System"
      },
      "title": "Unter der Haube"
    },
    "workflow": {
      "steps": [
        {
          "title": "KI-Dateisuche",
          "description": "Intelligenter Dateifinder identifiziert relevante Dateien. Wählen Sie Stammverzeichnisse für fokussierten Kontext. Keine Kürzung."
        },
        {
          "title": "Multi-Modell-Generierung",
          "description": "Führen Sie Modelle mehrfach aus (3x GPT-5.2, 2x Gemini). Jeder Durchlauf bringt komplementäre Implementierungsdetails hervor. Echtzeit-Streaming mit Fortschrittsverfolgung."
        },
        {
          "title": "In Monaco bearbeiten",
          "description": "Professionelle Bearbeitung mit VS Code-Features. Fügen Sie Schritte hinzu, modifizieren Sie Ansätze, strukturieren Sie Pläne um."
        },
        {
          "title": "Architektonische Synthese",
          "description": "Verschmelzen Sie mehrere Pläne mit benutzerdefinierten Anweisungen. SOLID-Prinzip-Auflösung, Quellen-Nachverfolgbarkeit."
        },
        {
          "title": "Im Terminal ausführen",
          "description": "Führen Sie Ihren Plan im integrierten Terminal aus. Sprachbefehle, persistente Sitzungen, echte Ergebnisse."
        }
      ],
      "title": "Der vollständige Planungs-Workflow"
    },
    "references": {
      "architecture": {
        "description": "System boundaries, IPC, and background jobs.",
        "title": "Architecture overview"
      },
      "buildYourOwn": {
        "description": "Design the pipeline stages in your own project.",
        "title": "Build your own pipeline"
      },
      "implementationPlans": {
        "description": "Plan format, storage, and review flow.",
        "title": "Implementation plan format"
      },
      "link": "Open docs",
      "title": "Related references"
    }
  },
  "textImprovement": {
    "capabilities": {
      "contextAware": {
        "description": "KI versteht Ihre Projektstruktur, enthaltene Dateien und benutzerdefinierte Anweisungen bei der Textverfeinerung.",
        "title": "Kontextbewusste Verfeinerung"
      },
      "customizable": {
        "description": "Definieren Sie projektspezifische Prompts mit Platzhaltern für Dateiinhalte, Verzeichnisbaum und benutzerdefinierte Anweisungen.",
        "title": "Anpassbare System-Prompts"
      },
      "instant": {
        "description": "Nicht-Streaming-Verarbeitung für Geschwindigkeit. Ergebnisse direkt angewendet mit Konflikterkennung zum Schutz Ihrer Bearbeitungen.",
        "title": "Sofortige Anwendung"
      },
      "mentalModel": {
        "description": "Iterative Verfeinerung hilft KI, Ihre Absicht zu verstehen. Auswählen → verfeinern → erneut verfeinern bis perfekt.",
        "title": "Erfassung mentaler Modelle"
      },
      "title": "Hauptfähigkeiten"
    },
    "cta": {
      "links": {
        "docs": "Text improvement docs",
        "demo": "Demo ansehen",
        "voice": "Sprachfunktionen ansehen"
      },
      "title": "Beginnen Sie mit KI klare Spezifikationen zu erfassen"
    },
    "faq": {
      "codeEditor": {
        "answer": "Ja. Funktioniert in Aufgabenbeschreibungsfeldern und Monaco-Code-Editoren. Text auswählen → Popover erscheint → Aktion wählen.",
        "question": "Funktioniert es in Code-Editoren?"
      },
      "conflicts": {
        "answer": "Konflikterkennung verhindert das Überschreiben Ihrer Bearbeitungen. Wenn sich Text während der Verarbeitung änderte, wird die Verbesserung mit Warnung übersprungen.",
        "question": "Was passiert, wenn ich Text während laufender Verbesserung bearbeite?"
      },
      "customize": {
        "answer": "Ja. Definieren Sie projektspezifische System-Prompts mit Platzhaltern für Dateiinhalte, Verzeichnisbaum, benutzerdefinierte Anweisungen und mehr.",
        "question": "Kann ich die Verbesserungs-Prompts anpassen?"
      },
      "model": {
        "answer": "Standard: Claude Sonnet 3.5 über OpenRouter. Sie können unterschiedliche Modelle pro Projekt in Einstellungen konfigurieren.",
        "question": "Welches KI-Modell verwendet Textverbesserung?"
      }
    },
    "hero": {
      "badge": "Spezifikationserfassungsmodus • Zwei KI-Prompt-Typen",
      "credits": "$5 Gratis-Guthaben • Pay-as-you-go • Funktioniert auf macOS und Windows",
      "description": "Der Spezifikationserfassungsmodus bietet ZWEI UNTERSCHIEDLICHE KI-Prompt-Typen, die Unternehmensteams helfen, Anforderungen zu erfassen und zu verfeinern, die Entwicklungsteams selbstbewusst umsetzen können.",
      "installButton": "PlanToCode installieren",
      "subtitle": "Textverbesserung verbessert Klarheit und Grammatik. Aufgabenverfeinerung erweitert Vollständigkeit und Implementierungsbereitschaft. Beide sind essenzielle Werkzeuge für Unternehmensteams, die komplexe Entwicklungs-Workflows und detaillierte Anforderungserfassung verwalten.",
      "title": "Spezifikationserfassungsmodus"
    },
    "howItWorks": {
      "steps": [
        {
          "step": "Text in Aufgabenbeschreibung auswählen",
          "description": "Markieren Sie beliebigen Text in Ihrer Aufgabenbeschreibung oder im Code-Editor. Ein Popover erscheint sofort."
        },
        {
          "step": "\"Verbessern\" oder \"Aufgabe verfeinern\" wählen",
          "description": "Verbessern: Schnelle Stil-/Klarheitskorrekturen. Aufgabe verfeinern: Tiefgehende kontextuelle Verbesserung mit Projektdateien."
        },
        {
          "step": "KI verarbeitet mit vollem Kontext",
          "description": "Claude Sonnet 3.5 analysiert mit Projektdateien, Verzeichnisstruktur und anpassbaren Prompts."
        },
        {
          "step": "Verfeinerter Text inline angewendet",
          "description": "Verbesserter Text ersetzt Auswahl automatisch. Bewahrt Formatierung und Cursor-Position."
        }
      ],
      "title": "So funktioniert es"
    },
    "painPoints": {
      "mentalModels": {
        "description": "Was Sie sich vorstellen, stimmt nicht mit dem überein, was niedergeschrieben wird, was zu Implementierungsdrift führt.",
        "title": "Mentale Modelle gehen in der Übersetzung verloren"
      },
      "rewriting": {
        "description": "Manuelle Verfeinerung mehrdeutiger Beschreibungen verlangsamt die Planung und schafft Fehlausrichtungen.",
        "title": "Umschreiben von Aufgabenbeschreibungen verschwendet Zeit"
      },
      "title": "Warum Unternehmensteams den Spezifikationserfassungsmodus nutzen",
      "vague": {
        "description": "KI generiert Code basierend auf unklaren Aufgabenbeschreibungen und übersieht kritische Einschränkungen und Randfälle.",
        "title": "Vage Anforderungen führen zu falschen Implementierungen"
      }
    },
    "promptTypes": {
      "note": "Beide Prompt-Typen nutzen große Sprachmodelle zur Inhaltsverbesserung unter Beibehaltung der ursprünglichen Absicht und Kernbedeutung der Benutzereingabe. Dies stellt sicher, dass Ihre Spezifikationen Ihrer Vision treu bleiben und gleichzeitig klarer und vollständiger werden.",
      "taskRefinement": {
        "description": "Erweitert Aufgabenbeschreibungen durch Identifizierung impliziter Anforderungen, Füllung übersehener Lücken, Klärung erwarteten Verhaltens und Randfälle sowie Hinzufügen technischer Überlegungen, um Aufgaben vollständiger und implementierungsbereiter zu machen.",
        "features": [
          "Identifiziert implizite Anforderungen",
          "Klärt Randfälle und Einschränkungen",
          "Fügt technische Implementierungsdetails hinzu",
          "Macht Aufgaben für Entwickler umsetzbar"
        ],
        "title": "Aufgabenverfeinerung"
      },
      "textEnhancement": {
        "description": "Verbessert Grammatik, Satzstruktur, Klarheit und Prägnanz unter Beibehaltung der ursprünglichen Absicht, des Tons und der technischen Detailtiefe des Benutzers. Perfekt zum Polieren von Rohentwürfen und Sprachtranskriptionen.",
        "features": [
          "Bewahrt ursprüngliche Bedeutung und Absicht",
          "Korrigiert Grammatik und Interpunktion",
          "Verbessert Satzfluss und Lesbarkeit",
          "Erhält technische Genauigkeit"
        ],
        "title": "Textverbesserung"
      },
      "title": "Zwei unterschiedliche KI-Prompt-Typen"
    },
    "useCases": {
      "clarify": {
        "description": "Verwandeln Sie \"Auth-Bug beheben\" in spezifische Schritte mit Randfällen, betroffenen Services und Validierungsprüfungen.",
        "title": "Vage Anforderungen vor Planung klären"
      },
      "expand": {
        "description": "Konvertieren Sie Kurzschrift wie \"User-Service refactoren\" in detaillierte Aufgabe mit Einschränkungen, Abhängigkeiten und Rollback-Plan.",
        "title": "Abgekürzte Notizen in vollen Kontext erweitern"
      },
      "refine": {
        "description": "Stellen Sie sicher, dass Aufgabenbeschreibungen für Reviewer und nachgelagerte Implementierung klar sind.",
        "title": "Aufgabenbeschreibungen für Team-Ausrichtung verfeinern"
      },
      "title": "Häufige Anwendungsfälle"
    }
  },
  "voiceTranscription": {
    "accuracy": {
      "bottomLine": "Summary: Audio quality and the configured model drive accuracy. Review transcribed text before planning.",
      "about": "About transcription quality",
      "models": {
        "aws": "Transcription runs through the configured provider; there is no offline or on-device mode.",
        "google": "Additional providers can be enabled by self-hosted admins via the allowlist.",
        "gpt": "Primary transcription model is configured per project from the server allowlist.",
        "whisper": "No diarization or speaker labels are produced in the current pipeline."
      },
      "title": "Accuracy factors"
    },
    "capabilities": {
      "multiLanguage": {
        "description": "The configured transcription provider supports multiple languages. Project settings select the default language.",
        "title": "Multiple Language Support"
      },
      "perProject": {
        "description": "Set project defaults for language, temperature, and transcription model. Integrates with text_improvement and task_refinement prompts.",
        "title": "Per-Project Configuration"
      },
      "terminalDictation": {
        "description": "Dictate commands into the active PTY session; the transcript is inserted into the terminal input buffer.",
        "title": "Terminal Dictation (Stage 5)"
      },
      "title": "Key Capabilities"
    },
    "cta": {
      "links": {
        "docs": "Voice transcription docs"
      },
      "title": "Voice transcription in the pipeline"
    },
    "example": {
      "competitor": {
        "label": "Baseline transcription",
        "text": "Create a Postgres replica in us-east with 2 CPUs, 8GB RAM, and enable replication; set wal level logical and max senders equals ten."
      },
      "comparisonTitle": "Token-level comparison",
      "errorSummary": "Errors — Substitutions: {sub}, Deletions: {del}, Insertions: {ins}. Small errors can flip units or flags.",
      "impact": "Impact: Mishearing \"read-replica\" as \"replica\", dropping region suffix \"-1\", or changing \"wal_level=logical\" can lead to incorrect deployments or data flows.",
      "primaryBadge": "reference-aligned",
      "primaryLabel": "Primary transcription model",
      "gpt": "Create a Postgres read-replica in us-east-1 with 2 vCPU, 8 GB RAM, and enable logical replication; set wal_level=logical and max_wal_senders=10.",
      "reference": "Create a Postgres read-replica in us-east-1 with 2 vCPU, 8GB RAM, and enable logical replication; set wal_level=logical and max_wal_senders=10.",
      "title": "Transcription comparison"
    },
    "faq": {
      "customize": {
        "answer": "Yes. You can configure language and model settings per project. Settings persist across sessions and are reused by transcription jobs.",
        "question": "Can I customize transcription settings per project?"
      },
      "languages": {
        "answer": "Supported languages depend on the configured transcription provider. You can set a default language per project.",
        "question": "Which languages are supported for voice transcription?"
      },
      "model": {
        "answer": "The transcription model is configured per project from the provider allowlist.",
        "question": "Which model is used for transcription?"
      },
      "offline": {
        "answer": "No. Voice transcription requires an internet connection to send audio to the configured provider.",
        "question": "Does voice transcription work offline?"
      },
      "whereToUse": {
        "answer": "Voice transcription works in two places: (1) Task description panel - dictate implementation requirements (Stage 1), and (2) Terminal modal - dictate commands that are appended to your active shell session (Stage 5).",
        "question": "Where can I use voice transcription in the app?"
      }
    },
    "hero": {
      "badge": "Stage 1 & Stage 5 Voice Input",
      "description": "Dictate tasks and commands; audio is sent to the configured transcription provider and inserted into the task description or PTY input. Voice transcription respects per-project settings and feeds text_improvement and task_refinement jobs.",
      "title": "Voice transcription for specification capture and terminal control"
    },
    "workflow": {
      "stage1": {
        "description": "Dictate tasks to capture constraints, context, and intent; transcribed text becomes input for refinement jobs.",
        "title": "Stage 1: Dictating Tasks"
      },
      "stage5": {
        "description": "Dictate terminal commands while reviewing output or diffs; the command is inserted into the PTY input.",
        "title": "Stage 5: Terminal Voice Control"
      },
      "integration": {
        "description": "Voice respects per-project language and temperature settings. Transcribed text feeds into text_improvement for grammar polish and task_refinement for completeness expansion.",
        "title": "Integration with Text Enhancement Prompts"
      },
      "title": "Voice Transcription Across Stages"
    },
    "nextSteps": {
      "description": "Voice transcription is Stage 1 input in the planning pipeline. After capturing dictated text, text_improvement cleans grammar and task_refinement expands completeness, preparing specs for Stage 2 file discovery.",
      "link": "Learn about text_improvement and task_refinement",
      "taskRefinement": {
        "description": "Expand descriptions with implied requirements, edge cases, and technical considerations. Prepares specs for FileFinderWorkflow.",
        "title": "Task Refinement (Stage 1 → 2)"
      },
      "textEnhancement": {
        "description": "Polish grammar, improve clarity, and preserve intent for review.",
        "title": "Text Enhancement (Stage 1)"
      },
      "title": "Refine Dictated Text Before File Discovery"
    },
    "painPoints": {
      "captureIdeas": {
        "description": "Dictation preserves context at discovery time and creates clean text inputs for refinement jobs.",
        "title": "Capture context at discovery time"
      },
      "contextSwitching": {
        "description": "Dictation writes directly into the active task or terminal field so the session context stays intact.",
        "title": "Keep input in the active surface"
      },
      "handsBusy": {
        "description": "Voice capture keeps input flowing during code review, debugging, or sketching; dictated text stays in the task or session.",
        "title": "Hands-free input during active review"
      },
      "title": "Why voice capture exists in intake"
    },
    "useCases": {
      "codeReview": {
        "outcome": "Transcribed text is ready for text_improvement and task_refinement.",
        "scenario": "While reviewing a diff, dictate refactor requirements into the task panel; the dictated text is stored in the task description.",
        "title": "Dictate refactor notes during review (Stage 1)"
      },
      "fasterEntry": {
        "outcome": "Dictated notes are queued for task_refinement to normalize into specs.",
        "scenario": "After QA, dictate multiple bug reports; each dictation becomes task input you can refine.",
        "title": "Batch capture for repeated reports"
      },
      "handsFree": {
        "outcome": "Captured text is stored as task input and can be refined later.",
        "scenario": "During a debugging session, dictate related issues without leaving the terminal or editor.",
        "title": "Capture issues during debug (Stage 1)"
      },
      "terminalCommands": {
        "outcome": "The command and output are logged to the session history.",
        "scenario": "While monitoring output, dictate a command into the active PTY input buffer.",
        "title": "Dictated commands in PTY (Stage 5)"
      },
      "title": "Pipeline examples"
    }
  },
  "integratedTerminal": {
    "cta": {
      "description": "Ein Terminal für Planung und Ausführung gebaut – integriert, persistent und schnell.",
      "links": {
        "docs": "Technische Dokumentation lesen",
        "voice": "Sprachbefehle erkunden"
      },
      "title": "Erleben Sie das Terminal, das nie Kontext verliert"
    },
    "features": {
      "integratedPlanning": {
        "description": "Führen Sie Implementierungspläne aus und kopieren Sie Schritte direkt ins Terminal, ohne die Anwendung zu verlassen.",
        "title": "Mit Planung integriert"
      },
      "persistent": {
        "description": "Ihre Terminal-Sitzungen bleiben bei Ihrer Arbeit und bewahren Kontext zwischen Aufgaben und Neustarts.",
        "title": "Persistente Sitzungen"
      },
      "title": "Ein Terminal für Ihren Workflow gebaut",
      "voiceSupport": {
        "description": "Nutzen Sie Ein-Klick-Copy-Paste für Befehle oder diktieren Sie sie direkt per Spracheingabe für mehr Geschwindigkeit.",
        "title": "Sprach- und Kopier-Unterstützung"
      }
    },
    "hero": {
      "badge": "Integriertes PTY-Terminal",
      "description": "Führen Sie Ihren Plan in einem persistenten Terminal aus. Gebaut für schnelle, fokussierte Ausführung.",
      "title": "Job-zentriertes Terminal, das Kontext behält"
    },
    "meta": {
      "title": "Integriertes Terminal - Persistente PTY-Sitzungen",
      "description": "Persistente Terminal-Sitzungen mit Zustandsüberwachung und Befehlsüberprüfung. Führen Sie Implementierungspläne direkt mit Sprachtranskriptionsunterstützung aus."
    }
  },
  "videoAnalysis": {
    "meta": {
      "title": "Video Analysis Pipeline - PlanToCode",
      "description": "Adaptive analysis of screen recordings guided by system prompts and your focus prompt."
    },
    "capabilities": {
      "fileUpload": {
        "description": "Upload existing recordings or capture new ones for analysis.",
        "features": [
          "MP4, WebM, MOV, AVI support",
          "Local recording stored before upload",
          "Long recordings split into chunks"
        ],
        "title": "Recording upload"
      },
      "fpsControl": {
        "description": "FPS is a sampling hint that trades detail for cost; for large files the provider may ignore it.",
        "features": [
          "0.1 to 20 FPS selection in the UI",
          "Lower FPS reduces token usage",
          "Long recordings may be chunked for analysis"
        ],
        "title": "Frame rate hint"
      },
      "gemini": {
        "description": "Video analysis uses Google Gemini video models configured per project; usage is tracked with job metadata.",
        "features": [
          "Allowed models set by server config",
          "Per-project model defaults",
          "Usage and cost tracking"
        ],
        "title": "Model selection"
      },
      "screenRecording": {
        "description": "Local capture with synchronized audio and video stored alongside the task.",
        "features": [
          "Full screen or window capture",
          "Audio and video sync",
          "Stored with the task id"
        ],
        "title": "Screen recording"
      },
      "title": "Pipeline controls"
    },
    "cta": {
      "description": "Connect video artifacts to the rest of the planning pipeline: deep research and file discovery.",
      "links": {
        "fileDiscovery": "File discovery pipeline",
        "research": "Deep research stage"
      },
      "title": "Continue in the pipeline"
    },
    "faq": {
      "formats": {
        "answer": "MP4, WebM, MOV, and AVI are supported. Other formats may work but are not guaranteed.",
        "question": "Which video formats are supported?"
      },
      "fps": {
        "answer": "FPS is a sampling hint. Higher FPS can increase cost; for very large files the provider may sample at a fixed rate, and long recordings may be chunked.",
        "question": "What FPS settings should I use?"
      },
      "model": {
        "answer": "Video analysis uses Google Gemini video models. The default model is configured per project from the server allowlist.",
        "question": "Which model should I choose?"
      },
      "optimization": {
        "answer": "Trim to relevant segments, keep the focus prompt specific, and use lower FPS when high visual detail is not required.",
        "question": "How can I optimize analysis costs?"
      }
    },
    "hero": {
      "badge": "Stage 1 input: Screen recording analysis",
      "description": "Record or upload a screen recording, add a focus prompt, and let the video analysis system prompt guide a Gemini model to extract what matters. Results are stored as a job response you can attach to the task.",
      "title": "Multimodal video analysis for requirements capture"
    },
    "howItWorks": {
      "steps": [
        {
          "title": "Capture or upload video",
          "description": "Record your screen (with optional audio) or pick an existing file. Recordings stay local until analysis starts."
        },
        {
          "title": "Set a focus prompt",
          "description": "Your task description and optional focus prompt are wrapped in <description> and <video_attention_prompt> tags."
        },
        {
          "title": "Run adaptive analysis",
          "description": "The default video analysis system prompt tells the model to focus on what you show and say and to quote visible text when relevant."
        },
        {
          "title": "Attach to the task pipeline",
          "description": "The analysis summary is stored in the job record and can be appended to the task description."
        }
      ],
      "title": "How the pipeline runs"
    },
    "insights": {
      "actionItems": {
        "description": "Action items and suggested fixes based on what was shown and said.",
        "title": "Action items"
      },
      "decisions": {
        "description": "Decisions or open questions captured from the recording.",
        "title": "Decisions"
      },
      "description": "Analysis results are stored in the job response and can be applied to the task description for refinement and planning.",
      "discussionPoints": {
        "description": "UI issues, design tradeoffs, or bugs worth following up.",
        "title": "Discussion points"
      },
      "title": "Structured outputs"
    },
    "models": {
      "flash": {
        "description": "Lower cost and latency for straightforward UI flows and documentation.",
        "features": [
          "Fast turnaround",
          "Lower cost for straightforward recordings",
          "Good for simple flows"
        ],
        "title": "Fast analysis model"
      },
      "pro": {
        "description": "Deeper context for complex UI issues and nuanced workflows.",
        "features": [
          "Richer reasoning",
          "Better for complex flows",
          "Higher cost for complex recordings"
        ],
        "title": "Deep analysis model"
      },
      "title": "Model tradeoffs"
    },
    "multimodal": {
      "audioTranscript": {
        "description": "The model analyzes the audio track directly; the app does not generate a separate transcript.",
        "features": [
          "Narration guides what to focus on",
          "Spoken intent and errors inform the summary",
          "No standalone transcript file produced"
        ],
        "title": "Audio and narration context"
      },
      "title": "Audio and visual extraction",
      "visualContent": {
        "description": "The model analyzes what is visible in the video and can quote on-screen text when it is clear.",
        "features": [
          "UI flows and state changes from what is visible",
          "Best-effort quotes of logs, errors, and labels",
          "No local frame export or OCR pipeline"
        ],
        "title": "Visual context from the recording"
      }
    },
    "painPoints": {
      "incompleteNotes": {
        "description": "Screenshare changes and error dialogs are easy to miss in notes; recordings preserve that context.",
        "title": "Manual notes omit frame references"
      },
      "requirementsLost": {
        "description": "Text notes miss on-screen state and timing; recordings keep the visual context intact.",
        "title": "UI state lives in recordings"
      },
      "reviewTime": {
        "description": "Long recordings are hard to review; a focused summary highlights what matters.",
        "title": "Raw recordings are expensive to review"
      },
      "title": "Why multimodal ingestion exists"
    },
    "useCases": {
      "bugCapture": {
        "description": "Summarize reproduction steps and visible errors from a recording.",
        "title": "Bug timeline artifacts"
      },
      "onboarding": {
        "description": "Produce walkthrough notes from a screen recording.",
        "title": "Walkthrough summaries"
      },
      "title": "Example outputs",
      "uiDemo": {
        "description": "Capture UI states and flows shown in the recording.",
        "title": "UI state capture"
      }
    }
  },
  "copyButtons": {
    "concept": {
      "dragDrop": {
        "description": "Drag-and-drop ordering for button sets. Organize buttons by execution stage or priority.",
        "title": "Drag-and-drop ordering"
      },
      "serverConfigured": {
        "description": "Template prompts with placeholders: {{IMPLEMENTATION_PLAN}}, {{TASK_DESCRIPTION}}, {{STEP_CONTENT}}. Server defaults with project-level overrides.",
        "title": "Template Placeholders"
      },
      "terminal": {
        "description": "Send templated content to persistent terminal sessions (Stage 5). Large content is chunked when writing to the PTY.",
        "title": "Terminal integration (Stage 5)"
      }
    },
    "configuration": {
      "projectSettings": {
        "description": "Copy buttons are stored in per-project task settings in key_value_store and merged with server defaults.",
        "features": [
          "Key-value storage in SQLite",
          "Server-managed default configurations",
          "Project directory scoping",
          "Settings sync across desktop and mobile"
        ],
        "title": "Project-Specific Settings"
      },
      "title": "Configuration & Management",
      "visualUI": {
        "description": "Configuration editor with drag-drop reordering and debounced inputs for labels and templates.",
        "features": [
          "Drag handles for visual reordering",
          "300ms debounced input processing",
          "Read-only mode for system buttons",
          "Template ordering support"
        ],
        "title": "Visual Configuration UI"
      }
    },
    "cta": {
      "links": {
        "planMode": "See Stage 3 planning & Stage 4 merge",
        "terminal": "Explore Stage 5 terminal integration"
      },
      "title": "Template-driven execution handoff"
    },
    "exampleConfig": {
      "title": "Example button configuration:",
      "footer": "→ Button runs the configured template",
      "templateBody": "{{IMPLEMENTATION_PLAN}}\n\nReview the plan. Read the files mentioned, understand them and launch parallel coding agents that run at the same time..."
    },
    "exampleLabels": {
      "button": "Button:",
      "dynamic": "Dynamic:",
      "label": "Label:",
      "purpose": "Purpose:",
      "result": "Result:",
      "template": "Template:"
    },
    "exampleValues": {
      "investigationButton": "\"Investigate Results\"",
      "investigationPurpose": "Validation and review workflows",
      "parallelButton": "\"Parallel Claude Coding Agents\"",
      "parallelPurpose": "Parallel agent instruction templates",
      "projectContextTemplate": "{{TASK_DESCRIPTION}}",
      "projectDynamic": "Task-aware instructions",
      "stepResult": "Focused step execution",
      "stepTemplate": "{{STEP_CONTENT}}"
    },
    "hero": {
      "badge": "Template handoff",
      "description": "Copy buttons insert {{IMPLEMENTATION_PLAN}}, {{TASK_DESCRIPTION}}, and {{STEP_CONTENT}} into predefined templates.",
      "title": "Template prompts with plan substitution"
    },
    "technical": {
      "architecture": {
        "heading": "# Copy button system architecture",
        "note": "[Extend with new placeholders and templates as needed]",
        "sections": {
          "execution": "## 4. Execution flow",
          "processing": "## 2. Template processing",
          "storage": "## 1. Configuration storage",
          "ui": "## 3. UI integration"
        },
        "execution": "Button click triggers template processing -> clipboard copy or PTY write (chunked)",
        "processing": "Regex placeholder matching -> substitution with plan, step, and task text -> missing values become empty strings",
        "storage": "CopyButtonConfig[] stored in per-project task settings (key_value_store) plus server-side defaults",
        "ui": "Implementation plan cards → Content viewing modals → Terminal interface headers → Drag-drop configuration editor"
      },
      "title": "Technical Implementation"
    },
    "templateSystem": {
      "placeholders": {
        "description": "Template prompts with {{PLACEHOLDER}} substitution. Supported placeholders include plan content, step content, and task description.",
        "examples": [
          "{{IMPLEMENTATION_PLAN}} - Full plan content",
          "{{STEP_CONTENT}} - Selected step content",
          "{{TASK_DESCRIPTION}} - Task requirements"
        ],
        "title": "Placeholder Substitution"
      },
      "processor": {
        "description": "Template processor injects XML plans, task descriptions, and governance constraints into predefined prompts.",
        "features": [
          "Regex-based placeholder matching",
          "XML plan formatting and escaping",
          "Multi-line governance instruction support",
          "Graceful undefined handling"
        ],
        "title": "Unified Prompt Processing"
      },
      "title": "Template system"
    },
    "terminalIntegration": {
      "oneClick": {
        "description": "Copy buttons integrate with Stage 5 terminal sessions and insert plan context into the active PTY with logging.",
        "features": [
          "Automatic paste to active terminal session",
          "Chunked sending for large XML plans",
          "Session health monitoring",
          "Clipboard fallback for safety"
        ],
        "title": "Stage 5 execution handoff"
      },
      "title": "Stage 5 Terminal Execution"
    },
    "useCases": {
      "customTeam": {
        "description": "Team-specific governance constraints with {{PROJECT_CONTEXT}} and coding standards.",
        "title": "Team governance templates"
      },
      "investigation": {
        "description": "Standardized review prompts for Stage 3 implementation plan results.",
        "title": "Investigation and review"
      },
      "parallel": {
        "description": "Example button: \"Parallel agent template\" inserts the plan XML and governance instructions.",
        "title": "Parallel agent templates"
      },
      "stepByStep": {
        "description": "Extract individual implementation steps with {{STEP_CONTENT}}. Execute step-by-step with full plan context.",
        "title": "Step-by-step execution"
      },
      "title": "Example configurations"
    }
  },
  "deepResearch": {
    "advanced": {
      "features": [
        {
          "title": "Intelligentes Abfrage-Design",
          "description": "KI erstellt ausgefeilte Rechercheabfragen, die mehrere Winkel und Perspektiven für umfassende Abdeckung erkunden."
        },
        {
          "title": "Kontextbewusste Analyse",
          "description": "Recherche ist auf Ihren spezifischen Projektkontext, Technologie-Stack und Entwicklungsanforderungen zugeschnitten."
        },
        {
          "title": "Hintergrundverarbeitung",
          "description": "Langläufige Rechercheaufgaben werden im Hintergrund mit Echtzeit-Fortschritts-Updates und Benachrichtigungen ausgeführt."
        },
        {
          "title": "Ergebnis-Integration",
          "description": "Rechercheergebnisse werden automatisch formatiert und zur sofortigen Verwendung in Ihre Aufgabenbeschreibungen integriert."
        },
        {
          "title": "Kostenoptimierung",
          "description": "Intelligente Modellauswahl und Abfrageoptimierung zum Ausbalancieren von Recherchequalität und Kosteneffizienz."
        },
        {
          "title": "Fortschrittsüberwachung",
          "description": "Echtzeit-Verfolgung des Recherchefortschritts mit detaillierten Status-Updates und Abschlussbenachrichtigungen."
        }
      ],
      "title": "Erweiterte Recherchefähigkeiten"
    },
    "aiCapabilities": {
      "multiModel": {
        "description": "Nutzt mehrere KI-Modelle zur Ausführung von Rechercheaufgaben mit unterschiedlichen Perspektiven und Fachgebieten.",
        "models": [
          "OpenAI GPT Modelle",
          "Anthropic Claude",
          "Google Gemini",
          "Spezialisierte Recherchemodelle"
        ],
        "title": "Multi-Modell-Recherche"
      },
      "parallel": {
        "description": "Führen Sie mehrere Rechercheaufgaben gleichzeitig mit intelligenter Ergebnisaggregation und -synthese aus.",
        "features": [
          "Gleichzeitige Ausführung",
          "Fortschrittsverfolgung",
          "Fehlerwiederherstellung",
          "Ergebnissynthese"
        ],
        "title": "Parallele Verarbeitung"
      },
      "projectContext": {
        "description": "KI analysiert Ihre Projektstruktur, Technologie-Stack und Codebasis zur Generierung hochrelevanter Recherche.",
        "features": [
          "Dateistruktur-Analyse",
          "Technologie-Stack-Erkennung",
          "Abhängigkeits-Mapping",
          "Kontextbewusste Erkenntnisse"
        ],
        "title": "Projekt-Kontext-Analyse"
      },
      "title": "KI-Recherchefähigkeiten"
    },
    "cta": {
      "links": {
        "planMode": "Implementierungsplanung ansehen",
        "textImprovement": "Textverbesserung erkunden"
      },
      "title": "Transformieren Sie Ihren Recherche-Workflow"
    },
    "developmentFocus": {
      "contextFiltering": {
        "description": "Rechercheumfang automatisch angepasst basierend auf Ihrem Projektkontext und Entwicklungs-Stack.",
        "features": [
          "Technologie-Stack-Bewusstsein",
          "Versionskompatibilitätsprüfung",
          "Projektanforderungs-Filterung",
          "Skalierbarkeits-Überlegungs-Priorität"
        ],
        "title": "Kontextbewusste Filterung"
      },
      "implementationReady": {
        "description": "Rechercheergebnisse optimiert für Entwicklungs-Workflows. Code-Beispiele, API-Dokumentation und Best Practices.",
        "features": [
          "Code-Snippet-Extraktion",
          "API-Referenz-Zusammenstellung",
          "Architekturmuster-Analyse",
          "Performance-Überlegungshinweise"
        ],
        "title": "Implementierungsbereite Erkenntnisse"
      },
      "title": "Entwicklungsfokussierte Recherche"
    },
    "features": {
      "parallelExecution": {
        "description": "Führen Sie mehrere ausgefeilte Rechercheaufgaben gleichzeitig aus. KI synthetisiert Erkenntnisse zu umsetzbaren Entwicklungs-Insights.",
        "title": "Parallele Rechercheausführung"
      },
      "projectIntegration": {
        "description": "Recherche ist auf Ihre spezifische Projektstruktur, Technologie-Stack und Entwicklungskontext zugeschnitten für maximale Relevanz.",
        "title": "Projekt-Kontext-Integration"
      },
      "queryGeneration": {
        "description": "KI erweitert Ihre Rechercheabfragen mit kontextbewussten Variationen. Multi-Winkel-Exploration für umfassende Abdeckung.",
        "title": "Intelligente Abfragegenerierung"
      }
    },
    "hero": {
      "badge": "KI-gestützte Recherche-Intelligenz",
      "description": "Generieren Sie intelligente Abfragen, führen Sie Suchen durch und integrieren Sie relevante Erkenntnisse in Ihre Aufgabe – ohne Ballast.",
      "title": "Tiefenrecherche – von der Abfrage zur Erkenntnis"
    },
    "intelligence": {
      "contextIntegration": {
        "description": "Rechercheergebnisse werden automatisch mit Ihrer Aufgabenbeschreibung integriert und bereichern sie mit relevanten Erkenntnissen und Empfehlungen.",
        "features": [
          "Automatische Aufgaben-Verbesserung",
          "Strukturierte Ergebnisformatierung",
          "Implementierungsplan-Integration",
          "Entwicklungs-Workflow-Ausrichtung"
        ],
        "title": "Kontext-Integration"
      },
      "execution": {
        "description": "Hochentwickelte KI-Modelle führen Rechercheaufgaben parallel aus und liefern umfassende Analysen und Erkenntnisse.",
        "features": [
          "Parallele Rechercheaufgaben-Ausführung",
          "Streaming-Ergebnisse mit Fortschrittsverfolgung",
          "Kontextbewusste Analyse und Synthese",
          "Entwicklungsfokussierte Erkenntnisse"
        ],
        "title": "KI-Rechercheausführung"
      },
      "queryExpansion": {
        "description": "KI analysiert Ihre initiale Abfrage und generiert strategische Variationen für umfassende Rechercheabdeckung.",
        "features": [
          "Kontextbewusste Abfragevariationen",
          "Semantische Synonym-Erweiterung",
          "Domänenspezifische Terminologie",
          "Multi-Perspektiven-Recherchewinkel"
        ],
        "title": "Intelligente Abfrage-Erweiterung"
      },
      "synthesis": {
        "description": "Fortgeschrittene KI-Modelle analysieren Ihren Projektkontext und generieren zielgerichtete Recherche-Insights, die auf Ihre Entwicklungsbedürfnisse zugeschnitten sind.",
        "features": [
          "Projektbewusste Recherchegenerierung",
          "Kontextsensitive Analyse",
          "Entwicklungsfokussierte Erkenntnisse",
          "Implementierungsbereite Empfehlungen"
        ],
        "title": "KI-Recherchesynthese"
      },
      "title": "Recherche-Intelligenz-Engine"
    },
    "process": {
      "stage1": {
        "description": "KI analysiert Ihre Aufgabenbeschreibung und Projektkontext zur Generierung ausgefeilter Rechercheabfragen. Erstellt mehrere strategische Recherchewinkel für umfassende Abdeckung.",
        "title": "Rechercheabfrage-Generierung"
      },
      "stage2": {
        "description": "Mehrere KI-Modelle führen Rechercheaufgaben gleichzeitig aus, jedes fokussiert auf unterschiedliche Aspekte Ihrer Anforderungen. Ergebnisse werden zu umsetzbaren Entwicklungs-Insights synthetisiert.",
        "title": "Parallele Rechercheausführung"
      },
      "title": "Zweistufiger KI-Rechercheprozess"
    }
  },
  "features": {
    "copyButtons": {
      "description": "Template-based prompt buttons that inject plan snippets, file lists, and task inputs.",
      "slug": "/docs/copy-buttons",
      "title": "Copy Buttons"
    },
    "deepResearch": {
      "description": "Parallel research stages that gather external context and attach notes before planning.",
      "slug": "/docs/deep-research",
      "title": "Deep Research"
    },
    "fileDiscovery": {
      "description": "Multi-stage file discovery pipeline that scores and persists relevant files before planning.",
      "slug": "/docs/file-discovery",
      "title": "File Discovery",
      "meta": {
        "title": "KI-Dateisuche – betroffene Dateien finden",
        "description": "Mehrstufiger KI-Workflow zur Identifizierung und Auswahl relevanter Dateien. Kosteneffektiv mit $0,10–0,15 pro Workflow und Fortschrittsanzeige in Echtzeit."
      }
    },
    "integratedTerminal": {
      "description": "PTY-backed terminal sessions with persistent logs and job binding.",
      "slug": "/docs/terminal-sessions",
      "title": "Integrated Terminal"
    },
    "mergeInstructions": {
      "description": "Plan merge processor that reconciles multiple plan drafts into one structured sequence.",
      "slug": "/docs/merge-instructions",
      "title": "Plan Merge Instructions",
      "meta": {
        "title": "Plansynthese – Multi‑Modell‑Zusammenführung",
        "description": "Architektonische Synthese über einfaches Mergen hinaus. KI analysiert Pläne, löst Konflikte nach SOLID und erzeugt nachvollziehbare, emergente Lösungen."
      }
    },
    "planMode": {
      "description": "Structured implementation plans with reviewable steps and links back to jobs.",
      "slug": "/docs/implementation-plans",
      "title": "Implementation Plans",
      "meta": {
        "title": "KI‑Implementierungspläne – Mensch im Loop",
        "description": "Dateiweise KI‑Pläne generieren. Jede Änderung vor der Ausführung prüfen. Regressionen in Legacy‑Code vermeiden. Sichere KI‑Entwicklung."
      }
    },
    "textImprovement": {
      "description": "Text improvement and task refinement prompts that normalize requirements.",
      "slug": "/docs/text-improvement",
      "title": "Task Refinement & Text Improvement",
      "meta": {
        "title": "Spezifikationserfassung – KI‑Textverbesserung",
        "description": "Spezifikationen mit zwei KI‑Prompts verfeinern: Textverbesserung für Klarheit, Aufgabenverfeinerung für Vollständigkeit. Umsetzbare Specs für Teams."
      }
    },
    "videoAnalysis": {
      "description": "Multimodal ingestion of recordings with prompt-guided analysis summaries.",
      "slug": "/docs/video-analysis",
      "title": "Video Analysis Pipeline"
    },
    "voiceTranscription": {
      "description": "Speech-to-text capture for requirements and terminal commands.",
      "slug": "/docs/voice-transcription",
      "title": "Voice to Text",
      "meta": {
        "title": "Sprache‑zu‑Text für schnelle Spezifikationserfassung",
        "description": "Freihändige Erfassung per Sprache. Exakte Transkription fügt Text dort ein, wo Sie arbeiten. Pro Projekt konfigurierbar, mehrere Sprachen unterstützt."
      }
    }
  }
}
