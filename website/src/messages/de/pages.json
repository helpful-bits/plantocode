{
  "home": {
    "meta": {
      "title": "KI-Implementierungsplanung für sicheres Coding",
      "description": "KI-Implementierungsplanung für große Codebasen. Änderungen vor Ausführung prüfen. Bugs und Duplikate vermeiden. Integration mit Cursor, Copilot, Claude Code."
    }
  },
  "about": {
    "meta": {
      "description": "KI-Entwicklungsplanung mit Multi-Modell-Integration, persistenten Terminals, Sprach-Transkription und architektonischer Synthese.",
      "title": "Über PlanToCode - KI-Entwicklungsplanungstool"
    },
    "architecture": {
      "comment": "Entwickelt für komplexe Entwicklungs-Workflows, nicht für einfachen KI-Chat",
      "title": "Technisches Fundament"
    },
    "capabilities": {
      "automation": {
        "description": "Konfigurierbare Kopier-Buttons mit intelligenten Vorlagen. Wandeln Sie jeden Prompt in einen wiederverwendbaren Workflow mit Platzhalter-Substitution und Terminal-Integration um.",
        "title": "Workflow-Automatisierung"
      },
      "discovery": {
        "description": "Mehrstufiger Workflow: Root-Ordner-Auswahl, Regex-Pattern-Filterung, KI-Relevanz-Bewertung. Fokussierte Dateiauswahl mit Pfad-Validierung.",
        "title": "Intelligente Datei-Erkennung"
      },
      "planning": {
        "description": "Vollständiges Kontext-Laden ohne Truncation-Policy. Strukturierte XML-Pläne mit nummerierten Schritten. Multi-Modell-Generierung und architektonische Synthese.",
        "title": "Implementierungsplanung"
      },
      "synthesis": {
        "description": "Mehr als einfaches Zusammenführen - tiefgehende architektonische Analyse basierend auf SOLID-Prinzipien. Quell-Nachverfolgbarkeit mit [src:P1 step 2] Attribution für jede Entscheidung.",
        "title": "Architektonische Synthese"
      },
      "terminal": {
        "description": "PTY-Sessions mit 5-Sekunden-Health-Monitoring, automatischen Recovery-Aktionen und Agent-Attention-Detection. Sessions bleiben über App-Neustarts hinweg erhalten.",
        "title": "Job-zentriertes Terminal"
      },
      "title": "Kernfähigkeiten",
      "voice": {
        "description": "OpenAI gpt-4o-transcribe Integration für Terminal-Befehle. Selektionsbasierte Textverbesserung mit kontextbewusster Verarbeitung und Echtzeit-Job-Tracking.",
        "title": "Sprach- & Text-Integration"
      },
      "remote": {
        "description": "Pläne überprüfen und zusammenführen, Jobs, Payloads, Prompts und Metadaten inspizieren; Modelle und Parameter ändern, System-Prompt überprüfen und Terminal über Device-Link öffnen — ohne SSH-Ports freizugeben.",
        "title": "Fernsteuerung (iOS)"
      }
    },
    "company": {
      "contact": "Kontakt",
      "jurisdiction": "Deutschland",
      "name": "helpful bits GmbH",
      "title": "Firmeninformationen"
    },
    "hero": {
      "subtitle": "PlanToCode hilft Entwicklern, Code-Änderungen zu planen und zu deployen, indem es betroffene Dateien findet, Pläne generiert und zusammenführt und diese in einem Terminal ausführt.",
      "title": "Über PlanToCode"
    },
    "philosophy": {
      "noTruncation": {
        "description": "Wir laden vollständige Dateiinhalte. Kein präventives Kürzen - nur intelligente Warnungen. Sie erhalten den vollständigen Kontext, der für ernsthafte Entwicklungsarbeit nötig ist.",
        "title": "Keine Truncation-Policy"
      },
      "title": "Unsere Philosophie",
      "tooling": {
        "description": "Monaco-Editor, xterm.js, ordentliche Entwicklungsumgebungs-Integration. Nicht nur eine weitere Chat-Schnittstelle - eine vollständige Entwicklungsplanungs-Plattform.",
        "title": "Professionelle Werkzeuge"
      },
      "traceability": {
        "description": "Jede KI-Entscheidung enthält Quell-Attribution. Vollständige Audit-Trails, Kostentracking und Session-Persistenz. Sie wissen genau, was passiert ist und warum.",
        "title": "Vollständige Nachverfolgbarkeit"
      },
      "transparency": {
        "description": "Lokale Speicherung, transparente KI-Provider-Kommunikation und volle Kontrolle über das, was gesendet wird. Sie sehen den Kontext immer, bevor Sie API-Aufrufe bestätigen.",
        "title": "Transparenz & Kontrolle"
      }
    },
    "whatWeBuilt": {
      "environment": {
        "description": "Monaco-Editor-Integration, persistente Terminal-Sessions mit Health-Monitoring, Sprach-Transkription und 5MB SQLite Ring-Buffer. Entwickelt für echte Entwicklungs-Workflows.",
        "title": "Professionelle Entwicklungsumgebung"
      },
      "intro": "PlanToCode ist eine umfassende Entwicklungsplanungsumgebung, die für ernsthaftes Development konzipiert wurde, bei dem Kontext, Nachverfolgbarkeit und professionelle Werkzeuge wichtiger sind als schnelle KI-Interaktionen. Wir haben ein System für komplexe, mehrstufige Implementierungen entwickelt, bei denen traditionelle KI-Tools zu kurz greifen.",
      "multiModel": {
        "description": "Integration mit GPT-5.2, Claude Sonnet 4 und Gemini 3 Pro. Nicht nur API-Aufrufe - intelligente Orchestrierung mit projektspezifischen Konfigurationen, Echtzeit-Streaming und vollständiger Nachverfolgbarkeit.",
        "title": "Multi-Modell-Intelligenz"
      },
      "title": "Was wir gebaut haben"
    }
  },
  "architecture": {
    "meta": {
      "title": "System Architecture - PlanToCode",
      "description": "Detailed overview of the PlanToCode architecture: Tauri shell, Rust backend, SQLite persistence, and multi-model LLM orchestration."
    }
  },
  "evolution": {
    "meta": {
      "title": "System Evolution and Tradeoffs - PlanToCode",
      "description": "How PlanToCode evolved, why specific technologies were chosen, and what tradeoffs those decisions created."
    }
  },
  "aboutPage": {
    "hero": {
      "title": "What PlanToCode Is For",
      "description": "PlanToCode is a desktop planning workspace that turns tasks into reviewable implementation plans. It connects file discovery, plan generation, and execution handoff into one tracked pipeline."
    },
    "reference": {
      "title": "Reference architecture focus",
      "description": "The system wires together a Tauri shell, a Rust backend, SQLite persistence, and an LLM proxy layer. This page explains how those parts fit together so you can learn from the architecture."
    },
    "governance": {
      "title": "Safety, Governance, and Guardrails",
      "description": "Governance is a core architectural decision: plans are artifacts that can be reviewed, edited, and approved before execution."
    },
    "stack": {
      "title": "Where This Fits in Your Stack",
      "description": "PlanToCode sits alongside your editor and local tools. It assumes Git workflows and external LLM providers, then routes plans and execution through the same session history."
    }
  },
  "architecturePage": {
    "hero": {
      "title": "Architecture Overview",
      "description": "PlanToCode is a Tauri desktop application with a Rust backend, a React/Next.js frontend, and a SQLite-backed local database. Planning and analysis depend on external LLM providers configured with your API keys. This page explains how those pieces fit together so you can reason about or adapt the design."
    },
    "visuals": {
      "systemMap": {
        "title": "System map snapshot",
        "description": "This diagram depicts the PlanToCode system architecture as four interconnected layers arranged vertically. Top Layer - Desktop Frontend: A React/Next.js box containing components (Plan Viewer, Terminal Panel, Session Manager) connected via labeled arrows 'invoke()' and 'listen()' to Tauri IPC Bridge. Second Layer - Rust Backend: Contains WorkflowOrchestrator (scheduling multi-stage jobs), TerminalSessionManager (PTY lifecycle), and JobProcessors (FileDiscovery, PlanGeneration, TextImprovement, DeepResearch). Arrows show 'spawn()' to job threads and 'emit()' events back to UI. Third Layer - Persistence: SQLite database cylinder showing tables: sessions, background_jobs, terminal_output, project_settings, key_value_store. Bidirectional arrows labeled 'read/write' connect to Rust services. Fourth Layer - External Services: Server box with Auth (/api/auth), LLM Proxy (/api/llm/*), and Usage Tracking; arrows point outward to Provider icons (OpenAI, Anthropic, Google, OpenRouter) with 'route()' labels. Data flows: Task input flows down through layers; LLM responses stream back up via SSE; job status updates propagate via Tauri events. Key labels include 'HTTPS/WSS' on server connections, 'SQLite' on persistence, and 'FFI' on Rust-to-system calls.",
        "imageSrc": "/images/architecture/system-map.svg",
        "imageAlt": "Diagram showing PlanToCode system map",
        "caption": "Four-layer architecture with data flowing down and events streaming back up."
      }
    },
    "sections": {
      "shell": {
        "title": "Tauri Shell and Desktop Frontend",
        "description": "The desktop app bundles a React UI inside a Tauri shell. Frontend code calls Rust commands for tasks like file system access, terminal sessions, and background job orchestration."
      },
      "core": {
        "title": "Rust Core and SQLite Persistence",
        "description": "The Rust core manages background jobs, PTY sessions, and durable state. SQLite stores sessions, job history, and terminal output, acting as a local append-only record of what the system has done."
      },
      "jobs": {
        "title": "Background Job Orchestration",
        "description": "A workflow orchestrator schedules multi-stage jobs (file discovery, plan generation, research). Each stage is a Rust processor that can call out to LLM providers, read or write to the project, and emit streaming updates back to the UI."
      },
      "llm": {
        "title": "Multi-Model LLM Integration",
        "description": "The server layer routes requests to different providers, normalizes responses, and tracks usage. The desktop app receives a unified streaming API regardless of provider."
      }
    },
    "communication": {
      "title": "How the Pieces Communicate",
      "description": "Commands flow from the React UI into Tauri, which invokes Rust functions. Long-running work is executed as background jobs that stream updates (including partial LLM tokens) back to the UI. SQLite acts as both a cache and a durable log so sessions and terminal history can be replayed or resumed.",
      "followup": "For a deeper dive, read the architecture documentation and the build-your-own guides that map these concepts to code modules."
    }
  },
  "evolutionPage": {
    "hero": {
      "title": "Evolution and Tradeoffs",
      "description": "This page outlines the major architectural decisions behind PlanToCode and how the system changed as new workflows and constraints appeared."
    },
    "visuals": {
      "timeline": {
        "title": "Architecture timeline",
        "description": "This horizontal timeline diagram shows the evolution of PlanToCode across five major phases. Phase 1 'Editor Plugin Era' (leftmost): VS Code extension icon with features listed (inline suggestions, basic file context). Arrow labeled 'Limitation: No execution control' points to Phase 2. Phase 2 'Standalone Shell': Tauri desktop app icon with features (dedicated UI, local SQLite, PTY sessions). Arrow labeled 'Added: Job orchestration' points to Phase 3. Phase 3 'Multi-Stage Workflows': Workflow diagram icon showing connected stages (FileDiscovery, Scoring, Planning, Execution). Arrow labeled 'Added: Review gates' points to Phase 4. Phase 4 'Multi-Provider LLM': Server routing icon with provider logos (OpenAI, Anthropic, Google, OpenRouter) showing unified API normalization. Arrow labeled 'Added: Model flexibility' points to Phase 5. Phase 5 'Current Architecture' (rightmost): Complete system icon showing Desktop + Server + Mobile components. Below the timeline, key architectural decisions are annotated: 'Tauri over Electron' at Phase 2, 'SQLite as local truth' at Phase 2, 'Background job queue' at Phase 3, 'Server-side provider routing' at Phase 4, 'Cross-platform sync' at Phase 5. Tradeoff callouts include 'Binary size vs. ecosystem' (Tauri), 'Local-first vs. cloud sync' (SQLite), 'Latency vs. flexibility' (LLM routing).",
        "imageSrc": "/images/evolution/timeline.png",
        "imageAlt": "Timeline of PlanToCode system evolution",
        "caption": "Placeholder for an evolution timeline graphic."
      }
    },
    "origins": {
      "title": "Project Origins",
      "description": "PlanToCode began as an experiment in separating planning from execution: use LLMs to propose concrete implementation plans, then execute them via local tools and terminals. Early prototypes were editor-centric; over time, the architecture moved toward a dedicated desktop shell with tighter control over file access and job orchestration."
    },
    "choices": {
      "title": "Technology Choices",
      "items": [
        {
          "title": "Tauri over Electron:",
          "description": "Chosen for a smaller binary, a Rust backend, and a more constrained security model. It also enables shared logic between CLI-like workflows and the desktop app."
        },
        {
          "title": "SQLite as the local source of truth:",
          "description": "A file-based database is easy to ship, snapshot, and inspect. It stores sessions, job metadata, and terminal history so workflows can be resumed or audited."
        },
        {
          "title": "Multi-provider LLM routing:",
          "description": "The server supports multiple providers and models, normalizing responses and tracking usage centrally. This makes it easier to swap models without rewriting the desktop client."
        }
      ]
    },
    "sourceAvailable": {
      "title": "What the system focuses on",
      "description": "The focus is on planning-first workflows: file discovery, multi-model plan generation, review, and execution handoff. These stages depend on external LLM providers for scoring and drafting, while the desktop app handles review, storage, and execution logs."
    }
  },
  "changelog": {
    "meta": {
      "title": "Changelog - Neueste Updates",
      "description": "Neueste Funktionen und Verbesserungen in PlanToCode. Updates zur Multi‑Modell‑Planung für Claude Code, Cursor und OpenAI Codex Integration."
    },
    "hero": {
      "title": "Changelog",
      "subtitle": "Release notes focused on architecture changes, workflow updates, and system improvements."
    },
    "changes": {
      "added": "Added",
      "improved": "Improved",
      "fixed": "Fixed",
      "removed": "Removed"
    },
    "footer": {
      "title": "Follow updates",
      "subtitle": "Track release notes and architecture changes as the system evolves.",
      "followX": "Follow updates on X",
      "joinCommunity": "Join the community"
    }
  },
  "downloads": {
    "cta": {
      "architect": "Mit einem Experten sprechen",
      "docs": "Terminal-Dokumentation",
      "footer": "Made in Germany • DSGVO-konform • Lokale Session-Speicherung",
      "professional": "Professional-Optionen",
      "title": "Bereit für den nächsten Schritt?"
    },
    "hero": {
      "subtitle": "Code-Änderungen mit einem Tool planen - relevante Dateien finden, Pläne generieren und zusammenführen, Befehle in einem persistenten Terminal ausführen.",
      "title": "PlanToCode herunterladen"
    },
    "macos": {
      "professional": {
        "description": "Vollständig von Apple notarisiert. Code-signiert. Integriertes Terminal mit CLI-Autoerkennung und Session-Persistenz.",
        "title": "Professional Ready"
      },
      "requirements": {
        "internet": "Internetverbindung für KI-Features erforderlich",
        "os": "macOS 11.0 (Big Sur) oder neuer",
        "processor": "Apple Silicon (M1/M2/M3/M4) Prozessor",
        "ram": "4GB RAM mindestens (8GB empfohlen)",
        "title": "Systemanforderungen"
      },
      "subtitle": "Für Heavy Coding-Agent-Nutzer",
      "title": "macOS"
    },
    "meta": {
      "description": "PlanToCode für macOS und Windows herunterladen. Kostenlose 5$ Guthaben. Planen Sie Multi-Datei-Änderungen mit KI, prüfen Sie vor der Ausführung. Keine Kreditkarte erforderlich.",
      "title": "PlanToCode herunterladen - macOS & Windows | Kostenlose Testversion"
    },
    "trust": {
      "planning": {
        "description": "GPT-5.2, Claude Sonnet 4, Gemini 3 Pro, o3/o4-mini, Grok 4, DeepSeek R1, Kimi K2. Council of LLMs Ansatz.",
        "title": "Multi-Modell-Planung"
      },
      "pricing": {
        "description": "Sofort loslegen. Pay-as-you-go. Keine Abonnements. Token-Transparenz für Power-User, die Kosten verfolgen.",
        "title": "Nutzungsbasierte Preise"
      },
      "professional": {
        "description": "Single-Tenant-Server. On-Prem-Deployment. Terminal-Governance. Entwickelt für Teams, die nicht Cloud-Only nutzen können.",
        "title": "Professional-Optionen"
      },
      "terminal": {
        "description": "Führen Sie claude, cursor, codex oder gemini direkt aus. Sprach-Transkription ist verfügbar, und Logs werden lokal gespeichert, sodass Sie die Arbeit ohne Kontextwechsel fortsetzen können.",
        "title": "Integriertes Terminal"
      },
      "title": "Entwickelt für Heavy Coding-Agent-Nutzer"
    },
    "windows": {
      "integration": {
        "description": "PowerShell und Eingabeaufforderung unterstützt. Führen Sie claude, cursor, codex oder gemini mit Health-Monitoring und Recovery aus.",
        "title": "Terminal-Integration"
      },
      "requirements": {
        "internet": "Internetverbindung für KI-Features erforderlich",
        "os1": "Windows 10 Version 1903 (Build 18362) oder neuer",
        "os2": "Windows 11 unterstützt",
        "processor": "x64 oder ARM64 Prozessor",
        "ram": "4GB RAM mindestens (8GB empfohlen)",
        "title": "Systemanforderungen"
      },
      "subtitle": "Microsoft Store - Professional Ready",
      "title": "Windows"
    },
    "mobile": {
      "button": "Im App Store herunterladen",
      "connected": {
        "description": "Steuern Sie Ihre Desktop-PlanToCode-Sessions remote. Pläne überprüfen, Terminals verwalten und unterwegs produktiv bleiben.",
        "title": "Fernsteuerung"
      },
      "features": {
        "design": "Native iOS/iPadOS Design-Sprache",
        "monitor": "Terminal-Sessions remote überwachen",
        "review": "Implementierungspläne unterwegs überprüfen und bearbeiten",
        "sync": "Nahtlose Synchronisation mit Desktop-Workspace",
        "title": "Features",
        "voice": "Sprach-Transkription für schnelle Ideenerfassung"
      },
      "subtitle": "Fernsteuerung für iPhone & iPad",
      "title": "iOS Mobile App"
    }
  },
  "securityNotarization": {
    "meta": {
      "title": "macOS Notarization and Gatekeeper - PlanToCode",
      "description": "How the macOS build is signed and notarized, how Gatekeeper verifies it, and where to read Apple's docs.",
      "imageAlt": "PlanToCode macOS notarization and Gatekeeper overview"
    },
    "hero": {
      "title": "macOS notarization",
      "subtitle": "The macOS build is signed and notarized by Apple. Notarization validates developer identity and scans the build for malicious content; Gatekeeper uses the notarization ticket when the app is first opened."
    },
    "links": {
      "gatekeeper": {
        "label": "Apple Support:",
        "text": "Gatekeeper and runtime protection"
      },
      "notarize": {
        "label": "Apple Developer:",
        "text": "Notarizing macOS software before distribution"
      }
    },
    "footer": {
      "text": "If Gatekeeper blocks first launch, use Finder -> Open to approve the app, or visit",
      "link": "Downloads"
    }
  },
  "legal": {
    "meta": {
      "title": "Select Your Region - Legal Documents | PlanToCode",
      "description": "Choose your region (EU/UK or United States) to view applicable legal documents including terms of service, privacy policy, and regional compliance requirements."
    },
    "restricted": {
      "meta": {
        "title": "451 - Service Not Available in Your Region",
        "description": "This service is not available in your geographic region."
      }
    }
  },
  "howItWorks": {
    "cta": {
      "links": {
        "architecture": "Architecture overview",
        "buildYourOwn": "Build your own pipeline",
        "docs": "Dokumentation anzeigen",
        "workflows": "Implementation plan docs",
        "demo": "Interaktive Demo ausprobieren",
        "planning": "Über Plan-Bearbeitung lernen"
      },
      "subtitle": "Von Meeting-Erfassung bis zur sicheren Ausführung - der komplette Workflow für Corporate-Teams, die KI-Coding-Agents selbstbewusst einsetzen. Anforderungen aus jeder Quelle erfassen, mit KI verfeinern, granulare Pläne generieren, mit voller Kontrolle überprüfen und sicher ausführen.",
      "title": "Bereit, Ihren Corporate-Entwicklungs-Workflow zu transformieren?"
    },
    "hero": {
      "badge": "Professioneller KI-Planungs-Workflow",
      "subtitle": "Von Meeting-Erfassung bis zur sicheren Ausführung - der komplette Corporate-KI-Entwicklungs-Workflow",
      "title": "Wie es funktioniert"
    },
    "keyFeatures": {
      "deploy": {
        "description": "Nutzen Sie den mitgelieferten Rust-Proxy-Server mit Ihren eigenen API-Keys, wenn Sie Requests auf Ihrer kontrollierten Infrastruktur halten müssen.",
        "title": "Nach Ihren Bedingungen deployen"
      },
      "governance": {
        "description": "Jeden Plan vor Ausführung überprüfen. Ansätze bearbeiten, Strategien zusammenführen, genehmigen oder ablehnen. KI assistiert, Menschen kontrollieren. Entwickelt für Teams, bei denen Code-Qualität zählt.",
        "title": "Human-in-the-Loop-Governance"
      },
      "sessions": {
        "description": "Terminal-Output wird lokal gespeichert und Sessions werden beim Start wiederhergestellt. App schließen, nächste Woche wiederkommen, Debugging fortsetzen.",
        "title": "Persistente Sessions"
      },
      "title": "Warum Corporate-Teams diesen Workflow wählen"
    },
    "meta": {
      "description": "KI-Implementierungsplanung verhindert Chaos. Datei-Erkennung, Multi-Modell-Pläne, menschliche Überprüfung und sichere Ausführung mit jedem Coding-Agent.",
      "title": "Wie es funktioniert - KI-Planungs-Workflow"
    },
    "workflow": {
      "exampleMergeInstructions": "Example merge instructions:",
      "step1": {
        "description": "Beginnen Sie mit der Erfassung von Anforderungen aus mehreren Quellen. Laden Sie Microsoft Teams Meeting-Aufzeichnungen für multimodale Analyse hoch, zeichnen Sie Screen-Präsentationen auf, um visuellen Kontext zu erfassen, oder nutzen Sie Sprach-Diktat für schnelle Ideenerfassung. Alle Eingabemethoden führen in denselben Verfeinerungs-Workflow.",
        "meetings": {
          "description": "Teams-Meetings hochladen. Multimodale KI analysiert Audio-Transkripte (mit Sprecher-Identifikation) und visuellen Inhalt (geteilte Bildschirme, Dokumente), um Anforderungen, Entscheidungen und Aktionspunkte zu extrahieren.",
          "title": "Meeting-Aufzeichnungen"
        },
        "links": {
          "meeting": "Meeting ingestion details",
          "voice": "Voice transcription details"
        },
        "screen": {
          "description": "Workflows, Bugs oder UI-Präsentationen aufzeichnen. Gemini Vision analysiert sowohl Audio-Narration als auch visuellen Inhalt, um vollständigen Kontext für Requirements-Gathering zu erfassen.",
          "title": "Screen-Aufzeichnungen"
        },
        "subtitle": "Meeting-Aufzeichnungen, Screen-Captures und Sprach-Diktat",
        "title": "Ideen & Kontext erfassen",
        "voice": {
          "description": "Anforderungen natürlich sprechen. OpenAI gpt-4o-transcribe transkribiert mit intelligenter Text-Insertion und Sprecher-Identifikation für schnelle Spezifikations-Erfassung.",
          "title": "Sprach-Diktat"
        }
      },
      "step2": {
        "description": "Verwandeln Sie rohe Meeting-Transkripte, Sprachaufnahmen und grobe Notizen in klare, implementierungsbereite Spezifikationen mithilfe zweier unterschiedlicher KI-Prompt-Typen, die zusammenarbeiten, um sowohl Klarheit als auch Vollständigkeit zu gewährleisten.",
        "subtitle": "Zwei KI-Prompt-Typen für Klarheit und Vollständigkeit",
        "taskRefinement": {
          "description": "Erweitert Aufgabenbeschreibungen durch Identifikation impliziter Anforderungen, Füllung übersehener Lücken, Klärung erwarteten Verhaltens und Grenzfällen sowie Hinzufügung technischer Überlegungen für Implementierungsbereitschaft.",
          "title": "Aufgaben-Verfeinerung"
        },
        "textEnhancement": {
          "description": "Verbessert Grammatik, Satzstruktur, Klarheit und Prägnanz, während Ihre ursprüngliche Absicht, Ton und technisches Detail-Niveau beibehalten werden. Perfekt zum Polieren von Sprach-Transkripten und Meeting-Notizen.",
          "title": "Text-Verbesserung"
        },
        "links": {
          "specCapture": "Specification capture details"
        },
        "title": "In umsetzbare Spezifikationen verfeinern"
      },
      "step3": {
        "description": "KI-Datei-Erkennung identifiziert relevante Dateien in Ihrer Codebasis. Mehrere KI-Modelle generieren Implementierungspläne mit Datei-für-Datei-Granularität - exakte Dateipfade, spezifische Zeilenbereiche und klare Operations-Typen (modify/create/delete). Diese Granularität macht Impact-Assessment kristallklar.",
        "features": {
          "dependencies": "Dependency-Analyse und Impact-Assessment",
          "models": "Multi-Modell-Support (GPT-5.2, Claude 4, Gemini 3 Pro)",
          "multiple": "Mehrfach-Plan-Generierung für Ansatz-Vergleich",
          "operations": "Klare Operations-Typen (modify, create, delete)",
          "paths": "Exakte Dateipfade aus Ihrer Repository-Struktur",
          "ranges": "Spezifische Zeilenbereiche und Änderungs-Details"
        },
        "links": {
          "fileDiscovery": "File discovery pipeline",
          "planGeneration": "Plan generation details"
        },
        "subtitle": "Datei-für-Datei-Pläne mit exakten Repository-Pfaden",
        "title": "Granulare Implementierungspläne generieren"
      },
      "step4": {
        "capabilities": {
          "approve": "Zur Ausführung genehmigen oder mit Audit-Trail ablehnen",
          "editing": "Direkte Bearbeitung aller Plan-Schritte und Details",
          "editor": "Professioneller Monaco-Editor mit Syntax-Highlighting",
          "merge": "Mehrere Pläne mit benutzerdefinierten Anweisungen zusammenführen",
          "modifications": "Änderungen oder alternative Ansätze anfordern",
          "visibility": "Vollständige Sichtbarkeit der vorgeschlagenen Änderungen"
        },
        "description": "Pläne öffnen sich im Monaco-Editor für umfassende Überprüfung. Team-Leads prüfen jede vorgeschlagene Änderung, bearbeiten Schritte direkt, führen mehrere Ansätze mit benutzerdefinierten Anweisungen zusammen oder lehnen Pläne vollständig ab. Keine Code-Änderungen erfolgen ohne explizite menschliche Genehmigung - dies gewährleistet Übereinstimmung mit Corporate-Anforderungen und Team-Workflows.",
        "links": {
          "governance": "Review and governance",
          "merge": "Plan merging details"
        },
        "subtitle": "Volle Kontrolle vor Code-Änderungen",
        "title": "Überprüfen, Bearbeiten & Genehmigen (Human-in-the-Loop)"
      },
      "step5": {
        "description": "Nach Genehmigung übertragen Sie den Plan sicher an Ihren gewählten Coding-Agent (Claude Code, Cursor, Codex) oder zugewiesenen Software-Entwickler. Datei-für-Datei-Granularität verhindert Regressionen und unbeabsichtigte Änderungen - gewährleistet sichere Ausführung. Integriertes Terminal mit persistenten Sessions ermöglicht sofortige Ausführung und Debugging.",
        "links": {
          "terminal": "Terminal integration details",
          "planDocs": "Implementation plan format"
        },
        "subtitle": "Sichere Übergabe an Entwickler oder Coding-Agents",
        "title": "Mit Vertrauen ausführen",
        "tools": {
          "audit": "Vollständiger Audit-Trail der Ausführung",
          "claude": "Claude Code CLI mit Plan-Mode-Support",
          "codex": "OpenAI Codex CLI Ausführung",
          "cursor": "Cursor CLI Integration",
          "sessions": "Persistente Terminal-Sessions mit Auto-Recovery",
          "terminal": "Integriertes Terminal mit Sprach-Transkription"
        }
      },
      "title": "Der komplette Workflow"
    },
    "demo": {
      "button": "Interaktive Demo ausprobieren",
      "description": "Sehen Sie die interaktive Demo, um den kompletten Workflow zu erleben",
      "title": "In Aktion sehen"
    },
    "useCases": {
      "bugs": {
        "description": "Screen-Captures von Bugs aufzeichnen, KI-Analyse erhalten, Debugging-Pläne generieren, mit voller Terminal-Kontrolle ausführen.",
        "items": {
          "persistent": "Persistentes Terminal-Log",
          "systematic": "Systematische Debugging-Ansätze",
          "visual": "Visueller Kontext mit Screen-Recording"
        },
        "title": "Komplexe Bug-Untersuchung"
      },
      "features": {
        "description": "Multi-Datei-Features, die sorgfältige Planung erfordern. Generieren Sie mehrere Ansätze, führen Sie die besten Teile zusammen, bearbeiten Sie für Ihre spezifische Codebasis.",
        "items": {
          "api": "API-Design und Integration",
          "cross": "Cross-Component-Feature-Implementierung",
          "schema": "Datenbank-Schema-Änderungen"
        },
        "title": "Große Feature-Entwicklung"
      },
      "legacy": {
        "description": "KI versteht Legacy-Patterns und technische Schulden. Generieren Sie sichere Refactoring-Pläne, Library-Upgrades und architektonische Verbesserungen.",
        "items": {
          "breaking": "Breaking-Change-Migrations-Pläne",
          "cleanup": "Technische-Schulden-Cleanup",
          "dependency": "Dependency-Upgrade-Strategien"
        },
        "title": "Legacy-Codebasis-Wartung"
      },
      "professional": {
        "description": "Befehlsgenehmigungen, Session-Retention, Single-Tenant-Deployment. Entwickelt für Teams, bei denen ein falscher Befehl Millionen kostet.",
        "items": {
          "audit": "Vollständige Audit-Trails",
          "governance": "Terminal-Governance und Genehmigungen",
          "onprem": "On-Premise-Deployment-Optionen"
        },
        "title": "Professionelle Entwicklung"
      },
      "title": "Entwickelt für Corporate-Entwicklungsteams"
    }
  },
  "support": {
    "button": "Support kontaktieren",
    "hero": {
      "subtitle": "Holen Sie sich Hilfe zu PlanToCode",
      "title": "Support"
    },
    "meta": {
      "description": "Holen Sie sich Hilfe bei PlanToCode-Installation, Claude Code, Cursor und Codex Integration. Troubleshooting und Feature-Requests. 24h Antwortzeit.",
      "title": "PlanToCode Support - Hilfe & Troubleshooting"
    },
    "resources": {
      "changelog": "Changelog",
      "feedback": "Feedback",
      "help": "Hilfe-Center",
      "roadmap": "Roadmap",
      "title": "FeatureBase-Ressourcen"
    }
  },
  "compare": {
    "meta": {
      "title": "KI‑Coding‑Tools vergleichen | PlanToCode vs. Alternativen",
      "description": "Vergleich mit Cursor, Windsurf, Claude Code, Aider u. a. Finden Sie das passende Tool für Ihren Workflow."
    }
  },
  "screenshots": {
    "title": "PlanToCode Screenshots",
    "description": "See PlanToCode in action with real screenshots from actual workflows."
  },
  "planMode": {
    "capabilities": {
      "architect": {
        "capability": "KI-Architekt führt Pläne mit Ihrer Anleitung zusammen",
        "details": "Leiten Sie das Zusammenführen mit Ihren architektonischen Anforderungen. KI konsolidiert komplementäre Details aus mehreren Runs in einen umfassenden Plan"
      },
      "execution": {
        "capability": "Ausführung mit voller Kontrolle",
        "details": "Plan überprüfen, Scope verifizieren, dann ausführen. Oder in den Chat Ihrer IDE einfügen."
      },
      "know": {
        "capability": "Wissen Sie, was geändert wird, bevor es passiert",
        "details": "Datei-Erkennung zeigt exakten Impact. Sehen Sie, welche Dateien jeder Plan berührt. Keine Überraschungen.",
        "link": "Sehen Sie, wie es funktioniert"
      },
      "prompts": {
        "capability": "Ein-Klick-Prompts, die funktionieren",
        "details": "Kopier-Buttons für Ihre kampferprobten Prompts. Kein erneutes Eintippen von \"mach es type-safe\" 20 Mal mehr."
      },
      "title": "Was Sie tatsächlich bekommen"
    },
    "circumstances": {
      "footer": "Das sind keine \"Pain Points\". Das sind Momente, wo Sie Sichtbarkeit und Kontrolle brauchen, bevor Sie sich auf einen Ansatz festlegen. Das haben wir gebaut.",
      "items": {
        "breaks": {
          "moment": "Ihre Änderung bricht drei Downstream-Services, in Prod entdeckt",
          "progress": "Datei-Erkennung mappt alle Dependencies im Voraus, erkennt Impacts früh"
        },
        "drift": {
          "moment": "KI driftet von Ihren Anforderungen ab, baut, was es denkt, dass Sie wollen",
          "progress": "KI-Architekt hält Pläne an Ihren tatsächlichen Zielen ausgerichtet, kein Drift"
        },
        "plans": {
          "moment": "Ein Plan erkennt Grenzfälle, ein anderer handhabt Error-States, ein dritter fügt Types hinzu",
          "progress": "KI-Architekt kombiniert komplementäre Einsichten in vollständige Implementierung"
        },
        "symptom": {
          "moment": "KI behebt das Symptom in /components, übersieht die Ursache in /config",
          "progress": "Leiten Sie es mit Datei-Erkennung zur richtigen Abstraktionsebene"
        }
      },
      "title": "Wenn KI architektonischen Kontext braucht"
    },
    "cta": {
      "book": "Architekten-Session buchen",
      "demo": "Interaktive Demo zuerst ausprobieren",
      "pricing": "Pay-as-you-go Credits. $5 kostenlose Promo für neue Nutzer. Keine Abonnements.",
      "subtitle": "Treten Sie Entwicklern bei, die große Änderungen mit Klarheit, Nachverfolgbarkeit und operationeller Zuverlässigkeit shippen.",
      "title": "Bereit, Ihren Architekten einzustellen?"
    },
    "faq": {
      "q1": {
        "answer": "PlanToCode bietet architektonische Vor-Planung **bevor** Sie Codex, Claude Code oder Cursor nutzen. Es fügt Datei-Erkennung, Multi-Modell-Synthese und Merge-Anweisungen hinzu, die die Ausführungs-Phase dieser Tools ergänzen.",
        "question": "Wie unterscheidet sich das von Codex CLI oder Claude Code?"
      },
      "q2": {
        "answer": "Ja. PlanToCode arbeitet neben Codex CLI, Claude Code, Cursor und Windsurf. Generieren Sie Pläne in PlanToCode, führen Sie dann in Ihrem bevorzugten Tool mit vollem Kontext aus.",
        "question": "Kann ich das mit meinem bestehenden KI-Coding-Tool nutzen?"
      },
      "q3": {
        "answer": "Führen Sie dieselbe Aufgabe mehrmals mit verschiedenen KI-Modellen aus. Jeder Run liefert verschiedene Implementierungs-Details. PlanToCode führt sie in einen umfassenden Plan mit Quell-Attribution zusammen.",
        "question": "Was bedeutet Multi-Modell-Synthese?"
      },
      "title": "Häufig gestellte Fragen"
    },
    "hero": {
      "badge": "Für Entwickler, die vor dem Ausführen überprüfen",
      "credits": "$5 kostenlose Credits • Pay-as-you-go • Funktioniert mit jedem KI-Coding-Tool",
      "guidance": "Sehen Sie den vollen Scope, leiten Sie es zu den richtigen Dateien, wählen Sie den Ansatz, der zu Ihrem System passt.",
      "insight": "Die neuesten, fortschrittlichsten Modelle sind brillant im Code, blind für Architektur.",
      "install": "PlanToCode installieren",
      "subtitle": "Sie können sich unmöglich an jeden Webhook, Cache, Background-Job und API-Consumer erinnern, der von dieser einen Funktion abhängt. So schleichen sich Regressionen ein.",
      "title": "Architektonische Planung für Codex CLI, Claude Code & Cursor"
    },
    "integrations": {
      "claude": {
        "description": "Claude Codes nativen Plan-Mode mit Multi-Modell-Synthese, Datei-Erkennung und Merge-Anweisungen erweitern.",
        "link": "Claude Code Planungs-Workflow-Guide öffnen",
        "title": "Claude Code Planungs-Workflow"
      },
      "codex": {
        "description": "Jede Dependency mappen, Multi-Modell-Pläne zusammenführen, dann mit Codex-Genehmigungs-Modi für sichere Iteration ausführen.",
        "link": "Codex CLI Planungs-Workflow-Guide öffnen",
        "title": "Codex CLI Planungs-Workflow"
      },
      "cursor": {
        "description": "Cursor Composer und Agent-Mode vollständigen architektonischen Kontext mit WSL-freundlichen Ausführungs-Guardrails geben.",
        "link": "Cursor Planungs-Workflow-Guide öffnen",
        "title": "Cursor Planungs-Workflow"
      },
      "title": "Wählen Sie Ihren CLI-Planungs-Workflow"
    },
    "meta": {
      "description": "Software-Änderungen planen, bevor Sie coden. Datei-für-Datei-Implementierungs-Specs generieren, mit Ihrem Team überprüfen, dann mit voller Sichtbarkeit und Governance ausführen.",
      "title": "Planen Sie, bevor Sie coden - Prüfbare Specs"
    },
    "progress": {
      "execute": {
        "description": "Exakten Scope vor Ausführung sehen. Integriertes Terminal oder in Ihre IDE einfügen",
        "title": "Mit voller Sichtbarkeit ausführen"
      },
      "guide": {
        "description": "Sagen Sie der KI, was Sie mögen, was Sie vermeiden sollten. Sie folgt Ihren architektonischen Entscheidungen überraschend gut",
        "title": "Zusammenführungen mit Ihrer Expertise leiten"
      },
      "quote": "KI generiert den Code. Sie architektonieren die Lösung.",
      "ship": {
        "description": "KI-Architekt führt komplementäre Einsichten aus mehreren Plänen in vollständige Implementierung zusammen",
        "title": "Komplexe Features mit Vertrauen shippen"
      },
      "title": "Der Fortschritt, den Sie tatsächlich machen"
    },
    "users": {
      "cli": {
        "quote": "Mein CLI-Agent würde Grenzfälle übersehen oder bestehende Features brechen. Jetzt erkennt der KI-Architekt Lücken und Regressionen in Plänen, bevor sie meine Codebasis treffen.",
        "title": "CLI-Agent-Nutzer"
      },
      "ide": {
        "quote": "IDE-Agents fehlt architektonischer Kontext. Jetzt plant mein KI-Architekt den richtigen Ansatz im Voraus, berücksichtigt alle System-Impacts. Dann füge ich den validierten Plan in Cursor ein.",
        "title": "Cursor & Windsurf Nutzer"
      },
      "senior": {
        "quote": "KI behob ständig Symptome, nicht Ursachen. Jetzt leite ich es zuerst zur richtigen Abstraktionsebene. Datei-Erkennung zeigt die echte Architektur, bevor Code geschrieben wird.",
        "title": "Senior-Engineers"
      },
      "title": "Wer nutzt das"
    },
    "whyNow": {
      "ide": {
        "detail": "Beliebte KI-Coding-Tools sind brilliant auf Mikro-Ebene. Sie brauchen etwas, das das Makro sieht.",
        "reason": "Jede IDE hat jetzt KI"
      },
      "models": {
        "detail": "Moderne Modelle sind fähig. Aber sie kennen **Ihre** Architektur, **Ihre** Patterns, **Ihre** Constraints nicht.",
        "reason": "KI-Modelle schreiben exzellenten Code"
      },
      "systems": {
        "detail": "User-Service ändern, Mobile-App brechen. Dieses Interface aktualisieren, drei Microservices beeinflussen. KI sieht diese Verbindungen nicht.",
        "reason": "Codebasen sind vernetzte Systeme"
      },
      "title": "Warum das jetzt wichtig ist"
    },
    "workflow": {
      "discovery": {
        "description": "Mehrstufiger Workflow bringt die richtigen Dateien ans Licht, bevor Sie planen",
        "step": "Datei-Erkennung"
      },
      "execute": {
        "description": "Im Terminal ausführen oder in Ihr KI-Coding-Tool einfügen",
        "step": "Ausführen"
      },
      "generate": {
        "description": "Mehrere Modelle mit verschiedenen Perspektiven und Token-Guardrails ausführen",
        "step": "Pläne generieren"
      },
      "link": "Detaillierten Workflow sehen",
      "merge": {
        "description": "Merge-Anweisungen bereitstellen, KI konsolidiert komplementäre Details aus mehreren Runs",
        "step": "KI führt zusammen + Sie leiten"
      },
      "title": "Wie es funktioniert"
    }
  },
  "all-pages": {
    "meta": {
      "title": "Alle Seiten - pSEO‑Überblick",
      "description": "Interne Übersichtsseite für alle programmatischen SEO‑Seiten"
    }
  },
  "workflows": {
    "hub": {
      "badge": "KI-Entwicklungs-Workflows",
      "card": {
        "solves": "Löst:",
        "viewLink": "Workflow ansehen"
      },
      "cta": {
        "downloadLink": "PlanToCode herunterladen",
        "subtitle": "Beginnen Sie mit Datei-Erkennung, generieren Sie umfassende Pläne und führen Sie mit Vertrauen aus.",
        "title": "Bereit, Ihren Entwicklungs-Workflow zu transformieren?"
      },
      "description": "Entdecken Sie bewährte Workflows für komplexe Entwicklungsaufgaben. Jeder Workflow kombiniert Datei-Erkennung, Multi-Modell-Planung und integrierte Terminal-Ausführung, um echte Engineering-Herausforderungen zu lösen.",
      "meta": {
        "description": "KI-Entwicklungs-Workflows für komplexe Aufgaben. Integration mit Claude Code, Cursor, Codex für Refactorings, Bug-Triage und Migrationen.",
        "title": "KI-Coding-Workflows - PlanToCode-Integrationsmuster"
      },
      "title": "KI-Powered Entwicklungs-Workflows",
      "toolCategories": {
        "claudeCode": "Claude Code Workflows",
        "codexCli": "Codex CLI Workflows",
        "cursor": "Cursor Workflows",
        "general": "Allgemeine Workflows"
      }
    }
  },
  "blog": {
    "hub": {
      "meta": {
        "title": "Blog - Einblicke in KI‑Code‑Planung | PlanToCode",
        "description": "Einblicke in KI‑gestützte Code‑Planung und Entwicklungs‑Workflows."
      }
    },
    "ai-code-planning-best-practices": {
      "meta": {
        "title": "Best Practices der KI‑Code‑Planung 2025 – Workflow‑Guide",
        "description": "Bewährte Verfahren: Multi‑Modell‑Planung, Abhängigkeits‑Mapping, Review‑Checklisten, Team‑Workflows für Produktionscodebasen."
      }
    },
    "github-copilot-alternatives-2025": {
      "meta": {
        "title": "GitHub Copilot Alternativen 2025 | Beste Optionen",
        "description": "Umfassender Vergleich: Cursor, Windsurf, Codeium, Tabnine, PlanToCode, Aider. Preise, Funktionen, beste Wahl fürs Team."
      }
    },
    "best-ai-coding-assistants-2025": {
      "meta": {
        "title": "Beste KI-Coding-Assistenten 2025 - Vollständiger Leitfaden",
        "description": "Umfassender Vergleich von 15+ KI-Coding-Tools einschließlich Cursor, GitHub Copilot, Windsurf und PlanToCode. Erfahren Sie, welche Tools bei Code-Generierung vs. Implementierungsplanung glänzen."
      }
    },
    "ai-pair-programming-vs-ai-planning": {
      "meta": {
        "title": "KI-Pair-Programming vs. Planung - Team-Leitfaden",
        "description": "Vergleichen Sie KI-Pair-Programming (Copilot, Cursor) mit KI-Planung (PlanToCode). Wann welcher Ansatz für Produktions-Codebasen, Teams und komplexe Refactorings zu verwenden ist."
      }
    },
    "what-is-ai-code-planning": {
      "meta": {
        "title": "Was ist KI-Code-Planung? Entwickler-Leitfaden",
        "description": "Was KI-Code-Planung ist, warum sie für große Codebasen wichtig ist, wie planungsorientierte Entwicklung KI-Coding-Chaos verhindert."
      }
    }
  },
  "comparisons": {
    "hub": {
      "badge": "Tool-Vergleiche",
      "card": {
        "badge": "Vergleich",
        "viewLink": "Vergleich ansehen",
        "whySwitchLabel": "Warum Entwickler wechseln:"
      },
      "cta": {
        "button": "PlanToCode kostenlos ausprobieren",
        "footer": "$5 kostenlose Credits • Keine Kreditkarte erforderlich",
        "subtitle": "Sehen Sie, warum Entwickler zu PlanToCode für komplexe, mission-kritische Arbeit wechseln.",
        "title": "Erleben Sie den Unterschied"
      },
      "cursorNote": {
        "link": "Erfahren Sie, wie PlanToCode Cursor ergänzt →",
        "strong": "Suchen Sie nach einer Cursor-Alternative?",
        "text": "PlanToCode arbeitet MIT Cursor zusammen, nicht statt es."
      },
      "description": "Sehen Sie, wie PlanToCodes architektonischer Planungsansatz sich mit traditionellen Terminal-Tools, KI-Coding-Assistenten und anderen Entwicklungs-Workflows vergleicht.",
      "meta": {
        "description": "Vergleichen Sie PlanToCode mit tmux, script, asciinema, Cursor, Claude Code und anderen Entwicklungs-Tools. Sehen Sie, wie architektonische Planung Ihren Workflow verbessert.",
        "title": "PlanToCode vs Alternativen - Feature-Vergleiche"
      },
      "title": "PlanToCode vs Alternativen",
      "whatMakesDifferent": {
        "architectural": {
          "description": "Mehrstufige Datei-Erkennung mappt Ihre gesamte Codebasis-Architektur, bevor Änderungen gemacht werden. Die meisten Tools sehen nur, was Sie ihnen zeigen.",
          "title": "Architektonisches Bewusstsein"
        },
        "humanInLoop": {
          "description": "Überprüfen, bearbeiten und genehmigen Sie jeden Plan vor Ausführung. Persistente Terminal-Sessions ermöglichen es Ihnen, jederzeit zu pausieren, zu untersuchen und fortzufahren.",
          "title": "Human-in-the-Loop"
        },
        "multiModel": {
          "description": "Generieren Sie Pläne von mehreren KI-Modellen (GPT-5.2, Claude 4.5, Gemini 3 Pro) und führen Sie die besten Erkenntnisse zusammen. Single-Modell-Tools verpassen Perspektiven.",
          "title": "Multi-Modell-Planung"
        },
        "title": "Was PlanToCode unterschiedlich macht"
      }
    }
  },
  "cursorAlternative": {
    "comparison": {
      "intro": "Das ist kein wettbewerblicher Vergleich - es zeigt, wie die Tools sich ergänzen:",
      "table": {
        "approval": {
          "cursor": "Nicht eingebaut",
          "name": "Team-Genehmigungs-Workflows",
          "plan": "Vollständiger Audit-Trail",
          "together": "In PlanToCode genehmigen, in Cursor implementieren"
        },
        "autocomplete": {
          "cursor": "Branchenführend",
          "name": "Autocomplete & IntelliSense",
          "plan": "Nicht enthalten",
          "together": "Cursor handhabt Autocomplete"
        },
        "capability": "Fähigkeit",
        "chat": {
          "cursor": "Exzellente UX",
          "name": "Chat-Interface",
          "plan": "Aufgabenbasierte UI",
          "together": "Cursors Chat fühlt sich natürlich an"
        },
        "cursor": "Cursor",
        "discovery": {
          "cursor": "Basis-Indexierung",
          "name": "Datei-Erkennung & Analyse",
          "plan": "Fortgeschrittener Workflow",
          "together": "PlanToCode findet Dateien, Cursor ändert sie"
        },
        "duplicates": {
          "cursor": "Nicht eingebaut",
          "name": "Duplikat-Datei-Prävention",
          "plan": "In Review erkannt",
          "together": "PlanToCode verhindert, Cursor führt korrekt aus"
        },
        "multiModel": {
          "cursor": "Ein Modell pro Request",
          "name": "Multi-Modell-Synthese",
          "plan": "Modelle vergleichen & zusammenführen",
          "together": "Bester Plan von mehreren Modellen → Cursor"
        },
        "planning": {
          "cursor": "Nicht verfügbar",
          "name": "Implementierungsplanung",
          "plan": "Kern-Feature",
          "together": "PlanToCode leitet Cursor"
        },
        "plantocode": "PlanToCode",
        "pricing": {
          "cursor": "$20/Monat Abo",
          "name": "Preismodell",
          "plan": "Pay-as-you-go (kein Abo)",
          "together": "$20/Monat + tatsächliche Nutzung ($5-15 typisch)"
        },
        "review": {
          "cursor": "Manuell via Chat",
          "name": "Pre-Execution-Review",
          "plan": "Eingebauter Workflow",
          "together": "Review in PlanToCode, Ausführung in Cursor"
        },
        "speed": {
          "cursor": "Exzellent",
          "name": "Code-Generierungs-Geschwindigkeit",
          "plan": "Nicht enthalten",
          "together": "Cursor handhabt Generierung"
        },
        "together": "Besser zusammen"
      },
      "title": "Feature-Vergleich: Komplementäre Stärken"
    },
    "faq": {
      "q1": {
        "answer": "Nein, PlanToCode ist kein Cursor-Ersatz. Es ist ein komplementäres Tool, das neben Cursor arbeitet. Während Cursor bei Code-Generierung und Autocomplete glänzt, fügt PlanToCode eine Sicherheitsebene durch Implementierungsplanung hinzu. Nutzen Sie Cursor für Geschwindigkeit, PlanToCode für Sicherheit.",
        "question": "Ist PlanToCode eine Cursor-Alternative oder ein Ersatz?"
      },
      "q2": {
        "answer": "Die gemeinsame Nutzung beider Tools verhindert häufige Cursor-Probleme: Duplikat-Datei-Erstellung, falsche Dateipfade (besonders in Multi-Workspace-Projekten), unerwartete Datei-Änderungen und Production-Bugs durch ungeprüfte Änderungen. PlanToCodes Planungs-Phase erkennt diese Probleme vor Ausführung.",
        "question": "Welche Probleme löst die gemeinsame Nutzung von Cursor und PlanToCode?"
      },
      "q3": {
        "answer": "Der Workflow ist: 1) Datei-für-Datei-Implementierungsplan in PlanToCode generieren, 2) Plan überprüfen und genehmigen (Pfad-Fehler oder Duplikate erkennen), 3) Genehmigten Plan in Cursor Agent oder Composer einfügen, 4) Cursor Code-Generierung mit klarem architektonischen Kontext ausführen lassen.",
        "question": "Wie nutze ich PlanToCode mit Cursor?"
      },
      "q4": {
        "answer": "Cursor kostet $20/Monat für ein Abo. PlanToCode nutzt Pay-as-you-go-Preise ohne Abo. Gesamtkosten: $20/Monat für Cursor + Ihre tatsächliche API-Nutzung in PlanToCode (typisch $5-15/Monat für reguläre Nutzung). Viele Entwickler finden das günstiger als stundenlangen Duplikat-Datei-Cleanup.",
        "question": "Wie sieht die kombinierte Preisgestaltung aus?"
      },
      "q5": {
        "answer": "Absolut. Cursor funktioniert eigenständig großartig für kleine Projekte, Greenfield-Entwicklung und schnelle Prototypen. Fügen Sie PlanToCode hinzu bei großen Codebasen (50k+ LOC), komplexem Refactoring, Team-Umgebungen mit Genehmigungs-Anforderungen oder wenn Sie Duplikat-Datei-Probleme erlebt haben.",
        "question": "Kann ich Cursor ohne PlanToCode nutzen?"
      },
      "q6": {
        "answer": "Ja. Generieren Sie Ihren Implementierungsplan in PlanToCode, überprüfen Sie ihn, fügen Sie dann den genehmigten Plan in Cursor Agent Terminal ein oder geben Sie ihn Background Agents. Sie führen mit vollständigem architektonischen Kontext aus und verhindern häufige Pfad- und Duplikations-Fehler.",
        "question": "Funktioniert PlanToCode mit Cursor Agent und Background Agents?"
      },
      "q7": {
        "answer": "Die Planungs-Phase fügt 3-5 Minuten im Voraus hinzu, spart aber Stunden an Debugging, Duplikat-Datei-Cleanup und Pfad-Korrekturen. Die meisten Entwickler berichten von Netto-Zeiteinsparungen, besonders bei komplexen Tasks in großen Codebasen. Für schnelle Prototypen, wo Fehler günstig zu beheben sind, können Sie Planung überspringen und Cursor allein nutzen.",
        "question": "Verlangsamt die Nutzung beider Tools meinen Workflow?"
      },
      "q8": {
        "answer": "Ja, absolut. PlanToCode interferiert nicht mit Cursors Autocomplete oder anderen Cursor-Features. Sie sind separate Tools, die zusammenarbeiten. Nutzen Sie Cursors Autocomplete für normales Coding und wechseln Sie zu PlanToCode, wenn Sie Implementierungsplanung für größere Änderungen brauchen.",
        "question": "Kann ich Cursors Autocomplete weiterhin mit PlanToCode nutzen?"
      },
      "title": "Häufig gestellte Fragen"
    },
    "finalCta": {
      "description": "Die Antwort ist nicht, Cursor zu ersetzen - sondern die Sicherheitsebene hinzuzufügen, die doppelte Dateien, falsche Pfade und Production-Bugs verhindert.",
      "download": "PlanToCode herunterladen (Kostenlos)",
      "footer": "Kostenlos herunterladen. Pay-as-you-go API-Nutzung. Funktioniert mit Ihrem bestehenden Cursor-Setup.",
      "guide": "Integrations-Guide lesen",
      "title": "Hören Sie auf, nach Cursor-Alternativen zu suchen"
    },
    "gettingStarted": {
      "guide": "Setup-Guide: Cursor + PlanToCode",
      "quickWins": {
        "duplicates": "Duplikat-Dateien erkennen, bevor sie erstellt werden",
        "existing": "Funktioniert mit Ihrem bestehenden Cursor-Setup",
        "paths": "Exakte Dateipfade vor Ausführung überprüfen",
        "plan": "Erster Plan in unter 5 Minuten generiert",
        "subscription": "Kein Abo für PlanToCode erforderlich",
        "title": "Quick Wins"
      },
      "resources": {
        "comparison": "Detaillierter Tool-Vergleich",
        "discovery": "Datei-Erkennung-Workflow",
        "documentation": "Vollständige Dokumentation",
        "integration": "Cursor-Integrations-Guide",
        "title": "Kostenlose Ressourcen"
      },
      "step1": {
        "cursor": "Cursor von cursor.sh herunterladen ($20/Monat nach Trial)",
        "install": "Beide auf derselben Maschine für nahtlosen Workflow installieren",
        "plan": "PlanToCode von unserer Downloads-Seite herunterladen (kostenlos, Pay-as-you-go API-Nutzung)",
        "title": "Schritt 1: Beide Tools installieren"
      },
      "step2": {
        "items": {
          "1": "Projekt in Cursor (für Kontext) und PlanToCode (für Planung) öffnen",
          "2": "In PlanToCode: Aufgabe beschreiben, Datei-Erkennung ausführen, Implementierungsplan generieren",
          "3": "Plan im Monaco-Editor überprüfen - Dateipfade prüfen, auf Duplikate verifizieren",
          "4": "Genehmigten Plan kopieren",
          "5": "In Cursor: Agent Terminal oder Composer öffnen, Plan einfügen, Cursor ausführen lassen",
          "6": "Cursors generierten Code überprüfen (Architektur bereits verifiziert)"
        },
        "title": "Schritt 2: Ersten kombinierten Workflow ausprobieren"
      },
      "step3": {
        "comparison": "Detaillierten Vergleich sehen, wann welches Tool zu nutzen ist",
        "docs": "Implementierungsplanungs-Docs für Best Practices erkunden",
        "integration": "Unseren Cursor-Integrations-Guide für detaillierte Workflows lesen",
        "title": "Schritt 3: Fortgeschrittene Workflows lernen"
      },
      "title": "Mit beiden Tools starten"
    },
    "hero": {
      "badge": "Kein Ersatz - ein Sicherheits-Companion",
      "download": "PlanToCode herunterladen (Kostenlos)",
      "guide": "Cursor-Integrations-Guide ansehen",
      "subtitle": "Hören Sie auf, nach Cursor-Alternativen zu suchen. Die echte Lösung ist nicht, Cursor zu ersetzen - sondern eine Sicherheitsebene hinzuzufügen, die doppelte Dateien, falsche Pfade und Production-Bugs verhindert, bevor sie entstehen.",
      "title": "Cursor-Alternative?",
      "titleHighlight": "Nein - Ihr Cursor Safety Companion"
    },
    "meta": {
      "description": "Suchen Sie keinen Cursor-Ersatz? PlanToCode arbeitet MIT Cursor zusammen, um doppelte Dateien, falsche Pfade und Production-Bugs zu verhindern. Nutzen Sie beide zusammen.",
      "title": "Cursor Safety Companion - Keine Alternative"
    },
    "prevention": {
      "bugs": {
        "generate": "Cursors Generate-First-Ansatz: Änderungen werden sofort angewendet. Sie bemerken vielleicht nicht, dass Cursor utils/helpers.ts geändert hat, was 15 andere Dateien bricht. Sie entdecken den Bruch in Production oder beim Testen.",
        "plan": "PlanToCodes Plan-First-Ansatz: Plan zeigt alle Datei-Änderungen vor Ausführung. Sie sehen, dass utils/helpers.ts sich ändern wird. Sie führen Dependency-Analyse aus. Sie erkennen, dass 15 Dateien davon abhängen. Sie passen den Plan entsprechend an.",
        "title": "Production-Bugs verhindern"
      },
      "duplicates": {
        "generate": "Cursors Generate-First-Ansatz: KI generiert Code sofort. Wenn es die richtige Datei nicht findet oder durch ähnliche Namen verwirrt wird, erstellt es eine neue Datei. Sie entdecken Duplikate nach Generierung.",
        "plan": "PlanToCodes Plan-First-Ansatz: Plan listet exakte Dateipfade vor jeder Code-Generierung. Sie sehen components/Button.tsx und components/ui/Button.tsx im Plan. Sie erkennen das Duplikat-Benennungs-Problem während Review.",
        "title": "Doppelte Dateien verhindern"
      },
      "intro": "Die Probleme, die Entwickler mit Cursor erleben, sind nicht zufällig - sie sind vorhersehbare Konsequenzen von Generate-First-Workflows. So verhindert Planning-First jedes einzelne:",
      "paths": {
        "generate": "Cursors Generate-First-Ansatz: Besonders in Multi-Workspace-Projekten kann Cursor Code im falschen Workspace generieren oder relative Pfade falsch nutzen. Sie entdecken Pfad-Fehler, wenn Code nicht läuft.",
        "plan": "PlanToCodes Plan-First-Ansatz: Datei-Erkennung zeigt die vollständige Repository-Struktur. Pläne nutzen absolute Pfade. Sie verifizieren, dass Pfade zu Ihrer tatsächlichen Struktur während Review-Phase passen. Cursor bekommt korrekte Pfade vom Plan.",
        "title": "Falsche Dateipfade verhindern"
      },
      "scope": {
        "generate": "Cursors Generate-First-Ansatz: Gebeten, \"Dark-Mode-Toggle hinzuzufügen\", könnte Cursor auch Ihr gesamtes Theming-System refactoren, 30 Components aktualisieren und Ihre CSS-Architektur ändern. Sie entdecken die Scope-Explosion nach Generierung.",
        "plan": "PlanToCodes Plan-First-Ansatz: Plan zeigt \"Änderungen: 47 Dateien inklusive vollständigem Theming-Refactor.\" Sie sehen den Scope sofort. Sie verfeinern den Prompt: \"Nur Toggle-Component hinzufügen, kein Refactoring.\" Plan neu generieren. Jetzt sind es 3 Dateien. Genehmigen und ausführen.",
        "title": "Scope-Creep verhindern"
      },
      "title": "Warum Planning-First Cursors häufige Probleme verhindert"
    },
    "problem": {
      "bugs": {
        "description": "Änderungen werden direkt ohne Review angewendet, brechen Production-Code ohne klaren Rollback-Pfad.",
        "source": "— Häufige Beschwerde in großen Codebasen",
        "title": "Production-Bugs"
      },
      "duplicates": {
        "description": "\"Warum erstellt Cursor doppelte Dateistrukturen? Ich habe Projekte komplett aufgegeben wegen angesammelter Duplikate.\"",
        "source": "— Cursor Forum #47028 (14+ Antworten)",
        "title": "Doppelte-Dateien-Chaos"
      },
      "insight": "Hier ist die Einsicht: Das sind keine Cursor-Bugs - sie sind inhärent zum Generate-First, Review-Later-Ansatz. Die Lösung ist kein anderer Code-Generator. Es ist das Hinzufügen einer Plan-First-Sicherheitsebene.",
      "intro": "Sie suchen nicht nach einer Cursor-Alternative, weil Cursor schlecht in Code-Generierung ist. Sie suchen, weil Sie eines (oder alle) dieser Probleme erlebt haben:",
      "paths": {
        "description": "\"Cursor bekommt Dateipfade sehr oft falsch, fast immer bei mehreren Workspaces.\"",
        "source": "— Cursor Issue #31402",
        "title": "Falsche Pfad-Fehler"
      },
      "title": "Warum Entwickler nach \"Cursor-Alternative\" suchen",
      "unexpected": {
        "description": "\"Code-Update aus Chat anwenden erstellt eine neue Datei, anstatt bestehende zu ändern.\"",
        "source": "— Cursor Issue #22347",
        "title": "Unerwartete Datei-Erstellung"
      }
    },
    "testimonials": {
      "enterprise": {
        "quote": "Unser Compliance-Team verlangt, dass alle KI-Änderungen von einem Senior-Engineer vor Ausführung überprüft werden. PlanToCode gibt uns den Genehmigungs-Workflow, den wir brauchen. Junior-Devs generieren Pläne, Seniors überprüfen und genehmigen, dann fügen Juniors genehmigte Pläne in Cursor ein. Alle sind glücklich.",
        "title": "Enterprise-Team, Legacy-Codebasis (400k LOC)",
        "tools": "Tools: Cursor Pro für 8 Entwickler ($160/Monat) + PlanToCode Self-hosted Server"
      },
      "freelancer": {
        "quote": "Ich berechne Kunden stündlich. Kann mir nicht leisten, 2 Stunden mit Duplikat-Datei-Cleanup zu verbringen. PlanToCode erkennt alles während der 5-Minuten-Review-Phase. Ich zeige Kunden den Plan zur Genehmigung, sie sehen genau, wofür sie bezahlen, dann führe ich in Cursor aus. Super professionell.",
        "title": "Freelancer, Kunden-Projekte",
        "tools": "Tools: Cursor Pro ($20/Monat) + PlanToCode (~$6/Monat Nutzung)"
      },
      "intro": "Diese Workflows zeigen, wie Entwickler beide Tools zusammen nutzen:",
      "solo": {
        "quote": "Ich bekam ständig doppelte Dateien in meinem Monorepo. Cursor würde packages/api/auth.ts und packages/api/src/auth.ts erstellen. Jetzt generiere ich den Plan in PlanToCode, verifiziere, dass die Pfade korrekt sind, füge dann in Cursor Agent ein. Null Duplikate seit dem Wechsel.",
        "title": "Solo-Entwickler, Monorepo (120k LOC)",
        "tools": "Tools: Cursor Pro ($20/Monat) + PlanToCode (~$8/Monat Nutzung)"
      },
      "startup": {
        "quote": "Cursors Pfad-Fehler in Multi-Workspace-Projekten haben uns umgebracht. PlanToCodes Datei-Erkennung zeigt die vollständige Struktur über alle Workspaces. Ich verifiziere Pfade im Plan, dann führt Cursor perfekt aus, weil es den richtigen Kontext hat.",
        "title": "Startup-CTO, Multi-Workspace-Projekt",
        "tools": "Tools: Cursor Pro ($20/Monat) + PlanToCode (~$12/Monat Nutzung)"
      },
      "title": "Echte Cursor-Nutzer, die PlanToCode hinzugefügt haben"
    },
    "twist": {
      "complement": "PlanToCode ersetzt Cursor nicht. Es fügt das fehlende Stück hinzu: Implementierungsplanung vor Ausführung. Denken Sie daran als Sicherheitsebene, die Fehler erkennt, bevor sie zu Code werden.",
      "cursorFor": {
        "autocomplete": "Intelligentes Autocomplete",
        "commands": "Natürlichsprachliche Befehle",
        "ide": "IDE-Integration",
        "prototypes": "Schnelle Prototypen",
        "speed": "Code-Generierungs-Geschwindigkeit",
        "title": "Cursor nutzen für:"
      },
      "planFor": {
        "approval": "Team-Genehmigungs-Workflows",
        "duplicates": "Doppelte Dateien verhindern",
        "paths": "Pfad-Fehler früh erkennen",
        "planning": "Implementierungsplanung",
        "review": "Review vor Ausführung",
        "title": "PlanToCode nutzen für:"
      },
      "strength": "Cursor ist exzellent in dem, was es tut: blitzschnelle Code-Generierung, intelligentes Autocomplete und intuitive Chat-Interfaces. Aber es generiert Code sofort, was gleichzeitig seine Stärke und Schwäche ist.",
      "title": "Die Wendung: PlanToCode ist kein Ersatz"
    },
    "whenToUse": {
      "enterprise": {
        "cursor": "Cursor für einzelne Mitwirkende nutzen",
        "cursorDesc": "Entwickler nutzen Cursor täglich. Pläne von PlanToCode leiten ihre Arbeit.",
        "plan": "PlanToCode für Genehmigungs-Workflows nutzen",
        "planDesc": "Stakeholder überprüfen Pläne vor Ausführung. Audit-Trail für Compliance und Governance.",
        "title": "Team-Umgebungen & Enterprise"
      },
      "greenfield": {
        "cursor": "Cursor eigenständig nutzen",
        "cursorDesc": "Neue Projekte mit einfacher Struktur, wo Sie Fehler schnell erkennen können. Datei-Organisation ist noch nicht komplex.",
        "plan": "PlanToCode optional",
        "planDesc": "Nicht kritisch für kleine Projekte mit klarer Struktur.",
        "title": "Greenfield-Projekte & schnelle Prototypen"
      },
      "large": {
        "cursor": "Mit Cursor ausführen",
        "cursorDesc": "Genehmigten Plan in Cursor Agent einfügen. Lassen Sie es Code-Generierung mit klarem Kontext handhaben.",
        "plan": "Mit PlanToCode-Planung starten",
        "planDesc": "Datei-für-Datei-Plan generieren, falsche Pfade und Duplikate in Review-Phase erkennen.",
        "title": "Große/Legacy-Codebasen (50k+ LOC)"
      },
      "medium": {
        "cursor": "Cursor für Implementierung nutzen",
        "cursorDesc": "Noch schnell genug, um Änderungen manuell zu überprüfen. Gutes Autocomplete spart Zeit.",
        "plan": "PlanToCode für komplexe Tasks hinzufügen",
        "planDesc": "Planung für Refactoring, Multi-Package-Änderungen oder wenn Sie Pfad-Fehler erlebt haben.",
        "title": "Mittlere Codebasen (10k-50k LOC)"
      },
      "title": "Wann Cursor vs PlanToCode nutzen (Seite-an-Seite)"
    },
    "workflow": {
      "combined": "Kombinierter Workflow: Planen → Ausführen → Überprüfen",
      "example": {
        "title": "Echtes Beispiel: Authentication-System-Refactoring",
        "with": "Mit PlanToCode: Plan generieren, der alle 12 Dateien zeigt, die Änderungen benötigen. Erkennen, dass Cursors initialer Plan 3 API-Routes übersehen hat. Korrigierten Plan genehmigen. In Cursor einfügen. In 30 Minuten fertig, null Duplikate.",
        "without": "Ohne PlanToCode: Cursor bitten, \"Auth zu refactoren, um JWT statt Sessions zu nutzen.\" Cursor erstellt auth-new.ts, middleware/auth.ts (Duplikat), übersieht api/login.ts. 2 Stunden mit Reparatur verbringen."
      },
      "intro": "Der effektivste Workflow kombiniert beide Tools und nutzt jedes für das, was es am besten kann:",
      "step1": {
        "catch": "Was Sie erkennen: Falsche Dateipfade, doppelte Dateien, fehlende Dependencies, Scope-Creep",
        "description": "Beschreiben Sie Ihre Aufgabe (Sprache oder Text), führen Sie Datei-Erkennung aus, um alle betroffenen Dateien zu finden, generieren Sie Implementierungspläne von mehreren KI-Modellen (Claude, GPT, Gemini).",
        "title": "In PlanToCode planen"
      },
      "step2": {
        "description": "Plan im Monaco-Editor öffnen. Exakte Dateipfade mit Ihrer Repository-Struktur verifizieren. Nach Duplikaten suchen. Schritte bearbeiten, die Verfeinerung brauchen. Pläne von verschiedenen Modellen bei Bedarf zusammenführen.",
        "gate": "Sicherheits-Gate: Nichts passiert ohne Ihre explizite Genehmigung",
        "title": "Überprüfen & Genehmigen"
      },
      "step3": {
        "alternative": "Alternative: Direkt in PlanToCode's integriertem Terminal mit vollem Logging ausführen",
        "description": "Genehmigten Plan kopieren. In Cursor Agent Terminal oder Composer einfügen. Cursor hat jetzt vollständigen architektonischen Kontext - es weiß genau, welche Dateien zu ändern sind, was zu ändern ist und warum.",
        "title": "In Cursor ausführen"
      },
      "step4": {
        "description": "Cursor generiert den Code gemäß Ihrem genehmigten Plan. Überprüfen Sie die tatsächliche Implementierung. Da Sie die Architektur bereits genehmigt haben, prüfen Sie nur Code-Qualität - nicht strukturelle Fehler.",
        "saved": "Zeit gespart: Kein Duplikat-Datei-Cleanup, keine Pfad-Korrekturen, kein architektonisches Rework",
        "title": "Implementierung überprüfen"
      },
      "title": "Wie Cursor + PlanToCode zusammen nutzen"
    }
  },
  "demo": {
    "cta": {
      "button": "Alle Screenshots anzeigen",
      "description": "Erkunden Sie echte Screenshots aus tatsächlichen Workflows - Datei-Erkennung, Implementierungspläne, Terminal-Sessions und mehr.",
      "title": "Mehr sehen?"
    },
    "hero": {
      "screenshots": "Echte Screenshots ansehen",
      "subtitle": "Sehen Sie, wie PlanToCode Code-Änderungen plant und ausführt.",
      "title": "Interaktive Demo",
      "video": "Demo ansehen"
    },
    "meta": {
      "description": "Sehen Sie, wie PlanToCode Code-Änderungen plant und ausführt.",
      "title": "Interaktive Demo"
    }
  },
  "schedule": {
    "benefits": {
      "review": {
        "description": "Besprechen Sie die Integration mit Ihren bestehenden Claude Code-, Cursor- oder Aider-Workflows.",
        "title": "Architektur-Review"
      },
      "session": {
        "description": "Fokussierte Beratung zu den Anforderungen Ihres Teams und wie PlanToCode helfen kann.",
        "title": "30-Minuten-Session"
      },
      "team": {
        "description": "Erfahren Sie mehr über Enterprise-Features, Terminal-Governance und Deployment-Optionen.",
        "title": "Team-Lösungen"
      }
    },
    "footer": "Keine passende Zeit gefunden? Schreiben Sie uns an",
    "hero": {
      "subtitle": "Holen Sie sich Expertenberatung zur Nutzung von PlanToCode für die spezifischen Bedürfnisse Ihres Teams. Wir besprechen Architektur-Patterns, Integrations-Strategien und Deployment-Optionen.",
      "title": "Mit einem Architekten sprechen"
    },
    "meta": {
      "description": "Holen Sie sich Expertenberatung zur Nutzung von PlanToCode für die spezifischen Bedürfnisse Ihres Teams. Wir besprechen Architektur-Patterns, Integrations-Strategien und Deployment-Optionen.",
      "title": "Mit einem Architekten sprechen"
    },
    "topics": {
      "items": {
        "cost": "Kostenoptimierung für große Teams",
        "deployment": "On-Premise-Deployment-Anforderungen",
        "integration": "Integration mit bestehenden Claude Code/Cursor Workflows",
        "orchestration": "Terminal-Orchestrierung für CI/CD-Pipelines",
        "planning": "Multi-Modell-Planungs-Strategien für Legacy-Code",
        "security": "Sicherheits- & Compliance-Überlegungen"
      },
      "title": "Häufige Themen, die wir behandeln"
    }
  }
}