{
  "home": {
    "meta": {
      "title": "KI-Implementierungsplanung für sicheres Coding",
      "description": "KI-Implementierungsplanung für große Codebasen. Änderungen vor Ausführung prüfen. Bugs und Duplikate vermeiden. Integration mit Cursor, Copilot, Claude Code."
    }
  },
  "about": {
    "architecture": {
      "comment": "Entwickelt für komplexe Entwicklungs-Workflows, nicht für einfachen KI-Chat",
      "title": "Technisches Fundament"
    },
    "capabilities": {
      "automation": {
        "description": "Konfigurierbare Kopier-Buttons mit intelligenten Vorlagen. Wandeln Sie jeden Prompt in einen wiederverwendbaren Workflow mit Platzhalter-Substitution und Terminal-Integration um.",
        "title": "Workflow-Automatisierung"
      },
      "discovery": {
        "description": "Mehrstufiger Workflow: Root-Ordner-Auswahl, Regex-Pattern-Filterung, KI-Relevanz-Bewertung. Fokussierte Dateiauswahl mit Pfad-Validierung.",
        "title": "Intelligente Datei-Erkennung"
      },
      "planning": {
        "description": "Vollständiges Kontext-Laden ohne Truncation-Policy. Strukturierte XML-Pläne mit nummerierten Schritten. Multi-Modell-Generierung und architektonische Synthese.",
        "title": "Implementierungsplanung"
      },
      "synthesis": {
        "description": "Mehr als einfaches Zusammenführen - tiefgehende architektonische Analyse basierend auf SOLID-Prinzipien. Quell-Nachverfolgbarkeit mit [src:P1 step 2] Attribution für jede Entscheidung.",
        "title": "Architektonische Synthese"
      },
      "terminal": {
        "description": "PTY-Sessions mit 5-Sekunden-Health-Monitoring, automatischen Recovery-Aktionen und Agent-Attention-Detection. Sessions bleiben über App-Neustarts hinweg erhalten.",
        "title": "Job-zentriertes Terminal"
      },
      "title": "Kernfähigkeiten",
      "voice": {
        "description": "OpenAI gpt-4o-transcribe Integration für Terminal-Befehle. Selektionsbasierte Textverbesserung mit kontextbewusster Verarbeitung und Echtzeit-Job-Tracking.",
        "title": "Sprach- & Text-Integration"
      },
      "remote": {
        "description": "Pläne überprüfen und zusammenführen, Jobs, Payloads, Prompts und Metadaten inspizieren; Modelle und Parameter ändern, System-Prompt überprüfen und Terminal über Device-Link öffnen — ohne SSH-Ports freizugeben.",
        "title": "Fernsteuerung (iOS)"
      }
    },
    "company": {
      "contact": "Kontakt",
      "jurisdiction": "Deutschland",
      "name": "helpful bits GmbH",
      "title": "Firmeninformationen"
    },
    "hero": {
      "subtitle": "PlanToCode hilft Entwicklern, Code-Änderungen zu planen und zu deployen, indem es betroffene Dateien findet, Pläne generiert und zusammenführt und diese in einem Terminal ausführt.",
      "title": "Über PlanToCode"
    },
    "meta": {
      "description": "KI-Entwicklungsplanung mit Multi-Modell-Integration, persistenten Terminals, Sprach-Transkription und architektonischer Synthese.",
      "title": "Über PlanToCode - KI-Entwicklungsplanungstool"
    },
    "philosophy": {
      "noTruncation": {
        "description": "Wir laden vollständige Dateiinhalte. Kein präventives Kürzen - nur intelligente Warnungen. Sie erhalten den vollständigen Kontext, der für ernsthafte Entwicklungsarbeit nötig ist.",
        "title": "Keine Truncation-Policy"
      },
      "title": "Unsere Philosophie",
      "tooling": {
        "description": "Monaco-Editor, xterm.js, ordentliche Entwicklungsumgebungs-Integration. Nicht nur eine weitere Chat-Schnittstelle - eine vollständige Entwicklungsplanungs-Plattform.",
        "title": "Professionelle Werkzeuge"
      },
      "traceability": {
        "description": "Jede KI-Entscheidung enthält Quell-Attribution. Vollständige Audit-Trails, Kostentracking und Session-Persistenz. Sie wissen genau, was passiert ist und warum.",
        "title": "Vollständige Nachverfolgbarkeit"
      },
      "transparency": {
        "description": "Lokale Speicherung, transparente KI-Provider-Kommunikation und volle Kontrolle über das, was gesendet wird. Sie sehen den Kontext immer, bevor Sie API-Aufrufe bestätigen.",
        "title": "Transparenz & Kontrolle"
      }
    },
    "whatWeBuilt": {
      "environment": {
        "description": "Monaco-Editor-Integration, persistente Terminal-Sessions mit Health-Monitoring, Sprach-Transkription und 5MB SQLite Ring-Buffer. Entwickelt für echte Entwicklungs-Workflows.",
        "title": "Professionelle Entwicklungsumgebung"
      },
      "intro": "PlanToCode ist eine umfassende Entwicklungsplanungsumgebung, die für ernsthaftes Development konzipiert wurde, bei dem Kontext, Nachverfolgbarkeit und professionelle Werkzeuge wichtiger sind als schnelle KI-Interaktionen. Wir haben ein System für komplexe, mehrstufige Implementierungen entwickelt, bei denen traditionelle KI-Tools zu kurz greifen.",
      "multiModel": {
        "description": "Integration mit GPT-5.2, Claude Sonnet 4 und Gemini 3 Pro. Nicht nur API-Aufrufe - intelligente Orchestrierung mit projektspezifischen Konfigurationen, Echtzeit-Streaming und vollständiger Nachverfolgbarkeit.",
        "title": "Multi-Modell-Intelligenz"
      },
      "title": "Was wir gebaut haben"
    }
  },
  "changelog": {
    "meta": {
      "title": "Changelog - Neueste Updates",
      "description": "Neueste Funktionen und Verbesserungen in PlanToCode. Updates zur Multi‑Modell‑Planung für Claude Code, Cursor und OpenAI Codex Integration."
    }
  },
  "compare": {
    "meta": {
      "title": "KI‑Coding‑Tools vergleichen | PlanToCode vs. Alternativen",
      "description": "Vergleich mit Cursor, Windsurf, Claude Code, Aider u. a. Finden Sie das passende Tool für Ihren Workflow."
    }
  },
  "screenshots": {
    "title": "PlanToCode Screenshots",
    "description": "See PlanToCode in action with real screenshots from actual workflows."
  },
  "downloads": {
    "cta": {
      "architect": "Mit einem Experten sprechen",
      "docs": "Terminal-Dokumentation",
      "footer": "Made in Germany • DSGVO-konform • Lokale Session-Speicherung",
      "professional": "Professional-Optionen",
      "title": "Bereit für den nächsten Schritt?"
    },
    "hero": {
      "subtitle": "Code-Änderungen mit einem Tool planen - relevante Dateien finden, Pläne generieren und zusammenführen, Befehle in einem persistenten Terminal ausführen.",
      "title": "PlanToCode herunterladen"
    },
    "macos": {
      "professional": {
        "description": "Vollständig von Apple notarisiert. Code-signiert. Integriertes Terminal mit CLI-Autoerkennung und Session-Persistenz.",
        "title": "Professional Ready"
      },
      "requirements": {
        "internet": "Internetverbindung für KI-Features erforderlich",
        "os": "macOS 11.0 (Big Sur) oder neuer",
        "processor": "Apple Silicon (M1/M2/M3/M4) Prozessor",
        "ram": "4GB RAM mindestens (8GB empfohlen)",
        "title": "Systemanforderungen"
      },
      "subtitle": "Für Heavy Coding-Agent-Nutzer",
      "title": "macOS"
    },
    "meta": {
      "description": "PlanToCode für macOS und Windows herunterladen. Kostenlose 5$ Guthaben. Planen Sie Multi-Datei-Änderungen mit KI, prüfen Sie vor der Ausführung. Keine Kreditkarte erforderlich.",
      "title": "PlanToCode herunterladen - macOS & Windows | Kostenlose Testversion"
    },
    "mobile": {
      "button": "Im App Store herunterladen",
      "connected": {
        "description": "Steuern Sie Ihre Desktop-PlanToCode-Sessions remote. Pläne überprüfen, Terminals verwalten und unterwegs produktiv bleiben.",
        "title": "Fernsteuerung"
      },
      "features": {
        "design": "Native iOS/iPadOS Design-Sprache",
        "monitor": "Terminal-Sessions remote überwachen",
        "review": "Implementierungspläne unterwegs überprüfen und bearbeiten",
        "sync": "Nahtlose Synchronisation mit Desktop-Workspace",
        "title": "Features",
        "voice": "Sprach-Transkription für schnelle Ideenerfassung"
      },
      "subtitle": "Fernsteuerung für iPhone & iPad",
      "title": "iOS Mobile App"
    },
    "trust": {
      "planning": {
        "description": "GPT-5.2, Claude Sonnet 4, Gemini 3 Pro, o3/o4-mini, Grok 4, DeepSeek R1, Kimi K2. Council of LLMs Ansatz.",
        "title": "Multi-Modell-Planung"
      },
      "pricing": {
        "description": "Sofort loslegen. Pay-as-you-go. Keine Abonnements. Token-Transparenz für Power-User, die Kosten verfolgen.",
        "title": "Nutzungsbasierte Preise"
      },
      "professional": {
        "description": "Single-Tenant-Server. On-Prem-Deployment. Terminal-Governance. Entwickelt für Teams, die nicht Cloud-Only nutzen können.",
        "title": "Professional-Optionen"
      },
      "terminal": {
        "description": "Führen Sie claude, cursor, codex oder gemini direkt aus. Sprach-Transkription ist verfügbar, und Logs werden lokal gespeichert, sodass Sie die Arbeit ohne Kontextwechsel fortsetzen können.",
        "title": "Integriertes Terminal"
      },
      "title": "Entwickelt für Heavy Coding-Agent-Nutzer"
    },
    "windows": {
      "integration": {
        "description": "PowerShell und Eingabeaufforderung unterstützt. Führen Sie claude, cursor, codex oder gemini mit Health-Monitoring und Recovery aus.",
        "title": "Terminal-Integration"
      },
      "requirements": {
        "internet": "Internetverbindung für KI-Features erforderlich",
        "os1": "Windows 10 Version 1903 (Build 18362) oder neuer",
        "os2": "Windows 11 unterstützt",
        "processor": "x64 oder ARM64 Prozessor",
        "ram": "4GB RAM mindestens (8GB empfohlen)",
        "title": "Systemanforderungen"
      },
      "subtitle": "Microsoft Store - Professional Ready",
      "title": "Windows"
    }
  },
  "planMode": {
    "capabilities": {
      "architect": {
        "capability": "KI-Architekt führt Pläne mit Ihrer Anleitung zusammen",
        "details": "Leiten Sie das Zusammenführen mit Ihren architektonischen Anforderungen. KI konsolidiert komplementäre Details aus mehreren Runs in einen umfassenden Plan"
      },
      "execution": {
        "capability": "Ausführung mit voller Kontrolle",
        "details": "Plan überprüfen, Scope verifizieren, dann ausführen. Oder in den Chat Ihrer IDE einfügen."
      },
      "know": {
        "capability": "Wissen Sie, was geändert wird, bevor es passiert",
        "details": "Datei-Erkennung zeigt exakten Impact. Sehen Sie, welche Dateien jeder Plan berührt. Keine Überraschungen.",
        "link": "Sehen Sie, wie es funktioniert"
      },
      "prompts": {
        "capability": "Ein-Klick-Prompts, die funktionieren",
        "details": "Kopier-Buttons für Ihre kampferprobten Prompts. Kein erneutes Eintippen von \"mach es type-safe\" 20 Mal mehr."
      },
      "title": "Was Sie tatsächlich bekommen"
    },
    "circumstances": {
      "footer": "Das sind keine \"Pain Points\". Das sind Momente, wo Sie Sichtbarkeit und Kontrolle brauchen, bevor Sie sich auf einen Ansatz festlegen. Das haben wir gebaut.",
      "items": {
        "breaks": {
          "moment": "Ihre Änderung bricht drei Downstream-Services, in Prod entdeckt",
          "progress": "Datei-Erkennung mappt alle Dependencies im Voraus, erkennt Impacts früh"
        },
        "drift": {
          "moment": "KI driftet von Ihren Anforderungen ab, baut, was es denkt, dass Sie wollen",
          "progress": "KI-Architekt hält Pläne an Ihren tatsächlichen Zielen ausgerichtet, kein Drift"
        },
        "plans": {
          "moment": "Ein Plan erkennt Grenzfälle, ein anderer handhabt Error-States, ein dritter fügt Types hinzu",
          "progress": "KI-Architekt kombiniert komplementäre Einsichten in vollständige Implementierung"
        },
        "symptom": {
          "moment": "KI behebt das Symptom in /components, übersieht die Ursache in /config",
          "progress": "Leiten Sie es mit Datei-Erkennung zur richtigen Abstraktionsebene"
        }
      },
      "title": "Wenn KI architektonischen Kontext braucht"
    },
    "cta": {
      "book": "Architekten-Session buchen",
      "demo": "Interaktive Demo zuerst ausprobieren",
      "pricing": "Pay-as-you-go Credits. $5 kostenlose Promo für neue Nutzer. Keine Abonnements.",
      "subtitle": "Treten Sie Entwicklern bei, die große Änderungen mit Klarheit, Nachverfolgbarkeit und operationeller Zuverlässigkeit shippen.",
      "title": "Bereit, Ihren Architekten einzustellen?"
    },
    "faq": {
      "q1": {
        "answer": "PlanToCode bietet architektonische Vor-Planung **bevor** Sie Codex, Claude Code oder Cursor nutzen. Es fügt Datei-Erkennung, Multi-Modell-Synthese und Merge-Anweisungen hinzu, die die Ausführungs-Phase dieser Tools ergänzen.",
        "question": "Wie unterscheidet sich das von Codex CLI oder Claude Code?"
      },
      "q2": {
        "answer": "Ja. PlanToCode arbeitet neben Codex CLI, Claude Code, Cursor und Windsurf. Generieren Sie Pläne in PlanToCode, führen Sie dann in Ihrem bevorzugten Tool mit vollem Kontext aus.",
        "question": "Kann ich das mit meinem bestehenden KI-Coding-Tool nutzen?"
      },
      "q3": {
        "answer": "Führen Sie dieselbe Aufgabe mehrmals mit verschiedenen KI-Modellen aus. Jeder Run liefert verschiedene Implementierungs-Details. PlanToCode führt sie in einen umfassenden Plan mit Quell-Attribution zusammen.",
        "question": "Was bedeutet Multi-Modell-Synthese?"
      },
      "title": "Häufig gestellte Fragen"
    },
    "hero": {
      "badge": "Für Entwickler, die vor dem Ausführen überprüfen",
      "credits": "$5 kostenlose Credits • Pay-as-you-go • Funktioniert mit jedem KI-Coding-Tool",
      "guidance": "Sehen Sie den vollen Scope, leiten Sie es zu den richtigen Dateien, wählen Sie den Ansatz, der zu Ihrem System passt.",
      "insight": "Die neuesten, fortschrittlichsten Modelle sind brillant im Code, blind für Architektur.",
      "install": "PlanToCode installieren",
      "subtitle": "Sie können sich unmöglich an jeden Webhook, Cache, Background-Job und API-Consumer erinnern, der von dieser einen Funktion abhängt. So schleichen sich Regressionen ein.",
      "title": "Architektonische Planung für Codex CLI, Claude Code & Cursor"
    },
    "integrations": {
      "claude": {
        "description": "Claude Codes nativen Plan-Mode mit Multi-Modell-Synthese, Datei-Erkennung und Merge-Anweisungen erweitern.",
        "link": "Claude Code Planungs-Workflow-Guide öffnen",
        "title": "Claude Code Planungs-Workflow"
      },
      "codex": {
        "description": "Jede Dependency mappen, Multi-Modell-Pläne zusammenführen, dann mit Codex-Genehmigungs-Modi für sichere Iteration ausführen.",
        "link": "Codex CLI Planungs-Workflow-Guide öffnen",
        "title": "Codex CLI Planungs-Workflow"
      },
      "cursor": {
        "description": "Cursor Composer und Agent-Mode vollständigen architektonischen Kontext mit WSL-freundlichen Ausführungs-Guardrails geben.",
        "link": "Cursor Planungs-Workflow-Guide öffnen",
        "title": "Cursor Planungs-Workflow"
      },
      "title": "Wählen Sie Ihren CLI-Planungs-Workflow"
    },
    "meta": {
      "description": "Software-Änderungen planen, bevor Sie coden. Datei-für-Datei-Implementierungs-Specs generieren, mit Ihrem Team überprüfen, dann mit voller Sichtbarkeit und Governance ausführen.",
      "title": "Planen Sie, bevor Sie coden - Prüfbare Specs"
    },
    "progress": {
      "execute": {
        "description": "Exakten Scope vor Ausführung sehen. Integriertes Terminal oder in Ihre IDE einfügen",
        "title": "Mit voller Sichtbarkeit ausführen"
      },
      "guide": {
        "description": "Sagen Sie der KI, was Sie mögen, was Sie vermeiden sollten. Sie folgt Ihren architektonischen Entscheidungen überraschend gut",
        "title": "Zusammenführungen mit Ihrer Expertise leiten"
      },
      "quote": "KI generiert den Code. Sie architektonieren die Lösung.",
      "ship": {
        "description": "KI-Architekt führt komplementäre Einsichten aus mehreren Plänen in vollständige Implementierung zusammen",
        "title": "Komplexe Features mit Vertrauen shippen"
      },
      "title": "Der Fortschritt, den Sie tatsächlich machen"
    },
    "users": {
      "cli": {
        "quote": "Mein CLI-Agent würde Grenzfälle übersehen oder bestehende Features brechen. Jetzt erkennt der KI-Architekt Lücken und Regressionen in Plänen, bevor sie meine Codebasis treffen.",
        "title": "CLI-Agent-Nutzer"
      },
      "ide": {
        "quote": "IDE-Agents fehlt architektonischer Kontext. Jetzt plant mein KI-Architekt den richtigen Ansatz im Voraus, berücksichtigt alle System-Impacts. Dann füge ich den validierten Plan in Cursor ein.",
        "title": "Cursor & Windsurf Nutzer"
      },
      "senior": {
        "quote": "KI behob ständig Symptome, nicht Ursachen. Jetzt leite ich es zuerst zur richtigen Abstraktionsebene. Datei-Erkennung zeigt die echte Architektur, bevor Code geschrieben wird.",
        "title": "Senior-Engineers"
      },
      "title": "Wer nutzt das"
    },
    "whyNow": {
      "ide": {
        "detail": "Beliebte KI-Coding-Tools sind brilliant auf Mikro-Ebene. Sie brauchen etwas, das das Makro sieht.",
        "reason": "Jede IDE hat jetzt KI"
      },
      "models": {
        "detail": "Moderne Modelle sind fähig. Aber sie kennen **Ihre** Architektur, **Ihre** Patterns, **Ihre** Constraints nicht.",
        "reason": "KI-Modelle schreiben exzellenten Code"
      },
      "systems": {
        "detail": "User-Service ändern, Mobile-App brechen. Dieses Interface aktualisieren, drei Microservices beeinflussen. KI sieht diese Verbindungen nicht.",
        "reason": "Codebasen sind vernetzte Systeme"
      },
      "title": "Warum das jetzt wichtig ist"
    },
    "workflow": {
      "discovery": {
        "description": "Mehrstufiger Workflow bringt die richtigen Dateien ans Licht, bevor Sie planen",
        "step": "Datei-Erkennung"
      },
      "execute": {
        "description": "Im Terminal ausführen oder in Ihr KI-Coding-Tool einfügen",
        "step": "Ausführen"
      },
      "generate": {
        "description": "Mehrere Modelle mit verschiedenen Perspektiven und Token-Guardrails ausführen",
        "step": "Pläne generieren"
      },
      "link": "Detaillierten Workflow sehen",
      "merge": {
        "description": "Merge-Anweisungen bereitstellen, KI konsolidiert komplementäre Details aus mehreren Runs",
        "step": "KI führt zusammen + Sie leiten"
      },
      "title": "Wie es funktioniert"
    }
  },
  "howItWorks": {
    "cta": {
      "links": {
        "demo": "Interaktive Demo ausprobieren",
        "docs": "Dokumentation anzeigen",
        "planning": "Über Plan-Bearbeitung lernen"
      },
      "subtitle": "Von Meeting-Erfassung bis zur sicheren Ausführung - der komplette Workflow für Corporate-Teams, die KI-Coding-Agents selbstbewusst einsetzen. Anforderungen aus jeder Quelle erfassen, mit KI verfeinern, granulare Pläne generieren, mit voller Kontrolle überprüfen und sicher ausführen.",
      "title": "Bereit, Ihren Corporate-Entwicklungs-Workflow zu transformieren?"
    },
    "demo": {
      "button": "Interaktive Demo ausprobieren",
      "description": "Sehen Sie die interaktive Demo, um den kompletten Workflow zu erleben",
      "title": "In Aktion sehen"
    },
    "hero": {
      "badge": "Professioneller KI-Planungs-Workflow",
      "subtitle": "Von Meeting-Erfassung bis zur sicheren Ausführung - der komplette Corporate-KI-Entwicklungs-Workflow",
      "title": "Wie es funktioniert"
    },
    "keyFeatures": {
      "deploy": {
        "description": "Nutzen Sie den mitgelieferten Rust-Proxy-Server mit Ihren eigenen API-Keys, wenn Sie Requests auf Ihrer kontrollierten Infrastruktur halten müssen.",
        "title": "Nach Ihren Bedingungen deployen"
      },
      "governance": {
        "description": "Jeden Plan vor Ausführung überprüfen. Ansätze bearbeiten, Strategien zusammenführen, genehmigen oder ablehnen. KI assistiert, Menschen kontrollieren. Entwickelt für Teams, bei denen Code-Qualität zählt.",
        "title": "Human-in-the-Loop-Governance"
      },
      "sessions": {
        "description": "Terminal-Output wird lokal gespeichert und Sessions werden beim Start wiederhergestellt. App schließen, nächste Woche wiederkommen, Debugging fortsetzen.",
        "title": "Persistente Sessions"
      },
      "title": "Warum Corporate-Teams diesen Workflow wählen"
    },
    "meta": {
      "description": "KI-Implementierungsplanung verhindert Chaos. Datei-Erkennung, Multi-Modell-Pläne, menschliche Überprüfung und sichere Ausführung mit jedem Coding-Agent.",
      "title": "Wie es funktioniert - KI-Planungs-Workflow"
    },
    "useCases": {
      "bugs": {
        "description": "Screen-Captures von Bugs aufzeichnen, KI-Analyse erhalten, Debugging-Pläne generieren, mit voller Terminal-Kontrolle ausführen.",
        "items": {
          "persistent": "Persistentes Terminal-Log",
          "systematic": "Systematische Debugging-Ansätze",
          "visual": "Visueller Kontext mit Screen-Recording"
        },
        "title": "Komplexe Bug-Untersuchung"
      },
      "features": {
        "description": "Multi-Datei-Features, die sorgfältige Planung erfordern. Generieren Sie mehrere Ansätze, führen Sie die besten Teile zusammen, bearbeiten Sie für Ihre spezifische Codebasis.",
        "items": {
          "api": "API-Design und Integration",
          "cross": "Cross-Component-Feature-Implementierung",
          "schema": "Datenbank-Schema-Änderungen"
        },
        "title": "Große Feature-Entwicklung"
      },
      "legacy": {
        "description": "KI versteht Legacy-Patterns und technische Schulden. Generieren Sie sichere Refactoring-Pläne, Library-Upgrades und architektonische Verbesserungen.",
        "items": {
          "breaking": "Breaking-Change-Migrations-Pläne",
          "cleanup": "Technische-Schulden-Cleanup",
          "dependency": "Dependency-Upgrade-Strategien"
        },
        "title": "Legacy-Codebasis-Wartung"
      },
      "professional": {
        "description": "Befehlsgenehmigungen, Session-Retention, Single-Tenant-Deployment. Entwickelt für Teams, bei denen ein falscher Befehl Millionen kostet.",
        "items": {
          "audit": "Vollständige Audit-Trails",
          "governance": "Terminal-Governance und Genehmigungen",
          "onprem": "On-Premise-Deployment-Optionen"
        },
        "title": "Professionelle Entwicklung"
      },
      "title": "Entwickelt für Corporate-Entwicklungsteams"
    },
    "workflow": {
      "step1": {
        "description": "Beginnen Sie mit der Erfassung von Anforderungen aus mehreren Quellen. Laden Sie Microsoft Teams Meeting-Aufzeichnungen für multimodale Analyse hoch, zeichnen Sie Screen-Präsentationen auf, um visuellen Kontext zu erfassen, oder nutzen Sie Sprach-Diktat für schnelle Ideenerfassung. Alle Eingabemethoden führen in denselben Verfeinerungs-Workflow.",
        "meetings": {
          "description": "Teams-Meetings hochladen. Multimodale KI analysiert Audio-Transkripte (mit Sprecher-Identifikation) und visuellen Inhalt (geteilte Bildschirme, Dokumente), um Anforderungen, Entscheidungen und Aktionspunkte zu extrahieren.",
          "title": "Meeting-Aufzeichnungen"
        },
        "screen": {
          "description": "Workflows, Bugs oder UI-Präsentationen aufzeichnen. Gemini Vision analysiert sowohl Audio-Narration als auch visuellen Inhalt, um vollständigen Kontext für Requirements-Gathering zu erfassen.",
          "title": "Screen-Aufzeichnungen"
        },
        "subtitle": "Meeting-Aufzeichnungen, Screen-Captures und Sprach-Diktat",
        "title": "Ideen & Kontext erfassen",
        "voice": {
          "description": "Anforderungen natürlich sprechen. OpenAI gpt-4o-transcribe transkribiert mit intelligenter Text-Insertion und Sprecher-Identifikation für schnelle Spezifikations-Erfassung.",
          "title": "Sprach-Diktat"
        }
      },
      "step2": {
        "description": "Verwandeln Sie rohe Meeting-Transkripte, Sprachaufnahmen und grobe Notizen in klare, implementierungsbereite Spezifikationen mithilfe zweier unterschiedlicher KI-Prompt-Typen, die zusammenarbeiten, um sowohl Klarheit als auch Vollständigkeit zu gewährleisten.",
        "subtitle": "Zwei KI-Prompt-Typen für Klarheit und Vollständigkeit",
        "taskRefinement": {
          "description": "Erweitert Aufgabenbeschreibungen durch Identifikation impliziter Anforderungen, Füllung übersehener Lücken, Klärung erwarteten Verhaltens und Grenzfällen sowie Hinzufügung technischer Überlegungen für Implementierungsbereitschaft.",
          "title": "Aufgaben-Verfeinerung"
        },
        "textEnhancement": {
          "description": "Verbessert Grammatik, Satzstruktur, Klarheit und Prägnanz, während Ihre ursprüngliche Absicht, Ton und technisches Detail-Niveau beibehalten werden. Perfekt zum Polieren von Sprach-Transkripten und Meeting-Notizen.",
          "title": "Text-Verbesserung"
        },
        "title": "In umsetzbare Spezifikationen verfeinern"
      },
      "step3": {
        "description": "KI-Datei-Erkennung identifiziert relevante Dateien in Ihrer Codebasis. Mehrere KI-Modelle generieren Implementierungspläne mit Datei-für-Datei-Granularität - exakte Dateipfade, spezifische Zeilenbereiche und klare Operations-Typen (modify/create/delete). Diese Granularität macht Impact-Assessment kristallklar.",
        "features": {
          "dependencies": "Dependency-Analyse und Impact-Assessment",
          "models": "Multi-Modell-Support (GPT-5.2, Claude 4, Gemini 3 Pro)",
          "multiple": "Mehrfach-Plan-Generierung für Ansatz-Vergleich",
          "operations": "Klare Operations-Typen (modify, create, delete)",
          "paths": "Exakte Dateipfade aus Ihrer Repository-Struktur",
          "ranges": "Spezifische Zeilenbereiche und Änderungs-Details"
        },
        "subtitle": "Datei-für-Datei-Pläne mit exakten Repository-Pfaden",
        "title": "Granulare Implementierungspläne generieren"
      },
      "step4": {
        "capabilities": {
          "approve": "Zur Ausführung genehmigen oder mit Audit-Trail ablehnen",
          "editing": "Direkte Bearbeitung aller Plan-Schritte und Details",
          "editor": "Professioneller Monaco-Editor mit Syntax-Highlighting",
          "merge": "Mehrere Pläne mit benutzerdefinierten Anweisungen zusammenführen",
          "modifications": "Änderungen oder alternative Ansätze anfordern",
          "visibility": "Vollständige Sichtbarkeit der vorgeschlagenen Änderungen"
        },
        "description": "Pläne öffnen sich im Monaco-Editor für umfassende Überprüfung. Team-Leads prüfen jede vorgeschlagene Änderung, bearbeiten Schritte direkt, führen mehrere Ansätze mit benutzerdefinierten Anweisungen zusammen oder lehnen Pläne vollständig ab. Keine Code-Änderungen erfolgen ohne explizite menschliche Genehmigung - dies gewährleistet Übereinstimmung mit Corporate-Anforderungen und Team-Workflows.",
        "subtitle": "Volle Kontrolle vor Code-Änderungen",
        "title": "Überprüfen, Bearbeiten & Genehmigen (Human-in-the-Loop)"
      },
      "step5": {
        "description": "Nach Genehmigung übertragen Sie den Plan sicher an Ihren gewählten Coding-Agent (Claude Code, Cursor, Codex) oder zugewiesenen Software-Entwickler. Datei-für-Datei-Granularität verhindert Regressionen und unbeabsichtigte Änderungen - gewährleistet sichere Ausführung. Integriertes Terminal mit persistenten Sessions ermöglicht sofortige Ausführung und Debugging.",
        "subtitle": "Sichere Übergabe an Entwickler oder Coding-Agents",
        "title": "Mit Vertrauen ausführen",
        "tools": {
          "audit": "Vollständiger Audit-Trail der Ausführung",
          "claude": "Claude Code CLI mit Plan-Mode-Support",
          "codex": "OpenAI Codex CLI Ausführung",
          "cursor": "Cursor CLI Integration",
          "sessions": "Persistente Terminal-Sessions mit Auto-Recovery",
          "terminal": "Integriertes Terminal mit Sprach-Transkription"
        }
      },
      "title": "Der komplette Workflow"
    }
  },
  "all-pages": {
    "meta": {
      "title": "Alle Seiten - pSEO‑Überblick",
      "description": "Interne Übersichtsseite für alle programmatischen SEO‑Seiten"
    }
  },
  "workflows": {
    "hub": {
      "badge": "KI-Entwicklungs-Workflows",
      "card": {
        "solves": "Löst:",
        "viewLink": "Workflow ansehen"
      },
      "cta": {
        "downloadLink": "PlanToCode herunterladen",
        "subtitle": "Beginnen Sie mit Datei-Erkennung, generieren Sie umfassende Pläne und führen Sie mit Vertrauen aus.",
        "title": "Bereit, Ihren Entwicklungs-Workflow zu transformieren?"
      },
      "description": "Entdecken Sie bewährte Workflows für komplexe Entwicklungsaufgaben. Jeder Workflow kombiniert Datei-Erkennung, Multi-Modell-Planung und integrierte Terminal-Ausführung, um echte Engineering-Herausforderungen zu lösen.",
      "meta": {
        "description": "KI-Entwicklungs-Workflows für komplexe Aufgaben. Integration mit Claude Code, Cursor, Codex für Refactorings, Bug-Triage und Migrationen.",
        "title": "KI-Coding-Workflows - PlanToCode-Integrationsmuster"
      },
      "title": "KI-Powered Entwicklungs-Workflows",
      "toolCategories": {
        "claudeCode": "Claude Code Workflows",
        "codexCli": "Codex CLI Workflows",
        "cursor": "Cursor Workflows",
        "general": "Allgemeine Workflows"
      }
    }
  },
  "blog": {
    "hub": {
      "meta": {
        "title": "Blog - Einblicke in KI‑Code‑Planung | PlanToCode",
        "description": "Einblicke in KI‑gestützte Code‑Planung und Entwicklungs‑Workflows."
      }
    },
    "ai-code-planning-best-practices": {
      "meta": {
        "title": "Best Practices der KI‑Code‑Planung 2025 – Workflow‑Guide",
        "description": "Bewährte Verfahren: Multi‑Modell‑Planung, Abhängigkeits‑Mapping, Review‑Checklisten, Team‑Workflows für Produktionscodebasen."
      }
    },
    "github-copilot-alternatives-2025": {
      "meta": {
        "title": "GitHub Copilot Alternativen 2025 | Beste Optionen",
        "description": "Umfassender Vergleich: Cursor, Windsurf, Codeium, Tabnine, PlanToCode, Aider. Preise, Funktionen, beste Wahl fürs Team."
      }
    },
    "best-ai-coding-assistants-2025": {
      "meta": {
        "title": "Beste KI-Coding-Assistenten 2025 - Vollständiger Leitfaden",
        "description": "Umfassender Vergleich von 15+ KI-Coding-Tools einschließlich Cursor, GitHub Copilot, Windsurf und PlanToCode. Erfahren Sie, welche Tools bei Code-Generierung vs. Implementierungsplanung glänzen."
      }
    },
    "ai-pair-programming-vs-ai-planning": {
      "meta": {
        "title": "KI-Pair-Programming vs. Planung - Team-Leitfaden",
        "description": "Vergleichen Sie KI-Pair-Programming (Copilot, Cursor) mit KI-Planung (PlanToCode). Wann welcher Ansatz für Produktions-Codebasen, Teams und komplexe Refactorings zu verwenden ist."
      }
    },
    "what-is-ai-code-planning": {
      "meta": {
        "title": "Was ist KI-Code-Planung? Entwickler-Leitfaden",
        "description": "Was KI-Code-Planung ist, warum sie für große Codebasen wichtig ist, wie planungsorientierte Entwicklung KI-Coding-Chaos verhindert."
      }
    }
  },
  "comparisons": {
    "hub": {
      "badge": "Tool-Vergleiche",
      "card": {
        "badge": "Vergleich",
        "viewLink": "Vergleich ansehen",
        "whySwitchLabel": "Warum Entwickler wechseln:"
      },
      "cta": {
        "button": "PlanToCode kostenlos ausprobieren",
        "footer": "$5 kostenlose Credits • Keine Kreditkarte erforderlich",
        "subtitle": "Sehen Sie, warum Entwickler zu PlanToCode für komplexe, mission-kritische Arbeit wechseln.",
        "title": "Erleben Sie den Unterschied"
      },
      "cursorNote": {
        "link": "Erfahren Sie, wie PlanToCode Cursor ergänzt →",
        "strong": "Suchen Sie nach einer Cursor-Alternative?",
        "text": "PlanToCode arbeitet MIT Cursor zusammen, nicht statt es."
      },
      "description": "Sehen Sie, wie PlanToCodes architektonischer Planungsansatz sich mit traditionellen Terminal-Tools, KI-Coding-Assistenten und anderen Entwicklungs-Workflows vergleicht.",
      "meta": {
        "description": "Vergleichen Sie PlanToCode mit tmux, script, asciinema, Cursor, Claude Code und anderen Entwicklungs-Tools. Sehen Sie, wie architektonische Planung Ihren Workflow verbessert.",
        "title": "PlanToCode vs Alternativen - Feature-Vergleiche"
      },
      "title": "PlanToCode vs Alternativen",
      "whatMakesDifferent": {
        "architectural": {
          "description": "Mehrstufige Datei-Erkennung mappt Ihre gesamte Codebasis-Architektur, bevor Änderungen gemacht werden. Die meisten Tools sehen nur, was Sie ihnen zeigen.",
          "title": "Architektonisches Bewusstsein"
        },
        "humanInLoop": {
          "description": "Überprüfen, bearbeiten und genehmigen Sie jeden Plan vor Ausführung. Persistente Terminal-Sessions ermöglichen es Ihnen, jederzeit zu pausieren, zu untersuchen und fortzufahren.",
          "title": "Human-in-the-Loop"
        },
        "multiModel": {
          "description": "Generieren Sie Pläne von mehreren KI-Modellen (GPT-5.2, Claude 4.5, Gemini 3 Pro) und führen Sie die besten Erkenntnisse zusammen. Single-Modell-Tools verpassen Perspektiven.",
          "title": "Multi-Modell-Planung"
        },
        "title": "Was PlanToCode unterschiedlich macht"
      }
    }
  },
  "cursorAlternative": {
    "comparison": {
      "intro": "Das ist kein wettbewerblicher Vergleich - es zeigt, wie die Tools sich ergänzen:",
      "table": {
        "approval": {
          "cursor": "Nicht eingebaut",
          "name": "Team-Genehmigungs-Workflows",
          "plan": "Vollständiger Audit-Trail",
          "together": "In PlanToCode genehmigen, in Cursor implementieren"
        },
        "autocomplete": {
          "cursor": "Branchenführend",
          "name": "Autocomplete & IntelliSense",
          "plan": "Nicht enthalten",
          "together": "Cursor handhabt Autocomplete"
        },
        "capability": "Fähigkeit",
        "chat": {
          "cursor": "Exzellente UX",
          "name": "Chat-Interface",
          "plan": "Aufgabenbasierte UI",
          "together": "Cursors Chat fühlt sich natürlich an"
        },
        "cursor": "Cursor",
        "discovery": {
          "cursor": "Basis-Indexierung",
          "name": "Datei-Erkennung & Analyse",
          "plan": "Fortgeschrittener Workflow",
          "together": "PlanToCode findet Dateien, Cursor ändert sie"
        },
        "duplicates": {
          "cursor": "Nicht eingebaut",
          "name": "Duplikat-Datei-Prävention",
          "plan": "In Review erkannt",
          "together": "PlanToCode verhindert, Cursor führt korrekt aus"
        },
        "multiModel": {
          "cursor": "Ein Modell pro Request",
          "name": "Multi-Modell-Synthese",
          "plan": "Modelle vergleichen & zusammenführen",
          "together": "Bester Plan von mehreren Modellen → Cursor"
        },
        "planning": {
          "cursor": "Nicht verfügbar",
          "name": "Implementierungsplanung",
          "plan": "Kern-Feature",
          "together": "PlanToCode leitet Cursor"
        },
        "plantocode": "PlanToCode",
        "pricing": {
          "cursor": "$20/Monat Abo",
          "name": "Preismodell",
          "plan": "Pay-as-you-go (kein Abo)",
          "together": "$20/Monat + tatsächliche Nutzung ($5-15 typisch)"
        },
        "review": {
          "cursor": "Manuell via Chat",
          "name": "Pre-Execution-Review",
          "plan": "Eingebauter Workflow",
          "together": "Review in PlanToCode, Ausführung in Cursor"
        },
        "speed": {
          "cursor": "Exzellent",
          "name": "Code-Generierungs-Geschwindigkeit",
          "plan": "Nicht enthalten",
          "together": "Cursor handhabt Generierung"
        },
        "together": "Besser zusammen"
      },
      "title": "Feature-Vergleich: Komplementäre Stärken"
    },
    "faq": {
      "q1": {
        "answer": "Nein, PlanToCode ist kein Cursor-Ersatz. Es ist ein komplementäres Tool, das neben Cursor arbeitet. Während Cursor bei Code-Generierung und Autocomplete glänzt, fügt PlanToCode eine Sicherheitsebene durch Implementierungsplanung hinzu. Nutzen Sie Cursor für Geschwindigkeit, PlanToCode für Sicherheit.",
        "question": "Ist PlanToCode eine Cursor-Alternative oder ein Ersatz?"
      },
      "q2": {
        "answer": "Die gemeinsame Nutzung beider Tools verhindert häufige Cursor-Probleme: Duplikat-Datei-Erstellung, falsche Dateipfade (besonders in Multi-Workspace-Projekten), unerwartete Datei-Änderungen und Production-Bugs durch ungeprüfte Änderungen. PlanToCodes Planungs-Phase erkennt diese Probleme vor Ausführung.",
        "question": "Welche Probleme löst die gemeinsame Nutzung von Cursor und PlanToCode?"
      },
      "q3": {
        "answer": "Der Workflow ist: 1) Datei-für-Datei-Implementierungsplan in PlanToCode generieren, 2) Plan überprüfen und genehmigen (Pfad-Fehler oder Duplikate erkennen), 3) Genehmigten Plan in Cursor Agent oder Composer einfügen, 4) Cursor Code-Generierung mit klarem architektonischen Kontext ausführen lassen.",
        "question": "Wie nutze ich PlanToCode mit Cursor?"
      },
      "q4": {
        "answer": "Cursor kostet $20/Monat für ein Abo. PlanToCode nutzt Pay-as-you-go-Preise ohne Abo. Gesamtkosten: $20/Monat für Cursor + Ihre tatsächliche API-Nutzung in PlanToCode (typisch $5-15/Monat für reguläre Nutzung). Viele Entwickler finden das günstiger als stundenlangen Duplikat-Datei-Cleanup.",
        "question": "Wie sieht die kombinierte Preisgestaltung aus?"
      },
      "q5": {
        "answer": "Absolut. Cursor funktioniert eigenständig großartig für kleine Projekte, Greenfield-Entwicklung und schnelle Prototypen. Fügen Sie PlanToCode hinzu bei großen Codebasen (50k+ LOC), komplexem Refactoring, Team-Umgebungen mit Genehmigungs-Anforderungen oder wenn Sie Duplikat-Datei-Probleme erlebt haben.",
        "question": "Kann ich Cursor ohne PlanToCode nutzen?"
      },
      "q6": {
        "answer": "Ja. Generieren Sie Ihren Implementierungsplan in PlanToCode, überprüfen Sie ihn, fügen Sie dann den genehmigten Plan in Cursor Agent Terminal ein oder geben Sie ihn Background Agents. Sie führen mit vollständigem architektonischen Kontext aus und verhindern häufige Pfad- und Duplikations-Fehler.",
        "question": "Funktioniert PlanToCode mit Cursor Agent und Background Agents?"
      },
      "q7": {
        "answer": "Die Planungs-Phase fügt 3-5 Minuten im Voraus hinzu, spart aber Stunden an Debugging, Duplikat-Datei-Cleanup und Pfad-Korrekturen. Die meisten Entwickler berichten von Netto-Zeiteinsparungen, besonders bei komplexen Tasks in großen Codebasen. Für schnelle Prototypen, wo Fehler günstig zu beheben sind, können Sie Planung überspringen und Cursor allein nutzen.",
        "question": "Verlangsamt die Nutzung beider Tools meinen Workflow?"
      },
      "q8": {
        "answer": "Ja, absolut. PlanToCode interferiert nicht mit Cursors Autocomplete oder anderen Cursor-Features. Sie sind separate Tools, die zusammenarbeiten. Nutzen Sie Cursors Autocomplete für normales Coding und wechseln Sie zu PlanToCode, wenn Sie Implementierungsplanung für größere Änderungen brauchen.",
        "question": "Kann ich Cursors Autocomplete weiterhin mit PlanToCode nutzen?"
      },
      "title": "Häufig gestellte Fragen"
    },
    "finalCta": {
      "description": "Die Antwort ist nicht, Cursor zu ersetzen - sondern die Sicherheitsebene hinzuzufügen, die doppelte Dateien, falsche Pfade und Production-Bugs verhindert.",
      "download": "PlanToCode herunterladen (Kostenlos)",
      "footer": "Kostenlos herunterladen. Pay-as-you-go API-Nutzung. Funktioniert mit Ihrem bestehenden Cursor-Setup.",
      "guide": "Integrations-Guide lesen",
      "title": "Hören Sie auf, nach Cursor-Alternativen zu suchen"
    },
    "gettingStarted": {
      "guide": "Setup-Guide: Cursor + PlanToCode",
      "quickWins": {
        "duplicates": "Duplikat-Dateien erkennen, bevor sie erstellt werden",
        "existing": "Funktioniert mit Ihrem bestehenden Cursor-Setup",
        "paths": "Exakte Dateipfade vor Ausführung überprüfen",
        "plan": "Erster Plan in unter 5 Minuten generiert",
        "subscription": "Kein Abo für PlanToCode erforderlich",
        "title": "Quick Wins"
      },
      "resources": {
        "comparison": "Detaillierter Tool-Vergleich",
        "discovery": "Datei-Erkennung-Workflow",
        "documentation": "Vollständige Dokumentation",
        "integration": "Cursor-Integrations-Guide",
        "title": "Kostenlose Ressourcen"
      },
      "step1": {
        "cursor": "Cursor von cursor.sh herunterladen ($20/Monat nach Trial)",
        "install": "Beide auf derselben Maschine für nahtlosen Workflow installieren",
        "plan": "PlanToCode von unserer Downloads-Seite herunterladen (kostenlos, Pay-as-you-go API-Nutzung)",
        "title": "Schritt 1: Beide Tools installieren"
      },
      "step2": {
        "items": {
          "1": "Projekt in Cursor (für Kontext) und PlanToCode (für Planung) öffnen",
          "2": "In PlanToCode: Aufgabe beschreiben, Datei-Erkennung ausführen, Implementierungsplan generieren",
          "3": "Plan im Monaco-Editor überprüfen - Dateipfade prüfen, auf Duplikate verifizieren",
          "4": "Genehmigten Plan kopieren",
          "5": "In Cursor: Agent Terminal oder Composer öffnen, Plan einfügen, Cursor ausführen lassen",
          "6": "Cursors generierten Code überprüfen (Architektur bereits verifiziert)"
        },
        "title": "Schritt 2: Ersten kombinierten Workflow ausprobieren"
      },
      "step3": {
        "comparison": "Detaillierten Vergleich sehen, wann welches Tool zu nutzen ist",
        "docs": "Implementierungsplanungs-Docs für Best Practices erkunden",
        "integration": "Unseren Cursor-Integrations-Guide für detaillierte Workflows lesen",
        "title": "Schritt 3: Fortgeschrittene Workflows lernen"
      },
      "title": "Mit beiden Tools starten"
    },
    "hero": {
      "badge": "Kein Ersatz - ein Sicherheits-Companion",
      "download": "PlanToCode herunterladen (Kostenlos)",
      "guide": "Cursor-Integrations-Guide ansehen",
      "subtitle": "Hören Sie auf, nach Cursor-Alternativen zu suchen. Die echte Lösung ist nicht, Cursor zu ersetzen - sondern eine Sicherheitsebene hinzuzufügen, die doppelte Dateien, falsche Pfade und Production-Bugs verhindert, bevor sie entstehen.",
      "title": "Cursor-Alternative?",
      "titleHighlight": "Nein - Ihr Cursor Safety Companion"
    },
    "meta": {
      "description": "Suchen Sie keinen Cursor-Ersatz? PlanToCode arbeitet MIT Cursor zusammen, um doppelte Dateien, falsche Pfade und Production-Bugs zu verhindern. Nutzen Sie beide zusammen.",
      "title": "Cursor Safety Companion - Keine Alternative"
    },
    "prevention": {
      "bugs": {
        "generate": "Cursors Generate-First-Ansatz: Änderungen werden sofort angewendet. Sie bemerken vielleicht nicht, dass Cursor utils/helpers.ts geändert hat, was 15 andere Dateien bricht. Sie entdecken den Bruch in Production oder beim Testen.",
        "plan": "PlanToCodes Plan-First-Ansatz: Plan zeigt alle Datei-Änderungen vor Ausführung. Sie sehen, dass utils/helpers.ts sich ändern wird. Sie führen Dependency-Analyse aus. Sie erkennen, dass 15 Dateien davon abhängen. Sie passen den Plan entsprechend an.",
        "title": "Production-Bugs verhindern"
      },
      "duplicates": {
        "generate": "Cursors Generate-First-Ansatz: KI generiert Code sofort. Wenn es die richtige Datei nicht findet oder durch ähnliche Namen verwirrt wird, erstellt es eine neue Datei. Sie entdecken Duplikate nach Generierung.",
        "plan": "PlanToCodes Plan-First-Ansatz: Plan listet exakte Dateipfade vor jeder Code-Generierung. Sie sehen components/Button.tsx und components/ui/Button.tsx im Plan. Sie erkennen das Duplikat-Benennungs-Problem während Review.",
        "title": "Doppelte Dateien verhindern"
      },
      "intro": "Die Probleme, die Entwickler mit Cursor erleben, sind nicht zufällig - sie sind vorhersehbare Konsequenzen von Generate-First-Workflows. So verhindert Planning-First jedes einzelne:",
      "paths": {
        "generate": "Cursors Generate-First-Ansatz: Besonders in Multi-Workspace-Projekten kann Cursor Code im falschen Workspace generieren oder relative Pfade falsch nutzen. Sie entdecken Pfad-Fehler, wenn Code nicht läuft.",
        "plan": "PlanToCodes Plan-First-Ansatz: Datei-Erkennung zeigt die vollständige Repository-Struktur. Pläne nutzen absolute Pfade. Sie verifizieren, dass Pfade zu Ihrer tatsächlichen Struktur während Review-Phase passen. Cursor bekommt korrekte Pfade vom Plan.",
        "title": "Falsche Dateipfade verhindern"
      },
      "scope": {
        "generate": "Cursors Generate-First-Ansatz: Gebeten, \"Dark-Mode-Toggle hinzuzufügen\", könnte Cursor auch Ihr gesamtes Theming-System refactoren, 30 Components aktualisieren und Ihre CSS-Architektur ändern. Sie entdecken die Scope-Explosion nach Generierung.",
        "plan": "PlanToCodes Plan-First-Ansatz: Plan zeigt \"Änderungen: 47 Dateien inklusive vollständigem Theming-Refactor.\" Sie sehen den Scope sofort. Sie verfeinern den Prompt: \"Nur Toggle-Component hinzufügen, kein Refactoring.\" Plan neu generieren. Jetzt sind es 3 Dateien. Genehmigen und ausführen.",
        "title": "Scope-Creep verhindern"
      },
      "title": "Warum Planning-First Cursors häufige Probleme verhindert"
    },
    "problem": {
      "bugs": {
        "description": "Änderungen werden direkt ohne Review angewendet, brechen Production-Code ohne klaren Rollback-Pfad.",
        "source": "— Häufige Beschwerde in großen Codebasen",
        "title": "Production-Bugs"
      },
      "duplicates": {
        "description": "\"Warum erstellt Cursor doppelte Dateistrukturen? Ich habe Projekte komplett aufgegeben wegen angesammelter Duplikate.\"",
        "source": "— Cursor Forum #47028 (14+ Antworten)",
        "title": "Doppelte-Dateien-Chaos"
      },
      "insight": "Hier ist die Einsicht: Das sind keine Cursor-Bugs - sie sind inhärent zum Generate-First, Review-Later-Ansatz. Die Lösung ist kein anderer Code-Generator. Es ist das Hinzufügen einer Plan-First-Sicherheitsebene.",
      "intro": "Sie suchen nicht nach einer Cursor-Alternative, weil Cursor schlecht in Code-Generierung ist. Sie suchen, weil Sie eines (oder alle) dieser Probleme erlebt haben:",
      "paths": {
        "description": "\"Cursor bekommt Dateipfade sehr oft falsch, fast immer bei mehreren Workspaces.\"",
        "source": "— Cursor Issue #31402",
        "title": "Falsche Pfad-Fehler"
      },
      "title": "Warum Entwickler nach \"Cursor-Alternative\" suchen",
      "unexpected": {
        "description": "\"Code-Update aus Chat anwenden erstellt eine neue Datei, anstatt bestehende zu ändern.\"",
        "source": "— Cursor Issue #22347",
        "title": "Unerwartete Datei-Erstellung"
      }
    },
    "testimonials": {
      "enterprise": {
        "quote": "Unser Compliance-Team verlangt, dass alle KI-Änderungen von einem Senior-Engineer vor Ausführung überprüft werden. PlanToCode gibt uns den Genehmigungs-Workflow, den wir brauchen. Junior-Devs generieren Pläne, Seniors überprüfen und genehmigen, dann fügen Juniors genehmigte Pläne in Cursor ein. Alle sind glücklich.",
        "title": "Enterprise-Team, Legacy-Codebasis (400k LOC)",
        "tools": "Tools: Cursor Pro für 8 Entwickler ($160/Monat) + PlanToCode Self-hosted Server"
      },
      "freelancer": {
        "quote": "Ich berechne Kunden stündlich. Kann mir nicht leisten, 2 Stunden mit Duplikat-Datei-Cleanup zu verbringen. PlanToCode erkennt alles während der 5-Minuten-Review-Phase. Ich zeige Kunden den Plan zur Genehmigung, sie sehen genau, wofür sie bezahlen, dann führe ich in Cursor aus. Super professionell.",
        "title": "Freelancer, Kunden-Projekte",
        "tools": "Tools: Cursor Pro ($20/Monat) + PlanToCode (~$6/Monat Nutzung)"
      },
      "intro": "Diese Workflows zeigen, wie Entwickler beide Tools zusammen nutzen:",
      "solo": {
        "quote": "Ich bekam ständig doppelte Dateien in meinem Monorepo. Cursor würde packages/api/auth.ts und packages/api/src/auth.ts erstellen. Jetzt generiere ich den Plan in PlanToCode, verifiziere, dass die Pfade korrekt sind, füge dann in Cursor Agent ein. Null Duplikate seit dem Wechsel.",
        "title": "Solo-Entwickler, Monorepo (120k LOC)",
        "tools": "Tools: Cursor Pro ($20/Monat) + PlanToCode (~$8/Monat Nutzung)"
      },
      "startup": {
        "quote": "Cursors Pfad-Fehler in Multi-Workspace-Projekten haben uns umgebracht. PlanToCodes Datei-Erkennung zeigt die vollständige Struktur über alle Workspaces. Ich verifiziere Pfade im Plan, dann führt Cursor perfekt aus, weil es den richtigen Kontext hat.",
        "title": "Startup-CTO, Multi-Workspace-Projekt",
        "tools": "Tools: Cursor Pro ($20/Monat) + PlanToCode (~$12/Monat Nutzung)"
      },
      "title": "Echte Cursor-Nutzer, die PlanToCode hinzugefügt haben"
    },
    "twist": {
      "complement": "PlanToCode ersetzt Cursor nicht. Es fügt das fehlende Stück hinzu: Implementierungsplanung vor Ausführung. Denken Sie daran als Sicherheitsebene, die Fehler erkennt, bevor sie zu Code werden.",
      "cursorFor": {
        "autocomplete": "Intelligentes Autocomplete",
        "commands": "Natürlichsprachliche Befehle",
        "ide": "IDE-Integration",
        "prototypes": "Schnelle Prototypen",
        "speed": "Code-Generierungs-Geschwindigkeit",
        "title": "Cursor nutzen für:"
      },
      "planFor": {
        "approval": "Team-Genehmigungs-Workflows",
        "duplicates": "Doppelte Dateien verhindern",
        "paths": "Pfad-Fehler früh erkennen",
        "planning": "Implementierungsplanung",
        "review": "Review vor Ausführung",
        "title": "PlanToCode nutzen für:"
      },
      "strength": "Cursor ist exzellent in dem, was es tut: blitzschnelle Code-Generierung, intelligentes Autocomplete und intuitive Chat-Interfaces. Aber es generiert Code sofort, was gleichzeitig seine Stärke und Schwäche ist.",
      "title": "Die Wendung: PlanToCode ist kein Ersatz"
    },
    "whenToUse": {
      "enterprise": {
        "cursor": "Cursor für einzelne Mitwirkende nutzen",
        "cursorDesc": "Entwickler nutzen Cursor täglich. Pläne von PlanToCode leiten ihre Arbeit.",
        "plan": "PlanToCode für Genehmigungs-Workflows nutzen",
        "planDesc": "Stakeholder überprüfen Pläne vor Ausführung. Audit-Trail für Compliance und Governance.",
        "title": "Team-Umgebungen & Enterprise"
      },
      "greenfield": {
        "cursor": "Cursor eigenständig nutzen",
        "cursorDesc": "Neue Projekte mit einfacher Struktur, wo Sie Fehler schnell erkennen können. Datei-Organisation ist noch nicht komplex.",
        "plan": "PlanToCode optional",
        "planDesc": "Nicht kritisch für kleine Projekte mit klarer Struktur.",
        "title": "Greenfield-Projekte & schnelle Prototypen"
      },
      "large": {
        "cursor": "Mit Cursor ausführen",
        "cursorDesc": "Genehmigten Plan in Cursor Agent einfügen. Lassen Sie es Code-Generierung mit klarem Kontext handhaben.",
        "plan": "Mit PlanToCode-Planung starten",
        "planDesc": "Datei-für-Datei-Plan generieren, falsche Pfade und Duplikate in Review-Phase erkennen.",
        "title": "Große/Legacy-Codebasen (50k+ LOC)"
      },
      "medium": {
        "cursor": "Cursor für Implementierung nutzen",
        "cursorDesc": "Noch schnell genug, um Änderungen manuell zu überprüfen. Gutes Autocomplete spart Zeit.",
        "plan": "PlanToCode für komplexe Tasks hinzufügen",
        "planDesc": "Planung für Refactoring, Multi-Package-Änderungen oder wenn Sie Pfad-Fehler erlebt haben.",
        "title": "Mittlere Codebasen (10k-50k LOC)"
      },
      "title": "Wann Cursor vs PlanToCode nutzen (Seite-an-Seite)"
    },
    "workflow": {
      "combined": "Kombinierter Workflow: Planen → Ausführen → Überprüfen",
      "example": {
        "title": "Echtes Beispiel: Authentication-System-Refactoring",
        "with": "Mit PlanToCode: Plan generieren, der alle 12 Dateien zeigt, die Änderungen benötigen. Erkennen, dass Cursors initialer Plan 3 API-Routes übersehen hat. Korrigierten Plan genehmigen. In Cursor einfügen. In 30 Minuten fertig, null Duplikate.",
        "without": "Ohne PlanToCode: Cursor bitten, \"Auth zu refactoren, um JWT statt Sessions zu nutzen.\" Cursor erstellt auth-new.ts, middleware/auth.ts (Duplikat), übersieht api/login.ts. 2 Stunden mit Reparatur verbringen."
      },
      "intro": "Der effektivste Workflow kombiniert beide Tools und nutzt jedes für das, was es am besten kann:",
      "step1": {
        "catch": "Was Sie erkennen: Falsche Dateipfade, doppelte Dateien, fehlende Dependencies, Scope-Creep",
        "description": "Beschreiben Sie Ihre Aufgabe (Sprache oder Text), führen Sie Datei-Erkennung aus, um alle betroffenen Dateien zu finden, generieren Sie Implementierungspläne von mehreren KI-Modellen (Claude, GPT, Gemini).",
        "title": "In PlanToCode planen"
      },
      "step2": {
        "description": "Plan im Monaco-Editor öffnen. Exakte Dateipfade mit Ihrer Repository-Struktur verifizieren. Nach Duplikaten suchen. Schritte bearbeiten, die Verfeinerung brauchen. Pläne von verschiedenen Modellen bei Bedarf zusammenführen.",
        "gate": "Sicherheits-Gate: Nichts passiert ohne Ihre explizite Genehmigung",
        "title": "Überprüfen & Genehmigen"
      },
      "step3": {
        "alternative": "Alternative: Direkt in PlanToCode's integriertem Terminal mit vollem Logging ausführen",
        "description": "Genehmigten Plan kopieren. In Cursor Agent Terminal oder Composer einfügen. Cursor hat jetzt vollständigen architektonischen Kontext - es weiß genau, welche Dateien zu ändern sind, was zu ändern ist und warum.",
        "title": "In Cursor ausführen"
      },
      "step4": {
        "description": "Cursor generiert den Code gemäß Ihrem genehmigten Plan. Überprüfen Sie die tatsächliche Implementierung. Da Sie die Architektur bereits genehmigt haben, prüfen Sie nur Code-Qualität - nicht strukturelle Fehler.",
        "saved": "Zeit gespart: Kein Duplikat-Datei-Cleanup, keine Pfad-Korrekturen, kein architektonisches Rework",
        "title": "Implementierung überprüfen"
      },
      "title": "Wie Cursor + PlanToCode zusammen nutzen"
    }
  },
  "demo": {
    "cta": {
      "button": "Alle Screenshots anzeigen",
      "description": "Erkunden Sie echte Screenshots aus tatsächlichen Workflows - Datei-Erkennung, Implementierungspläne, Terminal-Sessions und mehr.",
      "title": "Mehr sehen?"
    },
    "hero": {
      "screenshots": "Echte Screenshots ansehen",
      "subtitle": "Sehen Sie, wie PlanToCode Code-Änderungen plant und ausführt.",
      "title": "Interaktive Demo",
      "video": "Demo ansehen"
    },
    "meta": {
      "description": "Sehen Sie, wie PlanToCode Code-Änderungen plant und ausführt.",
      "title": "Interaktive Demo"
    }
  },
  "schedule": {
    "benefits": {
      "review": {
        "description": "Besprechen Sie die Integration mit Ihren bestehenden Claude Code-, Cursor- oder Aider-Workflows.",
        "title": "Architektur-Review"
      },
      "session": {
        "description": "Fokussierte Beratung zu den Anforderungen Ihres Teams und wie PlanToCode helfen kann.",
        "title": "30-Minuten-Session"
      },
      "team": {
        "description": "Erfahren Sie mehr über Enterprise-Features, Terminal-Governance und Deployment-Optionen.",
        "title": "Team-Lösungen"
      }
    },
    "footer": "Keine passende Zeit gefunden? Schreiben Sie uns an",
    "hero": {
      "subtitle": "Holen Sie sich Expertenberatung zur Nutzung von PlanToCode für die spezifischen Bedürfnisse Ihres Teams. Wir besprechen Architektur-Patterns, Integrations-Strategien und Deployment-Optionen.",
      "title": "Mit einem Architekten sprechen"
    },
    "meta": {
      "description": "Holen Sie sich Expertenberatung zur Nutzung von PlanToCode für die spezifischen Bedürfnisse Ihres Teams. Wir besprechen Architektur-Patterns, Integrations-Strategien und Deployment-Optionen.",
      "title": "Mit einem Architekten sprechen"
    },
    "topics": {
      "items": {
        "cost": "Kostenoptimierung für große Teams",
        "deployment": "On-Premise-Deployment-Anforderungen",
        "integration": "Integration mit bestehenden Claude Code/Cursor Workflows",
        "orchestration": "Terminal-Orchestrierung für CI/CD-Pipelines",
        "planning": "Multi-Modell-Planungs-Strategien für Legacy-Code",
        "security": "Sicherheits- & Compliance-Überlegungen"
      },
      "title": "Häufige Themen, die wir behandeln"
    }
  },
  "support": {
    "button": "Support kontaktieren",
    "hero": {
      "subtitle": "Holen Sie sich Hilfe zu PlanToCode",
      "title": "Support"
    },
    "meta": {
      "description": "Holen Sie sich Hilfe bei PlanToCode-Installation, Claude Code, Cursor und Codex Integration. Troubleshooting und Feature-Requests. 24h Antwortzeit.",
      "title": "PlanToCode Support - Hilfe & Troubleshooting"
    },
    "resources": {
      "changelog": "Changelog",
      "feedback": "Feedback",
      "help": "Hilfe-Center",
      "roadmap": "Roadmap",
      "title": "FeatureBase-Ressourcen"
    }
  }
}
