{
  "capture": {
    "cards": {
      "taskRefinement": {
        "description": "암묵적 요구 사항 식별, 예상 동작 및 엣지 케이스 명확화, 기술적 고려 사항 추가를 통해 작업 설명을 확장합니다.",
        "link": "자세히 알아보기 →",
        "title": "작업 개선"
      },
      "textEnhancement": {
        "description": "원래의 의도, 톤 및 기술적 세부 수준을 유지하면서 문법, 문장 구조, 명확성 및 간결성을 개선합니다.",
        "link": "자세히 알아보기 →",
        "title": "텍스트 향상"
      },
      "voice": {
        "description": "음성 입력을 통해 초기 요구 사항을 캡처한 다음 정확성과 명확성을 위해 수동으로 개선할 수 있습니다.",
        "link": "자세히 알아보기 →",
        "title": "음성 받아쓰기"
      }
    },
    "subtitle": "음성 받아쓰기 및 AI 기반 향상을 통해 아이디어를 명확하고 실행 가능한 사양으로 빠르게 구체화하십시오.",
    "title": "사양 캡처 및 개선"
  },
  "cta": {
    "badge": "인간 참여형 AI 계획",
    "buttons": {
      "download": "무료 다운로드",
      "talk": "전문가와 상담"
    },
    "description": "하나의 작업 공간에서 AI 지원 변경 사항을 계획, 검토 및 실행합니다. 모델, 프롬프트, 파일 및 터미널 출력을 정렬 상태로 유지합니다.",
    "features": {
      "instant": "즉시 작업 시작",
      "noCard": "신용카드 불필요"
    },
    "title": "다음 구현 계획을 조율할 준비가 되셨습니까?"
  },
  "faq": {
    "items": {
      "q1": {
        "a": "예. PlanToCode는 팀 리더와 이해관계자가 생성된 구현 계획을 검토하고, 세부 사항을 편집하고, 수정을 요청하고, 코딩 에이전트 또는 개발자가 실행하기 전에 변경 사항을 승인할 수 있는 인간 참여형 워크플로우를 제공합니다. 이를 통해 기업 거버넌스를 보장하고 회귀를 방지합니다.",
        "q": "이해관계자가 실행 전에 계획을 검토하고 승인할 수 있습니까?"
      },
      "q10": {
        "a": "물론입니다. 계획은 구문 강조, diff 친화적 서식 및 클립보드 도우미를 갖춘 Monaco 에디터에서 열립니다. 프롬프트를 조정하고, 개별 단계를 복사하고, 작업 공간을 벗어나지 않고 생성을 다시 실행할 수 있습니다.",
        "q": "실행 전에 AI 생성 계획을 편집할 수 있습니까?"
      },
      "q11": {
        "a": "두 개 이상의 계획을 선택하고 병합 지침을 작성한 다음 제출합니다. 병합된 결과는 원본과 함께 저장되므로 초안을 비교하고, 메모를 보관하거나, 다른 지침으로 병합을 다시 실행할 수 있습니다.",
        "q": "병합 지침은 어떻게 작동합니까?"
      },
      "q12": {
        "a": "Prompt previews, model allowlists, token estimates, and terminal health checks surface issues before any command runs. Every job stores its inputs and outputs for review.",
        "q": "시니어 엔지니어가 이것을 사용하는 이유는 무엇입니까?"
      },
      "q13": {
        "a": "작업 설명(타이핑 또는 음성) → 파일 찾기 워크플로우 실행 → 하나 이상의 구현 계획 생성 → Monaco 에디터에서 계획 편집 또는 병합 → 내장 터미널을 시작하여 계획을 실행하고 로그를 모니터링합니다. 세션과 로그는 다음에 앱을 열 때 사용할 수 있습니다.",
        "q": "일반적인 워크플로우는 어떻게 생겼습니까?"
      },
      "q14": {
        "a": "네. 리포지토리는 Business Source License의 source-available로 공개되어 있으며 기본 system prompts는 리포지토리에 포함되고 앱에서 편집할 수 있습니다.",
        "q": "소스 코드와 system prompts를 사용할 수 있나요?"
      },
      "q2": {
        "a": "Microsoft Teams 회의 녹화 또는 화면 캡처를 PlanToCode에 업로드합니다. 고급 멀티모달 모델이 오디오 트랜스크립트(화자 식별 포함)와 시각적 콘텐츠(공유 화면, 문서)를 모두 분석하여 사양 요구 사항을 추출합니다. 추출된 인사이트(결정 사항, 작업 항목, 토론 포인트)를 검토하고 구현 계획에 통합합니다.",
        "q": "Teams 회의가 어떻게 사양이 됩니까?"
      },
      "q3": {
        "a": "예. 구현 계획은 프로젝트 구조에 해당하는 정확한 리포지토리 경로를 사용하여 파일별로 변경 사항을 세분화합니다. 이러한 세분화된 접근 방식을 통해 실행 전에 정확히 무엇이 수정될 것인지 알 수 있으며 완전한 가시성과 제어를 제공합니다.",
        "q": "계획이 저장소의 정확한 파일에 매핑됩니까?"
      },
      "q4": {
        "a": "PlanToCode는 데스크톱 계획 작업 공간입니다. 파일 검색 워크플로우를 실행하고, Monaco 에디터에서 구현 계획을 검토하고, 프롬프트를 조정한 다음 동일한 세션에서 터미널을 시작합니다. 채팅 도구는 단일 응답을 제공합니다. 여기서는 실행 전에 작업을 준비합니다.",
        "q": "채팅 기반 코딩 에이전트와 어떻게 다릅니까?"
      },
      "q5": {
        "a": "예. 이 앱은 귀하가 이미 대규모 리포지토리에서 작업하고 있으며 터미널, 종속성 그래프 및 아키텍처 트레이드오프에 익숙하다고 가정합니다. 소프트웨어는 더 빠르게 판단을 적용할 수 있도록 컨텍스트를 구성된 상태로 유지합니다.",
        "q": "코딩 방법을 알아야 합니까?"
      },
      "q6": {
        "a": "기본 구성에는 Gemini 3 Pro, GPT-5.2, Claude 4.5 Sonnet, o3, Grok 4, DeepSeek R1 및 Kimi K2가 포함되어 있습니다. 작업을 제출하기 전에 설정 패널에서 작업당 모델을 전환할 수 있습니다.",
        "q": "어떤 AI 모델이 계획을 생성할 수 있습니까?"
      },
      "q7": {
        "a": "프로젝트 상태, 터미널 로그 및 계획 초안은 SQLite에 로컬로 저장됩니다. 승인한 프롬프트와 선택한 파일만 구성된 서버 프록시를 통해 전송됩니다. 이 저장소의 Rust 서버는 트래픽을 자체 인프라에 유지해야 할 때 자체 호스팅할 수 있습니다.",
        "q": "내 소스 코드는 어떻게 됩니까?"
      },
      "q8": {
        "a": "Each tab is a PTY session managed by the Rust backend. Output is streamed to the UI and stored in SQLite so you can review or resume later.",
        "q": "터미널 내부에서 어떤 CLI 도구가 작동합니까?"
      },
      "q9": {
        "a": "파일 찾기 워크플로우를 시작하여 검색 패턴, 관련성 점수 및 우선 순위가 지정된 파일 목록을 생성합니다. 각 단계는 자체 백그라운드 작업으로 실행되므로 선택 사항을 세션에 적용하기 전에 결과를 검사할 수 있습니다.",
        "q": "대규모 코드베이스에 어떻게 대처합니까?"
      }
    },
    "subtitle": "PlanToCode에 대해 알아야 할 모든 것",
    "title": "자주 묻는 질문"
  },
  "features": {
    "cards": {
      "fileDiscovery": {
        "description": "정규식 패턴 생성, 관련성 점수 및 경로 수정을 위한 단계별 백그라운드 작업을 시작합니다. 결과를 세션에 적용하기 전에 각 단계를 검토하십시오.",
        "title": "파일 발견 워크플로우"
      },
      "implementation": {
        "description": "정확한 리포지토리 경로가 포함된 파일별 구현 계획을 생성합니다. 실행 전에 변경 사항을 검토, 편집 및 승인하여 회귀를 방지하고 요구 사항과의 일치를 보장합니다.",
        "title": "인간 검토 구현 계획"
      },
      "integratedTerminal": {
        "description": "내장 터미널에서 claude, cursor, codex 또는 gemini를 직접 시작합니다. 상태 모니터링, 자동 복구 및 크기 조정 처리로 장기 실행 작업을 안정적으로 유지합니다.",
        "title": "CLI 감지 기능이 있는 통합 PTY 터미널"
      },
      "meeting": {
        "description": "Microsoft Teams 회의 또는 화면 녹화를 업로드합니다. 멀티모달 분석은 오디오 트랜스크립트 및 시각적 콘텐츠에서 사양을 추출하여 검토 및 통합합니다.",
        "title": "회의 녹화 수집"
      },
      "mergePlans": {
        "description": "여러 계획을 선택하고 병합 지침을 작성하고 병합된 출력을 원본과 함께 보관합니다. 접근 방식이 표준과 일치할 때까지 반복합니다.",
        "title": "지침과 함께 계획 병합"
      },
      "modelConfiguration": {
        "description": "구현 계획을 위해 Gemini 3 Pro, GPT-5.2, Claude 4.5 Sonnet, Grok 4, DeepSeek R1 및 Kimi K2 중에서 선택하십시오. 설정은 프로젝트별로 유지됩니다.",
        "title": "작업당 모델 구성"
      },
      "monacoEditor": {
        "description": "계획은 구문 강조, diff 친화적 서식 및 클립보드 도우미를 갖춘 Monaco 에디터에서 열립니다. 단계를 편집하고, 초안을 저장하고, 다음 작업을 위한 템플릿을 준비하십시오.",
        "title": "Monaco 구현 계획 에디터"
      },
      "persistentSessions": {
        "description": "터미널 출력은 5MB 링 버퍼에 저장되고 프로젝트 세션은 시작 시 다시 로드됩니다. 컨텍스트를 재구축하지 않고 미완료 작업을 계속합니다.",
        "title": "영구 세션 및 로그"
      },
      "specification": {
        "description": "빠른 입력을 위한 음성 받아쓰기, 명확성을 위한 텍스트 향상, 암묵적 요구 사항 및 엣지 케이스를 식별하기 위한 작업 개선.",
        "title": "사양 캡처 및 개선"
      },
      "textImprovement": {
        "description": "모든 선택 항목을 강조 표시하여 Claude 4.5 Sonnet 또는 Gemini 3 Flash로 텍스트 개선 작업을 실행합니다. 재작성은 서식을 유지하고 Monaco 에디터, 작업 입력 및 터미널 받아쓰기 내부에 적용됩니다.",
        "title": "텍스트 개선 팝오버"
      },
      "tokenGuardrails": {
        "description": "작업을 제출하기 전에 정확한 프롬프트, 추정 토큰 수 및 컨텍스트 윈도우 경고를 확인하십시오. 완전한 가시성으로 지침을 조정하십시오.",
        "title": "토큰 가드레일 및 프롬프트 미리보기"
      },
      "voiceTranscription": {
        "description": "작업 설명 또는 터미널 명령을 녹음하고 전사 서비스를 통해 보냅니다. 각 프로젝트에 대한 언어 및 온도 기본값을 구성하십시오.",
        "title": "음성 전사 파이프라인"
      }
    },
    "linkText": "자세히 알아보기",
    "subtitle": "대규모 및 레거시 코드베이스를 다루는 개발자를 위해 제작되었습니다. Claude Code, Cursor 또는 Aider를 사용하는 경우 이것이 귀하의 계획 레이어입니다.",
    "title": "메커니즘"
  },
  "governance": {
    "cards": {
      "filePlans": {
        "description": "구현 계획은 파일과 작업 단위로 변경을 분해해 범위를 명확히 합니다.",
        "title": "정확한 경로가 있는 파일별 계획"
      },
      "handoff": {
        "description": "승인된 계획은 터미널 또는 에이전트 CLI로 컨텍스트와 감사 로그와 함께 전달됩니다.",
        "title": "실행 핸드오프"
      },
      "workflow": {
        "description": "데스크톱 또는 모바일에서 계획을 편집할 수 있으며 각 리비전이 보존됩니다.",
        "title": "검토, 편집, 승인"
      }
    },
    "subtitle": "Plans are artifacts you can review, edit, and approve before any agent runs. Logs and history keep changes traceable.",
    "title": "실행 전 플랜 리뷰"
  },
  "hero": {
    "cta": {
      "viewDemo": "PlanToCode 다운로드",
      "howItWorks": "플랜 형식 보기"
    }
  },
  "integrations": {
    "cards": {
      "allIntegrations": {
        "description": "서버를 직접 운영해 제공업체 라우팅을 제어하고 자체 키를 사용하세요.",
        "link": "서버 설정 가이드 ->",
        "title": "셀프호스팅 및 BYOK"
      },
      "claudeCode": {
        "description": "기본 프롬프트는 리포지토리와 서버 DB에 있어 확인 및 편집이 가능합니다.",
        "link": "프롬프트 유형 문서 ->",
        "title": "읽을 수 있는 시스템 프롬프트"
      },
      "cursor": {
        "description": "전체 시스템은 Business Source License로 GitHub에 공개되어 아키텍처를 감사할 수 있습니다.",
        "link": "GitHub 리포지토리 보기 ->",
        "title": "Source available (BSL 1.1)"
      }
    },
    "subtitle": "system prompts, 소스 코드, 셀프호스팅 정보가 공개되고 문서화됩니다.",
    "title": "투명성 및 제어"
  },
  "meetings": {
    "cards": {
      "insights": {
        "description": "추출된 인사이트(요약된 결정 사항, 작업 항목 및 주요 토론 포인트)는 팀 리더가 검토, 선택 및 실행 가능한 구현 계획에 통합할 수 있는 직관적인 인터페이스에 표시됩니다.",
        "link": "자세히 알아보기 →",
        "title": "인사이트 검토 및 통합"
      },
      "multimodal": {
        "description": "Microsoft Teams 회의 또는 화면 녹화를 업로드합니다. 고급 멀티모달 모델이 오디오 트랜스크립트(화자 식별 포함)와 관련 시각적 콘텐츠(공유 화면, 제시된 문서, 주요 순간)를 모두 분석하여 사양 요구 사항을 추출합니다.",
        "link": "자세히 알아보기 →",
        "title": "멀티모달 분석"
      }
    },
    "subtitle": "Microsoft Teams 회의 및 화면 녹화를 실행 가능한 구현 요구 사항으로 변환합니다.",
    "title": "회의 및 녹화 수집"
  },
  "pricing": {
    "card": {
      "description": "결과를 검증하기 위해 사용량 기반 가격 책정으로 시작하십시오. 구독 없음. 투명한 API 비용만.",
      "pricing": {
        "description": "플랜 에디터, 병합 지침, 터미널 통합을 테스트하십시오. 확신이 들면 자동 충전합니다.",
        "subtitle": "사용한 만큼만 지불하십시오.",
        "title": "사용량 기반 가격 책정"
      },
      "title": "투명한 가격 책정"
    },
    "subtitle": "투명한 토큰 비용으로 AI 추론에 대해서만 지불하십시오. 실시간으로 ROI를 확인하십시오. 저장된 프로덕션 사고 하나가 수개월의 사용 비용을 충당합니다.",
    "title": "전문 개발을 위해 제작됨"
  },
  "problems": {
    "cards": {
      "browseAll": {
        "description": "리팩토링, 마이그레이션, 사고 대응 등을 위한 워크플로우 탐색",
        "link": "모든 워크플로우 보기 →",
        "title": "모든 워크플로우 탐색"
      },
      "hardBugs": {
        "description": "보존된 컨텍스트, 재현 가능한 단계 및 완전한 조사 이력으로 디버그",
        "link": "자세히 알아보기 →",
        "title": "어려운 프로덕션 버그"
      },
      "largeFeatures": {
        "description": "아키텍처 인식 및 영향 분석을 통해 복잡한 구현 계획",
        "link": "자세히 알아보기 →",
        "title": "대규모 기능"
      },
      "legacyRefactoring": {
        "description": "기능을 보존하면서 구조를 개선하는 AI 지원 리팩토링으로 레거시 코드베이스 현대화",
        "link": "자세히 보기 →",
        "title": "레거시 코드 리팩토링"
      },
      "libraryUpgrades": {
        "description": "파손 변경 감지 및 마이그레이션 계획으로 종속성을 안전하게 업데이트",
        "link": "자세히 알아보기 →",
        "title": "라이브러리 업그레이드"
      },
      "preventDuplicates": {
        "description": "코드베이스 전체에서 중복 코드, 컴포넌트 및 구현 감지 및 방지",
        "link": "자세히 보기 →",
        "title": "중복 파일 방지"
      },
      "safeRefactoring": {
        "description": "아키텍처 인식과 포괄적인 영향 분석을 통해 자신 있게 리팩토링",
        "link": "자세히 보기 →",
        "title": "안전한 리팩토링"
      }
    },
    "subtitle": "소프트웨어 개발에서 가장 어려운 문제에 대한 실제 솔루션",
    "title": "복잡한 개발 과제 해결"
  },
  "gallery": {
    "heading": "앱 내 플랜 리뷰 워크플로",
    "intro": "See how file discovery, multi-model planning, merge instructions, and execution handoff keep agent work transparent and traceable.",
    "video": {
      "title": "Plan-first 워크플로 개요",
      "description": "작업 입력부터 플랜 리뷰, 병합 지시, 실행 핸드오프까지의 짧은 워크스루.",
      "bullets": [
        "같은 파일 컨텍스트로 여러 플랜 초안 생성",
        "명확한 지시로 최선의 아이디어 병합",
        "데스크톱 또는 모바일에서 플랜 검토 및 편집",
        "Claude Code 또는 로컬 터미널로 로그와 함께 전달"
      ]
    },
    "cards": {
      "fileFinder": {
        "title": "파일 검색 파이프라인",
        "description": "4단계 Rust 워크플로: LLM 지원 루트 선택, 정규식 필터링, 관련성 점수화, 집중된 파일 세트를 구축하기 위한 확장 경로 검색.",
        "features": [
          "루트 폴더 선택이 디렉토리 트리와 작업 설명을 사용",
          "정규식 필터가 패턴 그룹을 생성하고 git ls-files를 적용",
          "관련성 점수화가 토큰 추정으로 파일 내용을 분할",
          "확장 경로 파인더가 파일 및 트리 데이터로 컨텍스트를 확장"
        ]
      },
      "fileFinderWorkflow": {
        "title": "Plan history and logs",
        "description": "각 워크플로 단계가 background_jobs에 결과를 기록하여 파일 세트를 세션 간에 재사용하고 나중에 검사할 수 있습니다.",
        "features": [
          "워크플로 단계가 작업 레코드로 저장",
          "선택된 파일 목록이 JSON 응답으로 영속화",
          "세션 included_files가 작업 간에 재사용",
          "SQLite 기록이 재시작 후에도 유지"
        ]
      },
      "videoAnalysis": {
        "title": "Optional screen recording analysis",
        "description": "Screen recordings can be sent to the /api/llm/video/analyze endpoint with a focus prompt and FPS hint to generate analysis summaries.",
        "features": [
          "Multipart upload includes durationMs and framerate",
          "Model format is provider/model (google/* required)",
          "Usage and cost recorded per job",
          "Summary stored in background_jobs response and can be applied to the task description"
        ]
      },
      "implementationPlans": {
        "title": "멀티 모델 계획 생성",
        "description": "ImplementationPlanProcessor가 전체 파일 내용에서 계획 초안을 스트리밍하고, 병합 작업이 여러 초안을 하나의 계획으로 통합합니다.",
        "features": [
          "계획 작업에 선택된 파일 내용 + 디렉토리 트리 포함",
          "구조화된 계획 메타데이터를 작업별로 캡처",
          "병합 프롬프트가 <source_plans>와 <user_instructions> 사용",
          "최종 계획이 소스 초안과 함께 저장"
        ]
      },
      "backgroundTasks": {
        "title": "백그라운드 작업 모니터링",
        "description": "Rust 작업 프로세서가 UI에 진행 상황과 상태 전환을 스트리밍하면서 작업 기록을 SQLite에 영속화합니다.",
        "features": [
          "Created, queued, preparing, running, completed/failed/canceled",
          "Tauri 이벤트를 통한 스트리밍 업데이트",
          "실행별 토큰 사용량 캡처",
          "장시간 실행 작업 취소"
        ]
      },
      "settingsPrompts": {
        "title": "프롬프트 및 모델 구성",
        "description": "런타임 모델 설정은 `/api/config/desktop-runtime-config`에서 가져오고, 프롬프트 재정의는 SQLite에 저장됩니다.",
        "features": [
          "작업별 허용 모델 및 기본값",
          "서버 API에서 제공하는 시스템 프롬프트",
          "project_system_prompts의 프로젝트 수준 프롬프트 재정의",
          "런타임 기본 설정용 로컬 key_value_store"
        ]
      },
      "terminalVoiceRecording": {
        "title": "워크플로 자동화 버튼",
        "description": "복사 버튼이 작업 컨텍스트가 포함된 템플릿 기반 프롬프트를 삽입하여 터미널이나 외부 도구로 인계합니다.",
        "features": [
          "템플릿이 작업 모델 구성에서 가져옴",
          "플레이스홀더가 활성 계획에 대해 해결",
          "PTY 세션 또는 클립보드로 인계",
          "감사를 위해 작업 메타데이터에 액션 연결"
        ]
      },
      "mergeInstructionsWorkflow": {
        "title": "계획 병합 지침",
        "description": "ImplementationPlanMergeProcessor가 XML 태그가 지정된 소스 계획과 선택적 지침을 사용하여 여러 계획 초안을 병합합니다.",
        "features": [
          "소스 계획이 작업 ID로 가져옴",
          "병합 지침이 메타데이터에 저장",
          "파일 내용 + 디렉토리 트리가 컨텍스트 추가",
          "병합된 계획이 입력과 함께 저장"
        ]
      },
      "billingTransactions": {
        "title": "사용량 및 비용 원장",
        "description": "서버 측 사용량 항목과 작업 메타데이터가 제공업체 전반의 모델 사용량을 캡처합니다.",
        "features": [
          "작업별 토큰 및 비용 메타데이터",
          "제공업체 인식 사용량 항목",
          "청구 엔드포인트가 사용량 요약 노출",
          "Usage history for model spend"
        ]
      }
    },
    "viewFullSize": "전체 크기로 보기",
    "cta": {
      "title": "에이전트 실행 전에 플랜을 검토할 준비가 되셨나요?",
      "description": "데스크톱 앱을 다운로드해 멀티 모델 계획, 플랜 병합, 실행 핸드오프를 확인하세요.",
      "primary": "PlanToCode 다운로드",
      "secondary": "플랜 형식 보기"
    }
  },
  "technicalLanding": {
    "title": "PlanToCode: 구현 계획을 검토하고 병합",
    "description": "PlanToCode는 작업을 구조화된 구현 계획으로 변환하여 에이전트가 실행하기 전에 읽고 비교하고 편집할 수 있습니다. 여러 초안을 생성해 최선의 접근을 병합하고 Claude Code 또는 터미널로 컨텍스트와 함께 전달합니다.",
    "note": "호스팅은 관리형 모델 액세스를 사용하며 BYOK는 셀프호스팅에서만 가능합니다.",
    "noteLink": "셀프호스팅 가이드",
    "repo": {
      "title": "GitHub 소스 공개",
      "description": "이 사이트는 PlanToCode 리포지토리의 프론트 페이지입니다. 여기서 코드, 문서, 아키텍처를 확인할 수 있습니다.",
      "starsLabel": "GitHub 스타",
      "licenseLabel": "BSL 1.1"
    },
    "walkthroughTitle": "단계별: 구성 요소가 함께 작동하는 방식",
    "walkthroughDescription": "데스크톱 앱, Rust/Tauri 백엔드, SQLite 데이터베이스, LLM 오케스트레이션 파이프라인이 작업을 조정하고 결과를 UI로 스트리밍하는 방법을 완전히 설명합니다.",
    "tags": [
      "플랜 리뷰",
      "멀티 모델 계획",
      "플랜 병합",
      "모바일 플랜 뷰어",
      "Source available (BSL)"
    ]
  }
}
