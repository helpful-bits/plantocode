{
  "aiWrongPaths": {
    "badge": "AI 경로 검증",
    "comparison": {
      "features": {
        "binaryFiltering": "바이너리 파일 필터링",
        "gitIntegration": ".gitignore를 준수하는 Git 통합",
        "monorepoResolution": "모노레포 워크스페이스 해석",
        "pathAliasResolution": "TypeScript 경로 별칭 해석",
        "preExecutionValidation": "실행 전 경로 검증",
        "realtimeProgress": "실시간 검증 진행 상황",
        "symbolicLinks": "심볼릭 링크 해석",
        "tokenBatching": "비용 최적화 토큰 배치"
      },
      "title": "PlanToCode 비교"
    },
    "cta": {
      "description": "AI는 실제로 존재하는 파일을 참조해야 합니다. PlanToCode는 코드 생성 전에 모든 경로를 검증하여 가상의 임포트와 빌드 오류를 방지합니다. 모노레포, 레거시 코드베이스 및 복잡한 프로젝트 구조에 완벽합니다.",
      "links": {
        "deepDive": "심층 분석: 파일 탐색 시스템",
        "docs": "기술 문서 읽기"
      },
      "title": "환각된 파일 경로와의 싸움을 멈추세요"
    },
    "description": "AI 도구는 임포트 경로를 환각하고, 존재하지 않는 파일을 참조하며, 가상의 종속성으로 빌드를 중단시킵니다. PlanToCode는 실행 전에 모든 파일 경로를 검증하여 모노레포와 레거시 코드베이스에서 환각된 참조를 제거합니다.",
    "discoveryInAction": {
      "complete": {
        "description": "모든 파일이 파일 시스템에 대해 검증되었습니다. AI는 생성된 코드에서 검증된 경로만 참조합니다. 환각된 임포트가 발생할 수 없습니다.",
        "title": "탐색 완료"
      },
      "stage1": {
        "description": "리포지토리 스캔, 루트 디렉토리 구조 및 선택된 루트 표시",
        "title": "리포지토리 스캔 시작"
      },
      "stage2": {
        "description": "git ls-files 실행, 패턴 생성, 바이너리 파일 필터링",
        "title": "Git 통합을 통한 정규식 필터링"
      },
      "title": "실제 파일 탐색"
    },
    "faq": {
      "cost": {
        "answer": "일반적으로 리포지토리 크기와 복잡도에 따라 전체 워크플로우당 $0.10-0.15입니다. 5단계 탐색 프로세스는 지능형 토큰 배치와 콘텐츠 인식 추정을 사용하여 API 비용을 최소화하면서 정확도를 극대화합니다. 비용 추적은 모든 단계에 내장되어 있습니다.",
        "question": "파일 탐색은 실행당 비용이 얼마나 드나요?"
      },
      "excludeDirectories": {
        "answer": "네. 파일 탐색 워크플로우는 자동으로 .gitignore 규칙을 준수합니다. 또한 바이너리 파일과 97개의 일반적인 비코드 확장자가 기본적으로 필터링됩니다. 프로젝트 설정에서 사용자 정의 제외 패턴을 구성할 수도 있습니다.",
        "question": "탐색에서 특정 디렉토리를 제외할 수 있나요?"
      },
      "monorepoSupport": {
        "answer": "네. PlanToCode는 pnpm 워크스페이스, Yarn 워크스페이스, npm 워크스페이스 및 Nx를 포함한 모노레포 구조를 명시적으로 지원합니다. 파일 탐색 워크플로우는 워크스페이스 구성을 파싱하고 내부 패키지 참조, 호이스트된 종속성 및 워크스페이스 프로토콜 임포트를 올바르게 해석합니다.",
        "question": "파일 탐색이 모노레포와 호환되나요?"
      },
      "pathAliases": {
        "answer": "네. 경로 검증 단계는 tsconfig.json 경로 매핑을 이해하고 @/* 또는 ~/*와 같은 TypeScript 별칭을 실제 파일 시스템과 대조하여 해석합니다. 이를 통해 AI가 생성한 임포트가 올바른 별칭 구문을 사용하도록 보장합니다.",
        "question": "TypeScript 경로 별칭과 호환되나요?"
      },
      "stillWrongPath": {
        "answer": "파일 탐색이 경로 환각을 극적으로 줄이지만, AI 모델은 생성 중인 코드에 대한 새 파일 이름을 여전히 생성할 수 있습니다. PlanToCode는 기존 파일 검증에 중점을 둡니다. 새로 생성된 파일의 경우 구현 계획에 명확한 파일 경로가 표시되며 AI 도구에 복사하기 전에 검증할 수 있습니다.",
        "question": "AI가 여전히 잘못된 경로를 제안하면 어떻게 되나요?"
      },
      "title": "자주 묻는 질문",
      "verifiedPaths": {
        "answer": "물론입니다. PlanToCode는 단계별 업데이트와 함께 실시간 진행 상황 추적을 제공합니다. 어떤 디렉토리가 스캔되었는지, 몇 개의 파일이 검증을 통과했는지, 어떤 경로가 수정되었는지, 그리고 AI가 사용할 수 있는 검증된 파일의 최종 목록을 정확히 볼 수 있습니다.",
        "question": "어떤 경로가 검증되었는지 확인할 수 있나요?"
      }
    },
    "gettingStarted": {
      "step1": {
        "description": "macOS, Windows 또는 Linux용으로 설치하세요. 선호하는 AI 모델(Claude, GPT-4, Gemini 또는 로컬 모델)에 연결하세요. 시작하는 데 API 키가 필요하지 않습니다.",
        "title": "PlanToCode 다운로드"
      },
      "step2": {
        "description": "프로젝트를 열고 파일 탐색 워크플로우를 시작하세요. PlanToCode가 자동으로 전체 코드베이스 구조를 스캔하고 검증합니다. 각 단계의 실시간 진행 상황을 확인하세요.",
        "title": "파일 탐색 실행"
      },
      "step3": {
        "description": "AI가 검증된 파일 경로만 사용하여 코드를 생성합니다. 환각된 임포트, 가상의 종속성, 빌드 오류가 없습니다. 확신을 가지고 복사하세요.",
        "title": "검증된 코드 생성"
      },
      "title": "잘못된 파일 경로 방지 시작하기"
    },
    "howPlanToCodePrevents": {
      "monorepoAware": {
        "description": "PlanToCode는 모노레포 구조를 이해하고 워크스페이스 참조, 내부 패키지 경로 및 호이스트된 종속성을 올바르게 해석합니다.",
        "features": [
          "워크스페이스 구성 파싱(pnpm, yarn, npm)",
          "내부 패키지 상호 참조 해석",
          "여러 node_modules 계층 구조 처리",
          "워크스페이스 프로토콜 임포트 감지 및 준수"
        ],
        "title": "모노레포 인식 해석"
      },
      "pathValidation": {
        "description": "탐색 워크플로우의 5단계는 파일 경로를 구체적으로 검증하고 수정합니다. 이는 AI 모델이 코드베이스를 보기 전에 자동으로 수행됩니다.",
        "features": [
          "파일 접근성 및 권한 확인",
          "경로 불일치 자동 해석",
          "모노레포 워크스페이스 프로토콜 처리",
          "tsconfig의 임포트 별칭 매핑 검증"
        ],
        "link": "기술 문서",
        "title": "경로 검증 파이프라인"
      },
      "preExecutionDiscovery": {
        "description": "AI가 코드를 생성하기 전에 PlanToCode는 실제 파일 시스템을 매핑하는 5단계 파일 탐색 워크플로우를 실행합니다. 모든 파일 경로는 컨텍스트에 포함되기 전에 존재하는지 검증됩니다.",
        "features": [
          "git ls-files 통합으로 리포지토리 스캔",
          "실제 파일 시스템에 대한 파일 존재 검증",
          "심볼릭 링크 및 경로 별칭 해석",
          "크로스 플랫폼 호환성을 위한 경로 정규화"
        ],
        "link": "파일 탐색에 대해 알아보기",
        "title": "실행 전 파일 탐색"
      },
      "realTimeFeedback": {
        "description": "단계별 업데이트와 함께 실시간으로 파일 탐색 진행 상황을 확인하세요. AI가 코드를 생성하기 전에 어떤 경로가 검증되고 수정되는지 정확히 볼 수 있습니다.",
        "features": [
          "각 탐색 단계의 실시간 진행 상황 추적",
          "경로 문제에 대한 상세한 오류 메시지",
          "파일 수 및 토큰 사용량 추정",
          "비용 추적: 일반적으로 워크플로우당 $0.10-0.15"
        ],
        "title": "실시간 검증 피드백"
      },
      "title": "PlanToCode가 잘못된 파일 경로를 방지하는 방법"
    },
    "impact": {
      "forDevelopers": {
        "benefits": [
          "가상의 임포트 디버깅을 중단하세요. AI가 처음부터 생성했어야 했던 올바른 경로를 찾기 위해 디렉토리 트리를 탐색하는 시간을 낭비하지 마세요.",
          "더 빠르게 배포하세요. AI가 생성한 코드가 첫 번째 붙여넣기에서 작동하면 속도가 극적으로 증가합니다. 논리에 집중하고 경로 수정은 하지 마세요.",
          "AI 출력을 신뢰하세요. 경로 검증은 신뢰를 구축합니다. 코드를 에디터에 복사하기 전에 임포트가 올바르다는 것을 알 수 있습니다.",
          "레거시 코드 작업하기. 복잡하고 문서화되지 않은 코드베이스는 모든 경로가 현실과 대조하여 검증될 때 탐색 가능해집니다."
        ],
        "title": "개별 개발자를 위해"
      },
      "forTeams": {
        "benefits": [
          "더 빠르게 온보딩하세요. 새 팀원은 검증된 파일 탐색을 통해 코드베이스 구조를 이해합니다. 임포트 규칙을 추측할 필요가 없습니다.",
          "PR 노이즈를 줄이세요. 잘못된 임포트 경로를 수정하는 커밋만 제거하세요. 코드 리뷰는 논리에 집중하고 경로 수정은 하지 않습니다.",
          "모노레포를 자신 있게 확장하세요. 워크스페이스가 커질수록 경로 검증은 임포트 혼란의 기하급수적 증가를 방지합니다.",
          "AI 사용을 표준화하세요. 모두가 검증된 경로를 사용하면 AI가 생성한 코드가 팀 전체에서 일관성을 유지합니다."
        ],
        "title": "엔지니어링 팀을 위해"
      },
      "metrics": {
        "cost": "$0.12 검증 워크플로우당 평균 비용",
        "disclaimer": "200개에서 5,000개 파일에 이르는 모노레포 코드베이스를 사용한 내부 테스트 기반입니다. 결과는 리포지토리 구조 및 복잡도에 따라 다를 수 있습니다.",
        "reduction": "85% 경로 관련 디버깅 시간 감소",
        "speed": "23초 589개 파일 평균 스캔 시간",
        "title": "측정된 영향"
      },
      "title": "검증된 파일 경로의 영향"
    },
    "problem": {
      "description": "AI에게 컴포넌트를 리팩토링하라고 요청합니다. AI는 자신 있게 존재하지 않는 파일인 @/components/ui/NewButton에서 임포트하는 코드를 생성합니다. 빌드가 실패합니다. 가상의 임포트를 추적하는 데 20분을 낭비합니다.",
      "quote": "AI가 존재하지 않는 경로에서 임포트를 시도했습니다",
      "scenarios": {
        "contextWindow": {
          "description": "대형 프로젝트는 AI 컨텍스트 윈도우를 초과합니다. 모델은 불완전한 정보를 기반으로 파일 위치를 추측하여 자신 있지만 잘못된 경로 참조를 생성합니다.",
          "title": "컨텍스트 윈도우 제한"
        },
        "legacy": {
          "description": "코드베이스에 src/components와 lib/components가 있습니다. AI는 잘못된 것을 선택하거나 결코 존재하지 않았던 세 번째 디렉토리를 환각합니다.",
          "title": "레거시 코드 혼란"
        },
        "monorepo": {
          "description": "AI가 @workspace/core를 @workspace/shared와 혼동하여 그럴듯해 보이지만 잘못된 패키지를 참조하는 임포트를 생성합니다.",
          "title": "모노레포 악몽"
        }
      },
      "title": "잘못된 파일 경로 문제"
    },
    "realWorldScenarios": {
      "title": "실제 시나리오",
      "with": {
        "description": "파일 탐색이 경로 오류를 방지하고, 첫 시도에 올바른 임포트를 생성하며, 수 시간의 디버깅 시간을 절약하는 방법을 보여주는 시나리오입니다.",
        "title": "PlanToCode 검증 사용"
      },
      "without": {
        "description": "검증 없이 리팩토링할 때 경로 환각 문제를 보여주는 시나리오로, 임포트 오류 및 수동 경로 수정 작업이 발생합니다.",
        "title": "경로 검증 없음"
      }
    },
    "title": "AI가 잘못된 파일 경로를 생성하는 것을 중지하세요",
    "whyAIGeneratesWrongPaths": {
      "contextOverflow": {
        "description": "200K 토큰 컨텍스트 윈도우도 전체 엔터프라이즈 코드베이스를 담을 수 없습니다. 모델은 파일의 일부만 보고 나머지를 추론하여 경로 불일치를 초래합니다.",
        "points": [
          "불완전한 디렉토리 트리 가시성",
          "누락된 임포트 별칭 구성",
          "진화하는 코드베이스의 오래된 스냅샷"
        ],
        "title": "컨텍스트 윈도우 오버플로"
      },
      "modelHallucination": {
        "description": "대형 언어 모델은 다양한 구조를 가진 수백만 개의 코드베이스로 훈련됩니다. 코드를 생성할 때 실제 파일 시스템이 아닌 훈련 데이터와 패턴 매칭합니다.",
        "points": [
          "모델은 실제 경로가 아닌 가능성 있는 경로를 예측합니다",
          "훈련 데이터에 일관성 없는 명명 규칙이 포함됩니다",
          "생성 루프에 파일 시스템 검증이 없습니다"
        ],
        "title": "모델 환각"
      },
      "monorepoComplexity": {
        "description": "모노레포는 워크스페이스 프로토콜, 내부 패키지 및 여러 node_modules 디렉토리로 경로 혼란을 증폭시킵니다.",
        "points": [
          "워크스페이스 간 패키지 이름 충돌",
          "복잡한 tsconfig 경로 매핑",
          "불명확한 해석을 가진 호이스트된 종속성"
        ],
        "title": "모노레포 복잡성"
      },
      "noVerification": {
        "description": "표준 AI 코드 생성에는 파일 존재를 검증하는 후처리 단계가 없습니다. 생성된 코드는 파일 시스템 검사 없이 직접 사용자에게 전달됩니다.",
        "points": [
          "파일 존재 검증 없음",
          "임포트 경로 해석 테스트 없음",
          "실제 디렉토리 구조와의 상호 참조 없음"
        ],
        "title": "검증 레이어 없음"
      },
      "title": "AI가 잘못된 파일 경로를 생성하는 이유"
    }
  },
  "hardBugs": {
    "badge": "프로덕션 디버깅",
    "cta": {
      "description": "모든 조사를 보존하고, 모든 단계를 재현하며, 컨텍스트를 잃지 마세요. 이것이 프로덕션 디버깅이 작동해야 하는 방식입니다: 체계적이고, 재현 가능하며, 완전합니다.",
      "links": {
        "terminal": "터미널 지속성 탐색",
        "voice": "음성 메모에 대해 알아보기"
      },
      "title": "자신감을 가지고 프로덕션 문제 디버그하기"
    },
    "description": "PlanToCode는 디버깅 중인 작업에 모든 계획, 터미널 세션 및 음성 메모를 첨부된 상태로 유지합니다. 문제를 격리하는 데 사용된 정확한 명령, 토큰 예산 및 계획 수정을 다시 엽니다.",
    "sections": {
      "persistTerminal": {
        "description": "각 디버깅 터미널은 관리되는 PTY 내에서 실행됩니다. 세션 메타데이터, 작업 디렉토리 및 전체 출력 로그가 SQLite에 저장되며 충돌 후 다시 열 수 있습니다. CLI 감지는 claude, cursor, codex 또는 gemini 바이너리가 명령을 실행하기 전에 설치되었는지 확인합니다.",
        "link": "터미널 동작",
        "title": "터미널 출력 지속"
      },
      "reproduceSurface": {
        "description": "파일 탐색 워크플로우로 시작하여 사건에서 참조된 모듈로 리포지토리를 좁힙니다. 워크플로우는 세션 입력을 검증하고, 백그라운드 작업을 대기열에 넣고, 선택된 루트를 저장하여 모든 후속 계획이 동일한 범위를 사용하도록 합니다.",
        "link": "워크플로우 세부 정보",
        "title": "실패 표면 재현"
      },
      "reviewFixes": {
        "description": "구현 계획은 언어 감지, 복사 컨트롤 및 이전 작업 간 탐색 기능이 있는 Monaco 뷰어로 스트리밍됩니다. 토큰 추정은 프롬프트를 외부 도구에 복사하기 전에 실행되어 수정이 모델의 제한 내에 있는지 확인하는 데 도움이 됩니다.",
        "link": "계획 뷰어 개요",
        "title": "제안된 모든 수정 검토"
      },
      "voiceNotes": {
        "description": "음성 전사는 터미널 및 프롬프트 편집기와 직접 통합됩니다. 녹음 후크는 마이크 권한, 장치 선택, 무음 감지를 관리하고 트리거한 명령 옆에 인식된 텍스트를 삽입합니다.",
        "link": "전사 파이프라인",
        "title": "컨텍스트에서 음성 메모 캡처"
      }
    },
    "title": "보존된 컨텍스트로 어려운 버그 해결"
  },
  "hub": {
    "badge": "개발 솔루션",
    "categories": {
      "debugging": "디버깅",
      "development": "개발",
      "maintenance": "유지보수",
      "refactoring": "리팩토링",
      "safety": "안전성"
    },
    "cta": {
      "button": "PlanToCode 다운로드",
      "description": "자신감을 가지고 복잡한 변경 사항을 계획하기 시작하세요. 지금 PlanToCode를 다운로드하세요.",
      "title": "개발 과제를 해결할 준비가 되셨나요?"
    },
    "description": "AI 기반 계획으로 복잡한 개발 과제를 해결하세요. 어려운 버그 디버깅부터 레거시 코드 리팩토링까지, PlanToCode는 팀에 필요한 안전 계층을 제공합니다.",
    "solutions": {
      "aiWrongPaths": {
        "description": "실행 전 AI가 생성한 경로를 검토하여 파일 위치 오류 방지",
        "title": "잘못된 경로 방지"
      },
      "hardBugs": {
        "description": "재현 가능한 버그 조사를 위해 계획 이력, 터미널 로그 및 전사 캡처",
        "title": "어려운 버그 해결"
      },
      "largeFeatures": {
        "description": "종속성 매핑 및 단계별 실행으로 다중 파일 기능 계획 및 추적",
        "title": "대형 기능"
      },
      "legacyCodeRefactoring": {
        "description": "레거시 코드베이스의 안전한 현대화를 위한 AI 기반 계획",
        "title": "레거시 코드 리팩토링"
      },
      "libraryUpgrades": {
        "description": "영향 분석 및 종합 테스트로 종속성을 안전하게 업그레이드",
        "title": "라이브러리 업그레이드"
      },
      "maintenanceEnhancements": {
        "description": "감사 추적으로 진행 중인 작업을 문서화하고 회귀 방지",
        "title": "유지보수 및 개선"
      },
      "preventDuplicateFiles": {
        "description": "실행 전 파일 탐색으로 AI가 중복 파일을 만드는 것을 방지",
        "title": "중복 파일 방지"
      },
      "safeRefactoring": {
        "description": "종속성 가시성을 통한 무위험 코드 변경을 위한 AI 기반 계획",
        "title": "안전한 리팩토링"
      }
    },
    "title": "AI 기반 개발 솔루션",
    "viewSolution": "솔루션 보기"
  },
  "largeFeatures": {
    "badge": "기능 계획",
    "cta": {
      "description": "첫 번째 워크플로우부터 최종 배포까지 완벽한 추적성을 유지하세요. 이것이 기능 제공이 작동해야 하는 방식입니다: 조정되고, 예측 가능하며, 추적 가능합니다.",
      "links": {
        "plans": "구현 계획 보기",
        "workflows": "범위가 지정된 워크플로우에 대해 알아보기"
      },
      "title": "자신감을 가지고 복잡한 기능 제공"
    },
    "description": "다단계 제공은 일관된 범위, 검토 가능한 계획 및 예측 가능한 토큰 사용에 의존합니다. PlanToCode는 첫 번째 워크플로우 실행부터 최종 터미널 세션까지 이러한 신호를 연결된 상태로 유지합니다.",
    "sections": {
      "coordinatePlans": {
        "description": "계획은 Monaco 뷰어로 스트리밍되며 백그라운드 작업에 연결된 상태로 유지됩니다. 이전 초안을 탐색하고, 여러 계획을 병합하고, 컨텍스트를 잃지 않고 특정 작업에 대한 터미널 모달을 엽니다. 토큰 추정은 프롬프트를 내보내기 전에 실행됩니다.",
        "link": "구현 계획",
        "title": "구현 계획 조정"
      },
      "keepAligned": {
        "description": "터미널 세션은 SQLite에 출력 로그를 저장하고 연결 상태를 노출하므로 장기 실행 기능 작업이 감사 가능한 상태로 유지됩니다. 팀이 워크스루를 녹음하는 경우 음성 전사는 실행된 명령 옆에 검색 가능한 메모를 추가합니다.",
        "link": "터미널 및 전사",
        "title": "실행을 정렬된 상태로 유지"
      },
      "pickModel": {
        "description": "각 작업 유형은 기본 모델과 허용 목록을 제공합니다. 모델 선택기 토글은 모델의 컨텍스트 윈도우를 초과하는 프롬프트 전송을 방지하고 백엔드 명령에서 가져온 추정 토큰 요구 사항을 표시합니다.",
        "link": "모델 구성",
        "title": "작업별로 올바른 모델 선택"
      },
      "sameScope": {
        "description": "파일 탐색 워크플로우를 사용하여 모든 작업에 대한 관련 디렉토리를 수집합니다. 입력이 검증되고, 백그라운드 작업이 워크플로우 오케스트레이터를 통해 실행되며, 선택된 루트가 저장되어 나중에 계획 수정이 동일한 리포지토리 슬라이스를 재사용합니다.",
        "link": "파일 탐색 워크플로우",
        "title": "동일한 범위로 시작"
      }
    },
    "title": "추적 가능한 계획으로 대형 기능 제공"
  },
  "legacyCodeRefactoring": {
    "challenge": {
      "description": "5년 된 코드베이스를 현대화하는 임무를 맡았습니다: 오래된 프레임워크, 테스트 없음, 문서화되지 않은 패턴, 그리고 완전히 이해하지 못하는 중요한 비즈니스 로직. 직접적인 AI 리팩토링은 혼란이 될 것입니다. 계획은 로드맵을 제공합니다.",
      "title": "레거시 코드 과제"
    },
    "cta": {
      "buttons": {
        "download": "PlanToCode 다운로드",
        "learnMapping": "종속성 매핑에 대해 알아보기"
      },
      "description": "PlanToCode는 종속성을 매핑하고, 마이그레이션 계획을 생성하며, 프로덕션을 중단시키지 않고 리팩토링하는 데 도움을 줍니다.",
      "title": "레거시 코드를 안전하게 현대화하세요"
    },
    "description": "레거시 코드는 AI 지원 리팩토링이 위험해지는 곳입니다. 한 번의 잘못된 움직임이 프로덕션을 중단시킵니다. AI 계획으로 10만 라인 이상의 코드베이스를 안전하게 현대화하는 방법은 다음과 같습니다.",
    "furtherReading": {
      "bestPractices": "AI 코드 계획 모범 사례",
      "safeRefactoring": "프로덕션 코드를 위한 안전한 리팩토링 도구",
      "title": "추가 읽기",
      "whatIsPlanning": "AI 코드 계획이란 무엇인가?"
    },
    "gettingStarted": {
      "steps": [
        {
          "title": "리팩토링할 가장 작은 가치 있는 단위 선택",
          "description": "10,000라인 God 클래스로 시작하지 마세요. 가치를 제공하는 자체 포함된 200라인 모듈을 찾으세요."
        },
        {
          "title": "모든 종속성 매핑",
          "description": "파일 탐색을 사용하여 임포트, 익스포트, 함수 호출을 찾으세요. 폭발 반경을 파악하세요."
        },
        {
          "title": "특성화 테스트 작성",
          "description": "잘못된 경우에도 현재 동작을 캡처하는 테스트입니다. 리팩토링이 기능을 보존하도록 보장합니다."
        },
        {
          "title": "리팩토링 계획 생성",
          "description": "AI를 사용하여 파일별 마이그레이션 전략을 생성합니다. 누락된 단계나 위험을 검토합니다."
        },
        {
          "title": "점진적으로 실행",
          "description": "배포당 하나의 작은 변경. 테스트를 실행합니다. 프로덕션을 모니터링합니다. 반복합니다."
        }
      ],
      "title": "레거시 리팩토링 시작하기"
    },
    "mistakes": {
      "bigBang": {
        "instead": "대신: 지속적인 배포를 통한 점진적 리팩토링",
        "problem": "모든 것을 처음부터 다시 작성하는 데 6개월을 소비합니다. 80% 완료되었을 때 오래된 코드에 몰랐던 엣지 케이스가 있다는 것을 깨닫습니다. 프로젝트가 실패합니다.",
        "title": "빅뱅 재작성"
      },
      "noRollback": {
        "instead": "대신: 기능 플래그, down() 함수가 있는 데이터베이스 마이그레이션",
        "problem": "50개 파일을 리팩토링하고 배포하면 프로덕션이 중단됩니다. 변경 사항이 얽혀 있어 쉽게 되돌릴 수 없습니다.",
        "title": "롤백 계획 없음"
      },
      "noTests": {
        "instead": "대신: 먼저 특성화 테스트를 작성한 다음 리팩토링",
        "problem": "코드를 변경하고, 작동하기를 바라며, 배포하고, 프로덕션에서 버그를 찾습니다. 신뢰를 잃을 때까지 반복합니다.",
        "title": "테스트 없이 리팩토링"
      },
      "title": "일반적인 레거시 리팩토링 실수 피하기"
    },
    "patterns": {
      "featureFlag": {
        "bestFor": "중요한 경로에 대한 고위험 변경(인증, 결제, 핵심 기능)",
        "howItWorks": "코드를 리팩토링하고 기능 플래그 뒤에 배치합니다. 수주에 걸쳐 사용자의 1%, 10%, 50%, 100%에게 롤아웃합니다. 문제 발생 시 즉시 롤백합니다.",
        "title": "기능 플래그 롤아웃"
      },
      "parallelRun": {
        "bestFor": "데이터 처리 파이프라인, 중요한 알고리즘, 보고 시스템",
        "howItWorks": "오래된 코드와 새 코드를 병렬로 실행합니다. 출력을 비교합니다. 99.9% 일치율이 달성되면 새 코드로만 전환합니다.",
        "title": "병렬 실행 + 검증"
      },
      "stranglerFig": {
        "bestFor": "모놀리스 → 마이크로서비스, 오래된 프레임워크 → 새 프레임워크",
        "howItWorks": "오래된 코드 옆에 새 코드를 빌드합니다. 점진적으로 오래된 것에서 새 것으로 트래픽을 라우팅합니다. 100% 마이그레이션되었을 때만 오래된 코드를 삭제합니다.",
        "title": "Strangler Fig 패턴"
      },
      "title": "마이그레이션 전략 패턴"
    },
    "realExample": {
      "codebase": "2018년에 작성된 150개의 React 클래스 컴포넌트. 유지보수성과 성능을 위해 Hooks로 현대화해야 합니다.",
      "scenario": "시나리오",
      "title": "실제 예시: React 클래스를 Hooks로 마이그레이션",
      "with": {
        "steps": [
          "1주차: 리프 컴포넌트 마이그레이션(종속성 없음)",
          "2주차: 컨텍스트 프로바이더 마이그레이션(모든 소비자에 영향)",
          "3주차: 컨테이너 컴포넌트 마이그레이션(자식 오케스트레이션)",
          "4주차: 오래된 HOC 제거, 완전히 Hooks 기반",
          "결과: 깨끗한 마이그레이션, 프로덕션 중단 없음, 4주 일정"
        ],
        "title": "계획 사용:"
      },
      "without": {
        "steps": [
          "AI가 10개 컴포넌트를 변환",
          "다른 컴포넌트가 의존하는 라이프사이클 종속성 중단",
          "컨텍스트 프로바이더가 작동 중지(클래스 기반 API)",
          "모든 중단을 찾는 데 3일의 디버깅"
        ],
        "title": "계획 없이:"
      }
    },
    "scenarios": {
      "databaseSchema": {
        "approach": "계획 접근 방식:",
        "challenge": "2018년부터 비정규화된 스키마. user_data 테이블을 5개의 정규화된 테이블로 분할해야 합니다.",
        "steps": [
          "user_data에서 읽는 모든 쿼리 찾기(grep + 정적 분석)",
          "어떤 쿼리가 어떤 새 테이블을 필요로 하는지 매핑",
          "이중 쓰기 단계로 제로 다운타임 마이그레이션 계획",
          "데이터 일관성을 보장하기 위한 검증 쿼리 생성"
        ],
        "title": "데이터베이스 스키마 마이그레이션"
      },
      "frameworkMigration": {
        "approach": "계획 접근 방식:",
        "challenge": "DOM을 직접 조작하는 200페이지의 스파게티 jQuery. 컴포넌트 구조 없음. 모든 곳에 혼합된 관심사.",
        "steps": [
          "모든 jQuery 선택기를 매핑하여 UI 컴포넌트 식별",
          "관련 DOM 조작을 논리적 컴포넌트로 그룹화",
          "점진적 마이그레이션 계획: 한 번에 한 페이지씩, 두 프레임워크 공존",
          "전환 중 공유 상태를 위한 어댑터 레이어 생성"
        ],
        "title": "프레임워크 마이그레이션(jQuery → React)"
      },
      "monolith": {
        "approach": "계획 접근 방식:",
        "challenge": "500K라인 모놀리스, 모든 기능이 긴밀하게 결합됨. 사용자 관리를 별도 서비스로 추출해야 합니다.",
        "steps": [
          "서비스 경계 식별: 무엇이 유지되고 무엇이 이동하는지",
          "모든 경계 간 데이터 흐름 및 API 호출 매핑",
          "데이터베이스 추출 전략 계획(이중 쓰기 단계)",
          "각 마이그레이션 단계에 대한 롤백 계획 생성"
        ],
        "title": "모놀리스에서 마이크로서비스로"
      },
      "title": "일반적인 레거시 리팩토링 시나리오"
    },
    "title": "레거시 코드 리팩토링 도구: AI 계획이 재해를 방지하는 방법",
    "tools": {
      "complexity": {
        "description": "가장 복잡한 파일을 식별합니다(순환 복잡도). 간단한 것부터 리팩토링을 시작하세요.",
        "title": "코드 복잡도 분석",
        "tools": "도구: SonarQube, ESLint complexity rules"
      },
      "dependencyMapping": {
        "description": "모든 임포트 체인, 함수 호출 그래프, 타입 종속성을 찾습니다. X를 변경하면 무엇이 중단되는지 파악하세요.",
        "title": "종속성 매핑",
        "tools": "도구: PlanToCode 파일 탐색, madge, dependency-cruiser"
      },
      "staticAnalysis": {
        "description": "사용하지 않는 코드, 죽은 임포트, 타입 불일치를 찾습니다. 주요 리팩토링 전에 이를 정리하세요.",
        "title": "정적 분석",
        "tools": "도구: TypeScript strict mode, ESLint no-unused-vars"
      },
      "testCoverage": {
        "description": "리팩토링하기 전에 어떤 코드에 테스트가 있는지 파악하세요. 필요한 경우 중요한 경로에 대한 테스트를 먼저 작성하세요.",
        "title": "테스트 커버리지 보고서",
        "tools": "도구: Jest coverage, Istanbul, Codecov"
      },
      "title": "레거시 코드 계획을 위한 도구"
    },
    "whyBreaks": {
      "description": "레거시 코드베이스에는 리팩토링을 위험하게 만드는 특성이 있습니다:",
      "points": {
        "hiddenDeps": {
          "description": "20개 이상의 장소에서 호출되는 함수, 예기치 않게 수정된 글로벌 상태, 존재하는지 몰랐던 순환 임포트.",
          "title": "숨겨진 종속성"
        },
        "insufficientTests": {
          "description": "30% 코드 커버리지, 통과하지만 실제로 동작을 검증하지 않는 테스트, 실행하는 데 45분이 걸리는 통합 테스트.",
          "title": "불충분한 테스트"
        },
        "outdatedPatterns": {
          "description": "현대적인 모범 사례 이전에 작성된 코드. 콜백 지옥, 긴밀하게 결합된 모듈, 관심사의 분리 없음.",
          "title": "오래된 패턴"
        },
        "poorDocs": {
          "description": "주석 없음, 모호한 변수 이름, 구현 세부 사항에 묻힌 비즈니스 로직. 깨뜨려서 배웁니다.",
          "title": "열악한 문서화"
        }
      },
      "title": "레거시 코드가 쉽게 중단되는 이유"
    },
    "workflow": {
      "steps": [
        {
          "title": "기존 시스템 매핑",
          "description": "파일 탐색을 실행하고 리팩토링하는 영역에 닿는 모든 파일을 식별합니다. 무엇이든 변경하기 전에 종속성을 이해하세요."
        },
        {
          "title": "여러 마이그레이션 전략 생성",
          "description": "AI에게 3가지 다른 접근 방식을 요청하세요: 빅뱅 마이그레이션, 점진적 롤아웃, strangler fig 패턴. 트레이드오프를 비교하세요."
        },
        {
          "title": "점진적 계획 생성",
          "description": "주간 마일스톤으로 나눕니다. 각 단계는 독립적으로 배포 및 테스트 가능해야 합니다. 프로덕션에서 \"반 마이그레이션된\" 상태가 없어야 합니다."
        },
        {
          "title": "팀과 검토(레거시에 필수)",
          "description": "팀의 누군가는 숨겨진 문제점을 알고 있습니다. 계획 검토는 깨뜨리기 전에 그 부족한 지식을 표면화합니다."
        },
        {
          "title": "롤백 계획으로 실행",
          "description": "1단계를 구현하고 작동하는지 확인한 다음 2단계로 넘어갑니다. 항상 되돌릴 방법이 있어야 합니다. 기능 플래그는 친구입니다."
        }
      ],
      "subtitle": "안전한 레거시 리팩토링 프로세스",
      "title": "계획 우선 리팩토링 워크플로우"
    }
  },
  "libraryUpgrades": {
    "badge": "업그레이드 계획",
    "cta": {
      "description": "모든 변경 사항을 감사하고, 모든 마이그레이션을 추적하며, 완전한 제어를 유지하세요. 이것이 라이브러리 업그레이드가 작동해야 하는 방식입니다: 안전하고, 감사 가능하며, 되돌릴 수 있습니다.",
      "links": {
        "planning": "업그레이드 계획 탐색",
        "scope": "범위 분석에 대해 알아보기"
      },
      "title": "두려움 없이 종속성 업그레이드"
    },
    "description": "종속성 현대화는 종종 여러 리포지토리와 팀에 걸쳐 있습니다. PlanToCode는 작업 범위를 지정하고, 각 단계를 문서화하며, 변경된 내용에 대한 감사 가능한 추적을 유지하는 데 도움을 줍니다.",
    "sections": {
      "executionHistory": {
        "description": "터미널 세션은 재시작 후에도 전체 출력 로그와 연결 상태를 유지합니다. 음성 전사는 까다로운 마이그레이션 단계에 음성 컨텍스트를 추가하여 릴리스 노트 및 변경 검토를 위한 검색 가능한 추적을 생성할 수 있습니다.",
        "link": "터미널 및 전사",
        "title": "실행 이력 문서화"
      },
      "identifyFiles": {
        "description": "프로젝트 디렉토리에 대해 파일 탐색 워크플로우를 트리거하여 업그레이드 핫스팟을 수집합니다. 오케스트레이션된 백그라운드 작업은 선택된 루트를 기록하고 모든 후속 계획 또는 프롬프트에서 사용할 수 있도록 만듭니다.",
        "link": "파일 탐색 워크플로우",
        "title": "영향을 받는 파일 식별"
      },
      "modelLimits": {
        "description": "업그레이드 프롬프트에는 종종 큰 차이가 포함됩니다. 작업 수준 모델 설정은 허용되는 모델을 정의하며, 선택기 토글은 컨텍스트 윈도우가 추정 프롬프트 플러스 출력 토큰을 처리할 수 없는 선택을 차단합니다.",
        "link": "모델 가드레일",
        "title": "모델 제한 내에서 유지"
      },
      "trackPlans": {
        "description": "Monaco 뷰어 내에서 생성된 계획을 검토하고, 수정 버전을 비교하고, 중복되는 제안을 병합합니다. 계획은 백그라운드 작업에 연결된 상태로 유지되므로 업그레이드를 재방문할 때마다 관련 터미널 세션 또는 프롬프트 복사 모달을 다시 열 수 있습니다.",
        "link": "구현 계획",
        "title": "업그레이드 계획 추적"
      }
    },
    "title": "가드레일을 사용하여 라이브러리 업그레이드"
  },
  "maintenanceEnhancements": {
    "badge": "지속적인 유지보수",
    "cta": {
      "description": "체계적인 유지보수 워크플로우를 구축하세요. 보존된 컨텍스트, 재사용 가능한 계획 및 모델 가드레일은 기술 부채를 관리 가능하고 반복 가능한 프로세스로 전환합니다.",
      "links": {
        "history": "계획 이력에 대해 알아보기",
        "workflows": "범위가 지정된 워크플로우 탐색"
      },
      "title": "유지보수를 전략적 이점으로 전환하세요"
    },
    "description": "유지보수 작업은 팀이 범위를 추적하지 못하거나 동일한 조사를 반복할 때 느려집니다. PlanToCode는 수정을 안전하게 적용하는 데 필요한 컨텍스트, 계획 및 실행 이력을 유지합니다.",
    "sections": {
      "controlModels": {
        "description": "모델 선택기 토글은 유지보수 작업당 컨텍스트 윈도우를 적용합니다. 백엔드의 토큰 추정을 통해 큰 패치 설명이 에이전트에 보내기 전에 선택한 모델에 여전히 맞는지 확인할 수 있습니다.",
        "link": "모델 가드레일",
        "title": "모델 사용 제어"
      },
      "planHistory": {
        "description": "유지보수 계획은 수정 버전 간 탐색, 병합 작업 및 프롬프트 복사 컨트롤이 있는 Monaco 뷰어로 스트리밍됩니다. 이전 작업을 다시 열어 정확히 어떤 단계가 수행되었는지 그리고 반복해야 하는지 확인합니다.",
        "link": "구현 계획",
        "title": "계획 이력 유지"
      },
      "preserveLogs": {
        "description": "터미널 세션은 타임스탬프, 종료 코드 및 캡처된 출력과 함께 SQLite에 지속됩니다. 음성 전사는 동일한 작업에 음성 메모를 추가할 수 있어 향후 유지보수 담당자에게 무엇이 변경되었고 이유에 대한 전체 컨텍스트를 제공합니다.",
        "link": "터미널 및 전사",
        "title": "실행 로그 보존"
      },
      "reuseWorkflows": {
        "description": "파일 탐색 작업은 이전 유지보수 작업에서 건드린 디렉토리를 수집합니다. 유사한 작업이 돌아오면 범위를 수동으로 재구축하는 대신 저장된 루트에 대해 계획을 재실행할 수 있습니다.",
        "link": "파일 탐색 워크플로우",
        "title": "범위가 지정된 워크플로우 재사용"
      }
    },
    "title": "반복 가능한 워크플로우로 시스템 유지보수"
  },
  "preventDuplicateFiles": {
    "badge": "중복 파일 방지",
    "beforeAfter": {
      "title": "전후 비교: 계획 없는 AI vs PlanToCode 사용",
      "with": {
        "benefits": {
          "items": [
            "생성된 중복 파일 제로",
            "기존 코드에 대한 깔끔한 수정",
            "모든 임포트가 유효한 상태 유지",
            "절약된 시간: 2-4시간"
          ],
          "title": "달성된 이점:"
        },
        "steps": [
          {
            "label": "사용자: \"인증에 JWT 검증 추가\"",
            "detail": "파일 탐색 워크플로우가 자동으로 시작됩니다"
          },
          {
            "label": "5단계 탐색이 전체 코드베이스 매핑",
            "detail": "authService.ts, auth-helpers.ts, 관련 구성 파일 찾기"
          },
          {
            "label": "검토를 위한 구현 계획 생성",
            "detail": "기존 authService.ts를 수정하고 중복을 생성하지 않음을 보여줍니다"
          },
          {
            "label": "계획을 검토하고 승인",
            "detail": "코드가 파일 시스템에 닿기 전에 정확한 변경 사항 확인"
          },
          {
            "label": "결과: 깔끔하고 목표가 명확한 수정",
            "detail": "JWT 검증이 기존 authService.ts에 추가되고 중복이 생성되지 않음"
          }
        ],
        "title": "PlanToCode 사용"
      },
      "without": {
        "cleanup": {
          "items": [
            "중복 코드를 수동으로 병합",
            "모든 임포트 참조 업데이트",
            "깨진 테스트 및 종속성 수정",
            "낭비된 시간: 2-4시간"
          ],
          "title": "필요한 수동 정리:"
        },
        "steps": [
          {
            "label": "사용자: \"인증에 JWT 검증 추가\"",
            "detail": "AI는 제한된 컨텍스트를 가지며 현재 열린 파일만 봅니다"
          },
          {
            "label": "AI가 검색하지만 기존 인증 파일을 찾지 못함",
            "detail": "명명/경로 불일치로 src/services/authService.ts를 놓침"
          },
          {
            "label": "즉시 jwtValidation.ts를 생성",
            "detail": "검토 단계 없음, 변경 사항이 파일 시스템에 직접 적용됨"
          },
          {
            "label": "결과: 중복 파일 생성됨",
            "detail": "이제 중복된 기능을 가진 authService.ts와 jwtValidation.ts가 모두 있습니다"
          }
        ],
        "title": "PlanToCode 없이"
      }
    },
    "cta": {
      "description": "실행 전 파일 탐색. 적용 전 검토. 중복 제로. 이것이 AI 지원 개발이 작동해야 하는 방식입니다: 지능적이고, 예방적이며, 깔끔합니다.",
      "links": {
        "howItWorks": "작동 방식 보기",
        "planReview": "계획 검토에 대해 알아보기",
        "technical": "기술 가이드 읽기"
      },
      "title": "오늘부터 중복 파일 생성 중지"
    },
    "description": "AI 코딩 도구는 기존 코드 구조에 대한 컨텍스트가 부족하여 중복 파일을 자주 생성합니다. PlanToCode는 코드를 생성하기 전에 전체 코드베이스를 매핑하는 지능형 파일 탐색으로 이를 해결합니다.",
    "faq": {
      "discoveryCost": {
        "answer": "파일 탐색은 관련성 평가 단계(3단계)에 AI를 사용하므로 소량의 API 비용이 발생합니다. 그러나 비용은 최소화되며(일반적으로 탐색 실행당 $0.01-0.05) 시스템은 실행 전에 비용 추정치를 제공합니다. 중복 방지로 절약되는 2-4시간의 수동 정리 시간과 비교할 때 투자할 가치가 있습니다.",
        "question": "파일 탐색을 실행하는 데 비용이 드나요?"
      },
      "discoveryTime": {
        "answer": "파일 탐색은 일반적으로 중간 규모 프로젝트(500-2000개 파일)의 경우 30-90초 안에 완료됩니다. 10,000개 이상의 파일이 있는 매우 큰 모노레포는 2-3분이 걸릴 수 있습니다. 워크플로우는 백그라운드에서 실행되므로 실행하는 동안 계속 작업할 수 있습니다. 진행 상황 업데이트가 실시간으로 나타납니다.",
        "question": "파일 탐색 워크플로우는 얼마나 걸리나요?"
      },
      "hugeCodebase": {
        "answer": "PlanToCode는 지능형 타임아웃 관리 및 캐싱 메커니즘을 포함합니다. 극도로 큰 코드베이스의 경우 사용자 정의 타임아웃 값을 구성하고 제외 패턴을 사용하여 관련 없는 디렉토리(벤더 코드, 생성된 파일 등)를 건너뛸 수 있습니다. 시스템은 세션당 탐색 결과를 캐시하므로 동일한 세션의 후속 계획은 캐시된 파일 컨텍스트를 재사용합니다.",
        "link": "구성 옵션",
        "question": "거대한 코드베이스가 있으면 어떻게 되나요? 탐색이 타임아웃되나요?"
      },
      "newFiles": {
        "answer": "물론입니다. PlanToCode의 파일 탐색은 새 파일 생성을 방지하는 것이 아니라 중복 파일 생성을 방지합니다. 작업에 진정으로 새 파일이 필요한 경우(완전히 새로운 기능 모듈 추가 등) PlanToCode는 구현 계획에서 생성을 제안합니다. 차이점은 제안을 보고 실수로 중복된 것이 아니라 진정으로 새로운 기능인지 확인할 수 있다는 것입니다.",
        "question": "필요할 때 진정으로 새로운 파일을 생성할 수 있나요?"
      },
      "nonJavaScript": {
        "answer": "네. PlanToCode의 파일 탐색은 언어에 구애받지 않습니다. Python, Go, Rust, Java, TypeScript, JavaScript, Ruby, PHP, C++ 및 기타 텍스트 기반 코드베이스와 함께 작동합니다. 정규식 생성 및 AI 관련성 평가는 작업 설명 및 발견된 파일 확장자를 기반으로 프로젝트의 특정 언어 및 프레임워크에 적응합니다.",
        "question": "비JavaScript 프로젝트에서도 작동하나요?"
      },
      "refactoringDuplicates": {
        "answer": "네. 코드베이스에 이미 중복 파일이 있는 경우 PlanToCode를 사용하여 통합을 계획할 수 있습니다. 작업을 \"중복 인증 서비스를 authService.ts로 병합\" 등으로 설명하세요. 파일 탐색은 모든 관련 파일을 찾고 구현 계획은 깔끔하게 통합하는 방법을 정확히 보여줍니다.",
        "question": "기존 중복을 리팩토링하는 데 PlanToCode를 사용할 수 있나요?"
      },
      "stillProposesDuplicate": {
        "answer": "파일 탐색이 포괄적인 컨텍스트를 제공하므로 이는 드물지만, 발생하면 검토 단계에서 발견할 수 있습니다. 계획을 거부하고, 작업 설명을 구체화하거나(수정할 기존 파일에 대해 더 구체적으로), 파일 선택을 수동으로 조정하기만 하면 됩니다. 주요 이점은 손상이 발생한 후가 아니라 실행 전에 중복을 발견하는 것입니다.",
        "question": "AI가 계획에서 여전히 중복을 제안하면 어떻게 되나요?"
      },
      "title": "자주 묻는 질문",
      "worksWithCursor": {
        "answer": "네. PlanToCode는 기존 AI 코딩 도구와 함께 작동하는 계획 레이어로 설계되었습니다. PlanToCode를 사용하여 파일을 탐색하고 구현 계획을 생성한 다음 Cursor, GitHub Copilot, Claude Code 또는 다른 AI 어시스턴트를 사용하여 해당 계획을 실행합니다. 파일 탐색 및 계획은 어떤 도구가 코드를 실행하든 관계없이 중복을 방지합니다.",
        "question": "PlanToCode가 Cursor 및 GitHub Copilot과 호환되나요?"
      }
    },
    "gettingStarted": {
      "step1": {
        "description": "플랫폼에 맞는 PlanToCode 데스크톱 애플리케이션을 다운로드하세요. 파일 탐색 워크플로우 및 구현 계획 기능이 데스크톱 클라이언트에 직접 내장되어 있습니다.",
        "title": "1단계: PlanToCode 데스크톱 설치"
      },
      "step2": {
        "description": "PlanToCode를 열고 프로젝트의 루트 디렉토리를 선택하세요. PlanToCode는 git 리포지토리 상태를 검증하고 모든 파일 작업의 기본 디렉토리를 설정합니다. 건너뛸 디렉토리(node_modules, dist, build 등)에 대한 사용자 정의 제외 패턴을 구성하세요.",
        "tip": "기본 제외 패턴은 이미 node_modules, .git 및 빌드 아티팩트와 같은 일반적인 디렉토리를 다룹니다. 프로젝트에 비정상적인 디렉토리 구조가 있는 경우에만 사용자 정의하면 됩니다.",
        "title": "2단계: 프로젝트 루트 구성"
      },
      "step3": {
        "description": "수행하려는 작업에 대한 자연어 설명을 입력하세요. 예를 들어: \"인증 서비스에 JWT 검증 추가\" 또는 \"테마 프로바이더에 다크 모드 지원 구현\". 원하는 기능에 대해 최대한 구체적으로 설명하세요.",
        "goodDescriptions": {
          "examples": [
            "사용자 프로필 API 엔드포인트에 Redis 캐싱 추가",
            "채팅 서비스에 WebSocket 연결 관리 구현",
            "모든 폼 컴포넌트에 입력 검증 추가",
            "사용자 역할 테이블을 추가하도록 데이터베이스 마이그레이션 업데이트"
          ],
          "title": "좋은 작업 설명:"
        },
        "title": "3단계: 작업 설명"
      },
      "step4": {
        "description": "PlanToCode는 백그라운드에서 5단계 파일 탐색 워크플로우를 실행합니다. 관련 파일을 탐색하는 동안 실시간 진행 상황 업데이트를 볼 수 있습니다. 워크플로우는 일반적으로 코드베이스 크기에 따라 30-90초 안에 완료됩니다. 완료되면 탐색된 파일 목록을 검토하세요. PlanToCode가 작업과 관련된 것으로 식별한 파일을 볼 수 있습니다. 이것이 시스템이 기존 파일에 대한 적절한 컨텍스트를 갖도록 하는 첫 번째 체크포인트입니다.",
        "link": "탐색 프로세스에 대해 자세히 알아보기",
        "title": "4단계: 파일 탐색 검토"
      },
      "step5": {
        "checkpoint": "중복처럼 보이는 파일 생성(예: auth-new.ts 또는 UserService2.tsx)을 보면 여기서 중지하세요. 계속하기 전에 작업 설명을 구체화하거나 파일 목록을 수동으로 조정하세요.",
        "description": "PlanToCode는 탐색된 파일을 기반으로 상세한 구현 계획을 생성합니다. Monaco 에디터에서 계획을 열고 다음을 주의 깊게 검토하세요:",
        "reviewItems": [
          "수정될 파일(기존 파일 경로 찾기)",
          "생성될 파일(진정으로 필요한 새 파일인지 확인)",
          "각 파일에 대해 제안된 특정 코드 변경",
          "임포트 문 및 종속성 업데이트"
        ],
        "title": "5단계: 구현 계획 검토"
      },
      "step6": {
        "description": "계획을 검토하고 승인한 후 구현 지침을 선호하는 AI 코딩 도구(Cursor, Copilot, Claude 등)에 복사하거나 통합 터미널을 통해 직접 실행하세요. PlanToCode가 이미 파일 탐색 및 계획의 무거운 작업을 수행했으므로 실행은 잘 정의된 변경 사항을 적용하는 간단한 프로세스가 됩니다.",
        "link": "터미널 통합 가이드",
        "title": "6단계: 자신감을 가지고 실행"
      },
      "title": "시작하기: 오늘부터 중복 생성 중지"
    },
    "howPlanToCodePrevents": {
      "comprehensiveDiscovery": {
        "description": "PlanToCode는 구현 계획을 생성하기 전에 5단계 파일 탐색 워크플로우를 실행합니다. 이 워크플로우는 git 통합, 정규식 필터링, AI 기반 관련성 평가, 관계 분석 및 경로 검증을 사용하여 코드베이스의 완전한 맵을 구축합니다.",
        "link": "기술 문서",
        "process": {
          "steps": [
            "git 리포지토리 및 루트 폴더 검증",
            "작업별 정규식 패턴 생성",
            "파일 콘텐츠의 AI 관련성 평가",
            "관계를 통한 확장 경로 탐색",
            "최종 경로 수정 및 검증"
          ],
          "title": "탐색 프로세스:"
        },
        "result": "이러한 심층 탐색은 PlanToCode가 변경 사항을 제안하기 전에 authService.ts, auth-helpers.ts 및 authentication/ 디렉토리에 대해 알고 있음을 의미합니다. 완전한 컨텍스트를 가지고 있기 때문에 중복을 생성하지 않습니다.",
        "title": "포괄적 파일 탐색"
      },
      "description": "PlanToCode는 계획 우선 접근 방식으로 워크플로우를 근본적으로 변경합니다. 즉시 코드를 생성하고 실행하는 대신 PlanToCode는 변경 사항을 제안하기 전에 전체 코드베이스 구조를 매핑하는 포괄적인 파일 탐색 시스템을 사용합니다. 이 아키텍처 차이는 중복 파일 생성의 근본 원인을 제거합니다.",
      "gitAwareTracking": {
        "command": "git ls-files --cached --others --exclude-standard는 추적된 모든 파일과 무시되지 않은 추적되지 않은 파일을 캡처하여 PlanToCode에 진행 중인 파일을 포함한 코드베이스 상태의 완전한 보기를 제공합니다.",
        "description": "파일 탐색 워크플로우는 git과 직접 통합되어 .gitignore 규칙을 준수하고 커밋된 변경 사항과 커밋되지 않은 변경 사항을 모두 추적합니다. 이 git 통합은 PlanToCode가 아직 커밋되지 않은 최근 생성된 파일을 포함하여 실제 작업 트리를 볼 수 있도록 합니다.",
        "title": "Git 인식 파일 추적"
      },
      "intelligentPatternMatching": {
        "advanced": "시스템은 단순 문자열 매칭이 아닌 컨텍스트 인식 정규식 패턴을 생성하기 위해 AI를 사용합니다. \"JWT 검증 추가\"와 같은 작업의 경우 auth*, jwt*, token*, middleware/auth* 및 관련 패턴을 포함하는 패턴을 생성합니다.",
        "description": "PlanToCode의 정규식 생성 단계는 여러 명명 규칙, 대소문자 변형 및 일반적인 파일 구성 패턴을 고려하는 지능형 패턴을 생성합니다. \"사용자 서비스 업데이트\" 요청이 userService.ts, user-service.ts, UserService.ts 또는 services/user/와 일치해야 한다는 것을 이해합니다.",
        "title": "지능형 패턴 매칭"
      },
      "reviewBeforeExecution": {
        "contents": {
          "items": [
            "수정될 파일의 완전한 목록",
            "전체 경로가 있는 생성될 새 파일",
            "이전/이후 컨텍스트가 있는 특정 변경 사항",
            "작업당 토큰 수 추정",
            "필요한 종속성 및 임포트 업데이트"
          ],
          "title": "계획 내용 포함:"
        },
        "description": "즉시 변경 사항을 적용하는 도구와 달리 PlanToCode는 코드가 파일 시스템에 닿기 전에 Monaco 에디터에서 검토하는 상세한 구현 계획을 생성합니다. 어떤 파일이 생성, 수정 또는 삭제될지 정확히 볼 수 있습니다.",
        "link": "구현 계획 가이드",
        "review": "이 검토 단계를 통해 실행 전에 중복을 발견할 수 있습니다. 계획이 auth-new.ts를 생성하려고 하면 거부하고 탐색 범위를 구체화할 수 있습니다.",
        "title": "실행 전 검토"
      },
      "title": "PlanToCode가 중복 파일을 방지하는 방법"
    },
    "problem": {
      "caseStudy1": {
        "description": "개발자가 Cursor 포럼에서 \"인증 서비스 업데이트\"를 AI에게 요청할 때 Cursor가 기존 src/services/authService.ts를 수정하는 대신 새 파일 src/services/auth-service-new.ts를 생성했다고 보고했습니다. AI가 유사한 명명 패턴을 가진 기존 구현을 제대로 스캔하지 않았기 때문에 발생했습니다.",
        "impact": "개발자는 중복 코드를 수동으로 병합하고, 15개 파일에서 임포트 충돌을 해결하고, 중복을 제거하는 데 3시간을 소비했습니다. 프로젝트는 일부 임포트가 여전히 오래된 파일 경로를 가리키고 있어 프로덕션에서 참조가 깨졌습니다.",
        "link": "Cursor 포럼 토론 보기",
        "title": "사례 연구: Cursor 이슈 #47028"
      },
      "caseStudy2": {
        "description": "또 다른 문서화된 사례는 개발자가 \"다크 모드 지원 추가\"를 요청한 React 프로젝트와 관련이 있습니다. Cursor는 기존 components/ThemeProvider.tsx를 수정하는 대신 중복 기능을 가진 components/DarkModeProvider.tsx를 생성했습니다. 코드베이스는 두 개의 경쟁하는 테마 시스템이 동시에 실행되었습니다.",
        "impact": "중복 테마 프로바이더는 상태 관리 충돌을 일으키고, 번들 크기를 45KB 증가시켰으며, 테마 기본 설정이 올바르게 유지되지 않는 사용자 경험 버그를 생성했습니다. 정리에는 전체 리팩토링 스프린트가 필요했습니다.",
        "link": "Cursor 포럼 토론 보기",
        "title": "사례 연구: Cursor 이슈 #31402"
      },
      "commonScenarios": {
        "examples": [
          "유사한 함수가 있는 helpers.ts가 있을 때 utils-new.ts 생성",
          "api/client.ts를 업데이트하는 대신 apiClient2.ts 생성",
          "Button.tsx가 이미 있을 때 ButtonComponent.tsx 만들기",
          "testHelpers.js를 수정하는 대신 test-helper-updated.js 생성",
          "config-new.json 또는 settings-v2.yaml과 같은 구성 파일 중복"
        ],
        "title": "일반적인 중복 파일 시나리오"
      },
      "description": "중복 파일은 AI 코딩 어시스턴트를 사용할 때 개발자가 직면하는 가장 일반적이고 좌절스러운 문제 중 하나입니다. Cursor, GitHub Copilot 또는 기타 코드 생성 시스템과 같은 AI 도구가 기존 코드베이스에 대한 적절한 컨텍스트가 부족하면 기존 파일을 수정하는 대신 새 파일을 생성합니다. 이로 인해 코드 조각화, 병합 충돌 및 수 시간의 수동 정리 작업이 발생합니다.",
      "title": "중복 파일 문제: 실제 예시"
    },
    "title": "AI가 중복 파일을 만드는 것을 중지하세요",
    "whyAICreatesDuplicates": {
      "conflictAvoidance": {
        "description": "AI 모델은 종종 안전 우선 접근 방식으로 훈련됩니다: 파일이 존재하는지 또는 정확한 경로가 무엇인지 불확실할 때 기존 코드를 덮어쓸 위험보다 새 파일을 생성하는 것을 기본으로 합니다. 이 \"안전이 최우선\" 편향은 중복 파일 확산으로 이어집니다.",
        "title": "충돌 회피 편향",
        "training": "AI 모델은 보수적 행동(불필요한 중복 생성)보다 파괴적 행동(중요한 코드 덮어쓰기)에 대해 더 무겁게 처벌받습니다. 훈련 데이터의 이러한 비대칭 처벌 구조는 중복 생성을 \"더 안전한\" 옵션으로 장려합니다."
      },
      "description": "중복 파일 생성 뒤의 기술적 이유를 이해하면 이 문제가 AI 코딩 도구 전반에 걸쳐 왜 그렇게 지속적인지 설명하는 데 도움이 됩니다. 간단한 버그가 아니라 대부분의 AI 어시스턴트가 코드베이스와 상호 작용하는 방식의 근본적인 아키텍처 제한입니다.",
      "incompleteDiscovery": {
        "description": "AI 도구가 파일 탐색을 시도할 때 종종 현재 열린 파일, 최근 액세스한 파일 또는 기본 패턴 매칭 검색과 같은 얕은 방법을 사용합니다. 이러한 접근 방식은 적극적으로 열려 있지 않거나 비표준 명명 규칙을 가진 파일을 놓칩니다.",
        "example": "인증 서비스의 이름이 authService.ts이지만 AI가 \"auth*\"와 일치하는 파일을 검색하는 경우 검색이 대소문자를 구분하거나 특정 디렉토리로 제한되면 놓칠 수 있습니다. 그러면 AI는 파일이 존재하지 않는다고 결론 내리고 중복을 생성합니다.",
        "title": "불완전한 파일 탐색"
      },
      "limitedContext": {
        "description": "대부분의 AI 코딩 어시스턴트는 주어진 시간에 코드베이스의 작은 부분만 \"볼 수\" 있는 제한된 컨텍스트 윈도우로 작동합니다. 기능을 생성하거나 수정하도록 요청할 때 AI는 현재 열린 파일이나 프로젝트 구조의 좁은 조각에만 액세스할 수 있습니다.",
        "details": "큰 컨텍스트 윈도우(128K+ 토큰)가 있어도 AI 모델은 여전히 전체 프로젝트 인식에 어려움을 겪습니다. 500개 파일이 있는 일반적인 중간 규모 프로젝트는 완전히 인덱싱하려면 2-5백만 토큰이 필요할 수 있으며, 이는 실용적 한계를 훨씬 초과합니다. 이는 AI 도구가 완전한 지식을 갖는 대신 파일 위치에 대해 교육받은 추측을 하도록 강제합니다.",
        "title": "제한된 컨텍스트 윈도우"
      },
      "namingMismatches": {
        "description": "다른 프로젝트는 다른 명명 규칙을 사용합니다: camelCase, PascalCase, kebab-case, snake_case 또는 사용자 정의 패턴. AI 도구는 종종 user-service.ts, UserService.ts 및 user_service.ts가 모두 \"사용자 서비스\" 파일의 잠재적 일치임을 인식하는 데 어려움을 겪습니다.",
        "impact": "여러 언어(TypeScript, Python, Go)를 혼합하는 폴리글롯 프로젝트에서 명명 규칙은 언어 생태계에 따라 다릅니다. 주로 JavaScript 패턴으로 훈련된 AI는 동등한 Python 모듈을 인식하지 못하여 언어 간 중복으로 이어질 수 있습니다.",
        "title": "명명 규칙 불일치"
      },
      "noValidation": {
        "description": "대부분의 AI 코딩 도구는 검토 단계 없이 즉시 변경 사항을 실행합니다. 코드를 생성하고 파일 시스템에 직접 적용합니다. 중복이 생성되었음을 깨달았을 때는 이미 손상이 발생한 후입니다. 실행 전에 실수를 발견할 기회가 없습니다.",
        "title": "실행 전 검증 없음",
        "workflow": "전통적인 AI 어시스턴트는 \"생성 → 적용\" 패턴을 따릅니다. \"생성 → 검토 → 적용\" 워크플로우가 없으면 개발자는 변경 사항이 디스크에 기록되기 전에 파일 경로를 확인하고, 중복을 확인하거나, AI의 코드베이스 구조 이해를 검증할 기회가 없습니다."
      },
      "title": "AI 도구가 중복 파일을 생성하는 이유"
    }
  },
  "safeRefactoring": {
    "comparison": {
      "aiDirect": {
        "approach": "AI 직접",
        "bestFor": "프로토타입",
        "safety": "낮음",
        "speed": "빠름(분)",
        "visibility": "사후"
      },
      "aiPlanning": {
        "approach": "AI + 계획",
        "bestFor": "프로덕션 코드",
        "safety": "높음",
        "speed": "빠름(분 + 검토)",
        "visibility": "실행 전"
      },
      "headers": {
        "approach": "접근 방식",
        "bestFor": "최적의 용도",
        "safety": "안전성",
        "speed": "속도",
        "visibility": "가시성"
      },
      "manual": {
        "approach": "수동",
        "bestFor": "작은 변경",
        "safety": "높음",
        "speed": "느림(시간/일)",
        "visibility": "완전함"
      },
      "title": "수동 vs AI vs AI + 계획"
    },
    "cta": {
      "buttons": {
        "download": "PlanToCode 다운로드",
        "howItWorks": "계획 작동 방식"
      },
      "description": "AI 코딩 워크플로우에 안전 계층을 추가하세요. 변경 사항이 발생하기 전에 검토하세요.",
      "title": "리팩토링으로 프로덕션을 중단시키는 것을 중지하세요"
    },
    "description": "AI 코딩 도구는 인간보다 10배 빠르게 코드를 리팩토링할 수 있습니다. 또한 10배 빠르게 프로덕션을 중단시킬 수도 있습니다. 혼란 없이 속도를 얻는 방법은 다음과 같습니다.",
    "faq": {
      "compatibility": {
        "answer": "네. PlanToCode는 모든 AI 코딩 도구에 복사할 수 있는 구현 계획을 생성합니다. 계획은 코드 생성 중 도구가 더 나은 결정을 내리도록 컨텍스트를 제공합니다.",
        "question": "Cursor/Claude Code/Copilot과 함께 사용할 수 있나요?"
      },
      "dependencyMapping": {
        "answer": "AI 기반 파일 탐색은 임포트 문, 타입 참조 및 파일 간 종속성을 분석합니다. 어떤 파일이 어떤 파일에 의존하는지의 그래프를 구축하므로 리팩토링 계획에 영향을 받는 모든 파일이 포함됩니다.",
        "question": "종속성 매핑은 어떻게 작동하나요?"
      },
      "languages": {
        "answer": "모든 언어입니다. 파일 탐색은 파일 시스템 수준에서 작동하며 임포트에 대한 정적 분석을 사용합니다. TypeScript, JavaScript, Python, Rust, Go, Java 등.",
        "question": "어떤 프로그래밍 언어가 지원되나요?"
      },
      "slowDown": {
        "answer": "초기 검토: 네, 계획을 검토하는 데 5-15분이 걸립니다. 깨진 리팩토링 디버깅: 수 시간 또는 며칠이 걸릴 수 있습니다. 순 결과: 특히 복잡한 변경의 경우 전반적으로 더 빠릅니다.",
        "question": "개발 속도가 느려지나요?"
      },
      "title": "자주 묻는 질문"
    },
    "gettingStarted": {
      "steps": [
        "PlanToCode 다운로드(macOS, Windows, Linux)",
        "터미널에서 프로젝트 디렉토리 열기",
        "리팩토링을 설명하고 생성된 계획 검토"
      ],
      "subtitle": "3단계로 안전한 리팩토링 시도:",
      "title": "시작하기"
    },
    "howPlanToCodeHelps": {
      "description": "PlanToCode는 코드가 작성되기 전에 계획 레이어를 추가합니다. 즉시 실행하는 대신 AI가 먼저 검토하는 상세한 구현 계획을 생성합니다.",
      "title": "PlanToCode가 리팩토링을 안전하게 만드는 방법",
      "workflow": {
        "steps": [
          {
            "title": "리팩토링 설명",
            "description": "\"전체 코드베이스에서 getUserData를 fetchUserProfile로 이름 변경\""
          },
          {
            "title": "AI가 종속성 매핑",
            "description": "파일 탐색은 함수를 임포트하거나 참조하는 모든 파일을 식별합니다"
          },
          {
            "title": "구현 계획 생성",
            "description": "파일별 분석: 각 파일에서 무엇이 변경되는지, 어떤 순서로"
          },
          {
            "title": "검토 및 개선",
            "description": "실행 전에 누락된 파일, 잘못된 가정 또는 엣지 케이스를 발견합니다"
          },
          {
            "title": "자신감을 가지고 실행",
            "description": "승인된 계획을 Claude Code, Cursor에 전달하거나 수동으로 구현"
          }
        ],
        "title": "안전한 리팩토링 워크플로우"
      }
    },
    "integration": {
      "description": "PlanToCode는 AI 코딩 도구를 대체하지 않고 보완합니다:",
      "title": "기존 도구와의 통합",
      "workflow": {
        "steps": [
          {
            "title": "PlanToCode로 계획",
            "description": "종속성 매핑으로 구현 계획 생성 및 검토"
          },
          {
            "title": "선호하는 도구로 실행",
            "description": "Cursor, Claude Code 또는 Copilot에 계획을 붙여넣어 코드 생성"
          },
          {
            "title": "변경 사항 확인",
            "description": "테스트 실행, 계획과 대조하여 차이 확인"
          }
        ],
        "title": "결합 워크플로우"
      }
    },
    "keyFeatures": {
      "changeOrdering": {
        "description": "계획은 올바른 순서를 지정합니다: 먼저 타입을 업데이트한 다음 구현, 그다음 테스트. 중간 중단 상태를 피합니다.",
        "title": "변경 순서 지정"
      },
      "dependencyMapping": {
        "description": "AI 기반 파일 탐색은 숨겨진 임포트, 타입 종속성 및 모듈 간 참조를 포함하여 리팩토링의 영향을 받는 모든 파일을 발견합니다.",
        "title": "종속성 매핑"
      },
      "preExecutionReview": {
        "description": "코드가 작성되기 전에 정확히 무엇이 변경될지 확인하세요. 파일별 변경 사항을 검토하고, 계획을 편집하고, 준비가 되면 승인하세요.",
        "title": "실행 전 검토"
      },
      "testCoverageCheck": {
        "description": "프로덕션 코드와 함께 업데이트가 필요한 테스트 파일을 식별합니다. 깨진 테스트 스위트로 리팩토링을 배포하지 마세요.",
        "title": "테스트 커버리지 확인"
      },
      "title": "주요 안전 기능"
    },
    "realWorldExample": {
      "scenario": "시나리오: REST에서 GraphQL로 마이그레이션",
      "task": "50,000라인 Next.js 코드베이스 전체에서 모든 REST API 호출을 GraphQL 쿼리로 교체합니다.",
      "title": "실제 예시: 50K라인 코드베이스 리팩토링",
      "withPlanning": {
        "steps": [
          "파일 탐색이 REST API를 사용하는 47개 파일 찾기",
          "계획은 마이그레이션 순서를 보여줍니다: 타입 → 클라이언트 → 컴포넌트 → 유틸",
          "보존할 오류 처리 패턴 식별",
          "GraphQL 모의 업데이트가 필요한 테스트 파일 발견",
          "결과: 20분 안에 계획 검토, 안전하게 실행"
        ],
        "title": "PlanToCode 사용:"
      },
      "withoutPlanning": {
        "steps": [
          "AI가 API 클라이언트 파일 수정",
          "일부 컴포넌트 임포트 업데이트",
          "유틸리티 함수의 API 호출 놓침",
          "오류 처리 업데이트 잊어버림",
          "변경 사항이 컴파일되지만 런타임에 실패",
          "결과: 프로덕션 오류 디버깅에 4시간"
        ],
        "title": "계획 없이(Cursor/Copilot 직접):"
      }
    },
    "refactoringProblem": {
      "aiPowered": "AI 기반 리팩토링: 빠르지만 위험합니다. Cursor, Copilot 및 Claude는 몇 초 안에 20개 파일을 수정할 수 있지만 완료될 때까지 무엇이 변경되었는지 알 수 없습니다.",
      "gap": "격차: 검토 단계가 없습니다. \"내가 변경할 내용\"이라는 미리보기가 없습니다. 즉시 실행하고 최선을 바랄 뿐입니다.",
      "manual": "수동 리팩토링: 안전하지만 느립니다. 각 파일을 주의 깊게 업데이트하고, 종속성을 확인하고, 테스트를 실행합니다.",
      "title": "리팩토링 문제"
    },
    "title": "안전한 리팩토링 도구: AI에 계획 레이어가 필요한 이유",
    "whenToUse": {
      "skipPlanningWhen": {
        "scenarios": [
          "단일 파일 변경 - 외부 종속성이 없는 격리된 리팩토링",
          "프로토타입 - 깨뜨리는 것이 허용되는 일회성 코드",
          "작은 프로젝트 - 1,000라인 미만, 모든 것을 수동으로 검토하기 쉬움"
        ],
        "title": "계획을 건너뛸 때:"
      },
      "title": "안전한 리팩토링을 사용할 때",
      "usePlanningWhen": {
        "scenarios": [
          "대형 코드베이스(50K+ 라인) - 변경 후 수동으로 검토하기에는 너무 많은 코드",
          "다중 파일 리팩토링 - 5개 이상의 파일에 걸친 이름 변경, 이동 또는 재구성",
          "프로덕션 코드 - 일회성 프로토타입이 아닌 사용자에게 가는 변경 사항",
          "모노레포 - 공유 종속성이 있는 패키지 간 리팩토링",
          "팀 환경 - 여러 개발자가 변경 범위를 이해해야 함",
          "주요 변경 사항 - API 서명 변경, 타입 수정, 아키텍처 전환"
        ],
        "title": "계획 우선 리팩토링을 사용할 때:"
      }
    },
    "whyBreaks": {
      "description": "AI 도구가 숨겨진 종속성을 놓칠 때 리팩토링이 실패합니다:",
      "importChains": {
        "description": "getUserData() → fetchUserProfile() 이름 변경은 임포트하는 8개 파일을 중단시킵니다. AI는 함수를 보지만 연쇄 반응을 놓칩니다.",
        "title": "임포트 체인"
      },
      "sideEffects": {
        "description": "시작 스크립트를 업데이트하지 않고 데이터베이스 초기화 코드를 이동합니다. 변경 사항은 컴파일되지만 DB가 준비되지 않았을 때 런타임에 실패합니다.",
        "title": "부작용"
      },
      "testAssumptions": {
        "description": "오류 처리 로직을 리팩토링하고 특정 오류 메시지를 예상하는 15개의 통합 테스트를 중단시킵니다. AI는 프로덕션 코드를 업데이트하지만 테스트 모의를 잊어버립니다.",
        "title": "테스트 가정"
      },
      "title": "리팩토링이 일을 중단시키는 이유",
      "typeDefinitions": {
        "description": "인터페이스 속성을 변경하고 코드베이스 전체에서 TypeScript 오류가 폭발하는 것을 지켜봅니다. AI는 타입을 수정하지만 오래된 형태에 의존하는 파일을 잊어버립니다.",
        "title": "타입 정의"
      }
    }
  }
}
