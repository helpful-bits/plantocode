{
  "meta": {
    "title": "문서 - PlanToCode",
    "description": "PlanToCode로 코드 변경을 계획하고 배포하는 방법을 알아보세요: 파일 탐색, 구현 계획, 터미널 세션, 모델 가드레일, 음성 기능."
  },
  "architecture": {
    "meta": {
      "title": "PlanToCode 아키텍처 개요",
      "description": "구현 계획, 워크플로우, 터미널 세션을 구동하는 데스크톱, 오케스트레이션, 영속성 계층."
    },
    "category": "아키텍처",
    "date": "2025-09-19",
    "description": "데스크톱 셸, 백그라운드 워크플로우, 공유 서비스가 어떻게 구성되어 있는지 설명합니다.",
    "frontend": {
      "heading": "프론트엔드 영역",
      "providers": "공유 프로바이더는 알림, 런타임 구성, 계획 상태를 처리합니다. 구현 계획 패널은 계획 메타데이터를 유지하고, 모달 가시성을 관리하며, 필요에 따라 토큰 추정치나 프롬프트 콘텐츠를 요청합니다.",
      "ui": "데스크톱 UI는 React 컴포넌트로 구축되었습니다. 구현 계획 콘텐츠는 대용량 계획을 가상화하고, 언어를 감지하며, 복사 작업을 지원하는 Monaco 기반 뷰어를 통해 표시되어 검토자가 성능 문제 없이 계획 텍스트를 검토할 수 있습니다. 터미널 세션은 PTY 출력에 연결되고 연결 상태 업데이트를 표시하는 버퍼링된 뷰 내에서 렌더링됩니다."
    },
    "intro": "PlanToCode는 React 프론트엔드를 갖춘 Tauri 데스크톱 애플리케이션입니다. UI는 구현 계획, 터미널, 구성 컨트롤을 렌더링하고, Rust 백엔드는 워크플로우, 토큰 추정, 영구 터미널 세션을 위한 명령을 노출합니다. 이 개요는 이러한 구성 요소들이 어떻게 함께 작동하는지 요약합니다.",
    "metaDescription": "구현 계획, 워크플로우, 터미널 세션을 구동하는 데스크톱, 오케스트레이션, 영속성 계층.",
    "metaTitle": "PlanToCode 아키텍처 개요",
    "ogDescription": "React 프론트엔드, Tauri 명령, 백그라운드 서비스가 데스크톱 앱 내에서 어떻게 협력하는지 알아보세요.",
    "ogTitle": "PlanToCode 아키텍처 개요",
    "persistence": {
      "database": "터미널 출력과 세션 메타데이터는 터미널 세션 저장소를 통해 SQLite에 저장됩니다. 각 레코드에는 식별자, 타임스탬프, 작업 디렉토리, 환경 변수, 축적된 로그가 포함되어 있어 재시작 시 이전 출력을 복구할 수 있습니다. 동일한 저장소는 세션 상태가 변경될 때 이벤트를 발생시킵니다.",
      "heading": "영속성 및 구성",
      "modelConfig": "모델 기본값은 애플리케이션 구성 테이블에 저장됩니다. 각 작업은 기본 모델, 허용된 대안 목록, 토큰 예산, 선택적 복사 버튼 프리셋을 정의합니다. React 레이어는 이러한 설정을 읽어 모델 선택기와 가드레일을 채웁니다."
    },
    "readTime": "7분",
    "tauriCommands": {
      "commands": "애플리케이션의 Rust 측은 워크플로우, 터미널 세션, 모델 도구에 대한 명령을 노출합니다. 워크플로우 명령은 Workflow Orchestrator를 통해 백그라운드 작업을 시작하고, 입력을 검증하며, 파일 탐색 파이프라인이 실행될 때 진행 이벤트를 발생시킵니다. 토큰 추정 명령은 현재 선택된 모델에 대한 프롬프트 크기를 계산합니다.",
      "heading": "Tauri 명령 및 서비스",
      "terminal": "터미널 명령은 PTY 프로세스를 관리하고, 원격 클라이언트를 추적하며, 세션을 시작하기 전에 지원되는 CLI 바이너리가 사용 가능한지 확인합니다. 상태 확인은 PTY 상태와 데이터베이스 레코드를 결합하여 세션이 여전히 활성 상태인지 보고합니다."
    },
    "title": "PlanToCode 아키텍처",
    "voicePipeline": {
      "description": "음성 전사는 미디어 권한, 마이크 선택, 스트리밍 전사 요청을 조정하는 React 훅으로 구현됩니다. 이 훅은 계획 터미널 및 프롬프트 편집기와 통합되어 인식된 텍스트를 활성 컴포넌트에 직접 삽입하고 전사가 실패하면 알림을 표시합니다.",
      "heading": "음성 전사 파이프라인"
    },
    "server": {
      "heading": "서버 계층",
      "description": "서버는 프로바이더 구성(암호화된 볼트의 API 키, 속도 제한, OpenAI, Anthropic, Google에 대한 라우팅 규칙), 모델 라우팅(요청 프록시, 자동 장애 조치, 로드 밸런싱, 사용자/프로젝트별 비용 추적), 청구(구독 관리, 사용량 측정, 할당량 적용, 비용 알림), 웹 검색 API(30일/7일 TTL로 결과 캐싱, 지리적 제한, JWT 인증)를 처리합니다."
    },
    "dataFlows": {
      "heading": "데이터 흐름",
      "description": "작업, 계획, 작업, 세션은 컴포넌트 간에 흐릅니다: (1) 작업 정제: React UI → TextImprovementPopover → Tauri 명령 → WorkflowOrchestrator → text_improvement 프롬프트 → SQLite → React 프로바이더가 텍스트 교체. (2) 파일 탐색: 구현 계획 패널 → Tauri 명령 → 4개의 순차 작업 → 진행 이벤트 → SQLite → UI 표시. (3) 구현 계획: 파일 탐색 → 계획 생성 → Tauri 명령 → LLM 스트리밍 → SQLite → Monaco 뷰어 → 검토/승인 → 내보내기. (4) 터미널 실행: PTY 세션 → SQLite → 명령 실행 → 출력 스트리밍 → 음성 전사 주입 → 에이전트 주의 감지 → 감사 로그."
    },
    "visuals": {
      "systemMap": {
        "description": "This diagram depicts the PlanToCode system architecture as four interconnected layers arranged vertically. Top Layer - Desktop Frontend: A React/Next.js box containing components (Plan Viewer, Terminal Panel, Session Manager) connected via labeled arrows \"invoke()\" and \"listen()\" to the Tauri IPC bridge. Second Layer - Rust Backend: WorkflowOrchestrator (scheduling multi-stage jobs), TerminalSessionManager (PTY lifecycle), and job processors (FileDiscovery, PlanGeneration, TextImprovement, DeepResearch). Third Layer - Persistence: SQLite tables for sessions, background_jobs, and terminal_sessions with read/write arrows. Fourth Layer - External Services: Server routes under /api/llm/* and /api/auth with provider icons (OpenAI, Anthropic, Google, OpenRouter). Data flows run down through the layers; streaming responses and job events flow back up to the UI."
      }
    }
  },
  "deepResearch": {
    "meta": {
      "title": "심층 조사 - PlanToCode",
      "description": "웹 검색 워크플로우에 대한 기술 문서: API 통합, 쿼리 최적화, 결과 처리, 개발 워크플로우 통합."
    },
    "apiIntegration": {
      "heading": "API 통합 상세",
      "pipeline": {
        "description": "조사 결과는 서식과 컨텍스트를 유지하면서 의미 있는 정보를 추출하는 표준화된 처리 파이프라인을 통과합니다. 파이프라인은 다양한 콘텐츠 유형을 처리하고 개발 워크플로우를 위한 실행 가능한 인사이트로 결과를 종합합니다.",
        "heading": "콘텐츠 처리 파이프라인"
      },
      "providerConfig": {
        "description": "시스템은 OpenRouter를 통해 AI 언어 모델을 사용하여 지능형 웹 조사를 수행합니다. LLM은 작업 컨텍스트를 기반으로 대상화된 조사 쿼리를 생성하고 학습 데이터와 웹 검색 기능에서 결과를 종합합니다. 모델 선택 및 구성은 애플리케이션 설정을 통해 관리됩니다.",
        "heading": "AI 조사 구성"
      }
    },
    "architecture": {
      "description": "심층 조사 시스템은 2단계 워크플로우로 작동합니다: (1) WebSearchPromptsGeneration - AI가 작업과 프로젝트 컨텍스트를 분석하여 대상화된 조사 쿼리를 생성하고, (2) WebSearchExecution - LLM이 조사 프롬프트를 병렬로 실행하고 결과를 종합합니다. 각 단계는 안정성, 비용 효율성, 컨텍스트 관련성을 위해 설계되었습니다.",
      "heading": "아키텍처 개요"
    },
    "bestPractices": {
      "examples": {
        "description": "일반적인 통합 패턴은 특정 오류 디버깅부터 익숙하지 않은 API로 새 기능을 구현하는 것까지 웹 검색 결과가 다양한 개발 시나리오를 어떻게 향상시키는지 보여줍니다.",
        "heading": "통합 예제"
      },
      "heading": "모범 사례 및 예제",
      "strategies": {
        "description": "웹 검색 통합의 가치를 극대화하려면 쿼리 작성, 결과 해석, 개발 워크플로우에 결과 통합에 대한 검증된 전략을 따르세요.",
        "heading": "효과적인 검색 전략",
        "queryFormulation": {
          "constraints": "플랫폼 또는 환경 제약 조건 포함",
          "errors": "라이브러리 이름과 특정 오류 메시지 결합",
          "heading": "쿼리 작성",
          "practices": "패턴 검색에 \"모범 사례\" 또는 \"권장 접근 방식\" 사용",
          "versions": "관련이 있는 경우 특정 버전 번호 포함"
        },
        "resultEvaluation": {
          "crossReference": "여러 소스에서 솔루션 교차 참조",
          "dates": "시간에 민감한 정보의 경우 게시 날짜 확인",
          "heading": "결과 평가",
          "official": "서드파티 소스보다 공식 문서 우선",
          "verify": "개발 환경에서 코드 예제 검증"
        }
      }
    },
    "category": "기술 참조",
    "configuration": {
      "heading": "구성 및 사용자 정의",
      "preferences": {
        "description": "조사 동작은 모델 선택 및 작업 설정을 통해 구성됩니다. 조사 작업에 선호하는 AI 모델을 선택하고, 타임아웃을 구성하고, 컨텍스트에 포함할 파일을 선택하세요.",
        "filters": "모델 선택이 조사 품질과 비용을 결정",
        "heading": "조사 설정",
        "limits": "작업당 최대 12개의 조사 프롬프트 생성",
        "optionsHeading": "구성 가능한 옵션",
        "patterns": "더 나은 컨텍스트를 위해 관련 프로젝트 파일 포함",
        "sources": "컨텍스트를 위한 프로젝트 디렉토리 및 파일 선택",
        "triggers": "워크플로우 명령을 통해 수동으로 조사 시작"
      },
      "projectSettings": {
        "description": "조사 구성은 세션을 인식합니다. 시스템은 현재 세션의 프로젝트 디렉토리와 포함된 파일을 사용하여 컨텍스트를 제공합니다. 제외된 경로(node_modules, dist 등)는 AI에 표시되는 디렉토리 트리에서 자동으로 필터링됩니다.",
        "heading": "프로젝트별 설정"
      }
    },
    "costs": {
      "heading": "비용 고려사항",
      "optimization": {
        "description": "조사 비용은 지능형 프롬프트 생성을 통해 관리됩니다 - 시스템은 조사 프롬프트를 작업당 최대 12개로 제한합니다. 병렬 실행은 실제 소요 시간을 최소화합니다. 각 작업은 완전한 투명성을 위해 메타데이터에 토큰 사용량과 예상 비용을 추적합니다.",
        "heading": "비용 최적화"
      },
      "rateLimiting": {
        "cacheFirst": "중복 쿼리를 피하기 위해 세션별로 조사 결과 캐싱",
        "description": "심층 조사는 OpenRouter를 통해 구성된 AI 크레딧을 사용합니다. 각 조사 작업은 여러 병렬 LLM 호출을 생성하므로 비용은 생성된 조사 프롬프트 수에 따라 확장됩니다. 시스템은 투명성을 위해 작업별 토큰 사용량과 비용을 추적합니다.",
        "guidelinesHeading": "비용 관리 팁",
        "heading": "사용량 및 비용",
        "personal": "상세 비용 분석과 함께 조사 작업별 토큰 사용량 추적",
        "team": "OpenRouter 또는 PlanToCode 구독 크레딧을 통해 비용 관리",
        "throttling": "토큰 수와 예상 비용에 대한 작업 메타데이터 모니터링"
      }
    },
    "cta": {
      "description": "심층 조사 및 웹 검색 기능은 PlanToCode 데스크톱 애플리케이션에서 사용할 수 있습니다. 플랫폼에 맞는 빌드를 다운로드하여 개발 워크플로우에 웹 조사를 통합하기 시작하세요.",
      "heading": "심층 조사를 사용할 준비가 되셨나요?",
      "links": {
        "architecture": "시스템 아키텍처 보기",
        "buildYourOwn": "나만의 통합 구축"
      }
    },
    "date": "2025-09-20",
    "description": "PlanToCode가 웹 검색을 수행하고, 결과를 처리하고, 개발 워크플로우에 결과를 통합하는 방법.",
    "devIntegration": {
      "caching": {
        "description": "조사 결과는 작업 메타데이터에 저장되며 작업 상세 패널을 통해 액세스할 수 있습니다. 결과는 세션 기간 동안 유지되며 구현 계획을 만들거나 코딩 결정을 내릴 때 참조할 수 있습니다.",
        "heading": "결과 저장"
      },
      "contextAware": {
        "description": "조사 요청은 현재 세션의 컨텍스트로 자동 강화됩니다. 시스템은 프롬프트 생성 단계에서 프로젝트의 디렉토리 트리와 선택한 파일 콘텐츠를 포함하여 AI가 코드베이스에 특화된 조사 쿼리를 작성할 수 있도록 합니다.",
        "heading": "컨텍스트 인식 조사"
      },
      "heading": "개발 워크플로우 통합",
      "resultIntegration": {
        "description": "조사 결과는 구현 계획을 안내하는 데 사용할 수 있습니다. 조사 작업이 완료되면 결과는 후속 계획 작업에 통합할 수 있는 research_finding 태그로 형식화되어 구현이 현재 모범 사례와 정확한 문서로 안내되도록 합니다.",
        "heading": "결과 통합"
      }
    },
    "intro": "심층 조사 기능을 통해 PlanToCode는 지능형 AI 기반 조사를 수행하고, 관련 정보를 수집하며, 결과를 개발 워크플로우에 직접 통합할 수 있습니다. 이 시스템은 대규모 언어 모델을 사용하여 프로젝트 컨텍스트를 기반으로 대상화된 조사 쿼리를 생성하고, 병렬 조사 작업을 실행하며, 코드 생성 및 문제 해결 기능을 향상시키는 실행 가능한 인사이트를 종합합니다.",
    "metaDescription": "웹 검색 워크플로우에 대한 기술 문서: API 통합, 쿼리 최적화, 결과 처리, 개발 워크플로우 통합.",
    "metaTitle": "심층 조사 - PlanToCode",
    "ogDescription": "PlanToCode 내에서 웹 검색이 어떻게 작동하는지 이해하세요: 쿼리 생성부터 결과 처리 및 개발 워크플로우와의 통합까지.",
    "ogTitle": "심층 조사 - PlanToCode",
    "readTime": "8분",
    "title": "심층 조사 및 웹 검색",
    "troubleshooting": {
      "commonIssues": {
        "description": "대부분의 조사 문제는 LLM API 연결, 크레딧 부족, 또는 너무 광범위한 프롬프트에서 발생합니다. 시스템은 문제 해결을 위해 명확한 오류 메시지와 작업 상태 추적을 제공합니다.",
        "geographic": "모델 가용성",
        "geographicSolution": "일부 모델은 OpenRouter를 통해 지역 제한이 있을 수 있습니다",
        "heading": "일반적인 문제",
        "noResults": "조사 프롬프트가 생성되지 않음",
        "noResultsSolution": "더 구체적인 작업 설명을 제공하거나 컨텍스트를 위해 관련 파일을 포함하세요",
        "rateLimit": "API 오류",
        "rateLimitSolution": "OpenRouter API 상태 및 크레딧 잔액 확인"
      },
      "heading": "문제 해결 및 지원",
      "performance": {
        "description": "최적의 성능을 위해 명확하고 구체적인 작업 설명을 제공하세요. AI에게 더 나은 컨텍스트를 제공하기 위해 관련 프로젝트 파일을 포함하세요. 시스템은 총 실행 시간을 최소화하기 위해 조사 프롬프트를 병렬로 실행합니다.",
        "heading": "성능 최적화"
      }
    },
    "workflow": {
      "execution": {
        "blogs": "모범 사례 및 구현 패턴",
        "description": "조사 프롬프트는 AI 언어 모델에 의해 병렬로 실행됩니다. 각 프롬프트는 독립적으로 처리되어 시스템이 작업의 여러 측면에 대한 정보를 동시에 수집할 수 있습니다. 결과는 제목과 실행 가능한 인사이트가 포함된 구조화된 결과로 종합됩니다.",
        "documentation": "API 문서 및 기술 사양",
        "forums": "오류 해결 및 문제 해결 접근 방식",
        "github": "코드 예제 및 구현 패턴",
        "heading": "조사 실행",
        "releases": "버전 호환성 및 마이그레이션 안내",
        "sourcesHeading": "조사 집중 영역"
      },
      "heading": "조사 워크플로우 단계",
      "processing": {
        "deduplication": "여러 조사 프롬프트에서 결과 통합",
        "description": "조사 결과는 제목과 상세 결과가 포함된 JSON 형식으로 구조화됩니다. 시스템은 병렬 조사 작업의 결과를 집계하고, 성공 및 실패 횟수를 추적하며, 조사 결과의 요약을 제공합니다. 결과는 쉽게 액세스할 수 있도록 작업 메타데이터에 저장됩니다.",
        "extraction": "주요 결과 추출 및 통합을 위한 형식화",
        "heading": "결과 처리 및 종합",
        "scoring": "조사 주제 및 관련성별로 결과 정리",
        "snippets": "실행 가능한 인사이트 및 권장 사항 강조",
        "stepsHeading": "처리 단계",
        "timestamp": "타이밍 메트릭으로 조사 실행 추적"
      },
      "queryGeneration": {
        "api": "API 문서 및 라이브러리별 조사",
        "compatibility": "버전 호환성 및 마이그레이션 경로",
        "description": "조사 프롬프트는 작업 설명, 프로젝트 컨텍스트, 포함된 파일을 기반으로 AI에 의해 자동 생성됩니다. 시스템은 디렉토리 트리와 파일 콘텐츠를 통해 코드베이스 구조를 분석하여 대상화된 조사 쿼리를 작성합니다. 작업당 최대 12개의 집중 조사 프롬프트가 생성됩니다.",
        "errors": "오류 해결 및 디버깅 접근 방식",
        "heading": "프롬프트 생성",
        "practices": "모범 사례 및 권장 패턴",
        "security": "보안 고려 사항 및 취약점 인식",
        "typesHeading": "조사 주제"
      }
    },
    "visuals": {
      "pipeline": {
        "title": "심층 조사 파이프라인",
        "description": "2단계 워크플로우: 프롬프트 생성 및 병렬 조사 실행.",
        "imageSrc": "/images/docs/deep-research/workflow.svg",
        "imageAlt": "프롬프트 생성 및 실행 단계를 보여주는 심층 조사 파이프라인 다이어그램",
        "caption": "프롬프트 생성 및 병렬 실행 단계를 보여주는 심층 조사 워크플로우"
      },
      "workflow": {
        "title": "심층 조사 워크플로우",
        "description": "2단계 워크플로우: 프롬프트 생성 및 병렬 조사 실행.",
        "imageSrc": "/images/docs/deep-research/workflow.svg",
        "caption": "모든 처리 단계를 보여주는 심층 조사 워크플로우"
      }
    }
  },
  "fileDiscovery": {
    "meta": {
      "title": "File discovery workflow - PlanToCode",
      "description": "Comprehensive technical guide to the 4-stage AI workflow that identifies and filters relevant files for task execution."
    },
    "apiUsage": {
      "heading": "API Usage Examples",
      "monitoring": "Monitoring Progress",
      "retrieving": "Retrieving Results",
      "starting": "Starting a Workflow"
    },
    "architecture": {
      "caching": "Intermediate results are persisted in SQLite job records for reuse and debugging.",
      "costTracking": "Cost tracking and timeout management for AI operations",
      "distributed": "The system uses a distributed job architecture where each stage runs as an independent background job, enabling cancellation, retry logic, and detailed progress tracking. Real-time events are published throughout execution to provide immediate feedback to the user interface.",
      "errorHandling": "Comprehensive error handling with automatic retry mechanisms",
      "eventDriven": "Event-driven progress reporting with WebSocket-like updates",
      "featuresHeading": "Key Architecture Features:",
      "gitIntegration": "Git integration with fallback to directory traversal",
      "heading": "Workflow Architecture",
      "overview": "The workflow operates as an orchestrated background job system with four distinct stages that execute sequentially. Each stage builds upon the previous stage's output, progressively refining the file selection based on task requirements."
    },
    "category": "Technical Guide",
    "configuration": {
      "exclusion": {
        "description": "Define directories and file patterns to exclude from the discovery process.",
        "heading": "Exclusion Patterns"
      },
      "heading": "Configuration Options",
      "retry": {
        "description": "Set maximum retry attempts for failed stages with exponential backoff.",
        "heading": "Retry Configuration"
      },
      "timeout": {
        "description": "Configure maximum execution time for the entire workflow or individual stages to prevent indefinite hanging.",
        "heading": "Timeout Management"
      },
      "workflowConfig": "Workflow Configuration"
    },
    "cta": {
      "description": "The file discovery workflow runs inside the desktop client alongside implementation planning and terminal sessions.",
      "heading": "Need the desktop app?",
      "links": {
        "architecture": "Learn about architecture",
        "buildYourOwn": "Build your own pipeline"
      }
    },
    "date": "2025-09-21",
    "description": "Comprehensive technical guide to the 4-stage AI workflow that identifies and filters relevant files for task execution.",
    "errorHandling": {
      "commonIssues": {
        "binaryDetection": "Binary file detection: Uses both extension-based and content-based binary detection",
        "gitNotFound": "Git repository not found: Falls back to directory traversal with standard exclusions",
        "heading": "Common Issues",
        "networkTimeout": "Network timeouts: Automatic retry with exponential backoff for transient failures",
        "tokenLimit": "Token limit exceeded: Implements intelligent batching and provides clear error messages"
      },
      "debugging": {
        "description": "The workflow provides comprehensive logging, performance metrics export, and detailed error context including stage information, retry attempts, and intermediate data for troubleshooting.",
        "heading": "Debugging Tools"
      },
      "errorCategories": {
        "billing": "Billing Errors: Insufficient credits or payment failures with actionable guidance",
        "heading": "Error Categories",
        "system": "System Errors: File system access, git command failures, or memory constraints",
        "validation": "Validation Errors: Invalid session ID, missing task description, or invalid project directory",
        "workflow": "Workflow Errors: Stage-specific failures with detailed context and retry suggestions"
      },
      "heading": "Error Handling & Troubleshooting"
    },
    "integration": {
      "desktop": {
        "description": "The workflow integrates seamlessly with the desktop application through Tauri commands, providing native file system access and event-driven updates via the WorkflowTracker class.",
        "heading": "Desktop Application"
      },
      "heading": "Integration Patterns",
      "implementationPlans": {
        "description": "Selected files are automatically fed into the Implementation Plans panel, ensuring that plan generation uses the same optimized file context without requiring re-execution of the discovery workflow.",
        "heading": "Implementation Plans Integration"
      },
      "sessionManagement": {
        "description": "Selected files and task history persist per session so follow-up actions can reuse the same context without rerunning discovery.",
        "heading": "Session Management"
      }
    },
    "intro": "PlanToCode identifies the right files before you plan or run commands. The 4-stage workflow narrows scope and keeps context tight.",
    "metaDescription": "Comprehensive technical guide to the 4-stage AI workflow that identifies and filters relevant files for task execution.",
    "metaTitle": "File discovery workflow - PlanToCode",
    "ogDescription": "Technical documentation for the multi-stage file discovery workflow architecture.",
    "ogTitle": "File discovery workflow - PlanToCode",
    "performance": {
      "costOptimization": {
        "description": "AI stages track actual costs from API responses, implement intelligent batching to minimize token usage, and provide cost estimates before execution to help manage expenses.",
        "heading": "Cost Optimization"
      },
      "heading": "Performance Considerations",
      "memory": {
        "description": "The workflow uses token-aware chunking, streaming responses, and cleanup of temporary data to manage memory. There is no fixed file batch size.",
        "heading": "Memory Management"
      },
      "monitoring": {
        "description": "Built-in performance tracking monitors execution times, memory usage, throughput metrics, and provides recommendations for optimization based on historical data analysis.",
        "heading": "Performance Monitoring"
      }
    },
    "readTime": "12 min",
    "stages": {
      "heading": "4-Stage Workflow Process",
      "stage1": {
        "description": "Uses AI to intelligently select the most relevant root directories from a list of candidate paths based on the task description. The LLM analyzes the primary project directory and candidate roots to determine which directories are most likely to contain files relevant to the task.",
        "heading": "Stage 1: Root Folder Selection",
        "technical": "Technical Details: Receives candidate root directories (up to depth 2) and the task description. The LLM evaluates each path against the task context and returns a filtered list of root directories that will be searched in subsequent stages.",
        "inputOutput": "Input/Output: Receives candidate_roots array and task_description. Returns root_directories array containing the AI-selected directories most relevant to the task."
      },
      "stage2": {
        "binaryDetection": "Binary Detection: Filters out files with binary extensions (.jpg, .png, .pdf, .exe, etc.) and uses content analysis to detect binary files by null bytes and non-printable character ratios.",
        "description": "Uses AI to generate intelligent regex pattern groups based on the task description and directory structure. Each pattern group can include path patterns (positive and negative) and content patterns. The processor then applies these patterns to filter files from each selected root directory.",
        "gitIntegration": "Git Integration: Finds the git repository root for each selected directory and uses git_utils to get all non-ignored files, respecting .gitignore rules while including both tracked and untracked files.",
        "heading": "Stage 2: Regex File Filter",
        "technical": "Technical Details: Generates a directory tree for each root, calls the LLM to produce patternGroups with path_pattern, content_pattern, and negative_path_pattern fields. Uses fancy-regex for lookahead/lookbehind support. Processes roots in parallel with configurable concurrency."
      },
      "stage3": {
        "aiProcessing": "AI Processing: Uses large language models to evaluate file content against task requirements, with intelligent chunking based on actual file sizes and token estimates to manage context windows efficiently.",
        "description": "Employs AI models to analyze file content and assess relevance to the specific task description. This stage performs deep content analysis by reading file contents and having the LLM identify which files are most relevant to the task.",
        "heading": "Stage 3: AI File Relevance Assessment",
        "technical": "Technical Details: Estimates tokens per file using file-type-aware heuristics (code ~3 chars/token, structured data ~5 chars/token). Creates content-aware chunks to stay under the 90k token threshold. Processes chunks in parallel with streaming to avoid timeouts. Validates all LLM-suggested paths against the filesystem."
      },
      "stage4": {
        "description": "Discovers additional relevant files by providing the LLM with the previously identified files and their contents, along with the directory tree. The AI analyzes imports, dependencies, and project structure to find related files that enhance the context for the task.",
        "heading": "Stage 4: Extended Path Finder",
        "relationship": "Relationship Analysis: Reads content of all previously identified files and provides it to the LLM alongside the directory tree (scoped to selected roots if available). The AI identifies additional files based on imports, references, and structural relationships.",
        "technical": "Technical Details: Generates a combined directory tree for selected root directories. Reads content of all initial_paths files. Uses streaming LLM calls to avoid Cloudflare timeouts. Validates discovered paths against the filesystem and normalizes to relative paths within the project."
      }
    },
    "stateManagement": {
      "eventDriven": {
        "description": "The system publishes real-time events for workflow status changes, stage completions, and error conditions. These events enable responsive user interfaces and integration with external monitoring systems.",
        "heading": "Event-Driven Updates"
      },
      "heading": "Workflow State Management",
      "intermediateData": {
        "description": "Each stage stores its output in a structured intermediate data format, including directory tree content, regex patterns, filtered file lists results. This data is accessible for debugging and can be used to resume workflows from specific stages.",
        "heading": "Intermediate Data Storage"
      },
      "transitions": {
        "description": "The workflow progresses through clearly defined states: Created → Running → Paused (optional) → Completed/Failed/Canceled. Each state transition publishes events that can be monitored for real-time updates.",
        "heading": "State Transitions"
      }
    },
    "visuals": {
      "pipeline": {
        "title": "File discovery pipeline",
        "description": "The 4-stage workflow: root folder selection, regex filtering, AI relevance assessment, and extended path discovery.",
        "imageSrc": "/images/docs/file-discovery/pipeline.svg",
        "caption": "File discovery pipeline showing all 4 stages",
        "imageAlt": "Diagram showing the 4-stage file discovery workflow: Root Folder Selection, Regex File Filter, AI File Relevance Assessment, and Extended Path Finder"
      }
    },
    "title": "File Discovery Workflow",
    "sqliteStorage": {
      "heading": "SQLite Storage",
      "description": "All workflow state, intermediate results, and job metadata are persisted in SQLite. Each stage stores its output in the background_jobs table, enabling workflow resumption and debugging. The job records include token usage, cost tracking, and system prompt templates for each AI stage."
    }
  },
  "hub": {
    "ctaDescription": "이 문서에 설명된 구현 플래너, 모델 가드레일, 터미널 세션, 전사 기능에 액세스하려면 PlanToCode를 다운로드하세요.",
    "ctaHeading": "이 워크플로우를 사용해 볼 준비가 되셨나요?",
    "ctaLinks": {
      "overview": "개요로 시작하기",
      "runtime": "런타임 워크스루"
    },
    "description": "PlanToCode로 코드 변경을 계획하고 배포하는 방법을 알아보세요: 파일 탐색, 구현 계획, 터미널 세션, 모델 가드레일, 음성.",
    "exploreHeading": "문서 탐색",
    "learnMore": "자세히 알아보기",
    "searchAriaLabel": "문서 검색",
    "searchPlaceholder": "문서 검색...",
    "searchShortcut": "⌘K",
    "title": "PlanToCode 문서"
  },
  "onThisPage": {
    "title": "이 페이지에서"
  },
  "sidebar": {
    "title": "문서"
  },
  "sections": {
    "architecture": {
      "title": "아키텍처 및 내부"
    },
    "inputs": {
      "title": "입력 및 캡처"
    },
    "planning": {
      "title": "계획 파이프라인"
    },
    "execution": {
      "title": "실행 및 자동화"
    },
    "research": {
      "title": "조사 및 모델"
    },
    "platform": {
      "title": "빌드 및 배포"
    }
  },
  "items": {
    "overview": {
      "title": "시스템 개요",
      "description": "여기서 시작: 시스템이 무엇을 하는지, 핵심 루프가 어떻게 작동하는지, 각 컴포넌트가 어디에 있는지."
    },
    "runtime-walkthrough": {
      "title": "런타임 워크스루",
      "description": "작업 입력부터 실행까지 전체 타임라인."
    },
    "architecture": {
      "title": "시스템 아키텍처",
      "description": "데스크톱 셸, Rust 서비스, 서버 API, 영속성 계층이 어떻게 함께 맞춰지는지."
    },
    "desktop-app": {
      "title": "데스크톱 앱 내부",
      "description": "Tauri v2 셸, Rust 명령 계층, PTY 세션, UI 상태 관리."
    },
    "server-api": {
      "title": "서버 API 및 LLM 프록시",
      "description": "인증, 프로바이더 라우팅, 모델 구성, WebSocket 엔드포인트."
    },
    "mobile-ios": {
      "title": "iOS 클라이언트 아키텍처",
      "description": "Swift 워크플로우, Auth0 로그인 흐름, 디바이스 링크 세션 관리."
    },
    "background-jobs": {
      "title": "백그라운드 작업 및 오케스트레이션",
      "description": "작업 레코드, 워크플로우 오케스트레이션, 프로세서, 이벤트 스트리밍."
    },
    "data-model": {
      "title": "데이터 모델 및 저장소",
      "description": "SQLite 엔티티, 관계, 상태 재수화 방법."
    },
    "decisions-tradeoffs": {
      "title": "기술 결정 및 트레이드오프",
      "description": "왜 Tauri, SQLite, 전용 LLM 프록시를 선택했으며 그 비용은 무엇인지."
    },
    "build-your-own": {
      "title": "나만의 파이프라인 구축",
      "description": "파일 탐색 및 계획 생성 워크플로우 설계를 위한 개념 가이드."
    },
    "meeting-ingestion": {
      "title": "회의 및 녹음 수집",
      "description": "녹음이 구조화된 작업 입력 및 아티팩트가 되는 방법."
    },
    "video-analysis": {
      "title": "비디오 분석",
      "description": "녹음에서 프레임 샘플링, 프롬프트, 분석 아티팩트."
    },
    "voice-transcription": {
      "title": "음성 전사",
      "description": "녹음 수명 주기, 프로젝트 인식 설정, 디바이스 관리."
    },
    "text-improvement": {
      "title": "텍스트 개선",
      "description": "선택 팝오버, 작업 큐, 프롬프트 정리를 위한 통합."
    },
    "file-discovery": {
      "title": "파일 탐색 워크플로우",
      "description": "각 작업에 대해 관련 경로를 수집하는 백그라운드 워크플로우."
    },
    "implementation-plans": {
      "title": "구현 계획",
      "description": "계획이 Monaco 뷰어로 스트리밍되고 계획 기록에 연결되는 방법."
    },
    "merge-instructions": {
      "title": "병합 지침",
      "description": "XML 태그가 지정된 소스 계획과 사용자 안내를 사용하여 여러 계획 초안을 병합하는 방법."
    },
    "prompt-types": {
      "title": "프롬프트 유형 및 템플릿",
      "description": "프롬프트 기반 작업 유형 및 템플릿 조립 카탈로그."
    },
    "terminal-sessions": {
      "title": "터미널 세션",
      "description": "영구 PTY 세션, CLI 감지, 복구 동작."
    },
    "copy-buttons": {
      "title": "복사 버튼",
      "description": "계획에서 터미널 및 외부 도구로의 템플릿 전달."
    },
    "deep-research": {
      "title": "심층 조사 및 웹 검색",
      "description": "웹 검색 워크플로우, API 통합, 쿼리 최적화, 개발 워크플로우 통합."
    },
    "provider-routing": {
      "title": "프로바이더 라우팅 및 스트리밍",
      "description": "프로바이더 요청이 어떻게 정규화, 스트리밍, 추적되는지."
    },
    "model-configuration": {
      "title": "모델 구성",
      "description": "작업별 허용 모델 및 선택기 토글의 토큰 가드레일."
    },
    "server-setup": {
      "title": "전용 서버 설정",
      "description": "Ansible 기반 인프라: 기본 강화, 앱 배포, 볼트 관리 비밀."
    },
    "tauri-v2": {
      "title": "Tauri v2 개발 가이드",
      "description": "Tauri v2를 위한 프로젝트 레이아웃, 명령, 기능 기반 권한."
    },
    "distribution-macos": {
      "title": "macOS 배포",
      "description": "서명, 공증, DMG 패키징, 업데이터 아티팩트."
    },
    "distribution-windows": {
      "title": "Windows 배포 및 스토어",
      "description": "NSIS 빌드, MSIX 패키징, Microsoft Store 제출."
    }
  },
  "implementationPlans": {
    "meta": {
      "title": "구현 계획 - AI 변경 검토",
      "description": "AI 구현 계획 가이드. 실행 전에 파일별 계획을 생성, 검토, 승인하세요. 중복 및 잘못된 경로를 방지하세요."
    },
    "category": "제품 가이드",
    "context": {
      "audit": "Plan metadata persists with each job so you can review which inputs were used (task description, selected roots/files, model settings) and compare drafts later.",
      "heading": "기업 거버넌스를 위한 컨텍스트 및 메타데이터",
      "storage": "패널은 후속 작업이 동일한 범위를 재사용할 수 있도록 파일 탐색 워크플로우 중에 선택된 저장소 루트를 저장합니다. 또한 워크플로우를 다시 계산하지 않고도 다운스트림 프롬프트를 생성하거나 복사할 수 있도록 프로젝트 디렉토리와 준비된 프롬프트 콘텐츠와 같은 계획별 메타데이터를 기록합니다.",
      "tokenEstimation": "토큰 추정은 프롬프트가 복사되기 전에 실행됩니다. 패널은 프로젝트 디렉토리, 선택된 파일, 현재 선택된 모델로 토큰 추정 명령을 호출하여 팀이 모델 제한 내에 유지할 수 있도록 시스템 및 사용자 프롬프트 합계를 모두 표시합니다."
    },
    "cta": {
      "claudeCodeLink": "Claude 계획 모드 워크플로우 보기",
      "codexLink": "Codex 계획 모드 워크플로우 보기",
      "cursorLink": "Cursor 계획 모드 워크플로우 보기",
      "description": "휴먼 인 더 루프 구현 계획은 PlanToCode 데스크톱 애플리케이션 내에서 사용할 수 있습니다. 플랫폼에 맞는 빌드를 다운로드하여 안전하고 관리되는 AI 지원 개발을 경험하세요.",
      "heading": "AI 코딩 에이전트를 안전하게 도입할 준비가 되셨나요?",
      "links": {
        "architecture": "시스템 아키텍처",
        "decisions": "결정 및 트레이드오프",
        "buildYourOwn": "나만의 파이프라인 구축",
        "fileDiscovery": "파일 탐색 워크플로우"
      }
    },
    "date": "2025-09-19",
    "description": "How PlanToCode enables confident adoption of AI coding agents through human-in-the-loop review, granular file-by-file plans, and clear handoff workflows.",
    "fileGranularity": {
      "created": "생성됨 (완전한 파일 경로 및 초기 콘텐츠 구조 포함)",
      "declaredFiles": "계획의 각 단계는 어떤 파일이 다음과 같이 될지 명시적으로 선언합니다:",
      "deleted": "삭제됨 (정당성 및 종속성 분석 포함)",
      "heading": "파일별 세분성",
      "impact": "Reviewers can immediately identify if critical legacy code will be modified, if breaking changes are proposed, or if the plan touches files that require additional scrutiny.",
      "intro": "Implementation plans use a highly granular structure that breaks down development tasks on a file-by-file basis, with exact file paths corresponding to the project's repository structure. This granularity makes scope explicit before any code is touched.",
      "modified": "수정됨 (특정 줄 범위 및 변경 사항 설명 포함)",
      "referenced": "참조됨 (컨텍스트용이지만 수정되지 않음)",
      "transmission": "파일별 접근 방식은 또한 승인된 계획을 코딩 에이전트에 정확하게 전송할 수 있게 합니다. \"인증 시스템 업데이트\"와 같은 모호한 지침 대신 에이전트는 정확한 사양을 받습니다: \"토큰 로테이션을 추가하기 위해 src/auth/session_manager.rs 45-67줄 수정, 다음 구조로 src/auth/token_store.rs 생성...\""
    },
    "hitl": {
      "approve": "승인:",
      "approveDesc": "When you are ready, you can hand the plan off to a coding agent or developer for execution.",
      "conclusion": "This workflow keeps execution aligned with the plan you reviewed and helps prevent surprise changes.",
      "edit": "편집:",
      "editDesc": "You can directly modify steps, adjust approaches, add constraints, or remove risky operations using VS Code editing features.",
      "heading": "휴먼 인 더 루프 거버넌스",
      "intro": "PlanToCode keeps planning human-in-the-loop so you can review, edit, and decide when to hand off a plan for execution.",
      "reject": "Discard:",
      "rejectDesc": "If a draft isn't useful, you can delete it from the session list.",
      "requestChanges": "변경 요청:",
      "requestChangesDesc": "Generate alternative plans or merge drafts with custom instructions to converge on the approach you want.",
      "review": "검토:",
      "reviewDesc": "계획은 Monaco 편집기에서 열리며 검토자는 전체 구문 강조 및 전문 편집 도구로 제안된 모든 변경 사항을 검토할 수 있습니다.",
      "workflow": "Plans are designed for a structured review workflow before any code modifications begin:"
    },
    "intro": "Review and approve every plan before execution. File-by-file granularity keeps scope explicit and changes aligned with your requirements.",
    "metaDescription": "AI 구현 계획 가이드. 실행 전에 파일별 계획을 생성, 검토, 승인하세요. 중복 및 잘못된 경로를 방지하세요.",
    "metaTitle": "구현 계획 - AI 변경 검토",
    "multiplePlans": {
      "description": "Plans can be merged, deleted, or reopened later. The panel keeps a list of selected plan identifiers, manages a dedicated modal for terminal output tied to a plan, and exposes navigation helpers so reviewers can page through earlier plans without closing the viewer. Terminal access, prompt copy controls, and merge instructions all share the same job identifier so plan history stays consistent.",
      "heading": "여러 계획 작업"
    },
    "ogDescription": "휴먼 인 더 루프 거버넌스와 파일별 검토 워크플로우가 어떻게 코드 수정에 대한 완전한 제어와 함께 안전한 AI 개발을 보장하는지 이해하세요.",
    "ogTitle": "PlanToCode의 휴먼 인 더 루프 구현 계획",
    "plansOrigin": {
      "description": "각 계획은 현재 세션의 백그라운드 작업에 해당합니다. 패널은 계획 데이터를 구독하고, 현재 열려 있는 계획을 추적하며, 이전 작업과 새 작업 간의 탐색을 노출합니다. 이 동작은 {code} 및 주변 패널 컴포넌트 내에 있습니다.",
      "heading": "계획의 출처",
      "processor": "ImplementationPlanProcessor는 계획 생성을 처리합니다. 관련 파일을 읽고, 선택한 루트 디렉토리를 기반으로 선택적으로 디렉토리 트리를 생성하며, LLM을 위한 통합 프롬프트를 조립합니다.",
      "storage": "Plan responses are stored in the background_jobs table with metadata including planTitle, summary, sessionName, and token usage. The raw LLM response is preserved for review and debugging.",
      "streaming": "계획은 실시간 진행 이벤트와 함께 LlmTaskRunner를 통해 스트리밍됩니다. 100k 토큰을 초과하는 프롬프트에 대해 토큰 경고가 기록되지만 처리는 전체 콘텐츠로 계속됩니다."
    },
    "readTime": "6분",
    "reviewingPlans": {
      "description": "계획 콘텐츠는 Monaco Editor를 래핑하는 공유 {code}를 통해 렌더링됩니다. 뷰어는 일반적인 언어를 자동으로 감지하고, 클립보드에 복사 작업을 지원하며, 매우 큰 계획을 가상화하고, 문자 수 및 구문 인식 강조 표시와 같은 선택적 메트릭을 제공합니다.",
      "heading": "Monaco로 계획 검토",
      "opening": "계획이 열리면 패널은 작업 식별자로 활성 계획을 확인하고, 콘텐츠를 Monaco에 전달하며, 검토자가 현재 열린 모달을 잃지 않고 인접 작업 간에 이동할 수 있도록 합니다."
    },
    "visuals": {
      "structure": {
        "title": "구현 계획 구조",
        "description": "파일별 세분성 및 메타데이터가 포함된 구현 계획의 XML 형식.",
        "imageSrc": "/images/docs/implementation-plans/structure.svg",
        "caption": "단계, 파일, 종속성 추적을 보여주는 계획 구조"
      }
    },
    "title": "구현 계획",
    "planProcessor": {
      "heading": "계획 생성 파이프라인",
      "description": "ImplementationPlanProcessor는 파일 콘텐츠를 로드하고, 컨텍스트를 구축하며, LLM 작업 러너를 통해 결과를 스트리밍하여 계획 생성을 오케스트레이션합니다.",
      "inputs": "세션 컨텍스트, 작업 설명, 선택된 관련 파일, 선택적 디렉토리 트리(include_project_structure 플래그를 통해 구성 가능), 외부 조사를 위한 웹 검색 플래그.",
      "prompt": "prompt_utils::build_unified_prompt를 사용하여 작업 설명, 전체 파일 콘텐츠(잘림 없음), 디렉토리 트리를 추정 토큰 수와 함께 모델별 형식으로 결합합니다.",
      "output": "원시 LLM 응답은 JobResultData::Text로 저장됩니다. 메타데이터에는 planTitle, summary, 토큰 사용량, 캐시 통계, 실제 비용이 포함됩니다.",
      "display": "응답은 진행 이벤트를 통해 UI로 스트리밍됩니다. 계획은 구문 강조 및 복사 작업을 지원하는 Monaco 기반 VirtualizedCodeViewer에서 렌더링됩니다."
    },
    "schema": {
      "heading": "계획 데이터 구조",
      "description": "구현 계획은 연관된 메타데이터와 함께 원시 LLM 응답으로 저장됩니다. 응답 텍스트는 생성된 그대로 정확히 보존되며, 구조화된 메타데이터는 계획 컨텍스트와 사용량을 추적합니다.",
      "fieldsHeading": "메타데이터 필드",
      "fields": [
        "planTitle - 계획의 생성된 또는 사용자 제공 제목",
        "summary - 계획의 사람이 읽을 수 있는 요약",
        "sessionName - 계획을 생성한 세션의 이름",
        "isStructured - True for implementation_plan jobs; false for merge outputs",
        "isStreaming - 완료된 계획의 경우 false (생성 중에는 true)",
        "planData - agent_instructions(선택사항) 및 steps 배열 포함"
      ],
      "exampleHeading": "메타데이터 예제",
      "example": "{\n  \"planTitle\": \"Authentication System Refactor\",\n  \"summary\": \"Implementation plan generated\",\n  \"sessionName\": \"my-project\",\n  \"isStructured\": true,\n  \"isStreaming\": false,\n  \"planData\": {\n    \"agent_instructions\": null,\n    \"steps\": []\n  }\n}"
    }
  },
  "modelConfiguration": {
    "meta": {
      "title": "모델 구성 및 가드레일 - PlanToCode",
      "description": "PlanToCode가 작업별로 허용된 모델을 선택하고 프롬프트를 활성 컨텍스트 윈도우 내에서 유지하는 방법."
    },
    "category": "제품 가이드",
    "date": "2025-09-20",
    "description": "데스크톱 클라이언트의 작업 수준 모델 목록, 선택기 컨트롤, 토큰 가드레일.",
    "intro": "PlanToCode는 모델 선택을 작업 수준 결정으로 취급합니다. 각 워크플로우는 기본 모델과 허용 목록과 함께 제공되며, 데스크톱 클라이언트는 활성 컨텍스트 윈도우를 초과하는 프롬프트 전송을 방지하는 토글을 통해 이러한 옵션을 노출합니다.",
    "metaDescription": "PlanToCode가 작업별로 허용된 모델을 선택하고 프롬프트를 활성 컨텍스트 윈도우 내에서 유지하는 방법.",
    "metaTitle": "모델 구성 및 가드레일 - PlanToCode",
    "ogDescription": "작업 수준 모델 설정, 선택기 토글, 토큰 추정이 어떻게 함께 작동하는지 알아보세요.",
    "ogTitle": "모델 구성 및 가드레일 - PlanToCode",
    "promptEstimation": {
      "description": "토큰 수는 토큰 추정 명령을 통해 계산됩니다. 패널은 백엔드가 시스템, 사용자, 총 토큰 값을 반환할 수 있도록 세션 ID, 작업 설명, 관련 파일, 선택된 모델을 제출합니다. 이 수치는 선택기 가드레일에 직접 공급되어 팀이 다른 도구에 복사하기 전에 제한 초과 프롬프트를 발견할 수 있게 합니다.",
      "heading": "프롬프트 추정"
    },
    "readTime": "5분",
    "selectorToggle": {
      "description": "구현 계획 패널은 {code}로 허용된 모델을 렌더링합니다. 토글은 각 허용 모델을 표시하고, 활성 선택을 추적하며, 전환을 허용하기 전에 예상 프롬프트와 계획된 출력 토큰이 모델의 광고된 컨텍스트 윈도우 내에 맞는지 확인합니다.",
      "guardrails": "모델이 총 토큰 요구 사항을 지원할 수 없는 경우 토글은 버튼을 비활성화하고 계산된 초과분이 포함된 툴팁을 표시하여 검토자가 에이전트에 작업을 보내기 전에 안전한 한도 내에 있도록 합니다.",
      "heading": "클라이언트의 선택기 토글"
    },
    "taskDefaults": {
      "description": "기본 모델과 허용된 대안은 애플리케이션 구성에서 서버 측에 저장됩니다. 구현 계획, 병합, 프롬프트 생성, 음성 전사와 같은 각 작업 유형은 데스크톱 앱이 런타임에 읽는 선호 모델, 허용 옵션 목록, 토큰 제한을 정의합니다.",
      "heading": "작업 기반 기본값"
    },
    "title": "모델 구성"
  },
  "terminalSessions": {
    "meta": {
      "title": "터미널 세션 - PlanToCode",
      "description": "PlanToCode의 PTY 터미널 구현에 대한 기술 가이드. 세션 영속성, 에이전트 비활성 감지 작동 방식, 복구 메커니즘에 대해 알아보세요."
    },
    "attentionDetection": {
      "conclusion": "이 접근 방식은 에이전트가 왜 멈췄는지 추측하지 않고도 에이전트가 작업을 완료했거나 안내가 필요한 시점을 추적하는 데 도움이 됩니다. 주의 표시기는 새 출력이 수신되면 자동으로 지워집니다.",
      "heading": "에이전트 주의 감지",
      "intro": "터미널은 2단계 비활성 감지 시스템을 통해 에이전트 활동을 모니터링합니다. 에이전트가 출력 생성을 멈추면 시스템이 점진적으로 무슨 일이 일어났는지 확인하라고 알립니다:",
      "level1": "레벨 1(30초): 노란색 표시기와 함께 \"에이전트 유휴 상태 - 작업을 완료했을 수 있음\"",
      "level2": "레벨 2(2분): 빨간색 표시기 및 데스크톱 알림과 함께 \"에이전트 주의 필요 - 터미널 확인\""
    },
    "category": "제품 가이드",
    "date": "2025-09-22",
    "dependencyChecks": {
      "description": "명령을 시작하기 전에 터미널은 claude, cursor, codex, gemini와 같은 지원되는 CLI 도구의 존재를 확인합니다. 동일한 명령은 사용자가 어떤 환경이 실행될지 알 수 있도록 기본 셸도 보고합니다. 이는 필요한 바이너리를 찾을 수 없는 세션에서 시작하는 것을 방지합니다.",
      "heading": "종속성 확인"
    },
    "description": "구현 계획 터미널의 영구 PTY 세션, 에이전트 주의 감지, 복구 동작.",
    "intro": "상태 확인 및 로깅과 함께 영구 PTY에서 명령을 실행하세요. 필요할 때 음성 전사를 사용할 수 있습니다.",
    "lifecycle": {
      "description": "터미널이 열리면 UI 컴포넌트가 PTY 세션을 생성하고 버퍼링된 뷰를 통해 출력을 스트리밍합니다. 컴포넌트는 즉각적인 연결 상태를 표시하고, PTY에 키 입력을 전달하며, 세션이 실패하면 자동으로 재시도합니다. 세션 메타데이터는 타임스탬프, 종료 코드, 작업 디렉토리, 전체 출력 로그와 함께 SQLite에 저장되어 재시작 시 이전 컨텍스트를 재개할 수 있습니다.",
      "heading": "세션 수명 주기"
    },
    "metaDescription": "PlanToCode의 PTY 터미널 구현에 대한 기술 가이드. 세션 영속성, 에이전트 비활성 감지 작동 방식, 복구 메커니즘에 대해 알아보세요.",
    "metaTitle": "터미널 세션 - PlanToCode",
    "ogDescription": "계획 터미널에서 세션 영속성, 에이전트 주의 감지, 복구를 이해하세요.",
    "ogTitle": "터미널 세션 - PlanToCode",
    "readTime": "6분",
    "title": "터미널 세션",
    "voiceRecovery": {
      "heading": "음성 전사 및 복구",
      "recovery": "PTY 세션이 연결 해제되면 터미널 화면에 복구 컨트롤이 표시되고 지수 백오프로 연결을 재시도합니다. 상태 확인은 세션 상태를 계속 모니터링하고 연결 문제가 감지되면 자동 복구 작업을 제공합니다.",
      "voice": "Inside the terminal modal, voice transcription can capture speech and paste it into the terminal input area. The recording hook looks up project-level transcription settings, tracks recording state, and inserts transcribed text when the recording stops."
    }
  },
  "copyButtons": {
    "meta": {
      "title": "Copy Buttons - PlanToCode",
      "description": "How template-driven copy buttons resolve placeholders against plans and hand off to terminals or clipboard for agent execution."
    },
    "category": "Execution",
    "date": "2025-09-23",
    "readTime": "10 min",
    "title": "Copy Buttons",
    "description": "Template-driven handoff from implementation plans to PTY terminals and external tools.",
    "intro": "Copy buttons resolve template placeholders against the active plan and then send the result to the clipboard (plan views) or the PTY (terminal modal).",
    "metaTitle": "Copy buttons - PlanToCode",
    "metaDescription": "How template-driven copy buttons resolve placeholders against plans and hand off to terminals or clipboard for agent execution.",
    "ogTitle": "Copy buttons - PlanToCode",
    "ogDescription": "Technical guide to copy button templates, placeholder resolution, and terminal handoff.",
    "visuals": {
      "templateFlow": {
        "title": "Template resolution flow",
        "description": "Templates resolve {{IMPLEMENTATION_PLAN}}, {{TASK_DESCRIPTION}}, and {{STEP_CONTENT}} before copying or sending to the terminal.",
        "imageSrc": "/images/docs/copy-buttons/templates.svg",
        "imageAlt": "Flow showing copy button template resolution",
        "caption": "Placeholder for a template resolution flow diagram."
      }
    },
    "templateConfiguration": {
      "heading": "Template Configuration Sources",
      "description": "Copy button templates follow a layered configuration model. Server defaults provide baseline templates, and project-level overrides customize the implementation_plan task for a given repo.",
      "serverDefaults": {
        "heading": "Server Defaults",
        "description": "Shared templates from /api/config/desktop-runtime-config. Includes button labels and template strings."
      },
      "projectOverrides": {
        "heading": "Project Overrides",
        "description": "Project overrides are stored in SQLite key_value_store under project_task_settings and merged with server defaults."
      },
      "taskSpecific": {
        "heading": "Task-Specific",
        "description": "Copy buttons are configured per task type (implementation_plan) and stored per project. There are no per-job overrides."
      }
    },
    "placeholderResolution": {
      "heading": "Placeholder Resolution",
      "description": "Templates use double-brace placeholders that are resolved against plan content and the current task description.",
      "placeholdersHeading": "Available Placeholders",
      "placeholders": [
        {
          "placeholder": "{{IMPLEMENTATION_PLAN}}",
          "description": "Full implementation plan content as generated by the LLM"
        },
        {
          "placeholder": "{{TASK_DESCRIPTION}}",
          "description": "The task description from the current session"
        },
        {
          "placeholder": "{{STEP_CONTENT}}",
          "description": "Content for the selected plan step (when a step is selected)"
        }
      ],
      "resolutionOrder": "Missing placeholders are replaced with empty strings. Step content is only available when a plan step is selected.",
      "exampleTemplate": "Example template:\n\n{{IMPLEMENTATION_PLAN}}\n\nUnderstand the implementation plan above thoroughly. Analyze the architecture, data flows, and sequence of events.\n\nTask: {{TASK_DESCRIPTION}}"
    },
    "processingPipeline": {
      "heading": "Template Processing Pipeline",
      "description": "When a button is clicked, placeholders are extracted, values are resolved, and the output is sent to clipboard or PTY depending on where the button is used.",
      "steps": [
        {
          "number": 1,
          "title": "Extract Placeholders",
          "description": "Regex scan for {{...}} patterns in the template string"
        },
        {
          "number": 2,
          "title": "Lookup Context",
          "description": "Resolve plan content and task description values for placeholders"
        },
        {
          "number": 3,
          "title": "Substitute Values",
          "description": "Replace placeholders with resolved values"
        },
        {
          "number": 4,
          "title": "Send Output",
          "description": "Copy to clipboard or write to the PTY input buffer"
        }
      ],
      "chunking": {
        "heading": "Large Plan Chunking",
        "description": "When sending to the PTY, the text is chunked into 4KB segments and a carriage return is appended."
      }
    },
    "terminalHandoff": {
      "heading": "PTY Terminal Handoff",
      "description": "In the plan terminal modal, copy buttons write the resolved template to the PTY input buffer as if typed by the user.",
      "detailsHeading": "Handoff Details",
      "details": [
        "Content sent via write_terminal_input_command to the PTY input buffer",
        "Chunked into 4KB segments for large plans",
        "Appends a carriage return after sending"
      ],
      "codeExample": "// Terminal handoff (PlanTerminalModal)\nconst textToSend = replacePlaceholders(button.content, {\n  IMPLEMENTATION_PLAN: planContent,\n  TASK_DESCRIPTION: taskDescription ?? \"\"\n});\nawait sendInChunks(sessionId, textToSend);"
    },
    "clipboardHandoff": {
      "heading": "Clipboard Handoff",
      "description": "In plan cards and plan modals, buttons copy the resolved template to the system clipboard using the browser clipboard API.",
      "crossPlatform": {
        "heading": "Cross-Platform API",
        "description": "Uses navigator.clipboard.writeText() inside the Tauri webview for clipboard access."
      },
      "feedback": {
        "heading": "User Feedback",
        "description": "Toast notification confirms the copy action."
      }
    },
    "defaultButtons": {
      "heading": "Default Copy Buttons",
      "description": "PlanToCode ships with several default copy buttons for implementation plans. These are templates you can edit in settings.",
      "buttonsHeading": "Built-in Buttons",
      "buttons": [
        {
          "id": "parallel-agents",
          "label": "Parallel Claude Coding Agents",
          "description": "Template that instructs Claude Code to launch parallel agents using the plan."
        },
        {
          "id": "investigate-results",
          "label": "Investigate Results",
          "description": "Template that asks the agent to review changes without launching new agents."
        },
        {
          "id": "task-only",
          "label": "Task",
          "description": "Copies only the task description."
        },
        {
          "id": "task-and-plan",
          "label": "Task + Plan",
          "description": "Combines task description and implementation plan for full context."
        },
        {
          "id": "plan-only",
          "label": "Plan",
          "description": "Copies only the implementation plan content."
        }
      ]
    },
    "customization": {
      "heading": "Customizing Copy Buttons",
      "description": "Copy buttons can be customized at multiple levels: global defaults, project-level overrides, and per-task configurations.",
      "globalDefaults": {
        "heading": "Global Defaults",
        "description": "Server-side configuration in /api/config/desktop-runtime-config defines the base set of copy buttons. These are loaded when the desktop app starts and cached for offline use."
      },
      "projectSettings": {
        "heading": "Project-Level Customization",
        "description": "Each project can override the default buttons through the Settings panel. Project-specific buttons are stored in key_value_store and merged with server defaults at runtime."
      },
      "taskSettings": {
        "heading": "Task-Level Configuration",
        "description": "Copy buttons are configured per task type (implementation_plan) and applied per project."
      },
      "editorDescription": "The copy button editor supports drag-and-drop ordering, inline label editing, and template content modification. Changes are persisted automatically."
    },
    "uiIntegration": {
      "heading": "UI Integration and Safety",
      "description": "Copy buttons appear in plan viewers and terminal headers. Clicking a button sends output immediately; there is no preview step by default.",
      "tokenEstimation": {
        "heading": "Token Estimation",
        "description": "Plan cards display token counts for the plan job; copy buttons do not compute per-template token estimates."
      },
      "previewModal": {
        "heading": "Full Preview Modal",
        "description": "There is no dedicated preview modal; open the plan content to inspect what will be copied."
      },
      "disabledState": {
        "heading": "Disabled State",
        "description": "Buttons are disabled when required context is missing (e.g., no active plan, missing session). Tooltips explain what context is needed to enable the button."
      }
    },
    "auditTrail": {
      "heading": "History and signoff",
      "description": "Copy button clicks are not stored in a dedicated table. Plan edits are stored in background_jobs.response and signoff state is recorded in background_jobs.metadata.userSignoff.",
      "schemaHeading": "Notes",
      "schema": "No copy_button_actions table exists in the current release.",
      "fieldsHeading": "Stored plan signals",
      "fields": [
        {
          "field": "background_jobs.response",
          "description": "Plan content after edits or merges"
        },
        {
          "field": "background_jobs.metadata.userSignoff",
          "description": "User signoff state and timestamp"
        }
      ],
      "retention": "No separate retention policy exists for copy button actions; job history retention is controlled in app settings."
    },
    "mobileIntegration": {
      "heading": "Mobile Integration",
      "description": "Copy buttons work in the iOS remote terminal actions bar. Resolved templates are sent to the linked desktop terminal.",
      "deviceLink": {
        "heading": "Device Link Support",
        "description": "When a mobile device is linked to a desktop session, copy buttons can target the desktop terminal directly. The resolved content is sent through the device link WebSocket connection."
      },
      "mobileButtons": {
        "heading": "Mobile-Specific Buttons",
        "description": "Mobile clients use the same copy button configuration stored in project task settings."
      }
    },
    "cta": {
      "heading": "Trace handoff to execution",
      "description": "Terminal sessions show where copy button output lands and how it is logged.",
      "terminalLink": "Terminal sessions",
      "plansLink": "Implementation plans"
    }
  },
  "textImprovement": {
    "meta": {
      "title": "Text improvement - PlanToCode",
      "description": "How the desktop workspace rewrites highlighted text, preserves formatting, and links the feature to voice and video inputs."
    },
    "category": "Product Guide",
    "cta": {
      "description": "Download PlanToCode to combine voice capture, video context, and inline rewriting before you generate implementation plans.",
      "heading": "Try text improvement in the desktop app",
      "links": {
        "architecture": "Architecture overview",
        "buildYourOwn": "Build your own"
      }
    },
    "date": "2025-09-21",
    "description": "How PlanToCode rewrites highlighted text without changing formatting and links the result back to your workspace.",
    "intro": "Refine text with AI context. Select text in any editor, trigger a background job, and get improved content that keeps your formatting intact.",
    "metaDescription": "How the desktop workspace rewrites highlighted text, preserves formatting, and links the feature to voice and video inputs.",
    "metaTitle": "Text improvement - PlanToCode",
    "ogDescription": "Understand the selection popover, job queue, model configuration, and integrations that power text improvement.",
    "ogTitle": "Text improvement - PlanToCode",
    "readTime": "7 min",
    "selectionPopover": {
      "component": "The popover itself is a minimal component rendered by {code}, which simply triggers the provider hook and shows a loading indicator while a rewrite is running. Because the provider registers global listeners, the popover appears in Monaco plan viewers, the plan terminal dictation field, and any task description inputs without extra wiring.",
      "heading": "Selection popover behaviour",
      "provider": "The {code} listens for selection events on standard inputs and Monaco editors. When you highlight non-empty text it positions a popover near the cursor, stores the selected range, and tracks whether the popover should be visible. Clicking the button kicks off the job and disables the control until the result returns. When the job completes the provider applies the improved text back into the same selection and flushes any pending saves to keep session state in sync."
    },
    "title": "Text Improvement",
    "triggerImprovement": {
      "action": "Pressing the popover button calls {code}. The action validates the selection, ensures a session identifier exists, and invokes the Rust command {code} via Tauri. The command builds a {code} containing the original text and queues a background job against the active session.",
      "backend": "On the backend, the {code} resolves the configured model for the {code} task, wraps the selection in XML tags, and runs the request through the {code} without streaming. When the model response returns it records token usage, cost, and the system prompt template before emitting the improved text back to the UI. The default configuration ships with Claude Sonnet 4.5 and Gemini 3 Pro as the approved models, capped at 4,096 tokens with a temperature of 0.7.",
      "heading": "What happens when you trigger an improvement",
      "metadata": "The background jobs sidebar records the original text in job metadata, so you can review what was sent alongside the rewritten copy. If the selection changes while a job is running, the provider skips replacing the text to avoid clobbering manual edits."
    },
    "videoCapture": {
      "dialog": "The video analysis dialog combines the current task description with an optional focus prompt wrapped in <description> and <video_attention_prompt> tags before sending the job. You can narrate while recording; the resulting summary can be pasted into the task description and refined with the improvement popover.",
      "features": "Video jobs include frame-rate controls, optional audio capture, and usage tracking. Results appear in the background jobs sidebar alongside text improvements.",
      "heading": "Video capture and prompt scaffolding"
    },
    "voiceIntegration": {
      "heading": "Voice transcription integration",
      "hook": "Voice recordings use the {code} hook. It loads per-project transcription defaults, requests microphone access, and inserts transcribed text at the cursor inside the task description or terminal dictation buffer. The inserted text can be highlighted and passed through the improvement popover.",
      "preferences": "Language, model, and temperature preferences persist at the project level, so teams get consistent transcription quality before refining the copy. Silence detection warns about bad audio levels, and a ten-minute cap prevents oversized recordings from blocking improvement jobs with large payloads."
    },
    "visuals": {
      "popoverFlow": {
        "title": "Text improvement flow",
        "description": "Selection popover triggers improvement job and returns enhanced text.",
        "imageSrc": "/images/docs/text-improvement/flow.svg",
        "imageAlt": "Text improvement flow diagram"
      }
    },
    "processorDetails": {
      "heading": "Processor implementation details",
      "processor": "The {code} handles the text rewriting workflow on the Rust backend.",
      "stepsHeading": "Processing steps",
      "steps": [
        "Parse the incoming payload with original text and selection metadata",
        "Build the system prompt from the configured text_improvement template",
        "Submit the request to the LLM task runner without streaming",
        "Extract the improved text from the model response",
        "Record token usage, cost, and prompt template for billing",
        "Emit the result back to the UI via Tauri events"
      ]
    },
    "inlineRewriting": {
      "heading": "Inline rewriting behaviour",
      "description": "When the improved text returns, the provider automatically replaces the original selection. The rewriting preserves whitespace, line breaks, and any inline formatting present in the source. If the editor is Monaco-based, the change is applied as a single undo-able edit operation.",
      "contextsHeading": "Supported contexts",
      "contexts": [
        "Task description input fields",
        "Plan terminal dictation area",
        "Monaco plan viewers and editors",
        "Any standard HTML input or textarea"
      ]
    },
    "modelConfiguration": {
      "heading": "Model configuration",
      "description": "Text improvement uses the text_improvement task configuration from the desktop runtime config. You can override the default model and parameters in the settings panel.",
      "settingsHeading": "Configurable settings",
      "settings": [
        "Allowed models list (default: Claude Sonnet 4.5, Gemini 3 Pro)",
        "Maximum token limit (default: 4096)",
        "Temperature setting (default: 0.7)",
        "System prompt template override"
      ]
    },
    "keyFiles": {
      "heading": "Key implementation files",
      "items": [
        "desktop/src/contexts/TextImprovementProvider.tsx",
        "desktop/src/components/TextImprovementPopover.tsx",
        "desktop/src/actions/text-improvement/index.ts",
        "desktop/src-tauri/src/jobs/processors/text_improvement.rs",
        "server/src/config/task_model_config.rs"
      ]
    }
  },
  "voiceTranscription": {
    "meta": {
      "title": "Voice transcription - PlanToCode",
      "description": "How PlanToCode records audio, sends it to the configured transcription provider, and inserts text into task or terminal inputs."
    },
    "category": "Product Guide",
    "date": "2025-09-22",
    "description": "Recording lifecycle, device management, and transcription behavior for voice-driven prompts.",
    "deviceManagement": {
      "description": "The feature requests microphone permission, enumerates available audio inputs, and lets users choose the active device before recording. Changes take effect on the next recording.",
      "heading": "Device management",
      "monitoring": "Real-time audio level monitoring displays visual feedback during recording. The system warns when audio is silent so you can catch muted microphones before sending the recording."
    },
    "intro": "Voice transcription is available anywhere the desktop app exposes dictation controls, including the plan terminal and prompt editors. The feature records audio locally and sends a single recording to the transcription service when you stop, then inserts text into the active input field without blocking manual typing.",
    "metaDescription": "How PlanToCode records audio, sends it to the configured transcription provider, manages permissions, and inserts text into task or terminal inputs.",
    "metaTitle": "Voice transcription - PlanToCode",
    "ogDescription": "Learn how the recording hook manages devices, permissions, and streaming text.",
    "ogTitle": "Voice transcription - PlanToCode",
    "projectSettings": {
      "description": "When a recording session starts, the hook looks up the active project's transcription configuration so recordings follow the project's preferences.",
      "heading": "Project-aware settings",
      "storage": "Project transcription preferences are stored in SQLite key_value_store under project_task_settings and include the preferred model, language code, prompt, and temperature. Hosted uses managed providers; self-hosting can adjust the allowlist."
    },
    "readTime": "5 min",
    "recordingWorkflow": {
      "description": "The recording hook keeps a state machine with idle, recording, processing, and error states. It records audio into a single blob, enforces a ten-minute cap, and sends the recording on stop.",
      "heading": "Recording workflow",
      "statesHeading": "Recording states",
      "states": [
        "idle: No recording in progress, microphone permissions may or may not be granted",
        "recording: Capturing audio via MediaRecorder with live level monitoring",
        "processing: Uploading the recording to the transcription endpoint and awaiting a response",
        "error: Recording failed due to permission denial, device disconnection, or transcription API error"
      ]
    },
    "routingBehavior": {
      "heading": "Multi-destination routing",
      "description": "Transcribed text is routed based on the active UI context and inserted into the appropriate input.",
      "destinations": [
        "Task description editors: Cursor insertion with optional follow-up text_improvement",
        "Terminal dictation buffer: Command text inserted into PTY input",
        "Prompt editors: Direct insertion into active text inputs"
      ]
    },
    "pipeline": {
      "heading": "Transcription pipeline",
      "hook": "The {code} React hook manages the complete recording lifecycle. It initializes {code} for audio capture in WebM format with Opus codec, monitors audio levels, and handles device switching.",
      "command": "The desktop app invokes {code} to send audio data to the server endpoint {code}. The command validates minimum size (1KB), duration, temperature (0.0-1.0), and prompt length (max 1000 characters); the server enforces max file size (100MB).",
      "constraints": "Audio files must be between 1KB and 100MB. Supported formats: WAV, MP3, M4A, OGG, WebM, FLAC, AAC, and MP4. The transcription model must be specified explicitly and must be in the server allowlist (OpenAI models by default on hosted)."
    },
    "serverProcessing": {
      "heading": "Server-side processing",
      "endpoint": "The server exposes {code} which accepts multipart form data. It routes requests to OpenAI or Google based on the model's provider configuration, validates user credits, and calculates billing based on audio duration.",
      "parametersHeading": "Request parameters",
      "parameters": [
        "file: Audio file data (required) - WAV, MP3, M4A, OGG, WebM, FLAC, AAC, or MP4",
        "model: Transcription model ID (required) - from server allowlist (e.g., openai/gpt-4o-transcribe)",
        "durationMs: Recording duration in milliseconds (required for billing calculation)",
        "language: ISO 639-1 language code (optional) - improves accuracy for specific languages",
        "prompt: Context hint for transcription (optional, max 1000 characters) - helps with domain-specific vocabulary",
        "temperature: Sampling temperature 0.0-1.0 (optional, default 0.0) - lower values produce more deterministic output"
      ]
    },
    "dataFlow": {
      "heading": "Data flow",
      "description": "Audio data flows from the browser through the Tauri command layer to the server, which proxies requests to the appropriate transcription provider.",
      "stepsHeading": "Processing steps",
      "steps": [
        "Browser MediaRecorder captures audio in a single recording (WebM by default)",
        "useVoiceTranscription tracks duration and recording state",
        "On stop, the audio blob is converted to bytes and sent via transcribe_audio_command",
        "Tauri command validates size, duration, temperature, and prompt length",
        "Request sent to server /api/audio/transcriptions endpoint with auth token",
        "Server routes to the configured provider and returns transcribed text",
        "Transcribed text returned to desktop and inserted via callback"
      ]
    },
    "keyFiles": {
      "heading": "Key implementation files",
      "items": [
        "desktop/src/hooks/use-voice-recording/use-voice-transcription.ts",
        "desktop/src/actions/voice-transcription/transcribe.ts",
        "desktop/src-tauri/src/commands/audio_commands.rs",
        "server/src/handlers/proxy/specialized/transcription.rs",
        "server/src/clients/openai/transcription.rs",
        "server/src/clients/google_client.rs"
      ]
    },
    "examples": {
      "heading": "Usage examples",
      "description": "Common voice transcription workflows:",
      "items": [
        "Sprint planning: Dictate tasks, then run text_improvement and task_refinement",
        "Terminal commands: Dictation transcribed and typed directly into PTY for execution",
        "Bug reports: Verbal description captured, refined with text_improvement, then stored in task history",
        "Walkthrough notes: Narrate a screen recording and attach the video analysis summary to the task"
      ]
    },
    "cta": {
      "heading": "Continue exploring",
      "description": "Learn how transcribed text can be refined and how meeting recordings are processed into actionable tasks.",
      "links": {
        "textImprovement": "Text Improvement",
        "meetingIngestion": "Meeting Ingestion"
      }
    },
    "title": "Voice Transcription",
    "visuals": {
      "recordingFlow": {
        "title": "Voice transcription pipeline",
        "description": "Audio capture, provider transcription, and text insertion flow.",
        "imageSrc": "/images/docs/voice-transcription/pipeline.svg",
        "imageAlt": "Voice transcription pipeline diagram",
        "caption": "Audio flows from browser capture through Tauri commands to the configured transcription provider."
      }
    }
  },
  "overview": {
    "meta": {
      "title": "시스템 개요 - PlanToCode",
      "description": "여기서 시작: PlanToCode가 무엇을 하는지, 핵심 루프가 어떻게 작동하는지, 각 컴포넌트가 저장소의 어디에 있는지."
    },
    "category": "개요",
    "date": "2025-09-25",
    "readTime": "15분",
    "title": "시스템 개요",
    "description": "시스템, 핵심 루프, 필수 종속성에 대한 간결한 맵.",
    "intro": "PlanToCode는 실행 전에 코드 변경을 계획하고 검증하는 데스크톱 워크스페이스입니다. 로컬 Rust 작업 엔진, React UI, LLM 호출을 위한 서버 프록시를 조정합니다. 시스템은 오프라인 우선 아키텍처를 따르며 데스크톱 앱은 로컬 상태를 위해 SQLite를 사용하여 독립적으로 작동하고, 서버는 인증, LLM 프로바이더 라우팅, 청구를 처리합니다. LLM 접근이 없으면(호스팅은 관리형, 셀프호스팅은 자체 키) 계획 및 분석 파이프라인이 실행되지 않습니다.",
    "visuals": {
      "systemMap": {
        "title": "시스템 맵",
        "description": "데스크톱 앱, Rust 코어, 로컬 SQLite 저장소, 서버 프록시의 맵.",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "PlanToCode 시스템 맵 다이어그램",
        "caption": "데이터가 아래로 흐르고 이벤트가 위로 스트리밍되는 4계층 아키텍처."
      }
    },
    "systemLayers": {
      "heading": "시스템 계층",
      "description": "시스템은 잘 정의된 인터페이스를 통해 통신하는 네 개의 별개 계층으로 구성됩니다:",
      "items": [
        "프레젠테이션 계층: Monaco 편집기, 터미널 패널, 워크플로우 컨트롤이 있는 React UI (desktop/src/)",
        "명령 계층: IPC 및 상태 관리를 처리하는 React와 Rust를 연결하는 Tauri 명령 (desktop/src-tauri/src/commands/)",
        "처리 계층: Rust의 작업 프로세서, 워크플로우 오케스트레이터, 비즈니스 로직 (desktop/src-tauri/src/jobs/)",
        "영속성 계층: 로컬 상태를 위한 SQLite 저장소 및 인증/청구를 위한 서버 PostgreSQL (desktop/src-tauri/src/db_utils/)"
      ]
    },
    "coreLoop": {
      "heading": "실제 핵심 루프",
      "description": "모든 작업은 캡처부터 실행까지 잘 정의된 수명 주기를 통해 흐릅니다:",
      "steps": [
        "텍스트, 음성 전사(useVoiceTranscription 훅을 통해), 또는 비디오 녹화 분석에서 작업을 캡처합니다.",
        "TextImprovementProcessor를 통해 text_improvement 작업으로 작업 설명과 목표를 정제합니다.",
        "파일 탐색 워크플로우를 실행합니다: RootFolderSelectionProcessor가 디렉토리를 선택하고, RegexFileFilterProcessor가 패턴을 적용하고, FileRelevanceAssessmentProcessor가 콘텐츠에 점수를 매기고, ExtendedPathFinderProcessor가 컨텍스트를 확장합니다.",
        "ImplementationPlanProcessor를 통해 구현 계획을 생성합니다. 이는 XML 형식의 계획을 Monaco 뷰어로 스트리밍합니다.",
        "선택적으로 XML 태그가 지정된 소스 계획을 사용하여 ImplementationPlanMergeProcessor로 여러 계획 초안을 병합합니다.",
        "PTY 터미널 세션 또는 외부 에이전트용 복사 버튼 템플릿을 통해 승인된 계획을 실행하거나 내보냅니다.",
        "Persist every job, artifact, and terminal log to SQLite (background_jobs, terminal_sessions tables) for history and recovery."
      ]
    },
    "components": {
      "heading": "주요 컴포넌트",
      "description": "각 컴포넌트에는 특정 책임이 있으며 타입이 지정된 인터페이스를 통해 통신합니다:",
      "items": [
        "desktop/src/의 데스크톱 UI(React), Monaco 계획 뷰, 터미널 패널, 프로바이더(SessionProvider, TextImprovementProvider) 포함.",
        "desktop/src-tauri/의 Rust 코어(Tauri v2), 기능 기반 권한으로 명령, 작업, 영속성 처리.",
        "desktop/src-tauri/migrations/consolidated_schema.sql의 로컬 SQLite 스키마, 동시 액세스를 위한 WAL 모드.",
        "server/src/의 서버 프록시(Actix-Web), 인증, 프로바이더 라우팅, 스트리밍 응답, Stripe를 통한 청구.",
        "mobile/ios/Core/의 모바일 iOS 클라이언트, SwiftUI 인터페이스, Auth0 PKCE, WebSocket 디바이스 링크.",
        "infrastructure/ansible/의 인프라 자동화, Hetzner(EU) 및 InterServer(US) 전용 서버용."
      ]
    },
    "dependencies": {
      "heading": "필수 종속성",
      "description": "시스템에는 다음 외부 서비스 및 리소스가 필요합니다:",
      "items": [
        "계획 생성, 전사, 분석을 위한 외부 LLM 프로바이더(OpenAI, Anthropic, Google, X.AI, OpenRouter).",
        "데스크톱 및 모바일 세션을 위한 PKCE 흐름이 있는 Auth0 기반 인증.",
        "서버 측 사용자 계정, 청구 상태, 작업 큐를 위한 PostgreSQL 17 및 Redis 7+(자체 호스팅 배포).",
        "파일 탐색 워크플로우를 위한 git ls-files 또는 디렉토리 탐색을 통한 로컬 파일 시스템 액세스.",
        "음성 입력 처리를 위한 Whisper 호환 전사 엔드포인트."
      ]
    },
    "codeMap": {
      "heading": "저장소에서 동작이 있는 위치",
      "description": "주요 디렉토리 및 파일에 대한 빠른 참조:",
      "items": [
        "Tauri 명령: desktop/src-tauri/src/commands/ (35개 이상의 명령 모듈: job_commands.rs, workflow_commands.rs, terminal_commands.rs, session_commands.rs, auth0_commands.rs)",
        "워크플로우 오케스트레이션: desktop/src-tauri/src/jobs/workflow_orchestrator/ (definition_loader.rs, stage_scheduler.rs, event_emitter.rs, payload_builder.rs)",
        "작업 프로세서: desktop/src-tauri/src/jobs/processors/ (implementation_plan_processor.rs, text_improvement_processor.rs, root_folder_selection_processor.rs)",
        "SQLite 저장소: desktop/src-tauri/src/db_utils/ (background_job_repository/, session_repository.rs, terminal_repository.rs)",
        "서버 라우트: server/src/routes.rs (configure_routes, configure_public_auth_routes, configure_webhook_routes)",
        "LLM 프록시 핸들러: server/src/handlers/proxy_handlers.rs 및 server/src/handlers/proxy/ (router.rs, providers/)",
        "프로바이더 트랜스포머: server/src/handlers/provider_transformers/ (openai.rs, google.rs, anthropic.rs, xai.rs)",
        "iOS 워크플로우: mobile/ios/Core/Sources/Workflows/WorkflowManager.swift, MobileSessionManager 및 APIClient 포함",
        "인프라 플레이북: infrastructure/ansible/site-base.yml (강화, PostgreSQL, Redis) 및 site-app.yml (배포)"
      ]
    },
    "keyAbstractions": {
      "heading": "주요 추상화",
      "description": "이러한 핵심 개념을 이해하면 코드베이스를 탐색하는 데 도움이 됩니다:",
      "items": [
        "세션: task_description, included_files, 모델 기본 설정과 함께 sessions 테이블에 저장된 프로젝트 컨텍스트. UUID로 식별됨.",
        "백그라운드 작업: task_type, 프롬프트, 응답, 토큰 추적, 비용과 함께 background_jobs 테이블에 저장된 LLM 지원 작업.",
        "워크플로우: IntermediateData가 단계 간에 전달되는 WorkflowOrchestrator에 의해 조정되는 다단계 오케스트레이션 프로세스(예: file_finder_workflow).",
        "Terminal Session: PTY process stored in terminal_sessions with output_log, status, and optional job_id linking for traceability.",
        "프로바이더: 요청 변환 및 응답 정규화가 있는 server/src/handlers/proxy/providers/의 LLM 서비스 추상화."
      ]
    },
    "dataFlowSummary": {
      "heading": "데이터 흐름 요약",
      "description": "일반적인 계획 작업에서 시스템을 통해 데이터가 이동하는 방법:",
      "items": [
        "사용자 입력은 React 컴포넌트를 통해 들어와 @tauri-apps/api/core invoke()를 통해 Tauri 명령으로 흐릅니다.",
        "명령은 background_jobs 레코드를 생성하고 작업 큐를 통해 작업 프로세서로 디스패치합니다.",
        "프로세서는 프롬프트를 빌드하고, 서버 LLM 프록시를 통해 요청을 보내며, Tauri 이벤트를 통해 응답을 스트리밍합니다.",
        "응답은 SQLite에 저장되고 UI 상태를 업데이트하는 React 프로바이더로 전송됩니다.",
        "터미널 실행은 PTY 출력을 UI로 스트리밍하고 세션 복구를 위해 로그를 영속합니다."
      ]
    }
  },
  "runtimeWalkthrough": {
    "meta": {
      "title": "런타임 워크스루 - PlanToCode",
      "description": "입력에서 계획 출력까지 작업의 전체 타임라인, 작업 유형 및 아티팩트 흐름 포함."
    },
    "category": "아키텍처",
    "date": "2025-09-25",
    "readTime": "12분",
    "title": "런타임 워크스루",
    "description": "작업 입력에서 계획 출력까지의 전체 런타임 타임라인.",
    "intro": "이 워크스루는 초기 캡처부터 파일 탐색, 계획 생성, 터미널 실행까지 단일 작업을 추적합니다. 각 단계는 특정 작업 유형에 매핑되며 SQLite에 저장되는 아티팩트를 생성합니다.",
    "visuals": {
      "timeline": {
        "title": "런타임 타임라인",
        "description": "작업 입력, 워크플로우 단계, 계획 출력을 보여주는 시각적 타임라인.",
        "imageSrc": "/images/docs/runtime-walkthrough/timeline.svg",
        "imageAlt": "런타임 타임라인 다이어그램",
        "caption": "작업 실행은 6단계를 거치며, 모든 아티팩트는 SQLite에 영속됩니다."
      },
      "walkthroughVideo": {
        "title": "런타임 워크스루 비디오",
        "description": "입력에서 계획 출력까지 전체 작업 실행의 비디오 데모.",
        "videoSrc": "",
        "posterSrc": "",
        "caption": "비디오 워크스루 플레이스홀더 - 전체 계획 워크플로우 데모를 녹화하세요."
      }
    },
    "timeline": {
      "heading": "상위 레벨 런타임 시퀀스",
      "description": "완전한 작업 실행은 다음 작업 시퀀스를 따릅니다:",
      "steps": [
        "사용자가 TaskDescriptionEditor 컴포넌트를 통해 데스크톱 UI에서 작업 설명을 입력하거나 받아씁니다.",
        "선택 사항: text_improvement 작업이 TextImprovementProcessor를 통해 원시 입력을 다듬습니다.",
        "사용자가 구현 계획 패널 start_file_finder_workflow 명령을 통해 파일 탐색 워크플로우를 트리거합니다.",
        "desktop/src-tauri/src/jobs/workflow_orchestrator/의 WorkflowOrchestrator가 워크플로우 레코드를 생성하고 1단계를 예약합니다.",
        "1단계 (root_folder_selection): RootFolderSelectionProcessor가 디렉토리 트리를 LLM에 보내고 선택된 루트를 IntermediateData.selectedRoots에 저장합니다.",
        "2단계 (regex_file_filter): RegexFileFilterProcessor가 패턴을 생성하고, git ls-files를 실행하고, 매치를 IntermediateData.locallyFilteredFiles에 저장합니다.",
        "3단계 (file_relevance_assessment): FileRelevanceAssessmentProcessor가 파일 내용을 청크하고, 관련성을 점수화하고, IntermediateData.aiFilteredFiles에 저장합니다.",
        "4단계 (extended_path_finder): ExtendedPathFinderProcessor가 임포트와 의존성으로 컨텍스트를 확장하고 IntermediateData.verifiedPaths에 저장합니다.",
        "UI가 event_emitter.rs를 통해 workflow-completed 이벤트를 받고 파일 선택 표시를 업데이트합니다.",
        "사용자가 generate_implementation_plan 명령으로 선택된 파일로 계획 생성을 트리거합니다.",
        "desktop/src-tauri/src/jobs/processors/implementation_plan_processor.rs의 ImplementationPlanProcessor가 job:stream-progress 이벤트를 통해 XML 계획 내용을 Monaco 뷰어로 스트리밍합니다.",
        "사용자가 VirtualizedCodeViewer 컴포넌트에서 계획을 검토하고, 직접 편집하거나 병합을 요청할 수 있습니다.",
        "승인된 계획은 복사 버튼 템플릿을 통해 터미널로 복사되거나 외부 에이전트용으로 내보내집니다.",
        "terminal_commands.rs의 터미널 세션이 PTY 출력을 캡처하고 에이전트 주의 상태를 감지합니다.",
        "All artifacts persist in SQLite background_jobs and terminal_sessions tables for history and session recovery."
      ]
    },
    "jobTypes": {
      "heading": "런타임의 작업 유형",
      "description": "각 task_type은 특정 프로세서에 매핑되며 고유한 아티팩트를 생성합니다:",
      "items": [
        "text_improvement: TextImprovementProcessor가 텍스트를 XML로 래핑하고, LLM에 전송하고, 다듬어진 텍스트를 반환합니다. background_jobs.response에 저장됩니다.",
        "root_folder_selection: RootFolderSelectionProcessor가 디렉토리 트리를 받고 선택된 디렉토리의 JSON 배열을 반환합니다.",
        "regex_file_filter: RegexFileFilterProcessor가 작업 설명에서 패턴을 생성하고 git 파일 목록에 적용합니다.",
        "file_relevance_assessment: FileRelevanceAssessmentProcessor가 파일 내용을 로드하고, 토큰 한도로 청크하고, 관련성을 점수화합니다.",
        "extended_path_finder: ExtendedPathFinderProcessor가 임포트/의존성을 분석하고 관련 파일로 컨텍스트를 확장합니다.",
        "implementation_plan: ImplementationPlanProcessor가 plan_step 요소가 포함된 XML 형식 계획을 스트리밍합니다.",
        "implementation_plan_merge: ImplementationPlanMergeProcessor가 source_plans XML 태그와 사용자 지시를 사용하여 계획을 결합합니다.",
        "video_analysis: Processes screen recordings via /api/llm/video/analyze with a framerate hint.",
        "web_search_prompts_generation: 심층 조사 워크플로우를 위한 research_task XML 블록을 생성합니다.",
        "web_search_execution: 조사 프롬프트를 병렬로 실행하고 결과를 집계합니다."
      ]
    },
    "inputCapture": {
      "heading": "작업 입력 캡처",
      "description": "작업은 여러 입력 표면을 통해 시스템에 들어옵니다:",
      "text": "작업 설명은 TaskDescriptionEditor에 입력하거나 붙여넣고 sessions.task_description에 영속되며 멀티 디바이스 동기화를 위해 device_id와 함께 task_description_history 테이블에 히스토리 항목을 생성합니다.",
      "voice": "음성 입력은 MediaRecorder API를 통해 녹음하고 /api/audio/transcriptions로 전송하고 커서 위치에 삽입하는 useVoiceTranscription 훅을 사용합니다.",
      "video": "비디오 분석은 VideoAnalysisDialog를 사용하여 화면 녹화를 캡처하고 /api/llm/video/analyze에 업로드하고 UI 상태 관찰을 추출합니다."
    },
    "workflowExecution": {
      "heading": "워크플로우 실행 세부사항",
      "description": "WorkflowOrchestrator가 다단계 워크플로우를 조정합니다:",
      "scheduling": "workflow_lifecycle_manager.rs가 워크플로우 레코드를 생성하고 stage_scheduler.rs가 워크플로우 JSON 정의에 따라 순차적으로 단계를 디스패치합니다.",
      "data": "workflow_types.rs의 IntermediateData 구조가 단계 간에 출력을 전달합니다: selectedRoots, rawRegexPatterns, locallyFilteredFiles, aiFilteredFiles, verifiedPaths.",
      "events": "event_emitter.rs가 React UI의 WorkflowTracker가 소비하는 workflow-status 및 workflow-stage Tauri 이벤트를 게시합니다."
    },
    "persistence": {
      "heading": "상태 영속",
      "description": "All artifacts are persisted for review and recovery:",
      "jobs": "background_job_repository/가 session_id, task_type, status, prompt, response, tokens_sent/received, actual_cost와 함께 작업 레코드를 저장합니다.",
      "sessions": "session_repository.rs가 task_description, included_files, model_used, 히스토리 버전과 함께 sessions 테이블을 관리합니다.",
      "terminals": "terminal_repository.rs가 세션 복구를 위해 output_log, status, exit_code, working_directory와 함께 terminal_sessions를 영속합니다.",
      "rehydration": "앱 재시작 시 Rust 코어가 SQLite에서 세션 상태를 재수화하고, 오래된 실행 중인 작업을 실패로 표시하고, 터미널 출력 로그를 복원합니다."
    },
    "inputs": {
      "heading": "Task input capture",
      "capture": "Tasks enter the system through multiple input surfaces: typed text in TaskDescriptionEditor, voice dictation via useVoiceTranscription hook, or video analysis through VideoAnalysisDialog.",
      "artifacts": "Each input type updates SQLite state: task_description in sessions and task_description_history, voice transcription inserts text into the session or terminal input, and video analysis responses are stored in background_jobs."
    },
    "refinement": {
      "heading": "입력 다듬기",
      "jobs": "text_improvement 작업 유형은 TextImprovementProcessor를 통해 원시 입력을 다듬고, 텍스트를 XML로 래핑하고 문법, 명확성, 구조 개선을 위해 LLM에 전송합니다.",
      "storage": "다듬어진 텍스트는 background_jobs.response에 저장되며 React 프로바이더를 통해 sessions.task_description을 업데이트할 수 있습니다."
    },
    "discovery": {
      "heading": "파일 탐색 워크플로우",
      "workflow": "FileFinderWorkflow는 4개의 순차적 단계를 실행합니다: root_folder_selection이 디렉토리를 좁히고, regex_file_filter가 패턴을 적용하고, file_relevance_assessment가 내용을 점수화하고, extended_path_finder가 의존성으로 확장합니다.",
      "outputs": "각 단계는 프로세서 간에 전달되는 IntermediateData 구조에 결과를 저장하며, 최종 파일 선택은 sessions.included_files에 영속됩니다."
    },
    "planGeneration": {
      "heading": "계획 생성",
      "jobs": "implementation_plan 작업 유형은 ImplementationPlanProcessor를 사용하여 파일 경로, 작업 유형, 코드 변경을 포함하는 plan_step 요소가 있는 XML 형식 계획을 생성합니다.",
      "streaming": "계획 내용은 job:stream-progress Tauri 이벤트를 통해 UI로 스트리밍되며, 구문 강조와 함께 VirtualizedCodeViewer Monaco 컴포넌트에 표시됩니다."
    },
    "merge": {
      "heading": "계획 병합",
      "instructions": "implementation_plan_merge 작업은 source_plans XML 태그와 사용자 제공 병합 지시를 사용하여 여러 계획을 결합하고 충돌을 해결하고 변경을 통합합니다.",
      "outputs": "병합된 계획은 소스 계획에 대한 추적성을 유지하며 최종 background_jobs 레코드에 merged_from 메타데이터를 포함합니다."
    },
    "review": {
      "heading": "Plan review",
      "editor": "Plans open in the Monaco-based VirtualizedCodeViewer for review. Users can edit plan text directly, request modifications, or approve for execution.",
      "audit": "Plan edits are persisted in background_jobs.response; signoff state is recorded in background_jobs.metadata.userSignoff."
    },
    "execution": {
      "heading": "실행 핸드오프",
      "terminal": "승인된 계획은 복사 버튼 템플릿을 통해 통합 터미널로 복사되거나, Claude Code, Cursor, Codex와 같은 외부 에이전트용으로 내보내집니다.",
      "logging": "terminal_commands.rs의 터미널 세션은 PTY 출력을 캡처하고, 에이전트 주의 상태를 감지하고, 모든 실행 활동을 terminal_sessions 테이블에 로깅합니다."
    },
    "state": {
      "heading": "상태 영속",
      "jobs": "모든 작업 아티팩트는 session_id, task_type, status, prompt, response, 토큰 수, 비용 추적과 함께 background_jobs 테이블에 영속됩니다.",
      "rehydration": "앱 재시작 시 Rust 코어가 SQLite에서 세션 상태를 재수화하고, 오래된 실행 중인 작업을 실패로 표시하고, 터미널 출력 로그를 복원합니다."
    },
    "jobMap": {
      "heading": "작업 유형 매핑",
      "items": [
        "text_improvement → TextImprovementProcessor → 다듬어진 작업 설명",
        "root_folder_selection → RootFolderSelectionProcessor → 선택된 디렉토리",
        "regex_file_filter → RegexFileFilterProcessor → 패턴 매칭된 파일",
        "file_relevance_assessment → FileRelevanceAssessmentProcessor → 점수화된 파일",
        "extended_path_finder → ExtendedPathFinderProcessor → 확장된 컨텍스트",
        "implementation_plan → ImplementationPlanProcessor → XML 계획 문서",
        "implementation_plan_merge → ImplementationPlanMergeProcessor → 병합된 계획"
      ]
    },
    "cta": {
      "heading": "아키텍처 탐색하기",
      "description": "컴포넌트가 어떻게 함께 맞춰지는지 자세히 이해하세요.",
      "links": {
        "architecture": "아키텍처 개요",
        "jobs": "백그라운드 작업",
        "desktop": "데스크톱 앱 내부",
        "dataModel": "데이터 모델",
        "plans": "구현 계획"
      }
    }
  },
  "desktopApp": {
    "meta": {
      "title": "데스크톱 앱 내부 - PlanToCode",
      "description": "Tauri 데스크톱 셸, Rust 명령 레이어, SQLite 영속, PTY 세션이 어떻게 함께 작동하는지."
    },
    "category": "데스크톱",
    "date": "2025-09-25",
    "readTime": "14분",
    "title": "데스크톱 앱 내부",
    "description": "Tauri v2 셸, Rust 명령 레이어, PTY 세션, UI 상태 관리.",
    "intro": "데스크톱 앱은 React UI를 실행하는 Tauri v2 셸(버전 2.9.1)입니다. Rust 서비스는 워크플로우, 터미널 세션, 구성을 위한 명령을 노출하면서 상태를 SQLite에 로컬로 영속합니다. 기능 기반 권한 모델은 파일 시스템 액세스, HTTP 요청, 셸 실행, 시스템 알림에 대한 세분화된 보안 제어를 제공합니다.",
    "visuals": {
      "shell": {
        "title": "데스크톱 셸 개요",
        "description": "계획 편집기, 터미널 탭, 작업 상태 사이드바를 보여주는 스크린샷.",
        "imageSrc": "/assets/images/demo-implementation-plans.jpg",
        "imageAlt": "PlanToCode 데스크톱 셸",
        "caption": "구현 계획 패널과 사이드바를 보여주는 데스크톱 앱."
      }
    },
    "projectLayout": {
      "heading": "프로젝트 레이아웃",
      "description": "데스크톱 애플리케이션은 표준 Tauri v2 구조를 따릅니다:",
      "items": [
        "desktop/src/: React UI 컴포넌트, 훅, 프로바이더, 데스크톱 특화 어댑터.",
        "desktop/src-tauri/: 명령, 작업, 리포지토리, 서비스를 포함하는 Rust 코어.",
        "desktop/src-tauri/src/lib.rs: 플러그인 등록과 AppState 관리가 있는 애플리케이션 진입점.",
        "desktop/src-tauri/src/commands/: 도메인별로 구성된 35개 이상의 Tauri 명령 핸들러 모듈.",
        "desktop/src-tauri/src/jobs/: 백그라운드 작업 프로세서, 워크플로우 오케스트레이션, 큐 관리.",
        "desktop/src-tauri/capabilities/: 보안 권한을 위한 JSON 기능 정의 (default.json, desktop-default.json, plantocode-api.json).",
        "desktop/src-tauri/migrations/: consolidated_schema.sql의 SQLite 스키마 마이그레이션."
      ]
    },
    "ui": {
      "heading": "React UI와 표면 영역",
      "description": "React UI는 작업 설명 편집기, 계획 뷰어, 터미널 패널을 렌더링합니다:",
      "components": [
        "TaskDescriptionEditor: 음성 전사 통합과 텍스트 개선 팝오버가 있는 다중 라인 입력.",
        "VirtualizedCodeViewer: 구문 강조와 복사 액션이 있는 Monaco 기반 계획 표시.",
        "TerminalSurface: 연결 상태, 에이전트 주의 표시기, 음성 입력이 있는 PTY 출력 버퍼.",
        "SessionProvider: 활성 세션, 파일 선택, 모델 기본 설정을 위한 전역 상태 관리.",
        "TextImprovementProvider: 인라인 재작성을 위한 선택 리스너와 팝오버 위치 지정.",
        "WorkflowTracker: 다단계 워크플로우를 위한 실시간 진행 표시."
      ]
    },
    "commands": {
      "heading": "Tauri 명령",
      "description": "desktop/src-tauri/src/commands/의 명령은 Rust 기능을 React UI에 노출합니다. 주요 모듈은 다음과 같습니다:",
      "modules": [
        "job_commands.rs: create_job, get_job, cancel_job, get_jobs_for_session, clear_job_history.",
        "workflow_commands.rs: start_file_finder_workflow, get_workflow_status, retry_workflow, pause_workflow, resume_workflow.",
        "terminal_commands.rs: start_terminal_session, attach_terminal_output, write_terminal_input, resize_terminal_session, get_terminal_metadata, graceful_exit_terminal.",
        "session_commands.rs: create_session, get_session, update_session, sync_task_description_history, sync_file_selection_history.",
        "auth0_commands.rs: initiate_login, complete_login, refresh_token, logout, get_user_info.",
        "implementation_plan_commands.rs: generate_implementation_plan, merge_implementation_plans, estimate_tokens.",
        "config_commands.rs: get_runtime_config, get_model_config, get_system_prompts, refresh_config_cache.",
        "settings_commands.rs: get_setting, set_setting, get_project_system_prompt, set_project_system_prompt."
      ]
    },
    "appState": {
      "heading": "AppState 관리",
      "description": "Rust 코어는 Tauri의 상태 시스템을 통해 애플리케이션 상태를 관리합니다:",
      "structure": "lib.rs의 AppState 구조체는 다음을 보유합니다: config_load_error (Option<String>), HTTP 클라이언트 (reqwest::Client), Mutex 뒤의 RuntimeConfig (서버 URL, 온보딩 상태), 인증을 위한 Auth0State.",
      "config": "RuntimeConfig는 server_url, onboarding_complete 플래그를 포함하며 set_runtime_config 명령을 통해 업데이트됩니다. ConfigCache는 프로젝트별 오버라이드와 함께 런타임 AI 구성을 저장합니다.",
      "tokens": "TokenManager는 OS 키링(keyring 크레이트를 통해)을 사용하여 access_token, refresh_token, jwt를 안전하게 저장하며 만료 전에 자동으로 갱신합니다."
    },
    "jobs": {
      "heading": "작업 프로세서와 워크플로우",
      "description": "desktop/src-tauri/src/jobs/의 작업 처리 아키텍처:",
      "queue": "queue.rs는 인메모리 대기 작업과 SQLite 영속으로 작업 큐를 관리합니다. 작업은 다음 상태를 거칩니다: idle, created, queued, acknowledged_by_worker, preparing, preparing_input, running, generating_stream, processing_stream, completed, failed, canceled.",
      "processors": "processors/ 디렉토리에는 작업 특화 프로세서가 있습니다: ImplementationPlanProcessor (스트리밍 계획), TextImprovementProcessor (인라인 재작성), RootFolderSelectionProcessor, RegexFileFilterProcessor, FileRelevanceAssessmentProcessor, ExtendedPathFinderProcessor.",
      "orchestrator": "workflow_orchestrator/가 다단계 워크플로우를 조정합니다: definition_loader.rs가 JSON 워크플로우 정의를 로드하고, stage_scheduler.rs가 단계를 디스패치하고, payload_builder.rs가 입력을 구성하고, event_emitter.rs가 진행 이벤트를 게시합니다.",
      "streaming": "processors/generic_llm_stream_processor.rs가 스트리밍 LLM 응답을 처리하고, job:stream-progress 이벤트를 발생시키고 background_jobs.response에 내용을 누적합니다."
    },
    "persistence": {
      "heading": "로컬 영속",
      "description": "desktop/src-tauri/migrations/consolidated_schema.sql의 SQLite 저장소:",
      "tables": [
        "sessions: id (UUID), name, project_directory, project_hash, task_description, included_files, force_excluded_files, model_used, 히스토리 버전.",
        "background_jobs: id (UUID), session_id (FK), task_type, status, prompt, response, tokens_sent/received, cache_read/write_tokens, actual_cost, metadata (JSON), server_request_id.",
        "terminal_sessions: id, job_id (nullable FK), session_id, status, process_pid, output_log, working_directory, environment_vars, last_output_at.",
        "task_description_history: 멀티 디바이스 동기화를 위한 session_id (FK), description, device_id, sequence_number, version.",
        "file_selection_history: session_id (FK), included_files, force_excluded_files, device_id, sequence_number.",
        "project_system_prompts: 프로젝트별 프롬프트 오버라이드를 위한 project_hash, task_type, system_prompt.",
        "key_value_store: 앱 설정을 위한 key, value (JSON), updated_at.",
        "error_logs: 클라이언트 측 오류 추적을 위한 timestamp, level, error_type, message, context, stack, metadata."
      ],
      "repositories": "db_utils/의 리포지토리가 타입화된 액세스를 제공합니다: background_job_repository/ (base.rs, worker.rs, metadata.rs, cleanup.rs로 모듈화), session_repository.rs, terminal_repository.rs, settings_repository.rs, error_log_repository.rs."
    },
    "terminal": {
      "heading": "터미널 세션",
      "description": "PTY 터미널 구현:",
      "commands": "terminal_commands.rs가 세션 라이프사이클을 관리합니다: create_terminal_session이 portable-pty 크레이트를 통해 PTY를 생성하고, send_terminal_input이 키 입력을 전달하고, resize_terminal이 크기를 조정하고, check_cli_availability가 도구 존재 여부(claude, cursor, codex, gemini)를 확인합니다.",
      "persistence": "terminal_repository.rs가 output_log (누적된 터미널 출력), status (idle/running/completed/failed/agent_requires_attention), exit_code, working_directory와 함께 세션을 영속합니다. 세션은 앱 재시작 후 복원될 수 있습니다.",
      "attention": "에이전트 주의 감지가 last_output_at 타임스탬프를 모니터링합니다. 레벨 1 (30초 유휴): 노란색 표시기. 레벨 2 (2분 유휴): 데스크톱 알림과 함께 빨간색 표시기."
    },
    "inputStability": {
      "heading": "작업 설명 안정성",
      "description": "작업 설명 편집기에는 커서 점프를 방지하는 안전장치가 포함되어 있습니다:",
      "items": [
        "원격 업데이트는 사용자가 입력하는 동안 대기열에 추가되고 유휴 상태 또는 블러 시 플러시됩니다.",
        "선택 상태는 추적되고 React 리렌더링 후 복원됩니다.",
        "백그라운드 라이터는 sessionActions.updateCurrentSessionFields를 호출하여 업데이트를 조정합니다.",
        "멀티 디바이스 동기화는 충돌 해결을 위해 sequence_number와 version 필드를 사용합니다."
      ]
    },
    "plugins": {
      "heading": "Tauri 플러그인",
      "description": "PlanToCode는 Tauri v2 플러그인 생태계를 사용합니다:",
      "list": [
        "tauri-plugin-http (2.5.2): API 호출을 위한 CSP 인식 fetch가 있는 HTTP 클라이언트.",
        "tauri-plugin-dialog (2.4.2): 네이티브 파일/폴더 선택기와 메시지 다이얼로그.",
        "tauri-plugin-shell (2.3.3): 외부 CLI 도구를 위한 셸 명령 실행.",
        "tauri-plugin-store (2.4.1): 앱 설정을 위한 영속적 키-값 저장소.",
        "tauri-plugin-notification (2.3.0): 에이전트 주의를 위한 데스크톱 알림.",
        "tauri-plugin-updater (2.9.0): 서명 검증이 있는 인앱 업데이트.",
        "tauri-plugin-single-instance (2.3.4): 단일 인스턴스 적용.",
        "tauri-plugin-process (2.3.1): 프로세스 재시작 기능."
      ]
    }
  },
  "serverApi": {
    "meta": {
      "title": "서버 API 및 LLM 프록시 - PlanToCode",
      "description": "데스크톱 및 모바일 클라이언트가 사용하는 인증, 프로바이더 라우팅, 모델 구성, WebSocket 엔드포인트."
    },
    "category": "서버",
    "date": "2025-09-25",
    "readTime": "12분",
    "title": "서버 API 및 LLM 프록시",
    "description": "인증, 프로바이더 라우팅, 모델 구성, 청구, WebSocket 엔드포인트.",
    "intro": "서버는 인증, 모델 구성, LLM 프록싱, 청구를 제공하는 Rust로 작성된 Actix-Web 서비스입니다. 데스크톱 및 모바일 클라이언트는 안전한 프로바이더 라우팅과 스트리밍 응답을 위해 이에 의존합니다. 서버는 두 지역의 전용 인프라에서 실행됩니다: Hetzner (EU) api-eu.plantocode.com과 InterServer (US) api-us.plantocode.com.",
    "visuals": {
      "flow": {
        "title": "서버 요청 흐름",
        "description": "클라이언트, API 라우트, LLM 프록시를 보여주는 다이어그램.",
        "imageSrc": "/images/docs/provider-routing/routing-map.svg",
        "imageAlt": "서버 요청 흐름 다이어그램",
        "caption": "서버 요청 흐름을 위한 플레이스홀더."
      }
    },
    "routeOrganization": {
      "heading": "라우트 구성",
      "description": "라우트는 세 가지 구성 함수로 server/src/routes.rs에 구성됩니다:",
      "functions": [
        "configure_routes(): /api 스코프 아래의 JWT 인증 라우트. auth, billing, config, providers, models, llm proxy, audio, system-prompts, consent, devices, notifications 포함.",
        "configure_public_auth_routes(): /auth 스코프 아래의 브라우저 기반 인증 흐름. Auth0 initiate-login, callback, logged-out 라우트 포함.",
        "configure_webhook_routes(): /webhooks 스코프 아래의 비인증 웹훅 엔드포인트. 현재 Stripe 웹훅 처리."
      ]
    },
    "auth": {
      "heading": "인증 엔드포인트",
      "description": "인증은 PKCE 흐름과 함께 Auth0를 사용합니다:",
      "routes": [
        "/auth/auth0/initiate-login (GET): code_challenge로 OAuth 흐름을 시작하고 Auth0로 리디렉션합니다.",
        "/auth/auth0/callback (GET): Auth0 리디렉션을 처리하고 코드를 토큰으로 교환합니다.",
        "/api/auth/userinfo (GET): Auth0에서 인증된 사용자 정보를 반환합니다.",
        "/api/auth/logout (POST): 토큰을 취소하고 세션을 지웁니다.",
        "/api/auth/account (DELETE): 연쇄 정리와 함께 계정 삭제.",
        "/api/auth0/refresh-app-token (POST): 리프레시 토큰을 사용하여 액세스 토큰을 갱신합니다."
      ],
      "implementation": "인증 핸들러는 server/src/handlers/auth0_handlers.rs와 server/src/handlers/auth/에 있습니다. JWT 검증은 JWKS 순환과 함께 services/auth/jwt.rs를 사용합니다. 취소된 토큰은 revoked_token_repository.rs에서 추적됩니다."
    },
    "llmProxy": {
      "heading": "LLM 프록시 및 스트리밍",
      "description": "LLM 프록시는 프로바이더 간 요청을 정규화하고 응답을 스트리밍합니다:",
      "routes": [
        "/api/llm/chat/completions (POST): 메인 채팅 완성 엔드포인트. 모델 ID에 따라 OpenAI, Anthropic, Google, X.AI, OpenRouter로 라우팅합니다.",
        "/api/llm/video/analyze (POST): Multipart video upload for video analysis (FPS hint). Requires google/* models with video capability.",
        "/api/llm/cancel (POST): request_id로 진행 중인 스트리밍 요청을 취소합니다.",
        "/api/llm/status/{request_id} (GET): 요청 상태를 반환합니다 (active, completed, cancelled).",
        "/api/audio/transcriptions (POST): Whisper 호환 전사. 오디오 파일과 매개변수가 있는 멀티파트 업로드."
      ],
      "routing": "server/src/handlers/proxy/router.rs의 라우터가 모델 ID 접두사(openai/, anthropic/, google/, xai/, openrouter/)에 따라 프로바이더를 선택합니다. server/src/handlers/proxy/providers/의 프로바이더별 핸들러가 요청을 변환하고 응답을 정규화합니다.",
      "streaming": "스트리밍 응답은 streaming/sse_adapter.rs를 통해 Server-Sent Events (SSE)를 사용합니다. 프록시는 프로바이더에서 청크를 전달하고, 공통 형식으로 변환하고, 실시간으로 토큰 사용량을 추적합니다."
    },
    "providers": {
      "heading": "프로바이더 라우팅",
      "description": "server/src/handlers/proxy/providers/의 프로바이더 핸들러:",
      "handlers": [
        "openai.rs: OpenAI 및 OpenAI 호환 API (GPT-4, o1, o3).",
        "anthropic.rs: 프롬프트 캐싱 지원이 있는 Anthropic Claude 모델.",
        "google.rs: 비디오 분석 기능을 포함한 Google Gemini 모델.",
        "xai.rs: X.AI Grok 모델.",
        "openrouter.rs: 모델 라우팅을 위한 OpenRouter 집계."
      ],
      "transformers": "server/src/handlers/provider_transformers/의 요청/응답 변환기가 API 차이를 정규화합니다. 각 변환기가 처리하는 것: 요청 본문 형식, 인증 헤더, 스트리밍 청크 형식, 사용량 추출, 오류 정규화."
    },
    "config": {
      "heading": "구성 엔드포인트",
      "description": "구성 및 모델 메타데이터 엔드포인트:",
      "routes": [
        "/api/config/all-configurations (GET): 작업 유형별 모델 설정을 포함한 모든 애플리케이션 구성을 반환합니다.",
        "/api/config/desktop-runtime-config (GET): 데스크톱 특화 런타임 구성.",
        "/api/config/billing (GET/PUT): 청구 구성 관리.",
        "/api/providers (GET): 기능이 있는 사용 가능한 LLM 프로바이더 목록.",
        "/api/providers/with-counts (GET): 모델 수가 있는 프로바이더.",
        "/api/providers/by-capability/{capability} (GET): 기능별 프로바이더 필터링.",
        "/api/models (GET): 가격이 있는 모든 사용 가능한 모델.",
        "/api/models/{id} (GET): 단일 모델 세부사항.",
        "/api/models/by-provider/{provider_code} (GET): 특정 프로바이더의 모델.",
        "/api/models/estimate-cost (POST): 요청에 대한 비용 추정.",
        "/api/models/estimate-tokens (POST): 토큰 수 추정.",
        "/api/system-prompts/defaults (GET): 작업 유형별 기본 시스템 프롬프트."
      ]
    },
    "billing": {
      "heading": "청구 엔드포인트",
      "description": "Stripe와 통합된 크레딧 기반 청구 시스템:",
      "routes": [
        "/api/billing/dashboard (GET): 사용자 청구 대시보드 데이터.",
        "/api/billing/usage-summary (GET): 비용 분석이 있는 상세 사용량.",
        "/api/billing/credits/balance (GET): 현재 크레딧 잔액.",
        "/api/billing/credits/details (GET): 부여 및 구매를 포함한 크레딧 세부사항.",
        "/api/billing/credits/unified-history (GET): 거래 내역.",
        "/api/billing/checkout/credit-purchase (POST): 크레딧을 위한 Stripe 체크아웃 생성.",
        "/api/billing/checkout/setup (POST): 결제 방법을 위한 Stripe 설정 세션 생성.",
        "/api/billing/auto-top-off (GET/PUT): 자동 충전 설정 관리."
      ],
      "implementation": "청구 핸들러는 server/src/handlers/billing/에 있습니다. 크레딧 서비스는 services/credit_service.rs에 있습니다. Stripe 통합은 webhook_handlers.rs의 웹훅 처리와 함께 services/stripe_service.rs를 통해 이루어집니다."
    },
    "devices": {
      "heading": "디바이스 관리",
      "description": "디바이스 등록 및 푸시 알림:",
      "routes": [
        "/api/devices/register (POST): device_id로 데스크톱 디바이스 등록.",
        "/api/devices/mobile/register (POST): 플랫폼 정보로 모바일 디바이스 등록.",
        "/api/devices/{device_id}/heartbeat (POST): 존재 확인을 위한 디바이스 하트비트.",
        "/api/devices/{device_id}/push-token (POST): 푸시 알림 토큰 저장.",
        "/api/devices/{device_id}/connection-descriptor (GET): 디바이스 연결을 위한 WebSocket 연결 정보.",
        "/api/notifications/job-completed (POST): 완료된 작업에 대한 푸시 알림 전송.",
        "/api/notifications/job-progress (POST): 진행 알림 전송."
      ]
    },
    "websockets": {
      "heading": "WebSocket 엔드포인트",
      "description": "WebSocket을 통한 실시간 통신:",
      "endpoints": [
        "/ws/device-link: 데스크톱-모바일 디바이스 연결을 위한 릴레이. 연결된 디바이스 간 터미널 출력 스트리밍, 작업 상태 업데이트, RPC 명령 처리.",
        "/ws/events: 실시간 업데이트를 위한 일반 이벤트 스트림."
      ],
      "implementation": "디바이스 링크 릴레이는 server/src/handlers/device_link_ws.rs에 있습니다. 세션은 하트비트 모니터링과 재연결 지원이 있는 services/relay_session_store.rs에 의해 관리됩니다."
    },
    "serverStorage": {
      "heading": "서버 측 영속",
      "description": "server/src/db/repositories/의 리포지토리가 있는 PostgreSQL 데이터베이스:",
      "repositories": [
        "user_repository.rs: Auth0 sub에 연결된 사용자 계정.",
        "customer_billing_repository.rs: Stripe 고객 및 크레딧 상태.",
        "credit_transaction_repository.rs: 크레딧 거래 내역.",
        "provider_repository.rs: LLM 프로바이더 구성.",
        "system_prompts_repository.rs: 시스템 프롬프트 템플릿.",
        "consent_repository.rs: 법적 동의 추적.",
        "audit_log_repository.rs: 민감한 작업에 대한 감사 추적.",
        "revoked_token_repository.rs: JWT 취소 목록.",
        "api_key_repository.rs: 보안 해싱이 있는 API 키 관리."
      ]
    }
  },
  "backgroundJobs": {
    "meta": {
      "title": "백그라운드 작업 - PlanToCode",
      "description": "데스크톱 작업 엔진을 위한 작업 큐 아키텍처, 프로세서 유형, 상태 머신, 아티팩트 저장."
    },
    "category": "아키텍처",
    "date": "2025-09-25",
    "readTime": "14분",
    "title": "백그라운드 작업",
    "description": "작업 큐, 프로세서, 상태 머신, 이벤트 스트리밍, 아티팩트 저장.",
    "intro": "All LLM-backed work runs through the background job system in the desktop app. The job queue dispatches work to processors, streams progress events, and persists every prompt and response in SQLite for review and recovery. This architecture enables cancellation, retry, cost tracking, and real-time UI updates.",
    "visuals": {
      "stateMachine": {
        "title": "작업 상태 머신",
        "description": "생성에서 완료 또는 실패까지의 작업 상태 전환을 보여주는 다이어그램.",
        "imageSrc": "/images/docs/background-jobs/state-machine.svg",
        "imageAlt": "작업 상태 머신 다이어그램",
        "caption": "작업 상태 머신 다이어그램을 위한 플레이스홀더."
      }
    },
    "jobRecord": {
      "heading": "작업 레코드 구조",
      "description": "각 작업은 다음 필드와 함께 SQLite에 background_jobs 행을 생성합니다:",
      "fields": [
        "id (TEXT PRIMARY KEY): 작업의 UUID.",
        "session_id (TEXT NOT NULL, FK): CASCADE DELETE와 함께 sessions.id 참조.",
        "task_type (TEXT DEFAULT 'unknown'): 프로세서 식별자 (예: implementation_plan, text_improvement, root_folder_selection).",
        "status (TEXT): 유효한 값에 대한 CHECK 제약 조건이 있는 현재 상태.",
        "prompt (TEXT NOT NULL): Full text sent to the LLM, stored for review and debugging.",
        "response (TEXT): LLM 출력 또는 오류 메시지.",
        "error_message (TEXT): 실패 시 상세 오류 정보.",
        "tokens_sent (INTEGER DEFAULT 0): 프로바이더 응답의 입력 토큰 수.",
        "tokens_received (INTEGER DEFAULT 0): 출력 토큰 수.",
        "cache_read_tokens (INTEGER DEFAULT 0): 프로바이더 캐시에서 읽은 토큰 (Anthropic).",
        "cache_write_tokens (INTEGER DEFAULT 0): 캐시에 기록된 토큰.",
        "model_used (TEXT): 요청에 사용된 모델 식별자.",
        "actual_cost (REAL): 토큰 사용량과 모델 가격을 기반으로 계산된 비용.",
        "metadata (TEXT): 작업별 데이터, 워크플로우 ID, 단계 이름이 있는 JSON.",
        "system_prompt_template (TEXT): 시스템 프롬프트에 사용된 템플릿 식별자.",
        "server_request_id (TEXT): 서버 측 사용량 추적에 연결.",
        "created_at, updated_at, start_time, end_time (INTEGER): 타임스탬프.",
        "is_finalized (INTEGER DEFAULT 0): 최종 비용/사용량이 기록되었는지 여부."
      ]
    },
    "statusValues": {
      "heading": "상태 값과 전환",
      "description": "작업은 데이터베이스에서 추적되는 잘 정의된 상태를 거칩니다:",
      "statuses": [
        "idle: 처리 시작 전 초기 상태.",
        "created: 작업 레코드 생성됨, 아직 대기열에 없음.",
        "queued: 작업 큐에 추가됨, 프로세서 대기 중.",
        "acknowledged_by_worker: 프로세서가 작업을 픽업함.",
        "preparing: 프로세서가 입력(파일, 프롬프트)을 수집 중.",
        "preparing_input: LLM 요청 페이로드 빌드 중.",
        "running: LLM에 요청 전송됨, 응답 대기 중.",
        "generating_stream: 스트리밍 응답 진행 중.",
        "processing_stream: 스트리밍된 청크 처리 중.",
        "completed: 작업 성공적으로 완료됨.",
        "completed_by_tag: 스트림 종료 태그 감지로 완료됨.",
        "failed: error_message가 채워진 상태로 작업 실패.",
        "canceled: 사용자가 취소 요청."
      ],
      "transitions": "전환은 background_job_repository/worker.rs에서 적용됩니다. 유효하지 않은 전환은 거부됩니다. 상태 변경은 job:status-changed Tauri 이벤트를 발생시킵니다."
    },
    "orchestrator": {
      "heading": "워크플로우 오케스트레이터",
      "description": "다단계 워크플로우는 desktop/src-tauri/src/jobs/workflow_orchestrator/의 WorkflowOrchestrator에 의해 관리됩니다:",
      "modules": [
        "mod.rs: 메인 오케스트레이터 구조체와 워크플로우 실행 진입점.",
        "definition_loader.rs: 단계 순서와 프로세서 유형을 지정하는 워크플로우 JSON 정의 로드 (예: file_finder_workflow.json).",
        "stage_scheduler.rs: 단계를 순차적으로 예약하고 업스트림 완료를 대기.",
        "stage_job_manager.rs: 각 단계에 대한 background_job 레코드 생성.",
        "payload_builder.rs: IntermediateData에서 단계 입력 구성.",
        "data_extraction.rs: 완료된 단계 작업에서 출력 추출.",
        "event_emitter.rs: workflow-status 및 workflow-stage Tauri 이벤트 게시.",
        "state_updater.rs: 메모리와 데이터베이스에서 워크플로우 상태 업데이트.",
        "completion_handler.rs: 워크플로우 완료 및 정리 처리.",
        "failure_handler.rs: 단계 실패 및 재시도 결정 관리.",
        "retry_handler.rs: 지수 백오프로 재시도 로직 구현."
      ],
      "dataFlow": "워크플로우는 WorkflowIntermediateData(workflow_types.rs에 정의됨)를 사용하여 단계 간에 출력을 전달합니다: directoryTreeContent, selectedRoots, rawRegexPatterns, locallyFilteredFiles, aiFilteredFiles, verifiedPaths, unverifiedPaths."
    },
    "processors": {
      "heading": "작업 프로세서",
      "description": "각 task_type은 desktop/src-tauri/src/jobs/processors/의 프로세서에 매핑됩니다:",
      "implementations": [
        "implementation_plan_processor.rs: 선택된 파일 내용을 로드하고, 디렉토리 트리로 구조화된 프롬프트를 빌드하고, XML 계획을 UI로 스트리밍합니다. 스트리밍을 위해 generic_llm_stream_processor를 사용합니다.",
        "text_improvement_processor.rs: 선택을 XML 태그로 래핑하고, 비스트리밍 요청을 보내고, 개선된 텍스트를 반환합니다. LlmTaskRunner를 통해 실행됩니다.",
        "root_folder_selection_processor.rs: 디렉토리 트리를 LLM에 보내고 선택된 디렉토리의 JSON 배열 응답을 파싱합니다.",
        "RegexFileFilterProcessor (processors/mod.rs에 있음): 작업에서 정규식 패턴을 생성하고 git 파일 목록에 적용하고 바이너리를 필터링합니다.",
        "FileRelevanceAssessmentProcessor: 토큰 한도로 파일 내용을 청크하고, 배치로 관련성을 점수화하고, 관련 경로를 집계합니다.",
        "ExtendedPathFinderProcessor (path_finder_types.rs): 임포트/의존성을 분석하고, 관련 파일을 제안하고, 경로 존재를 검증합니다.",
        "web_search_prompts_generator_processor.rs: 심층 조사를 위한 research_task XML 블록을 생성합니다.",
        "web_search_executor_processor.rs: 서버 검색 API를 통해 조사 프롬프트를 병렬로 실행합니다.",
        "generic_llm_stream_processor.rs: 청크 누적, 이벤트 발생, 응답 최종화를 처리하는 재사용 가능한 스트리밍 프로세서."
      ]
    },
    "events": {
      "heading": "이벤트 스트리밍",
      "description": "작업 진행은 React UI가 소비하는 Tauri 이벤트를 발생시킵니다:",
      "eventTypes": [
        "job:status-changed: 페이로드 {jobId, status, error?}. 모든 상태 전환에서 발생.",
        "job:stream-progress: 페이로드 {jobId, content, tokensReceived}. 각 스트리밍 청크에 대해 발생.",
        "job:completed: 페이로드 {jobId, response, tokensTotal, cost}. 성공적 완료 시 발생.",
        "workflow-status: 페이로드 {workflowId, status, currentStage?}. 워크플로우 수준 상태 업데이트.",
        "workflow-stage: 페이로드 {workflowId, stageName, status}. 개별 단계 상태."
      ],
      "reactConsumption": "React 컴포넌트는 @tauri-apps/api/event의 listen()과 함께 useEffect를 통해 구독합니다. WorkflowTracker가 워크플로우 이벤트를 집계합니다. JobStatusIndicator가 실시간 상태를 표시합니다."
    },
    "retry": {
      "heading": "재시도 및 취소",
      "description": "작업 재시도 및 취소 메커니즘:",
      "retryLogic": "retry_handler.rs가 재시도 횟수와 지연을 관리합니다. 재시도는 구성 가능한 최대 시도 횟수로 지수 백오프를 사용합니다. 재시도 상태는 job.metadata.retryCount에 저장됩니다.",
      "cancellation": "취소는 generic_llm_stream_processor.rs에서 스트리밍 청크 사이에 확인되는 플래그를 설정합니다. 서버 측 취소는 request_id와 함께 /api/llm/cancel을 전송합니다.",
      "cleanup": "workflow_cleanup.rs가 불완전한 워크플로우의 정리를 처리합니다. 오래된 작업(앱 재시작 후 실행 중 상태)은 실패로 표시됩니다."
    },
    "artifacts": {
      "heading": "아티팩트 저장",
      "description": "Job inputs and outputs are fully persisted for review:",
      "stored": [
        "prompt: 시스템 프롬프트와 사용자 내용을 포함한 완전한 LLM 프롬프트.",
        "response: 전체 LLM 응답 텍스트 또는 스트리밍 누적.",
        "metadata: 작업별 데이터가 있는 JSON (개선을 위한 원본 텍스트, 파일 목록, 워크플로우 컨텍스트).",
        "system_prompt_template: 서버 측 프롬프트 템플릿 버전에 연결하는 식별자.",
        "토큰 수와 비용: 청구 및 분석을 위해 프로바이더 응답에서 캡처."
      ],
      "access": "background_job_repository가 쿼리를 제공합니다: get_jobs_for_session, get_job_by_id, get_jobs_by_task_type, get_recent_jobs. 작업 히스토리는 BackgroundJobsSidebar 컴포넌트에 표시됩니다."
    },
    "costTracking": {
      "heading": "비용 추적",
      "description": "작업별 비용 추적으로 예산 관리가 가능합니다:",
      "calculation": "비용은 server/src/models/model_pricing.rs의 모델 가격을 사용하여 계산됩니다. 공식: (tokens_sent * input_price + tokens_received * output_price) 캐시 조정 포함.",
      "accumulation": "세션 수준 비용은 background_jobs에서 집계됩니다. UI는 세션 헤더에 누적 비용을 표시합니다.",
      "serverSync": "server_request_id가 청구 조정을 위해 데스크톱 작업을 서버 측 사용 레코드에 연결합니다."
    },
    "cta": {
      "heading": "데이터 모델 보기",
      "description": "Understand the SQLite schema that stores jobs, sessions, and terminal session logs.",
      "links": {
        "dataModel": "데이터 모델",
        "runtime": "런타임 워크스루"
      }
    }
  },
  "buildYourOwn": {
    "meta": {
      "title": "자체 파이프라인 구축하기 - PlanToCode",
      "description": "PlanToCode와 유사한 파일 탐색 및 계획 생성 워크플로우를 설계하기 위한 개념 가이드."
    },
    "category": "참조",
    "date": "2025-09-25",
    "readTime": "12분",
    "title": "자체 파이프라인 구축하기",
    "description": "파일 탐색 및 계획 생성 워크플로우를 설계하기 위한 개념 가이드.",
    "intro": "이 가이드는 PlanToCode의 핵심 아키텍처 패턴을 개념적 청사진으로 추출합니다. 유사한 시스템을 구축하거나 특정 설계 결정이 내려진 이유를 이해하려는 경우, 이 문서는 재사용하거나 적응할 수 있는 기본 패턴을 다룹니다.",
    "visuals": {
      "pipelineMap": {
        "title": "파이프라인 아키텍처 맵",
        "description": "작업 입력에서 계획 출력까지의 다단계 파이프라인 개요.",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "파이프라인 아키텍처 다이어그램",
        "caption": "파이프라인 아키텍처 다이어그램을 위한 플레이스홀더."
      }
    },
    "keyPatterns": {
      "heading": "핵심 아키텍처 패턴",
      "jobQueue": {
        "title": "작업 큐 패턴",
        "description": "모든 LLM 기반 작업은 상태 추적, 취소 지원, 재시도 로직을 갖춘 백그라운드 작업으로 실행됩니다. 작업은 SQLite에 영속되어 앱 재시작 시에도 상태가 유지됩니다.",
        "benefits": [
          "UI 응답성을 LLM 지연에서 분리",
          "스트리밍 중간에 취소 가능",
          "Provides job history of all operations",
          "지수 백오프로 재시도 지원"
        ],
        "pitfalls": [
          "작업 상태 관리가 복잡성 추가",
          "재시작 시 오래된 작업의 주의 깊은 처리 필요",
          "대규모 응답에 대한 스트림 누적이 메모리 소비"
        ]
      },
      "workflowOrchestrator": {
        "title": "워크플로우 오케스트레이터 패턴",
        "description": "다단계 워크플로우는 단계를 순차적으로 예약하고, 단계 간에 중간 데이터를 전달하고, 모든 단계에서 실패를 처리하는 오케스트레이터에 의해 조정됩니다.",
        "components": [
          "정의 로더가 워크플로우 JSON 스펙을 읽음",
          "단계 스케줄러가 순서대로 단계를 디스패치",
          "페이로드 빌더가 이전 출력에서 입력 구성",
          "이벤트 이미터가 UI 업데이트를 위한 진행 게시"
        ]
      },
      "repositoryPattern": {
        "title": "리포지토리 패턴",
        "description": "모든 영속은 SQLite 작업을 추상화하는 타입화된 리포지토리를 통해 이루어집니다. 이는 깔끔한 API를 제공하고, 테스팅을 가능하게 하며, 데이터베이스 액세스를 중앙화합니다.",
        "benefits": [
          "타입화된 액세스가 SQL 인젝션 방지",
          "리포지토리를 테스팅용으로 목 가능",
          "중앙화된 쿼리 최적화",
          "일관된 오류 처리"
        ]
      }
    },
    "steps": {
      "step1": {
        "title": "1. 작업 모델 정의하기",
        "description": "시스템에서 작업을 구성하는 것을 정의하는 것부터 시작하세요. PlanToCode는 작업 설명, 파일 선택, 모델 기본 설정이 있는 세션을 사용합니다.",
        "details": "히스토리 추적을 위한 버전 관리와 함께 전용 테이블에 작업 메타데이터를 저장하세요."
      },
      "step2": {
        "title": "2. 작업 큐 구축하기",
        "description": "작업을 저장소에 영속하고, 상태 이벤트를 발생시키고, 취소를 지원하는 작업 큐를 만드세요. 작업은 프롬프트, 응답, 토큰, 비용을 추적해야 합니다.",
        "details": "병렬 LLM 요청을 제어하기 위해 세마포어 기반 동시성 제한기를 사용하세요."
      },
      "step3": {
        "title": "3. 프로세서 구현하기",
        "description": "각 작업 유형은 프롬프트를 빌드하고, LLM을 호출하고, 응답을 파싱하는 프로세서가 필요합니다. 긴 출력에는 스트리밍을 사용하세요.",
        "details": "프로세서는 무상태여야 하며 작업 매개변수를 통해 모든 컨텍스트를 받아야 합니다."
      },
      "step4": {
        "title": "4. 워크플로우 오케스트레이터 만들기",
        "description": "다단계 워크플로우의 경우, 단계를 예약하고, 중간 데이터를 관리하고, 실패를 처리하는 오케스트레이터를 구축하세요.",
        "details": "코드 변경 없이 쉽게 수정할 수 있도록 워크플로우 정의를 JSON으로 저장하세요."
      },
      "step5": {
        "title": "5. 라우팅 레이어 추가하기",
        "description": "페이로드를 정규화하고, API 키를 관리하고, 사용량을 추적하는 서버 프록시를 통해 LLM 요청을 라우팅하세요.",
        "details": "프로바이더 자격 증명은 서버에 보관하세요; 데스크톱 클라이언트에 절대 포함하지 마세요."
      }
    },
    "architectureDecisions": {
      "heading": "아키텍처 결정",
      "decisions": [
        {
          "question": "로컬 데이터베이스를 사용해야 할까요, 서버 측 저장소를 사용해야 할까요?",
          "recommendation": "작업 상태와 아티팩트에는 로컬 SQLite를 사용하세요. 이것은 오프라인 작업과 빠른 쿼리를 가능하게 합니다. 청구 및 크로스 디바이스 상태에만 서버와 동기화하세요."
        },
        {
          "question": "스트리밍 vs 비스트리밍 응답?",
          "recommendation": "계획 생성과 점진적으로 표시되는 모든 출력에는 스트리밍을 사용하세요. 텍스트 개선과 같은 짧은 변환에는 비스트리밍을 사용하세요."
        },
        {
          "question": "LLM 프로바이더 실패를 어떻게 처리할까요?",
          "recommendation": "지수 백오프로 자동 재시도를 구현하세요. 복원력을 위해 OpenRouter와 같은 폴백 프로바이더를 고려하세요."
        },
        {
          "question": "파일 내용은 어디서 로드해야 할까요?",
          "recommendation": "프롬프트를 빌드하기 직전에 프로세서에서 파일 내용을 로드하세요. 이것은 최신 내용을 보장하고 작업 레코드에 큰 blob 저장을 피합니다."
        }
      ]
    },
    "customizeVsReuse": {
      "heading": "사용자 정의 vs 재사용할 것",
      "customize": [
        "특정 사용 사례를 위한 프롬프트 템플릿",
        "프로젝트 유형에 맞는 파일 탐색 패턴",
        "출력 형식 (XML, JSON, Markdown)",
        "작업 유형별 모델 선택"
      ],
      "reuse": [
        "상태 추적이 있는 작업 큐 아키텍처",
        "워크플로우 오케스트레이터 패턴",
        "영속을 위한 리포지토리 패턴",
        "스트리밍 응답 처리",
        "프로바이더 라우팅과 정규화"
      ]
    },
    "commonPitfalls": {
      "heading": "피해야 할 일반적인 함정",
      "items": [
        {
          "pitfall": "클라이언트에 API 키 포함",
          "solution": "자격 증명을 안전하게 관리하는 서버 프록시를 통해 모든 LLM 요청을 라우팅하세요."
        },
        {
          "pitfall": "작업 상태를 영속하지 않음",
          "solution": "Store every job with full prompt and response for review and recovery."
        },
        {
          "pitfall": "LLM 호출에서 UI 차단",
          "solution": "응답성 있는 인터페이스를 위해 이벤트 기반 UI 업데이트와 함께 백그라운드 작업을 사용하세요."
        },
        {
          "pitfall": "토큰 한도 무시",
          "solution": "전송 전에 토큰을 추정하고 컨텍스트 윈도우 내에 유지하기 위해 큰 입력을 청크하세요."
        },
        {
          "pitfall": "취소 지원 없음",
          "solution": "스트리밍 청크 사이에 취소 플래그를 확인하고 서버로 전파하세요."
        }
      ]
    },
    "artifacts": {
      "heading": "영속할 아티팩트",
      "items": [
        "Full prompt sent to the LLM (for debugging and review)",
        "스트리밍 누적을 포함한 완전한 응답",
        "프로바이더 응답의 토큰 수",
        "모델 가격을 기반으로 계산된 비용",
        "버전 관리를 위한 시스템 프롬프트 템플릿 식별자",
        "다단계 흐름을 위한 워크플로우 중간 데이터"
      ]
    },
    "implementationNotes": {
      "heading": "구현 노트",
      "items": [
        "동시 읽기/쓰기 액세스를 위해 WAL 모드로 SQLite 사용",
        "실행 중인 작업을 실패로 표시하는 정상 종료 구현",
        "작업 처리 전 외부 의존성에 대한 헬스 체크 추가",
        "디버깅을 위해 전체 컨텍스트와 함께 모든 LLM 오류 로깅",
        "중복 읽기를 피하기 위해 짧은 TTL로 파일 내용 캐싱 고려"
      ]
    }
  },
  "decisionsTradeoffs": {
    "meta": {
      "title": "기술적 결정과 트레이드오프 - PlanToCode",
      "description": "Tauri, SQLite, 전용 LLM 프록시를 선택한 이유와 그것이 만드는 운영상의 트레이드오프."
    },
    "category": "아키텍처",
    "date": "2025-09-25",
    "readTime": "10분",
    "title": "기술적 결정과 트레이드오프",
    "description": "Tauri, SQLite, 전용 LLM 프록시를 선택한 이유와 그 비용.",
    "intro": "모든 아키텍처는 트레이드오프를 수반합니다. 이 문서는 PlanToCode의 주요 기술 선택, 그것이 제공하는 이점, 그리고 도입하는 비용이나 제한을 설명합니다.",
    "visuals": {
      "tradeoffMatrix": {
        "title": "트레이드오프 매트릭스",
        "description": "기술 선택과 그 이점 및 비용의 시각적 비교.",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "기술 트레이드오프 매트릭스",
        "caption": "기술 스택 결정을 보여주는 시스템 아키텍처 개요."
      }
    },
    "sections": {
      "tauri": {
        "title": "데스크톱을 위한 Tauri v2",
        "description": "Tauri는 웹 기반 프론트엔드와 함께 Rust 백엔드를 제공하여, 네이티브 성능과 작은 바이너리 크기로 크로스 플랫폼 데스크톱 앱을 가능하게 합니다.",
        "benefits": [
          "작은 바이너리 크기 (~15MB vs Electron의 200MB+)",
          "파일 작업과 작업 처리를 위한 네이티브 Rust 성능",
          "세분화된 권한이 있는 기능 기반 보안 모델",
          "macOS, Windows, Linux를 위한 단일 코드베이스",
          "시스템 API 액세스 (PTY, 키체인, 알림)"
        ],
        "tradeoffs": [
          "Electron보다 작은 생태계",
          "백엔드 개발을 위한 Rust 학습 곡선",
          "플랫폼 간 WebView 렌더링 차이",
          "IPC 이슈 디버깅을 위한 덜 성숙한 도구"
        ],
        "implementation": "PlanToCode는 ~35개 명령 모듈, 기능 기반 권한, 셸, 다이얼로그, 알림을 위한 플러그인과 함께 Tauri 2.9.1을 사용합니다."
      },
      "sqlite": {
        "title": "로컬 영속을 위한 SQLite",
        "description": "SQLite는 세션, 작업, 터미널 출력, 설정을 포함한 모든 로컬 상태를 저장합니다. 이것은 오프라인 작업과 빠른 쿼리를 가능하게 합니다.",
        "benefits": [
          "구성이 필요 없는 임베디드 데이터베이스",
          "로컬 데이터에 대한 빠른 쿼리",
          "오프라인 작업 가능",
          "단일 파일 백업 및 복원",
          "동시 액세스를 위한 WAL 모드"
        ],
        "tradeoffs": [
          "내장된 복제 또는 동기화 없음",
          "큰 터미널 로그가 데이터베이스를 증가시킬 수 있음",
          "수동 스키마 마이그레이션 필요",
          "단일 라이터 제한 (WAL로 완화)"
        ],
        "implementation": "~10개 테이블이 있는 consolidated_schema.sql의 스키마. 리포지토리가 rusqlite로 타입화된 액세스를 제공합니다."
      },
      "llmProxy": {
        "title": "전용 LLM 프록시 서버",
        "description": "모든 LLM 요청은 API 키를 관리하고, 요청을 정규화하고, 사용량을 추적하고, 청구를 처리하는 서버 프록시를 통해 라우팅됩니다.",
        "benefits": [
          "API 키가 서버를 떠나지 않음",
          "모든 프로바이더에 대한 단일 요청 형식",
          "중앙화된 사용량 추적과 청구",
          "클라이언트 업데이트 없이 프로바이더 페일오버",
          "콘텐츠 필터링과 속도 제한"
        ],
        "tradeoffs": [
          "서버 인프라 필요",
          "요청에 네트워크 지연 추가",
          "서버가 단일 실패 지점이 됨",
          "프로바이더 통합 유지 필요"
        ],
        "implementation": "server/src/handlers/proxy/의 핸들러가 있는 Actix-Web 서버. provider_transformers/의 변환기가 요청을 정규화합니다."
      },
      "websocket": {
        "title": "모바일을 위한 WebSocket 릴레이",
        "description": "데스크톱과 모바일 클라이언트는 디바이스 연결, 터미널 스트리밍, 작업 동기화를 위해 WebSocket 릴레이를 통해 연결합니다.",
        "benefits": [
          "실시간 양방향 통신",
          "직접적인 P2P 네트워킹 필요 없음",
          "NAT와 방화벽을 통해 작동",
          "여러 연결된 디바이스 지원"
        ],
        "tradeoffs": [
          "지속적인 서버 연결 필요",
          "대규모 페이로드에 대한 릴레이 지연 추가",
          "연결 관리 복잡성",
          "재연결 및 하트비트 로직 필요"
        ],
        "implementation": "device_link_ws.rs가 세션 추적, 하트비트, 터미널 출력을 위한 PTC1 바이너리 프레이밍으로 릴레이를 구현합니다."
      }
    },
    "operational": {
      "heading": "운영상의 결과",
      "items": [
        "Tauri: 각 플랫폼에 대한 별도 빌드 필요. CI/CD가 크로스 컴파일하거나 플랫폼 특화 러너를 사용해야 함.",
        "SQLite: 데이터베이스 파일이 터미널 출력과 함께 증가. 장기 실행 인스턴스에 대한 주기적 정리 필요 가능.",
        "LLM 프록시: 서버 다운타임이 모든 LLM 작업을 차단. 프로덕션을 위한 모니터링과 중복성 필요.",
        "WebSocket: 재연결 로직이 복잡성 추가. 클라이언트가 연결 끊김을 우아하게 처리해야 함."
      ]
    },
    "securityBoundaries": {
      "heading": "보안 경계",
      "description": "아키텍처는 노출을 제한하는 명확한 보안 경계를 만듭니다:",
      "items": [
        "API 키는 서버 볼트에 저장, 클라이언트에 전송되지 않음",
        "JWT 토큰은 JWKS 순환과 함께 모든 요청에서 검증",
        "기능 기반 권한이 파일 시스템 액세스 제한",
        "LLM에 전송되는 콘텐츠는 명시적 사용자 승인 필요",
        "감사 로그가 사용자 컨텍스트와 함께 모든 LLM 요청 추적"
      ]
    },
    "whenToReconsider": {
      "heading": "재고할 때",
      "description": "요구사항이 크게 변경되면 이러한 결정을 다시 검토해야 할 수 있습니다:",
      "items": [
        "브라우저 전용 액세스가 필요한 경우, Tauri 대신 웹 기반 대안 고려",
        "멀티 디바이스 동기화가 중요한 경우, 서버 측 작업 저장 고려",
        "프로바이더 락인이 허용되는 경우, 직접 API 호출이 지연을 줄일 수 있음",
        "모바일이 주요인 경우, 디바이스 연결 대신 네이티브 앱 고려"
      ]
    }
  },
  "dataModel": {
    "meta": {
      "title": "데이터 모델 및 저장소 - PlanToCode",
      "description": "SQLite 엔티티, 관계, 앱 재시작 시 상태가 재수화되는 방법."
    },
    "category": "아키텍처",
    "date": "2025-09-25",
    "readTime": "10분",
    "title": "데이터 모델 및 저장소",
    "description": "SQLite 엔티티, 관계, 상태가 재수화되는 방법.",
    "intro": "PlanToCode는 모든 로컬 상태에 SQLite를 사용합니다. 이 문서는 스키마, 엔티티 관계, 앱 재시작 시 상태가 복원되는 방법을 설명합니다.",
    "sqlite": {
      "heading": "SQLite 구성",
      "description": "데이터베이스는 동시 읽기/쓰기 액세스를 위해 WAL 모드를 사용합니다. 파일은 Tauri 앱 데이터 디렉토리에 저장됩니다 (Linux에서 ~/.local/share/plantocode, macOS에서 ~/Library/Application Support/plantocode).",
      "migrations": "스키마 마이그레이션은 consolidated_schema.sql에 통합됩니다. 앱은 시작 시 스키마 버전을 확인하고 보류 중인 마이그레이션을 실행합니다."
    },
    "entities": {
      "heading": "핵심 엔티티",
      "items": [
        "sessions: 작업 설명, 파일 선택, 모델 기본 설정, 검색 설정, 비디오/병합 프롬프트, 히스토리 인덱스가 있는 프로젝트 컨텍스트",
        "background_jobs: 프롬프트, 응답, 토큰, 비용, is_finalized 플래그, error_message가 있는 LLM 기반 작업",
        "terminal_sessions: 출력 로그, 상태, 프로세스 정보가 있는 PTY 세션",
        "task_description_history: 작업 설명에 대한 버전 히스토리",
        "file_selection_history: 파일 선택에 대한 버전 히스토리",
        "project_system_prompts: 프로젝트별 프롬프트 오버라이드",
        "key_value_store: 앱 설정 및 구성",
        "error_logs: 클라이언트 측 오류 추적",
        "migrations: 타임스탬프와 함께 적용된 데이터베이스 마이그레이션 추적",
        "db_diagnostic_logs: 데이터베이스 진단 이슈와 오류 기록",
        "app_settings: 설명이 있는 애플리케이션 구성 키-값 쌍"
      ]
    },
    "visuals": {
      "schema": {
        "title": "엔티티 관계 다이어그램",
        "description": "SQLite 스키마와 관계의 시각적 표현.",
        "imageSrc": "/images/docs/data-model/schema.svg",
        "imageAlt": "데이터베이스 스키마 다이어그램",
        "caption": "데이터베이스 스키마 다이어그램을 위한 플레이스홀더."
      }
    },
    "relationships": {
      "heading": "엔티티 관계",
      "description": "엔티티는 연쇄 삭제 규칙이 있는 외래 키를 통해 연결됩니다:",
      "links": [
        "sessions → background_jobs: 일대다, 연쇄 삭제",
        "background_jobs → terminal_sessions: job_id를 통한 선택적 일대일 링크",
        "sessions → task_description_history: 버전 추적을 위한 일대다",
        "sessions → file_selection_history: 버전 추적을 위한 일대다"
      ]
    },
    "repositories": {
      "heading": "리포지토리 레이어",
      "description": "모든 데이터베이스 액세스는 desktop/src-tauri/src/db_utils/의 타입화된 리포지토리를 통해 이루어집니다:",
      "examples": [
        "background_job_repository/: base.rs, worker.rs, metadata.rs, cleanup.rs로 모듈화",
        "session_repository.rs: 히스토리 관리가 있는 세션 CRUD",
        "terminal_repository.rs: 터미널 세션 영속 및 출력 로깅",
        "settings_repository.rs: 키-값 설정 저장소"
      ]
    },
    "rehydration": {
      "heading": "상태 재수화",
      "description": "앱이 시작되면 SQLite에서 상태가 복원됩니다:",
      "sessions": "활성 세션은 작업 설명, 파일 선택, 모델 기본 설정과 함께 로드됩니다. 최근 세션은 세션 선택기에서 사용 가능합니다."
    },
    "retention": {
      "heading": "데이터 보존",
      "description": "구성 가능한 보존 기간에 따라 오래된 데이터가 정리됩니다:",
      "exports": "세션과 작업은 정리 전에 백업을 위해 내보낼 수 있습니다."
    },
    "cta": {
      "heading": "작업 처리 탐색하기",
      "description": "백그라운드 작업이 이 데이터 모델을 어떻게 사용하는지 확인하세요.",
      "links": {
        "jobs": "백그라운드 작업",
        "terminals": "터미널 세션"
      }
    }
  },
  "serverSetup": {
    "meta": {
      "title": "전용 서버 설정 - PlanToCode",
      "description": "Ansible 기반 인프라 설정: 기본 강화, PostgreSQL, Redis, 애플리케이션 배포."
    },
    "category": "배포",
    "date": "2025-09-25",
    "readTime": "12분",
    "title": "전용 서버 설정",
    "description": "Ansible 기반 인프라: 기본 강화, 앱 배포, vault 관리 시크릿.",
    "intro": "PlanToCode는 Ansible 플레이북을 통해 관리되는 전용 서버에서 실행됩니다. 이 문서는 인프라 설정, 보안 강화, 배포 프로세스를 다룹니다.",
    "layers": {
      "heading": "인프라 레이어",
      "description": "인프라는 각각 전용 플레이북에 의해 관리되는 레이어로 구성됩니다:",
      "items": [
        "기본 레이어: OS 강화, SSH 구성, 방화벽 규칙",
        "데이터베이스 레이어: 복제와 백업이 있는 PostgreSQL 17",
        "캐시 레이어: 세션 상태와 작업 큐를 위한 Redis 7+",
        "애플리케이션 레이어: systemd 서비스가 있는 Rust 서버 바이너리",
        "프록시 레이어: SSL 종료가 있는 Nginx 리버스 프록시"
      ]
    },
    "servers": {
      "heading": "서버 지역",
      "description": "PlanToCode는 지리적 중복성을 위해 두 지역에서 실행됩니다:",
      "items": [
        "EU 지역: Hetzner 전용 서버 (api-eu.plantocode.com)",
        "US 지역: InterServer 전용 서버 (api-us.plantocode.com)"
      ]
    },
    "requirements": {
      "heading": "서버 요구사항",
      "items": [
        "Debian 12 또는 Ubuntu 22.04 LTS",
        "4+ CPU 코어, 16GB+ RAM, 200GB+ SSD",
        "포트 22, 80, 443에 대한 방화벽 액세스가 있는 공용 IPv4",
        "Ansible 배포를 위한 SSH 키 액세스"
      ]
    },
    "hardening": {
      "heading": "기본 강화",
      "description": "site-base.yml이 보안 강화를 적용합니다:",
      "items": [
        "루트 SSH 로그인 비활성화, 키 인증 필요",
        "최소 열린 포트로 UFW 방화벽 구성",
        "무차별 대입 보호를 위한 fail2ban 설치",
        "자동 보안 업데이트 활성화",
        "감사 로깅 구성"
      ]
    },
    "postgresql": {
      "heading": "PostgreSQL 설정",
      "description": "PostgreSQL 17이 프로덕션 용도로 구성됩니다:",
      "items": [
        "PgBouncer를 통한 연결 풀링",
        "pg_dump를 통한 자동화된 일일 백업",
        "시점 복구를 위한 WAL 아카이빙",
        "모든 연결에 SSL 필수",
        "멀티 테넌트 데이터를 위한 행 수준 보안"
      ]
    },
    "redis": {
      "heading": "Redis 설정",
      "description": "Redis 7+가 캐싱과 세션 상태를 처리합니다:",
      "items": [
        "비밀번호 인증 필수",
        "내구성을 위한 AOF 영속",
        "퇴거 정책이 있는 메모리 제한",
        "연결을 위한 TLS 암호화"
      ]
    },
    "zeroDowntime": {
      "heading": "무중단 배포",
      "description": "배포는 롤링 업데이트 전략을 사용합니다:",
      "items": [
        "실행 중인 버전과 함께 새 바이너리 업로드",
        "새 버전이 준비되었는지 헬스 체크 확인",
        "정상 종료로 Systemd 재시작",
        "전환 중 로드 밸런서가 연결 드레인",
        "이전 바이너리 심볼릭 링크를 통한 롤백 가능"
      ]
    },
    "quickStart": {
      "heading": "빠른 시작",
      "steps": [
        "인프라 리포지토리 클론",
        "inventory.example을 inventory로 복사하고 호스트 구성",
        ".vault_pass에 vault 비밀번호 설정",
        "실행: ansible-playbook -i inventory site-base.yml",
        "실행: ansible-playbook -i inventory site-app.yml"
      ]
    },
    "vault": {
      "heading": "시크릿 관리",
      "description": "민감한 구성은 Ansible Vault를 사용합니다:",
      "items": [
        "데이터베이스 자격 증명",
        "LLM 프로바이더용 API 키",
        "SSL 인증서와 개인 키",
        "Auth0 클라이언트 시크릿",
        "Stripe 웹훅 시크릿"
      ]
    },
    "operations": {
      "heading": "일반 작업",
      "items": [
        "ansible-playbook -i inventory site-app.yml --tags deploy",
        "ansible-playbook -i inventory site-base.yml --tags backup",
        "ansible-playbook -i inventory site-app.yml --tags rollback",
        "ansible-playbook -i inventory site-base.yml --tags logs"
      ]
    },
    "ssl": {
      "heading": "SSL/TLS 구성",
      "description": "Let's Encrypt가 무료 SSL 인증서를 제공합니다:",
      "items": [
        "Nginx 플러그인으로 Certbot 구성",
        "cron 작업을 통한 자동 갱신",
        "HSTS 헤더 활성화",
        "TLS 1.2+ 전용, 최신 암호 스위트"
      ]
    },
    "security": {
      "heading": "보안 체크리스트",
      "items": [
        "모든 기본 비밀번호 변경됨",
        "SSH 키 순환 예약됨",
        "방화벽 규칙 감사됨",
        "보안 업데이트 자동화됨",
        "백업 복원 테스트됨"
      ]
    },
    "recovery": {
      "heading": "재해 복구",
      "description": "일반적인 실패 시나리오에 대한 복구 절차:",
      "items": [
        "데이터베이스 손상: 최신 pg_dump 백업에서 복원",
        "서버 장애: 새 서버 프로비저닝하고 플레이북 실행",
        "SSL 만료: 수동 certbot renew --force-renewal",
        "보안 침해: 모든 자격 증명 순환, 로그 감사"
      ]
    }
  },
  "tauriV2": {
    "meta": {
      "title": "Tauri v2 개발 가이드 - PlanToCode",
      "description": "Tauri v2를 위한 프로젝트 레이아웃, 명령, 기능, 개발 워크플로우."
    },
    "category": "배포",
    "date": "2025-09-25",
    "readTime": "10분",
    "title": "Tauri v2 개발 가이드",
    "description": "Tauri v2를 위한 프로젝트 레이아웃, 명령, 기능 기반 권한.",
    "intro": "PlanToCode는 데스크톱 애플리케이션에 Tauri v2를 사용합니다. 이 가이드는 프로젝트 구조, 명령 시스템, 기능 기반 권한, 개발 워크플로우를 다룹니다.",
    "projectLayout": {
      "heading": "프로젝트 레이아웃",
      "description": "데스크톱 애플리케이션은 표준 Tauri v2 관례를 따릅니다:",
      "items": [
        "desktop/src/: 컴포넌트, 훅, 프로바이더가 있는 React 프론트엔드",
        "desktop/src-tauri/: 명령, 작업, 서비스가 있는 Rust 백엔드",
        "desktop/src-tauri/src/lib.rs: 애플리케이션 진입점",
        "desktop/src-tauri/src/commands/: Tauri 명령 핸들러 (~35개 모듈)",
        "desktop/src-tauri/capabilities/: 권한 정의",
        "desktop/src-tauri/tauri.conf.json: Tauri 구성"
      ]
    },
    "configuration": {
      "heading": "Tauri 구성",
      "description": "tauri.conf.json이 애플리케이션을 구성합니다:",
      "items": [
        "앱 메타데이터를 위한 productName, version, identifier",
        "프론트엔드를 위한 build.beforeDevCommand와 beforeBuildCommand",
        "설치 프로그램을 위한 bundle 설정 (DMG, NSIS, AppImage)",
        "Content Security Policy를 위한 security.csp",
        "공식 플러그인을 위한 plugins 구성"
      ]
    },
    "capabilities": {
      "heading": "기능 기반 권한",
      "description": "Tauri v2는 앱이 액세스할 수 있는 것을 제어하기 위해 기능을 사용합니다:",
      "items": [
        "default.json: 모든 윈도우를 위한 기본 권한",
        "desktop-default.json: 데스크톱 특화 권한",
        "plantocode-api.json: PlanToCode 명령을 위한 커스텀 권한",
        "권한이 액세스 허용: 파일 시스템, 셸, http, 다이얼로그, 알림"
      ]
    },
    "plugins": {
      "heading": "Tauri 플러그인",
      "description": "PlanToCode는 여러 공식 Tauri 플러그인을 사용합니다:",
      "items": [
        "tauri-plugin-http: API 호출을 위한 HTTP 클라이언트",
        "tauri-plugin-dialog: 네이티브 파일/폴더 선택기",
        "tauri-plugin-shell: 셸 명령 실행",
        "tauri-plugin-store: 영속적 키-값 저장소",
        "tauri-plugin-notification: 데스크톱 알림",
        "tauri-plugin-updater: 인앱 업데이트",
        "tauri-plugin-single-instance: 단일 인스턴스 적용"
      ]
    },
    "appState": {
      "heading": "애플리케이션 상태",
      "description": "Tauri의 상태 시스템을 통해 관리되는 Rust 상태:",
      "items": [
        "AppState 구조체가 공유 상태 보유",
        "서버 URL과 기능 플래그를 위한 RuntimeConfig",
        "보안 자격 증명 저장을 위한 TokenManager",
        "AI 모델 구성을 위한 ConfigCache"
      ]
    },
    "commands": {
      "heading": "명령 생성하기",
      "description": "Tauri 명령이 Rust 함수를 프론트엔드에 노출합니다:",
      "items": [
        "async 함수에 #[tauri::command] 속성 사용",
        "오류 처리를 위해 Result<T, String> 반환",
        "State<AppState> 매개변수를 통해 상태 액세스",
        "lib.rs invoke_handler에 등록"
      ]
    },
    "singleInstance": {
      "heading": "단일 인스턴스",
      "description": "앱이 데이터 충돌을 방지하기 위해 단일 인스턴스를 적용합니다:",
      "items": [
        "tauri-plugin-single-instance가 감지 처리",
        "두 번째 실행은 기존 윈도우에 포커스",
        "딥 링크가 실행 중인 인스턴스로 전달"
      ]
    },
    "devWorkflow": {
      "heading": "개발 워크플로우",
      "description": "개발을 위한 일반 명령:",
      "items": [
        "pnpm tauri dev: 핫 리로드와 함께 개발 시작",
        "pnpm tauri build: 프로덕션 릴리스 빌드",
        "cargo test: Rust 테스트 실행",
        "cargo clippy: Rust 코드 린트"
      ]
    },
    "mobile": {
      "heading": "모바일 고려사항",
      "description": "Tauri v2는 모바일을 지원하지만, PlanToCode는 네이티브 Swift를 사용합니다:",
      "items": [
        "네이티브 경험을 위해 SwiftUI로 빌드된 iOS 앱",
        "데스크톱과 모바일 간 공유 API 계약",
        "WebSocket 릴레이를 통한 디바이스 연결"
      ]
    },
    "distribution": {
      "heading": "배포",
      "description": "각 플랫폼을 위한 빌드 아티팩트:",
      "items": [
        "macOS: 유니버설 바이너리가 있는 .dmg (Intel + Apple Silicon)",
        "Windows: NSIS 설치 프로그램과 MSIX 패키지",
        "Linux: 광범위한 호환성을 위한 AppImage"
      ]
    }
  },
  "distributionMacos": {
    "meta": {
      "title": "macOS 배포 - PlanToCode",
      "description": "macOS를 위한 코드 서명, 공증, DMG 패키징, 업데이터 구성."
    },
    "category": "배포",
    "date": "2025-09-25",
    "readTime": "10분",
    "title": "macOS 배포",
    "description": "서명, 공증, DMG 패키징, 업데이터 아티팩트.",
    "intro": "macOS에서 배포하려면 코드 서명, 공증, 적절한 패키징이 필요합니다. 이 문서는 PlanToCode의 전체 프로세스를 다룹니다.",
    "signing": {
      "heading": "코드 서명",
      "description": "모든 바이너리는 Apple Developer ID로 서명해야 합니다:",
      "items": [
        "앱 서명을 위한 Developer ID Application 인증서",
        "PKG 서명을 위한 Developer ID Installer 인증서",
        "CI 시크릿에 저장되고 키체인으로 가져온 인증서",
        "공증 호환성을 위해 활성화된 강화된 런타임"
      ]
    },
    "entitlements": {
      "heading": "권한",
      "description": "PlanToCode 기능에 필요한 권한:",
      "items": [
        "com.apple.security.cs.allow-jit",
        "com.apple.security.cs.allow-unsigned-executable-memory",
        "com.apple.security.device.audio-input",
        "com.apple.security.network.client",
        "com.apple.security.files.user-selected.read-write"
      ]
    },
    "build": {
      "heading": "빌드 프로세스",
      "description": "서명된 릴리스를 빌드하는 단계:",
      "steps": [
        "pnpm tauri build --target universal-apple-darwin 실행",
        "Tauri가 환경에서 APPLE_SIGNING_IDENTITY로 서명",
        "Intel + ARM을 위해 lipo로 유니버설 바이너리 생성",
        "커스텀 배경과 레이아웃으로 DMG 패키징"
      ]
    },
    "universalBinaries": {
      "heading": "유니버설 바이너리",
      "description": "PlanToCode는 유니버설 바이너리로 제공됩니다:",
      "items": [
        "단일 .app이 Intel과 Apple Silicon 모두 지원",
        "--target universal-apple-darwin으로 빌드",
        "약간 더 큰 바이너리지만 더 간단한 배포",
        "두 아키텍처 모두에서 네이티브 성능"
      ]
    },
    "notarization": {
      "heading": "공증",
      "description": "Gatekeeper 승인을 위해 Apple 공증이 필요합니다:",
      "items": [
        "Apple 공증 서비스에 DMG 제출",
        "App Store Connect 자격 증명과 함께 notarytool 사용",
        "스테이플링으로 공증 티켓을 DMG에 첨부",
        "프로세스는 일반적으로 1-5분 소요"
      ]
    },
    "updater": {
      "heading": "인앱 업데이트",
      "description": "tauri-plugin-updater가 자동 업데이트를 처리합니다:",
      "items": [
        "실행 시 업데이트 엔드포인트 확인",
        "백그라운드에서 새 버전 다운로드",
        "적용을 위해 재시작 프롬프트",
        "설치 전 서명 검증"
      ]
    },
    "latestJson": {
      "heading": "업데이트 매니페스트",
      "description": "latest.json이 사용 가능한 업데이트를 설명합니다:",
      "items": [
        "version: 시맨틱 버전 문자열",
        "platforms.darwin-universal: URL과 서명",
        "notes: markdown의 릴리스 노트",
        "pub_date: ISO 8601 게시 타임스탬프"
      ]
    },
    "pitfalls": {
      "heading": "일반적인 함정",
      "description": "자주 발생하는 이슈:",
      "items": [
        "CI 중 키체인 잠금: 서명 전에 잠금 해제",
        "공증 타임아웃: 지수 백오프로 재시도",
        "잘못된 서명: 권한이 기능과 일치하는지 확인",
        "Gatekeeper 거부: 공증이 올바르게 스테이플되었는지 확인"
      ]
    },
    "verification": {
      "heading": "검증 명령",
      "description": "서명과 공증을 검증하는 명령:",
      "items": [
        "codesign -dv --verbose=4 PlanToCode.app",
        "spctl --assess --verbose PlanToCode.app",
        "stapler validate PlanToCode.dmg",
        "xcrun notarytool log <submission-id>"
      ]
    }
  },
  "distributionWindows": {
    "meta": {
      "title": "Windows 배포 - PlanToCode",
      "description": "Windows를 위한 NSIS 설치 프로그램, MSIX 패키징, Microsoft Store 제출, 코드 서명."
    },
    "category": "배포",
    "date": "2025-09-25",
    "readTime": "10분",
    "title": "Windows 배포 및 스토어",
    "description": "NSIS 빌드, MSIX 패키징, Microsoft Store 제출.",
    "intro": "PlanToCode는 직접 다운로드(NSIS 설치 프로그램)와 Microsoft Store(MSIX 패키지) 모두를 통해 Windows에서 배포됩니다. 이 문서는 두 배포 방법을 다룹니다.",
    "prereqs": {
      "heading": "전제 조건",
      "description": "필수 도구와 인증서:",
      "items": [
        "코드 서명 인증서 (EV 또는 표준)",
        "signtool을 위한 Windows SDK",
        "설치 프로그램 빌드를 위한 NSIS",
        "Store 제출을 위한 MSIX Packaging Tool"
      ]
    },
    "nsisBuild": {
      "heading": "NSIS 설치 프로그램",
      "description": "Tauri는 기본적으로 NSIS 설치 프로그램을 빌드합니다:",
      "items": [
        "PlanToCode 브랜딩이 있는 커스텀 설치 프로그램 UI",
        "사용자별 설치 (관리자 필요 없음)",
        "시작 메뉴 및 데스크톱 바로 가기",
        "깨끗한 제거가 있는 언인스톨러"
      ]
    },
    "codeSigning": {
      "heading": "코드 서명",
      "description": "Authenticode를 사용한 Windows 코드 서명:",
      "items": [
        "Windows SDK의 signtool로 서명",
        "신뢰할 수 있는 TSA 서버의 타임스탬프",
        "EV 인증서가 SmartScreen 평판 제공",
        "CI가 인증서와 비밀번호에 시크릿 사용"
      ]
    },
    "msixPackaging": {
      "heading": "Microsoft Store를 위한 MSIX",
      "description": "MSIX가 Store 호환 패키징을 제공합니다:",
      "items": [
        "AppxManifest.xml이 기능 정의",
        "가상 파일 시스템 격리",
        "Store를 통한 자동 업데이트",
        "샌드박스 실행 환경"
      ]
    },
    "msixConfig": {
      "heading": "MSIX 구성",
      "description": "주요 AppxManifest 설정:",
      "items": [
        "Identity: Name, Publisher, Version",
        "Capabilities: internetClient, microphone",
        "Visual elements: Tiles, splash screen",
        "파일 연결 및 프로토콜 핸들러"
      ]
    },
    "msixSteps": {
      "heading": "MSIX 빌드 단계",
      "description": "MSIX 패키지를 만드는 프로세스:",
      "steps": [
        "pnpm tauri build로 릴리스 빌드",
        "올바른 identity로 AppxManifest.xml 생성",
        "MakeAppx.exe로 패키징",
        "SignTool로 서명",
        "Windows App Cert Kit으로 검증"
      ]
    },
    "store": {
      "heading": "Microsoft Store 제출",
      "description": "Store 제출 프로세스:",
      "items": [
        "Partner Center에서 앱 생성",
        "MSIX 패키지 업로드",
        "가격 구성 (IAP 크레딧이 있는 무료)",
        "인증을 위해 제출",
        "검토는 1-3 영업일 소요"
      ]
    },
    "updaterWindows": {
      "heading": "Windows 업데이트",
      "description": "각 배포를 위한 업데이트 메커니즘:",
      "items": [
        "NSIS: GitHub 릴리스와 함께 tauri-plugin-updater",
        "MSIX/Store: Microsoft Store를 통한 자동",
        "둘 다 실행 시 업데이트 확인"
      ]
    },
    "webview2": {
      "heading": "WebView2 런타임",
      "description": "Tauri는 Windows에서 WebView2를 사용합니다:",
      "items": [
        "설치 프로그램에 번들된 WebView2 부트스트래퍼",
        "Evergreen 버전 자동 업데이트",
        "격리를 위한 고정 버전 사용 가능",
        "Windows 10 1803+ 필수"
      ]
    },
    "troubleshooting": {
      "heading": "문제 해결",
      "description": "일반적인 Windows 배포 이슈:",
      "items": [
        "SmartScreen 경고: EV 인증서 사용 또는 평판 구축",
        "WebView2 누락: 부트스트래퍼 실행 확인",
        "Store 거부: 인증 보고서 세부사항 검토",
        "업데이트 실패: 서명과 매니페스트 버전 확인"
      ]
    }
  },
  "promptTypes": {
    "meta": {
      "title": "프롬프트 유형 및 템플릿 - PlanToCode",
      "description": "프롬프트 기반 작업 유형 카탈로그 및 템플릿 조립 프로세스."
    },
    "category": "참조",
    "date": "2025-09-25",
    "readTime": "8분",
    "title": "프롬프트 유형 및 템플릿",
    "description": "프롬프트 기반 작업 유형 카탈로그 및 템플릿 조립.",
    "intro": "PlanToCode의 모든 LLM 기반 작업은 템플릿에서 구축된 구조화된 프롬프트를 사용합니다. 이 문서는 작업 유형을 카탈로그화하고 프롬프트가 조립되는 방법을 설명합니다.",
    "catalog": {
      "heading": "작업 유형 카탈로그",
      "items": [
        {
          "job": "implementation_plan",
          "title": "구현 계획",
          "description": "XML 구조로 파일별 구현 계획을 생성합니다. 점진적 표시를 위해 스트리밍을 사용합니다."
        },
        {
          "job": "implementation_plan_merge",
          "title": "계획 병합",
          "description": "사용자 지침으로 여러 계획을 결합합니다. 소스 계획은 XML 태그로 래핑됩니다."
        },
        {
          "job": "text_improvement",
          "title": "텍스트 개선",
          "description": "서식을 유지하면서 선택한 텍스트를 다듬습니다. 빠른 결과를 위해 비스트리밍."
        },
        {
          "job": "root_folder_selection",
          "title": "루트 폴더 선택",
          "description": "디렉토리 트리를 분석하여 관련 프로젝트 루트를 선택합니다. JSON 배열을 반환합니다."
        },
        {
          "job": "regex_file_filter",
          "title": "Regex 파일 필터",
          "description": "작업 설명을 기반으로 파일 필터링을 위한 regex 패턴을 생성합니다."
        },
        {
          "job": "file_relevance_assessment",
          "title": "파일 관련성 평가",
          "description": "작업에 대한 파일 내용 관련성을 점수화합니다. 배치로 처리합니다."
        },
        {
          "job": "extended_path_finder",
          "title": "확장 경로 탐색기",
          "description": "임포트와 의존성을 통해 관련 파일을 발견합니다."
        },
        {
          "job": "web_search_prompts",
          "title": "웹 검색 프롬프트",
          "description": "딥 리서치 워크플로우를 위한 연구 쿼리를 생성합니다."
        },
        {
          "job": "video_analysis",
          "title": "비디오 분석",
          "description": "UI 상태와 액션 시퀀스를 위해 화면 녹화를 분석합니다."
        }
      ]
    },
    "templateStructure": {
      "heading": "템플릿 구조",
      "description": "프롬프트는 시스템 템플릿과 사용자 콘텐츠에서 조립됩니다:",
      "sampleLabel": "예시 템플릿 구조:",
      "sample": "<system_prompt>\n  You are an AI assistant that generates implementation plans.\n  [template content from server]\n</system_prompt>\n\n<task>\n  [user's task description]\n</task>\n\n<files>\n  [selected file paths and content]\n</files>\n\n<directory_tree>\n  [project structure]\n</directory_tree>"
    },
    "visuals": {
      "template": {
        "title": "프롬프트 조립 흐름",
        "description": "템플릿이 사용자 콘텐츠와 결합하여 완전한 프롬프트를 형성하는 방법.",
        "imageSrc": "/images/docs/implementation-plans/structure.svg",
        "imageAlt": "프롬프트 템플릿 조립 다이어그램",
        "caption": "프롬프트 조립 다이어그램을 위한 플레이스홀더."
      }
    },
    "assembly": {
      "heading": "조립 프로세스",
      "steps": [
        "프로세서가 작업 모델 구성에서 템플릿 ID를 검색",
        "시스템 프롬프트 템플릿이 서버 캐시에서 로드됨",
        "사용자 콘텐츠가 의미론적 XML 태그로 래핑됨",
        "컨텍스트(파일, 트리)가 작업 유형에 따라 추가됨",
        "완전한 프롬프트가 전송 전에 작업 레코드에 저장됨"
      ]
    },
    "serverConfig": {
      "heading": "서버 측 구성",
      "description": "템플릿과 모델 설정은 서버 측에서 구성됩니다:",
      "fields": "task_model_config 정의: default_model, allowed_models, system_prompt_template_id, max_tokens, temperature"
    },
    "tokenGuards": {
      "heading": "토큰 가드레일",
      "description": "각 작업 유형은 컨텍스트 오버플로우를 방지하기 위한 토큰 제한이 있습니다:",
      "items": [
        "max_tokens_input: 최대 프롬프트 크기",
        "max_tokens_output: 최대 응답 크기",
        "전송 전 검증으로 낭비되는 API 호출 방지",
        "UI에서 토큰 수를 표시하고 한도에 가까워지면 경고"
      ]
    },
    "versioning": {
      "heading": "템플릿 버전 관리",
      "description": "System prompt templates are versioned for reproducibility. Each job records the template ID used, enabling traceability and comparison of results across template versions."
    },
    "designNotes": {
      "heading": "설계 노트",
      "items": [
        "XML 태그는 LLM 파싱을 위한 명확한 경계를 제공",
        "의미론적 명명(task, files, context)이 모델 이해를 돕음",
        "템플릿은 사용자 입력을 살균하여 인스트럭션 인젝션을 방지",
        "스트리밍 작업은 완료 감지를 위해 종료 태그를 사용"
      ]
    },
    "cta": {
      "heading": "작업 처리를 실제로 보기",
      "description": "이러한 프롬프트가 작업 시스템을 통해 어떻게 흐르는지 알아보세요.",
      "links": {
        "jobs": "백그라운드 작업",
        "merge": "병합 지침"
      }
    }
  },
  "mergeInstructionsDoc": {
    "meta": {
      "title": "병합 지침 - PlanToCode",
      "description": "XML 태그가 지정된 소스 계획과 사용자 가이드를 사용하여 여러 계획 초안을 병합하는 방법."
    },
    "category": "계획",
    "date": "2025-09-25",
    "readTime": "8분",
    "title": "병합 지침",
    "description": "XML 태그가 지정된 소스 계획과 사용자 가이드를 사용하여 여러 계획 초안을 병합하는 방법.",
    "intro": "결합해야 하는 여러 구현 계획이 있을 때, 병합 워크플로우를 통해 계획을 선택하고, 가이드를 제공하고, 각 소스의 최상의 요소를 통합하는 통합 계획을 생성할 수 있습니다.",
    "processor": {
      "heading": "ImplementationPlanMergeProcessor",
      "description": "ImplementationPlanMergeProcessor는 소스 계획 응답을 가져오고, XML 태그 섹션으로 래핑하고, LlmTaskRunner를 통해 병합된 결과를 스트리밍합니다.",
      "payload": "source_job_ids 배열, 선택적 merge_instructions 문자열을 받고, 세션에서 모델 구성을 상속합니다.",
      "storage": "병합된 계획은 source_job_ids, merge_instructions, source_count, merged_at 타임스탬프, 세션 컨텍스트를 포함한 메타데이터와 함께 JobResultData::Text로 저장됩니다."
    },
    "inputs": {
      "heading": "병합 입력",
      "items": [
        "소스 계획: 계획 목록에서 선택된 2-5개의 구현 계획",
        "병합 지침: 결합 방법에 대한 사용자 가이드(우선순위, 충돌 해결)",
        "모델 선택: 병합 생성을 위한 LLM 모델",
        "작업 컨텍스트: 참조용 원래 작업 설명"
      ]
    },
    "xmlFormat": {
      "heading": "XML 태그가 지정된 소스 계획",
      "description": "소스 계획은 순차적 식별자와 함께 XML 태그로 래핑됩니다:",
      "example": "<task_description>\n  [original task from session]\n</task_description>\n\n<source_plans>\n  <implementation_plan_1>\n    [full plan content from first source]\n  </implementation_plan_1>\n  <implementation_plan_2>\n    [full plan content from second source]\n  </implementation_plan_2>\n</source_plans>\n\n<user_instructions>\n  Prioritize API structure from plan 1.\n  Use database schema from plan 2.\n  Resolve conflicts by preferring newer patterns.\n</user_instructions>"
    },
    "prompt": {
      "heading": "병합 프롬프트 구조",
      "description": "병합 프롬프트는 지능적인 결합에 필요한 모든 컨텍스트를 포함합니다:",
      "sections": [
        "병합 가이드라인이 있는 시스템 프롬프트",
        "XML 태그의 소스 계획",
        "사용자의 병합 지침",
        "컨텍스트용 작업 설명",
        "출력 형식 요구사항"
      ]
    },
    "visuals": {
      "mergeWalkthrough": {
        "title": "병합 워크플로우 워크스루",
        "description": "선택에서 출력까지 전체 병합 프로세스를 보여주는 비디오.",
        "videoSrc": "/videos/docs/merge-instructions/walkthrough.mp4",
        "posterSrc": "/images/docs/merge-instructions/flow.svg",
        "caption": "병합 워크스루 비디오를 위한 플레이스홀더."
      },
      "mergeFlow": {
        "title": "병합 지침 흐름",
        "description": "XML 태그가 지정된 소스 계획으로 다중 모델 병합 워크플로우를 보여주는 다이어그램.",
        "imageSrc": "/images/docs/merge-instructions/flow.svg",
        "caption": "소스 선택, 지침 처리, 출력 생성을 보여주는 병합 흐름"
      }
    },
    "rules": {
      "heading": "병합 규칙",
      "description": "LLM은 계획을 병합할 때 다음 규칙을 따릅니다:",
      "examples": [
        "소스 계획에 지정된 대로 파일 경로를 정확히 유지",
        "모든 소스에서 충돌하지 않는 변경사항 결합",
        "충돌의 경우 명시적인 사용자 지침 따르기",
        "병합된 콘텐츠 전체에서 일관된 코드 스타일 유지",
        "소스 계획을 나타내는 출처 코멘트 포함"
      ]
    },
    "output": {
      "heading": "병합된 출력",
      "description": "병합된 계획은 개별 계획과 동일한 유연한 형식을 따라 LLM에서 원시 텍스트로 반환됩니다.",
      "provenance": "각 섹션에는 어떤 소스 계획이 콘텐츠에 기여했는지 나타내는 코멘트가 포함됩니다.",
      "metadata": "source_job_ids, merge_instructions, source_count, merged_at 타임스탬프, planTitle, summary, isStructured (false), sessionName이 작업 메타데이터에 저장됩니다."
    },
    "ui": {
      "heading": "UI 통합",
      "description": "구현 계획 패널은 병합 워크플로우를 지원합니다:",
      "audit": "Merged plans link back to source plans for traceability."
    },
    "cta": {
      "heading": "계획 생성에 대해 알아보기",
      "description": "병합하기 전에 개별 계획이 어떻게 생성되는지 이해하세요.",
      "links": {
        "plans": "구현 계획",
        "runtime": "런타임 워크스루"
      }
    }
  },
  "meetingIngestionDoc": {
    "meta": {
      "title": "Meeting and recording ingestion - PlanToCode",
      "description": "How recordings are analyzed into task summaries through the video analysis pipeline."
    },
    "category": "Inputs",
    "date": "2025-09-25",
    "readTime": "8 min",
    "title": "Meeting & Recording Ingestion",
    "description": "How recordings become task summaries and planning inputs.",
    "intro": "PlanToCode can analyze meeting recordings and screen captures with the video analysis job. The model is guided by a system prompt that adapts to your goal, whether you are debugging, reviewing UI, or documenting a workflow.",
    "visuals": {
      "ingestionFlow": {
        "title": "Recording ingestion flow",
        "description": "How recordings flow through upload and analysis.",
        "imageSrc": "/images/docs/deep-research/workflow.svg",
        "imageAlt": "Recording ingestion flow diagram",
        "caption": "Placeholder for ingestion flow diagram."
      }
    },
    "inputs": {
      "heading": "Supported Inputs",
      "description": "The ingestion workflow accepts video recordings captured in the app or uploaded from other tools.",
      "items": [
        "Screen recordings captured in the desktop app",
        "Meeting recordings exported from Zoom, Meet, or Teams (video files)",
        "Design walkthroughs or bug reproductions recorded as video",
        "For audio-only notes, use voice transcription"
      ]
    },
    "uploadProcess": {
      "heading": "Upload Process",
      "description": "Recordings are uploaded to the server as multipart form data for analysis.",
      "stepsHeading": "Processing Steps",
      "steps": [
        "Desktop saves the recording locally and calculates duration",
        "Video file and analysis prompt are uploaded to /api/llm/video/analyze",
        "Server stores the file temporarily and routes it to Gemini video models",
        "Long recordings are split into 2-minute chunks by the desktop and processed in parallel",
        "Analysis summary is returned and stored in the job response"
      ]
    },
    "normalization": {
      "heading": "Format Normalization",
      "description": "Recordings are sent mostly as-is. WebM recordings are remuxed to fix container metadata before analysis.",
      "outputs": "No separate transcript or frame artifacts are generated; the output is a text analysis summary."
    },
    "multimodalAnalysis": {
      "heading": "Multimodal Analysis",
      "description": "Recordings are analyzed with {code} video models, which accept video and audio in a single request.",
      "combined": "The default video analysis system prompt adapts the output to your goal rather than forcing a fixed schema."
    },
    "transcription": {
      "heading": "Audio context",
      "description": "Audio is analyzed as part of the video; the app does not generate a standalone transcript.",
      "attribution": "If spoken content is unclear, the model may mark it as partially visible rather than guessing.",
      "featuresHeading": "Audio analysis notes",
      "features": [
        "Narration steers the summary",
        "Spoken intent and errors can be quoted",
        "No diarization or timestamped transcript"
      ]
    },
    "frames": {
      "heading": "Frame rate hint",
      "description": "FPS is a sampling hint sent with the analysis request. For large files the provider may ignore it.",
      "timestamps": "Long recordings can be chunked to keep analysis responsive."
    },
    "structuredExtraction": {
      "heading": "Structured Extraction",
      "description": "The analysis output is freeform and adapts to your prompt. Typical outputs include:",
      "extractedHeading": "Extracted Elements",
      "items": [
        "Bug reproduction steps and observed errors",
        "UI walkthrough notes and navigation paths",
        "Design feedback or UX issues shown on screen",
        "Suggested fixes or follow-up tasks"
      ]
    },
    "artifacts": {
      "heading": "Analysis Artifacts",
      "description": "Video analysis produces artifacts stored with the job:",
      "items": [
        "analysis_summary: Text summary stored in background_jobs.response",
        "job_metadata: durationMs, framerate, videoPath",
        "chunk_info: chunk boundaries for long recordings (when applicable)"
      ]
    },
    "keyFiles": {
      "heading": "Key Source Files",
      "items": [
        "desktop/src/app/components/generate-prompt/_components/video-recording-dialog.tsx",
        "desktop/src/contexts/screen-recording/Provider.tsx",
        "desktop/src-tauri/src/jobs/processors/video_analysis_processor.rs",
        "server/src/handlers/proxy/specialized/video_analysis.rs",
        "server/src/utils/multipart_utils.rs",
        "server/src/clients/google_client.rs"
      ]
    },
    "handoff": {
      "heading": "Planning Handoff",
      "description": "Video analysis summaries can be incorporated into the task description for planning.",
      "pipeline": "The summary can be refined with text_improvement and task_refinement before file discovery."
    },
    "cta": {
      "heading": "Continue to video analysis",
      "description": "Learn more about how video frames are analyzed.",
      "links": {
        "video": "Video analysis",
        "textImprovement": "Text improvement"
      }
    }
  },
  "videoAnalysisDoc": {
    "meta": {
      "title": "Video analysis - PlanToCode",
      "description": "Adaptive analysis of screen recordings with Gemini video models."
    },
    "category": "Inputs",
    "date": "2025-09-25",
    "readTime": "6 min",
    "title": "Video Analysis",
    "description": "Adaptive analysis and prompts for screen recordings.",
    "intro": "Video analysis sends the recording to Gemini video models with a system prompt that adapts to your goal. The output is a text summary, not a frame-by-frame export or separate transcript.",
    "visuals": {
      "frameNotes": {
        "title": "Video analysis pipeline",
        "description": "How recordings flow through the analysis model.",
        "imageSrc": "/assets/images/demo-video-analysis.jpg",
        "imageAlt": "Video analysis interface",
        "caption": "The video analysis interface showing analysis options."
      }
    },
    "apiEndpoint": {
      "heading": "API Endpoint",
      "endpoint": "Video analysis is handled by {code} on the server. The endpoint accepts multipart form data with the video file and analysis parameters.",
      "payloadHeading": "Payload Fields",
      "payloadFields": [
        "video: The video file",
        "model: Model identifier for analysis (google/* required)",
        "prompt: Task description and optional focus prompt (wrapped in <description> and <video_attention_prompt>)",
        "temperature: Sampling temperature from task settings",
        "durationMs: Recording duration in milliseconds",
        "framerate: Sampling hint (0.1-20 from the UI)",
        "systemPrompt: Composed system prompt (server-generated)"
      ]
    },
    "inputs": {
      "heading": "Supported Input Formats",
      "items": [
        "MP4, WebM, MOV, and AVI are common inputs",
        "Large files may be uploaded with the provider File API",
        "Long recordings are chunked by the desktop app before analysis"
      ]
    },
    "sampling": {
      "heading": "Frame rate hint",
      "description": "FPS is a hint for how densely to sample the video. For large files the provider may ignore it; for long recordings the desktop may downsample when chunking.",
      "fps": "Default recorder rate is 5 FPS. Lower rates reduce cost but may miss rapid UI changes.",
      "parametersHeading": "Sampling Parameters",
      "parameters": [
        "framerate: 0.1-20 selection in the UI (provider requests are clamped to 1-20)",
        "chunking: long recordings split into 2-minute segments",
        "audio: include narration when \"Include dictation\" is enabled"
      ]
    },
    "modelRequirements": {
      "heading": "Model Requirements",
      "format": "Video analysis requires Gemini video models. Model identifiers follow {code} format; only {code} models are supported.",
      "reasoning": "The server restricts video analysis to Google Gemini models that accept video inputs."
    },
    "analysis": {
      "heading": "Analysis Process",
      "description": "The model analyzes the full video (and audio if present) and produces a goal-oriented summary.",
      "prompting": "The default system prompt (default_video_analysis) tells the model to adapt to your goal, quote visible text when relevant, and mark unclear content instead of guessing.",
      "promptElementsHeading": "Prompt Elements",
      "promptElements": [
        "Goal alignment: focus on the user's stated intent",
        "Evidence: quote visible errors, logs, or UI text when relevant",
        "Sequence: describe the order of events or steps shown",
        "Next steps: suggest fixes or follow-up tasks"
      ]
    },
    "outputs": {
      "heading": "Analysis Outputs",
      "items": [
        "Analysis summary text tailored to the prompt",
        "Quoted errors or UI text when visible",
        "Workflow notes describing what happened on screen",
        "Suggested fixes or follow-up tasks"
      ]
    },
    "billing": {
      "heading": "Token Usage & Billing",
      "description": "Video analysis usage and cost are tracked per job using provider-reported tokens or duration-based estimates.",
      "tracked": [
        "tokens_sent: Prompt + video tokens",
        "tokens_received: Analysis response tokens",
        "actual_cost: Computed from model pricing"
      ]
    },
    "storage": {
      "heading": "Result Storage",
      "description": "Analysis results are stored in background_jobs.response with task_type \"video_analysis\". Long recordings may include chunk metadata.",
      "reuse": "Results can be incorporated into task descriptions or used directly in the planning workflow."
    },
    "keyFiles": {
      "heading": "Key Source Files",
      "items": [
        "desktop/src/app/components/generate-prompt/_components/video-recording-dialog.tsx",
        "desktop/src/contexts/screen-recording/Provider.tsx",
        "desktop/src-tauri/src/jobs/processors/video_analysis_processor.rs",
        "server/src/handlers/proxy/specialized/video_analysis.rs",
        "server/src/clients/google_client.rs"
      ]
    },
    "integration": {
      "heading": "Integration with Planning",
      "description": "Video analysis summaries can be appended to the task description for context-aware planning.",
      "followup": "Use text_improvement or task_refinement to polish the summary before file discovery."
    },
    "cta": {
      "heading": "See meeting ingestion",
      "description": "Learn more about how video analysis works.",
      "links": {
        "meeting": "Meeting ingestion",
        "runtime": "Runtime walkthrough"
      }
    }
  },
  "mobileIos": {
    "meta": {
      "title": "iOS 클라이언트 아키텍처 - PlanToCode",
      "description": "iOS 컴패니언 앱을 위한 Swift 워크플로우, Auth0 로그인 흐름, 디바이스 링크 세션 관리."
    },
    "category": "아키텍처",
    "date": "2025-09-25",
    "readTime": "12분",
    "title": "iOS 클라이언트 아키텍처",
    "description": "Swift 워크플로우, Auth0 로그인 흐름, 디바이스 링크 세션 관리.",
    "intro": "PlanToCode iOS 앱은 연결된 데스크톱 세션에 연결하는 컴패니언 클라이언트입니다. 데스크톱을 기본 계획 작업 공간으로 유지하면서 터미널 출력, 작업 상태, 음성 전사에 대한 모바일 액세스를 제공합니다.",
    "visuals": {
      "app": {
        "title": "iOS 앱 인터페이스",
        "description": "디바이스 연결 및 터미널 뷰를 보여주는 iOS 앱 스크린샷.",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "PlanToCode iOS 앱 스크린샷",
        "caption": "iOS 앱 스크린샷을 위한 플레이스홀더."
      }
    },
    "packageStructure": {
      "heading": "Swift 패키지 구조",
      "description": "iOS 앱은 Swift 패키지로 구성됩니다:",
      "packages": [
        {
          "name": "Core",
          "path": "mobile/ios/Core/",
          "description": "비즈니스 로직 및 API 클라이언트",
          "components": [
            "WorkflowManager",
            "APIClient",
            "MobileSessionManager",
            "DeviceLinkClient"
          ]
        },
        {
          "name": "Security",
          "path": "mobile/ios/Security/",
          "description": "인증 및 자격 증명 저장소",
          "components": [
            "Auth0Manager",
            "KeychainHelper",
            "TokenStore"
          ]
        },
        {
          "name": "VibeUI",
          "path": "mobile/ios/VibeUI/",
          "description": "SwiftUI 컴포넌트 및 디자인 시스템",
          "components": [
            "TerminalView",
            "JobListView",
            "SettingsView",
            "DeviceLinkView"
          ]
        }
      ]
    },
    "auth": {
      "heading": "Auth0 PKCE 통합",
      "description": "iOS 앱은 보안 인증을 위해 PKCE 흐름과 함께 Auth0를 사용합니다:",
      "flow": [
        "사용자가 로그인을 탭하면 앱이 코드 검증자와 챌린지를 생성",
        "ASWebAuthenticationSession이 Auth0 로그인 페이지를 열음",
        "사용자가 인증하면 Auth0가 인증 코드와 함께 리디렉션",
        "앱이 코드 검증자를 사용하여 코드를 토큰으로 교환",
        "토큰이 iOS 키체인에 안전하게 저장됨"
      ],
      "tokenManagement": {
        "heading": "토큰 관리",
        "items": [
          "API 요청에 사용되는 액세스 토큰",
          "자동 갱신을 위해 저장된 리프레시 토큰",
          "만료 전에 토큰 갱신 트리거",
          "로그아웃 시 키체인에서 모든 토큰 삭제"
        ]
      }
    },
    "deviceLink": {
      "heading": "WebSocket 릴레이를 통한 디바이스 연결",
      "description": "iOS는 서버의 WebSocket 릴레이를 통해 데스크톱 세션에 연결합니다:",
      "protocol": {
        "heading": "연결 프로토콜",
        "steps": [
          "데스크톱이 링크 코드를 생성하고 QR을 표시",
          "iOS가 QR을 스캔하거나 코드를 수동 입력",
          "양쪽이 자격 증명으로 /ws/device-link에 연결",
          "서버가 검증하고 릴레이를 설정",
          "양방향 통신 활성화"
        ]
      },
      "messageTypes": {
        "heading": "메시지 유형",
        "items": [
          "terminal_output: 데스크톱 터미널의 PTY 출력",
          "job_status: 백그라운드 작업 상태 업데이트",
          "session_sync: 세션 상태 동기화",
          "rpc_command: 모바일에서 데스크톱으로의 명령"
        ]
      },
      "reconnection": {
        "heading": "재연결 처리",
        "description": "WebSocket 연결은 자동 재연결, 지수 백오프, 세션 상태 복구로 네트워크 중단을 처리합니다."
      }
    },
    "rpcRouting": {
      "heading": "RPC 명령 라우팅",
      "description": "iOS는 연결된 데스크톱에 명령을 보낼 수 있습니다:",
      "commands": {
        "heading": "지원되는 명령",
        "items": [
          "send_terminal_input: 터미널에 키 입력 전송",
          "request_job_status: 특정 작업의 상태 가져오기",
          "start_voice_transcription: 모바일에서 녹음 시작",
          "sync_session: 전체 세션 상태 요청"
        ]
      },
      "implementation": {
        "heading": "구현",
        "description": "명령은 WebSocket을 통해 전송되는 JSON-RPC 메시지입니다. 데스크톱은 명령을 검증하고 비동기적으로 결과를 반환합니다."
      }
    },
    "offlineQueue": {
      "heading": "오프라인 액션 큐",
      "description": "연결이 끊긴 동안 수행된 액션은 동기화를 위해 큐에 저장됩니다:",
      "architecture": {
        "heading": "큐 아키텍처",
        "items": [
          "액션이 로컬 SQLite 데이터베이스에 저장됨",
          "재연결 시 큐 처리",
          "서버 타임스탬프로 충돌 해결",
          "실패한 액션이 사용자에게 보고됨"
        ]
      },
      "supportedActions": {
        "heading": "지원되는 오프라인 액션",
        "items": [
          "음성 전사 녹음 (로컬에 저장)",
          "세션 노트 및 주석",
          "기본 설정 변경"
        ]
      }
    },
    "localStorage": {
      "heading": "SQLite 로컬 저장소",
      "description": "iOS는 로컬 영속을 위해 SQLite를 사용합니다:",
      "database": {
        "heading": "데이터베이스 스키마",
        "path": "~/Documents/plantocode.sqlite",
        "tables": [
          "linked_devices: 데스크톱 연결",
          "offline_queue: 대기 중인 동기화 액션",
          "cached_sessions: 최근 세션 데이터",
          "transcriptions: 로컬 음성 녹음"
        ]
      },
      "migrations": {
        "heading": "마이그레이션",
        "description": "스키마 버전은 user_version pragma에서 추적됩니다. 마이그레이션은 앱 시작 시 실행됩니다."
      }
    },
    "sessions": {
      "heading": "모바일 세션",
      "description": "MobileSessionManager가 세션 상태를 조정합니다:",
      "lifecycle": [
        "시작 시 마지막 활성 세션 로드",
        "가능한 경우 연결된 데스크톱에 연결",
        "WebSocket을 통해 세션 업데이트 구독",
        "오프라인 액세스를 위해 세션 데이터 캐시"
      ]
    },
    "workflows": {
      "heading": "워크플로우 진입점",
      "description": "모바일에서 액세스 가능한 주요 워크플로우:",
      "items": [
        "터미널 모니터링: 출력 보기, 입력 전송",
        "작업 상태: 백그라운드 작업 진행 추적",
        "음성 캡처: 모바일에서 녹음 및 전사",
        "세션 탐색: 계획 및 히스토리 검토"
      ]
    },
    "region": {
      "heading": "지역 설정",
      "description": "iOS는 API 라우팅을 위한 사용자 지역 기본 설정을 존중합니다:",
      "implementation": "지역은 UserDefaults에 저장되며, 모든 요청에 대해 api-eu.plantocode.com 또는 api-us.plantocode.com을 선택하는 데 사용됩니다."
    }
  },
  "providerRouting": {
    "meta": {
      "title": "프로바이더 라우팅 및 스트리밍 - PlanToCode",
      "description": "PlanToCode가 프록시를 통해 LLM 요청을 라우팅하고, 응답을 정규화하고, 토큰을 데스크톱 클라이언트로 스트리밍하는 방법."
    },
    "category": "리서치 및 모델",
    "date": "2025-09-24",
    "readTime": "10분",
    "title": "프로바이더 라우팅 및 스트리밍",
    "description": "정규화, 스트리밍, 사용량 추적으로 모든 외부 LLM 요청을 중재하는 라우팅 레이어.",
    "visuals": {
      "routingMap": {
        "title": "프로바이더 라우팅 맵",
        "description": "요청이 데스크톱 앱에서 프록시를 거쳐 프로바이더로 흐르는 방법의 다이어그램.",
        "imageSrc": "/images/docs/provider-routing/routing-map.svg",
        "imageAlt": "데스크톱에서 외부 프로바이더로의 프로바이더 라우팅 흐름 다이어그램",
        "caption": "프로바이더 라우팅 다이어그램을 위한 플레이스홀더."
      }
    },
    "cta": {
      "heading": "모델 구성으로 계속",
      "description": "모델 구성은 허용 목록과 토큰 가드레일이 UI에 어떻게 노출되는지 설명합니다.",
      "links": {
        "modelConfiguration": "모델 구성",
        "runtimeWalkthrough": "런타임 워크스루"
      }
    }
  }
}
