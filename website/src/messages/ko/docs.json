{
  "architecture": {
    "meta": {
      "title": "PlanToCode 아키텍처 개요",
      "description": "구현 계획, 워크플로우, 터미널 세션을 지원하는 데스크톱, 오케스트레이션 및 영속성 레이어."
    },
    "category": "아키텍처",
    "date": "2025-09-19",
    "description": "데스크톱 셸, 백그라운드 워크플로우 및 공유 서비스가 어떻게 구성되어 있는지 설명합니다.",
    "frontend": {
      "heading": "프론트엔드 인터페이스",
      "providers": "공유 프로바이더는 알림, 런타임 구성 및 플랜 상태를 처리합니다. 구현 플랜 패널은 플랜 메타데이터를 유지하고, 모달 가시성을 관리하며, 필요에 따라 토큰 추정 또는 프롬프트 콘텐츠를 요청합니다.",
      "ui": "데스크톱 UI는 React 컴포넌트로 구축되었습니다. 구현 플랜 콘텐츠는 대용량 플랜을 가상화하고, 언어를 감지하며, 복사 작업을 지원하는 Monaco 기반 뷰어를 통해 표시되어 검토자가 성능 문제 없이 플랜 텍스트를 검토할 수 있습니다. 터미널 세션은 PTY 출력에 연결되고 연결 상태 업데이트를 표시하는 버퍼링된 뷰 내에서 렌더링됩니다."
    },
    "intro": "PlanToCode는 React 프론트엔드를 사용하는 Tauri 데스크톱 애플리케이션입니다. UI는 구현 플랜, 터미널 및 구성 컨트롤을 렌더링하며, Rust 백엔드는 워크플로우, 토큰 추정 및 영구 터미널 세션을 위한 명령을 노출합니다. 이 개요는 이러한 구성 요소가 어떻게 함께 작동하는지 요약합니다.",
    "metaDescription": "구현 플랜, 워크플로우 및 터미널 세션을 지원하는 데스크톱, 오케스트레이션 및 영속성 계층입니다.",
    "metaTitle": "PlanToCode 아키텍처 개요",
    "ogDescription": "React 프론트엔드, Tauri 명령 및 백그라운드 서비스가 데스크톱 앱 내에서 어떻게 협력하는지 알아보세요.",
    "ogTitle": "PlanToCode 아키텍처 개요",
    "persistence": {
      "database": "터미널 출력 및 세션 메타데이터는 터미널 세션 저장소를 통해 SQLite에 저장됩니다. 각 레코드에는 식별자, 타임스탬프, 작업 디렉터리, 환경 변수 및 누적 로그가 포함되어 재시작 시 이전 출력을 복구할 수 있습니다. 동일한 저장소는 세션 상태가 변경될 때 이벤트를 발생시킵니다.",
      "heading": "영속성 및 구성",
      "modelConfig": "모델 기본값은 애플리케이션 구성 테이블에 저장됩니다. 각 작업은 기본 모델, 허용된 대안 목록, 토큰 예산 및 선택적 복사 버튼 사전 설정을 정의합니다. React 레이어는 이러한 설정을 읽어 모델 선택기와 가드레일을 채웁니다."
    },
    "readTime": "7분",
    "tauriCommands": {
      "commands": "애플리케이션의 Rust 측은 워크플로우, 터미널 세션 및 모델 도구를 위한 명령을 노출합니다. 워크플로우 명령은 워크플로우 오케스트레이터를 통해 백그라운드 작업을 시작하고, 입력을 검증하며, 파일 검색 파이프라인이 실행될 때 진행 이벤트를 발생시킵니다. 토큰 추정 명령은 현재 선택된 모델에 대한 프롬프트 크기를 계산합니다.",
      "heading": "Tauri 명령 및 서비스",
      "terminal": "터미널 명령은 PTY 프로세스를 관리하고, 원격 클라이언트를 추적하며, 세션을 시작하기 전에 지원되는 CLI 바이너리를 사용할 수 있는지 확인합니다. 상태 확인은 PTY 상태와 데이터베이스 레코드를 결합하여 세션이 여전히 활성 상태인지 보고합니다."
    },
    "title": "PlanToCode 아키텍처",
    "voicePipeline": {
      "description": "음성 전사는 미디어 권한, 마이크 선택 및 스트리밍 전사 요청을 조정하는 React 훅으로 구현됩니다. 이 훅은 플랜 터미널 및 프롬프트 편집기와 통합되어 인식된 텍스트를 활성 컴포넌트에 직접 삽입하고 전사가 실패하면 알림을 표시합니다.",
      "heading": "음성 전사 파이프라인"
    }
  },
  "deepResearch": {
    "meta": {
      "title": "심층 조사 - PlanToCode",
      "description": "Web 검색 워크플로우에 대한 기술 문서: API 통합, 쿼리 최적화, 결과 처리 및 개발 워크플로우 통합."
    },
    "apiIntegration": {
      "heading": "API 통합 세부 정보",
      "pipeline": {
        "description": "검색된 콘텐츠는 포맷과 컨텍스트를 유지하면서 의미 있는 정보를 추출하는 표준화된 처리 파이프라인을 통과합니다. 파이프라인은 문서, 코드 저장소 및 기술 토론을 포함한 다양한 콘텐츠 유형을 처리합니다.",
        "heading": "콘텐츠 처리 파이프라인"
      },
      "providerConfig": {
        "description": "시스템은 포괄적인 범위와 중복성을 보장하기 위해 여러 검색 제공자와 통합됩니다. 제공자 선택은 쿼리 유형, 지리적 제한 및 가용성에 따라 자동으로 이루어집니다. API 키 및 속도 제한은 애플리케이션 구성 내에서 투명하게 관리됩니다.",
        "heading": "검색 제공자 구성"
      }
    },
    "architecture": {
      "description": "웹 검색 시스템은 파이프라인으로 작동합니다: 쿼리 생성, 검색 실행, 결과 처리 및 통합. 각 단계는 안정성, 비용 효율성 및 맥락적 관련성을 위해 설계되었습니다. 아키텍처는 독립형 연구 작업과 통합 개발 워크플로우를 모두 지원합니다.",
      "heading": "아키텍처 개요"
    },
    "bestPractices": {
      "examples": {
        "description": "일반적인 통합 패턴은 특정 오류 디버깅부터 익숙하지 않은 API로 새로운 기능 구현까지 웹 검색 결과가 다양한 개발 시나리오를 어떻게 향상시키는지 보여줍니다.",
        "heading": "통합 예제"
      },
      "heading": "모범 사례 및 예제",
      "strategies": {
        "description": "웹 검색 통합의 가치를 극대화하려면 쿼리 작성, 결과 해석 및 개발 워크플로우에 결과 통합을 위한 이러한 검증된 전략을 따르세요.",
        "heading": "효과적인 검색 전략",
        "queryFormulation": {
          "constraints": "플랫폼 또는 환경 제약 조건 포함",
          "errors": "라이브러리 이름과 특정 오류 메시지 결합",
          "heading": "쿼리 작성",
          "practices": "패턴 검색을 위해 \"best practices\" 또는 \"recommended approach\" 사용",
          "versions": "관련이 있는 경우 특정 버전 번호 포함"
        },
        "resultEvaluation": {
          "crossReference": "여러 소스에서 솔루션 교차 참조",
          "dates": "시간에 민감한 정보의 경우 게시 날짜 확인",
          "heading": "결과 평가",
          "official": "제3자 소스보다 공식 문서 우선순위 지정",
          "verify": "개발 환경에서 코드 예제 검증"
        }
      }
    },
    "category": "기술 참조",
    "configuration": {
      "heading": "구성 및 사용자 정의",
      "preferences": {
        "description": "사용자는 결과 필터링, 소스 우선순위 지정 및 통합 깊이를 제어하는 기본 설정을 통해 검색 동작을 사용자 정의할 수 있습니다. 이러한 설정은 프로젝트 인식 방식이며 팀 기본 설정 및 프로젝트 요구 사항에 맞게 작업 공간별로 구성할 수 있습니다.",
        "filters": "언어 및 프레임워크별 검색 필터",
        "heading": "검색 기본 설정",
        "limits": "결과 수 및 처리 깊이 제한",
        "optionsHeading": "구성 가능한 옵션",
        "patterns": "다양한 파일 유형에 대한 통합 패턴",
        "sources": "선호하는 문서 소스 및 권위",
        "triggers": "자동 vs. 수동 검색 트리거 모드"
      },
      "projectSettings": {
        "description": "검색 구성은 특정 프로젝트 및 기술에 맞게 조정할 수 있습니다. 시스템은 프로젝트 프레임워크, 언어 및 종속성을 자동으로 감지하여 검색 매개변수를 최적화합니다. 프로젝트별로 사용자 정의 도메인 필터 및 소스 기본 설정을 구성하여 관련 결과를 보장할 수 있습니다.",
        "heading": "프로젝트별 설정"
      }
    },
    "costs": {
      "heading": "비용 고려 사항 및 제한",
      "optimization": {
        "description": "기능을 저해하지 않으면서 검색 비용을 최적화하기 위해 여러 전략이 사용됩니다. 여기에는 지능형 쿼리 배치, 결과 캐싱, 제공자 폴백 및 효율적인 검색 패턴에 대한 사용자 교육이 포함됩니다. 비용 모니터링 및 알림은 팀이 예산 한도 내에 머무는 데 도움이 됩니다.",
        "heading": "비용 최적화"
      },
      "rateLimiting": {
        "cacheFirst": "API 호출을 최소화하기 위한 캐시 우선 응답",
        "description": "시스템은 필요할 때 검색 기능을 사용할 수 있도록 하면서 API 비용을 관리하기 위해 지능형 속도 제한을 구현합니다. 속도 제한은 사용자별, 프로젝트별 및 전역적으로 적용되며, 제한에 도달하면 자동으로 캐시된 결과로 폴백합니다.",
        "guidelinesHeading": "속도 제한 지침",
        "heading": "속도 제한 및 할당량",
        "personal": "개인 사용: 시간당 100회 검색, 일일 1000회",
        "team": "팀 작업 공간: 구독 등급에 따른 공유 할당량",
        "throttling": "한도에 도달하면 자동 조절"
      }
    },
    "cta": {
      "description": "Deep Research 및 웹 검색 기능은 PlanToCode 데스크톱 애플리케이션에서 사용할 수 있습니다. 플랫폼용 빌드를 다운로드하여 개발 워크플로우에 웹 연구를 통합하세요.",
      "heading": "Deep Research를 사용할 준비가 되셨나요?"
    },
    "date": "2025-09-20",
    "description": "PlanToCode가 웹 검색을 수행하고, 결과를 처리하며, 개발 워크플로우에 결과를 통합하는 방법입니다.",
    "devIntegration": {
      "caching": {
        "description": "검색 결과는 성능을 향상시키고 API 비용을 줄이기 위해 지능적으로 캐시됩니다. 캐싱 시스템은 콘텐츠 신선도, 쿼리 유사성 및 사용 패턴을 고려하여 정보 정확성을 보장하면서 빠른 응답을 제공합니다. 캐시 무효화는 콘텐츠 연령 및 관련성 감소에 따라 자동으로 발생합니다.",
        "heading": "캐싱 및 성능"
      },
      "contextAware": {
        "description": "연구 요청은 현재 개발 세션의 컨텍스트로 자동으로 강화됩니다. 시스템은 열린 파일, 최근 변경 사항, 오류 메시지 및 프로젝트 종속성을 분석하여 더 타겟팅된 검색 쿼리를 작성하고 최대 관련성을 위해 결과를 필터링합니다.",
        "heading": "컨텍스트 인식 연구"
      },
      "heading": "개발 워크플로우 통합",
      "resultIntegration": {
        "description": "검색 결과는 개발 워크플로우에 원활하게 통합됩니다. 코드 스니펫을 직접 삽입할 수 있고, 문서 링크는 참조용으로 보존되며, 주요 결과는 컨텍스트에 적합한 형식으로 요약됩니다. 통합은 기존 코드 스타일 및 프로젝트 규칙을 존중합니다.",
        "heading": "결과 통합"
      }
    },
    "intro": "Deep Research 기능은 PlanToCode가 지능형 웹 검색을 수행하고, 최신 정보를 수집하며, 결과를 개발 워크플로우에 직접 통합할 수 있게 해줍니다. 이 시스템은 쿼리 최적화, 결과 처리 및 맥락적 통합을 결합하여 코드 생성 및 문제 해결 기능을 향상시킵니다.",
    "metaDescription": "웹 검색 워크플로우에 대한 기술 문서: API 통합, 쿼리 최적화, 결과 처리 및 개발 워크플로우 통합.",
    "metaTitle": "Deep research - PlanToCode",
    "ogDescription": "PlanToCode 내에서 웹 검색이 어떻게 작동하는지 이해하세요: 쿼리 생성부터 결과 처리 및 개발 워크플로우와의 통합까지.",
    "ogTitle": "Deep research - PlanToCode",
    "readTime": "8분",
    "title": "Deep Research 및 웹 검색",
    "troubleshooting": {
      "commonIssues": {
        "description": "대부분의 웹 검색 문제는 연결 문제, 속도 제한 또는 지나치게 광범위한 쿼리에서 발생합니다. 시스템은 일반적인 실패 시나리오에 대한 명확한 오류 메시지와 제안된 해결 단계를 제공합니다.",
        "geographic": "지리적 제한",
        "geographicSolution": "지원되는 지역으로 제한된 검색 기능",
        "heading": "일반적인 문제",
        "noResults": "결과를 찾을 수 없음",
        "noResultsSolution": "쿼리 용어를 넓히거나 철자 확인",
        "rateLimit": "속도 제한 초과",
        "rateLimitSolution": "재설정 기간을 기다리거나 캐시된 결과 시도"
      },
      "heading": "문제 해결 및 지원",
      "performance": {
        "description": "최적의 성능을 위해 시스템은 검색 패턴을 모니터링하고 최적화를 제안합니다. 여기에는 쿼리 개선 권장 사항, 캐시 히트율 개선 및 통합 효율성 메트릭이 포함됩니다.",
        "heading": "성능 최적화"
      }
    },
    "workflow": {
      "execution": {
        "blogs": "인정받는 기술 전문가의 블로그 게시물",
        "description": "웹 검색은 개발자 중심 콘텐츠를 우선시하는 통합 검색 API를 통해 수행됩니다. 시스템은 GitHub, Stack Overflow 및 공식 프로젝트 문서와 같은 플랫폼의 기술 문서, 공식 소스 및 커뮤니티 토론에 집중하도록 결과를 자동으로 필터링합니다.",
        "documentation": "공식 프로젝트 문서 및 위키",
        "forums": "기술 포럼 및 커뮤니티 Q&A 사이트",
        "github": "GitHub 저장소, 이슈 및 토론",
        "heading": "검색 실행",
        "releases": "릴리스 노트 및 변경 로그",
        "sourcesHeading": "검색 소스"
      },
      "heading": "검색 워크플로우 단계",
      "processing": {
        "deduplication": "중복 감지 및 콘텐츠 중복 제거",
        "description": "검색 결과는 관련 정보를 추출하고, 노이즈를 제거하며, 최신성, 권위 및 맥락적 관련성에 따라 콘텐츠의 우선순위를 지정하는 지능형 처리를 거칩니다. 시스템은 웹 콘텐츠를 개발 워크플로우에 효율적으로 통합할 수 있는 구조화된 데이터로 변환합니다.",
        "extraction": "콘텐츠 추출 및 HTML에서 마크다운으로 변환",
        "heading": "결과 처리 및 필터링",
        "scoring": "쿼리 일치 및 소스 권위에 기반한 관련성 점수",
        "snippets": "코드 스니펫 추출 및 구문 검증",
        "stepsHeading": "처리 단계",
        "timestamp": "콘텐츠 신선도를 위한 타임스탬프 분석"
      },
      "queryGeneration": {
        "api": "특정 라이브러리 또는 프레임워크에 대한 API 문서 검색",
        "compatibility": "버전 호환성 및 마이그레이션 정보",
        "description": "검색 쿼리는 현재 개발 컨텍스트, 사용자 의도 및 작업 요구 사항에 따라 자동으로 생성됩니다. 시스템은 프로젝트 파일, 활성 토론 및 오류 메시지를 분석하여 최근 문서, 기술 토론 및 권위 있는 소스를 우선시하는 타겟팅된 검색 쿼리를 작성합니다.",
        "errors": "오류 메시지 해결 및 문제 해결 가이드",
        "heading": "쿼리 생성 및 최적화",
        "practices": "모범 사례 및 구현 패턴",
        "security": "보안 권고 및 취약점 보고서",
        "typesHeading": "쿼리 유형"
      }
    }
  },
  "fileDiscovery": {
    "apiUsage": {
      "heading": "API 사용 예제",
      "monitoring": "진행 상황 모니터링",
      "retrieving": "결과 검색",
      "starting": "워크플로우 시작"
    },
    "architecture": {
      "caching": "성능 최적화를 위한 중간 결과 캐싱",
      "costTracking": "AI 작업을 위한 비용 추적 및 시간 초과 관리",
      "distributed": "시스템은 각 단계가 독립적인 백그라운드 작업으로 실행되는 분산 작업 아키텍처를 사용하여 취소, 재시도 논리 및 상세한 진행 상황 추적을 가능하게 합니다. 실시간 이벤트는 실행 전반에 걸쳐 게시되어 사용자 인터페이스에 즉각적인 피드백을 제공합니다.",
      "errorHandling": "자동 재시도 메커니즘을 갖춘 포괄적인 오류 처리",
      "eventDriven": "WebSocket과 같은 업데이트를 통한 이벤트 기반 진행 보고",
      "featuresHeading": "주요 아키텍처 기능:",
      "gitIntegration": "디렉터리 탐색으로 폴백하는 Git 통합",
      "heading": "워크플로우 아키텍처",
      "overview": "워크플로우는 순차적으로 실행되는 5개의 별개 단계를 가진 오케스트레이션된 백그라운드 작업 시스템으로 작동합니다. 각 단계는 이전 단계의 출력을 기반으로 하여 작업 요구 사항에 따라 파일 선택을 점진적으로 개선합니다."
    },
    "category": "기술 가이드",
    "configuration": {
      "exclusion": {
        "description": "검색 프로세스에서 제외할 디렉터리 및 파일 패턴을 정의합니다.",
        "heading": "제외 패턴"
      },
      "heading": "구성 옵션",
      "retry": {
        "description": "지수 백오프를 사용하여 실패한 단계에 대한 최대 재시도 횟수를 설정합니다.",
        "heading": "재시도 구성"
      },
      "timeout": {
        "description": "무한 중단을 방지하기 위해 전체 워크플로우 또는 개별 단계의 최대 실행 시간을 구성합니다.",
        "heading": "시간 초과 관리"
      },
      "workflowConfig": "워크플로우 구성"
    },
    "cta": {
      "description": "파일 검색 워크플로우는 구현 계획 및 터미널 세션과 함께 데스크톱 클라이언트 내에서 실행됩니다.",
      "heading": "데스크톱 앱이 필요하신가요?"
    },
    "date": "2025-09-21",
    "description": "작업 실행을 위해 관련 파일을 식별하고 필터링하는 5단계 AI 워크플로우에 대한 포괄적인 기술 가이드입니다.",
    "errorHandling": {
      "commonIssues": {
        "binaryDetection": "바이너리 파일 감지: 확장자 기반 및 콘텐츠 기반 바이너리 감지 모두 사용",
        "gitNotFound": "Git 저장소를 찾을 수 없음: 표준 제외와 함께 디렉터리 탐색으로 폴백",
        "heading": "일반적인 문제",
        "networkTimeout": "네트워크 시간 초과: 일시적 실패에 대한 지수 백오프를 사용한 자동 재시도",
        "tokenLimit": "토큰 제한 초과: 지능형 배치를 구현하고 명확한 오류 메시지 제공"
      },
      "debugging": {
        "description": "워크플로우는 포괄적인 로깅, 성능 메트릭 내보내기 및 문제 해결을 위한 단계 정보, 재시도 시도 및 중간 데이터를 포함한 상세한 오류 컨텍스트를 제공합니다.",
        "heading": "디버깅 도구"
      },
      "errorCategories": {
        "billing": "청구 오류: 조치 가능한 지침과 함께 불충분한 크레딧 또는 결제 실패",
        "heading": "오류 범주",
        "system": "시스템 오류: 파일 시스템 액세스, git 명령 실패 또는 메모리 제약",
        "validation": "검증 오류: 잘못된 세션 ID, 누락된 작업 설명 또는 잘못된 프로젝트 디렉터리",
        "workflow": "워크플로우 오류: 상세한 컨텍스트 및 재시도 제안이 포함된 단계별 실패"
      },
      "heading": "오류 처리 및 문제 해결"
    },
    "integration": {
      "desktop": {
        "description": "워크플로우는 Tauri 명령을 통해 데스크톱 애플리케이션과 원활하게 통합되어 네이티브 파일 시스템 액세스와 WorkflowTracker 클래스를 통한 이벤트 기반 업데이트를 제공합니다.",
        "heading": "데스크톱 애플리케이션"
      },
      "heading": "통합 패턴",
      "implementationPlans": {
        "description": "선택된 파일은 구현 플랜 패널에 자동으로 제공되어 검색 워크플로우를 다시 실행하지 않고도 플랜 생성이 동일한 최적화된 파일 컨텍스트를 사용하도록 보장합니다.",
        "heading": "구현 플랜 통합"
      },
      "sessionManagement": {
        "description": "워크플로우 결과는 세션별로 캐시되어 동일한 세션 내의 여러 작업이 검색된 파일 컨텍스트를 재사용할 수 있게 하여 반복적인 개발 워크플로우의 성능을 크게 향상시킵니다.",
        "heading": "세션 관리"
      }
    },
    "intro": "PlanToCode는 플랜을 세우거나 명령을 실행하기 전에 올바른 파일을 식별합니다. 5단계 워크플로우는 범위를 좁히고 컨텍스트를 밀접하게 유지합니다.",
    "metaDescription": "작업 실행을 위해 관련 파일을 식별하고 필터링하는 5단계 AI 워크플로우에 대한 포괄적인 기술 가이드입니다.",
    "metaTitle": "파일 검색 워크플로우 - PlanToCode",
    "ogDescription": "다단계 파일 검색 워크플로우 아키텍처에 대한 기술 문서입니다.",
    "ogTitle": "파일 검색 워크플로우 - PlanToCode",
    "performance": {
      "costOptimization": {
        "description": "AI 단계는 API 응답에서 실제 비용을 추적하고, 토큰 사용을 최소화하기 위해 지능형 배치를 구현하며, 비용 관리를 돕기 위해 실행 전에 비용 추정치를 제공합니다.",
        "heading": "비용 최적화"
      },
      "heading": "성능 고려 사항",
      "memory": {
        "description": "워크플로우는 파일 캐싱(30초 TTL), 배치 처리(배치당 100개 파일) 및 메모리 고갈을 방지하기 위한 중간 데이터의 자동 정리를 통해 지능형 메모리 관리를 구현합니다.",
        "heading": "메모리 관리"
      },
      "monitoring": {
        "description": "내장된 성능 추적은 실행 시간, 메모리 사용량, 처리량 메트릭을 모니터링하고 과거 데이터 분석을 기반으로 최적화 권장 사항을 제공합니다.",
        "heading": "성능 모니터링"
      }
    },
    "readTime": "12분",
    "stages": {
      "heading": "5단계 워크플로우 프로세스",
      "stage1": {
        "description": "프로젝트 루트 디렉터리를 결정하고 git 저장소 상태를 검증합니다. 이 단계는 모든 후속 파일 작업의 기본 디렉터리를 설정하고 제외 패턴을 구성합니다.",
        "heading": "1단계: 루트 폴더 선택",
        "technical": "기술 세부 정보: 디렉터리 검증으로 폴백하는 git 감지를 사용하고, 사용자 정의 제외 패턴을 적용하며, 전체 워크플로우의 작업 디렉터리 컨텍스트를 설정합니다."
      },
      "stage2": {
        "binaryDetection": "바이너리 감지: 바이너리 확장자(.jpg, .png, .pdf, .exe 등)가 있는 파일을 필터링하고 콘텐츠 분석을 사용하여 널 바이트 및 인쇄할 수 없는 문자 비율로 바이너리 파일을 감지합니다.",
        "description": "작업 설명을 기반으로 지능형 정규식 패턴을 생성하여 초기 파일 필터링을 수행합니다. 이 단계는 git ls-files 출력과 바이너리 파일 감지를 결합하여 예비 파일 목록을 생성합니다.",
        "gitIntegration": "Git 통합: `git ls-files --cached --others --exclude-standard`를 실행하여 추적된 파일과 추적되지 않은 파일을 모두 포함하면서 .gitignore 규칙을 존중합니다.",
        "heading": "2단계: 정규식 파일 필터"
      },
      "stage3": {
        "aiProcessing": "AI 처리: 대형 언어 모델을 사용하여 작업 요구 사항에 대한 파일 콘텐츠를 평가하며, 토큰 제한 및 비용 최적화를 관리하기 위한 지능형 배치를 사용합니다.",
        "description": "AI 모델을 사용하여 파일 콘텐츠를 분석하고 특정 작업 설명과의 관련성을 평가합니다. 이 단계는 주어진 작업에 가장 유용할 가능성이 높은 파일을 식별하기 위해 심층 콘텐츠 분석을 수행합니다.",
        "heading": "3단계: AI 파일 관련성 평가"
      },
      "stage4": {
        "description": "관계 분석 및 종속성 추적을 통해 추가 관련 파일을 발견합니다. 이 단계는 초기 패턴과 일치하지 않을 수 있지만 맥락적으로 중요한 파일을 식별합니다.",
        "heading": "4단계: 확장 경로 찾기",
        "relationship": "관계 분석: import 문, 구성 파일 및 프로젝트 구조를 분석하여 특정 작업의 컨텍스트를 향상시키는 관련 파일을 찾습니다."
      }
    },
    "stateManagement": {
      "eventDriven": {
        "description": "시스템은 워크플로우 상태 변경, 단계 완료 및 오류 조건에 대한 실시간 이벤트를 게시합니다. 이러한 이벤트는 반응형 사용자 인터페이스와 외부 모니터링 시스템과의 통합을 가능하게 합니다.",
        "heading": "이벤트 기반 업데이트"
      },
      "heading": "워크플로우 상태 관리",
      "intermediateData": {
        "description": "각 단계는 디렉터리 트리 콘텐츠, 정규식 패턴, 필터링된 파일 목록 및 경로 수정 결과를 포함하는 구조화된 중간 데이터 형식으로 출력을 저장합니다. 이 데이터는 디버깅을 위해 액세스할 수 있으며 특정 단계에서 워크플로우를 재개하는 데 사용할 수 있습니다.",
        "heading": "중간 데이터 저장"
      },
      "transitions": {
        "description": "워크플로우는 명확하게 정의된 상태를 거쳐 진행됩니다: 생성됨 → 실행 중 → 일시 중지됨(선택 사항) → 완료됨/실패함/취소됨. 각 상태 전환은 실시간 업데이트를 위해 모니터링할 수 있는 이벤트를 게시합니다.",
        "heading": "상태 전환"
      }
    },
    "title": "파일 검색 워크플로우",
    "meta": {
      "title": "파일 검색 - PlanToCode",
      "description": "코드베이스 전체에서 관련 파일을 식별하는 5단계 AI 워크플로우에 대한 포괄적인 기술 가이드."
    }
  },
  "hub": {
    "ctaDescription": "PlanToCode를 다운로드하여 이 문서에 설명된 구현 플래너, 모델 가드레일, 터미널 세션 및 전사 기능에 액세스하세요.",
    "ctaHeading": "이러한 워크플로우를 사용해 보시겠습니까?",
    "description": "PlanToCode로 코드 변경 사항을 계획하고 배포하는 방법을 알아보세요: 파일 검색, 구현 플랜, 터미널 세션, 모델 가드레일 및 음성.",
    "exploreHeading": "문서 살펴보기",
    "learnMore": "더 알아보기",
    "searchAriaLabel": "문서 검색",
    "searchPlaceholder": "문서 검색...",
    "searchShortcut": "⌘K",
    "title": "PlanToCode 문서"
  },
  "onThisPage": {
    "title": "이 페이지에서"
  },
  "sidebar": {
    "title": "문서"
  },
  "sections": {
    "planning": {
      "title": "계획 및 컨텍스트"
    },
    "execution": {
      "title": "실행 인터페이스"
    },
    "architecture": {
      "title": "아키텍처"
    }
  },
  "items": {
    "text-improvement": {
      "title": "텍스트 개선",
      "description": "프롬프트 정리를 위한 선택 팝오버, 작업 대기열 및 통합."
    },
    "implementation-plans": {
      "title": "구현 플랜",
      "description": "플랜이 Monaco 뷰어로 스트리밍되고 플랜 기록에 연결되는 방법."
    },
    "file-discovery": {
      "title": "파일 검색 워크플로우",
      "description": "각 작업에 대한 관련 경로를 수집하는 백그라운드 워크플로우."
    },
    "deep-research": {
      "title": "Deep Research 및 웹 검색",
      "description": "웹 검색 워크플로우, API 통합, 쿼리 최적화 및 개발 워크플로우 통합."
    },
    "model-configuration": {
      "title": "모델 구성",
      "description": "작업당 허용된 모델 및 선택기 토글의 토큰 가드레일."
    },
    "terminal-sessions": {
      "title": "터미널 세션",
      "description": "영구 PTY 세션, CLI 감지 및 복구 동작."
    },
    "voice-transcription": {
      "title": "음성 전사",
      "description": "녹음 수명 주기, 프로젝트 인식 설정 및 장치 관리."
    },
    "architecture": {
      "title": "아키텍처 개요",
      "description": "React 프론트엔드, Tauri 명령 및 영속성이 어떻게 함께 작동하는지."
    }
  },
  "implementationPlans": {
    "category": "제품 가이드",
    "context": {
      "audit": "모든 메타데이터는 감사 목적으로 플랜과 함께 유지됩니다. 기업 팀은 어떤 이해 관계자가 어떤 플랜을 검토했는지, 어떤 수정이 요청되었는지, 그리고 초기 작업 설명에서 파일 검색을 거쳐 최종 승인된 플랜까지의 완전한 추론 체인을 추적할 수 있습니다.",
      "heading": "기업 거버넌스를 위한 컨텍스트 및 메타데이터",
      "storage": "패널은 후속 작업이 동일한 범위를 재사용할 수 있도록 파일 검색 워크플로우 중에 선택된 저장소 루트를 저장합니다. 또한 다운스트림 프롬프트를 워크플로우를 다시 계산하지 않고 생성하거나 복사할 수 있도록 프로젝트 디렉터리 및 준비된 프롬프트 콘텐츠와 같은 플랜별 메타데이터를 기록합니다.",
      "tokenEstimation": "프롬프트가 복사되기 전에 토큰 추정이 실행됩니다. 패널은 프로젝트 디렉터리, 선택된 파일 및 현재 선택된 모델로 토큰 추정 명령을 호출하여 팀이 모델 제한 내에 머물 수 있도록 시스템 및 사용자 프롬프트 합계를 모두 표시합니다."
    },
    "cta": {
      "claudeCodeLink": "Claude 플랜 모드 워크플로우 보기",
      "codexLink": "Codex 플랜 모드 워크플로우 보기",
      "cursorLink": "Cursor 플랜 모드 워크플로우 보기",
      "description": "사람이 개입하는 구현 플랜은 PlanToCode 데스크톱 애플리케이션 내에서 사용할 수 있습니다. 플랫폼용 빌드를 다운로드하여 안전하고 관리되는 AI 지원 개발을 경험하세요.",
      "heading": "AI 코딩 에이전트를 안전하게 도입할 준비가 되셨나요?"
    },
    "date": "2025-09-19",
    "description": "PlanToCode가 사람이 개입하는 거버넌스, 세밀한 파일별 플랜 및 포괄적인 검토 워크플로우를 통해 AI 코딩 에이전트의 자신 있는 도입을 가능하게 하는 방법입니다.",
    "fileGranularity": {
      "created": "생성됨(완전한 파일 경로 및 초기 콘텐츠 구조 포함)",
      "declaredFiles": "플랜의 각 단계는 다음과 같은 파일을 명시적으로 선언합니다:",
      "deleted": "삭제됨(정당성 및 종속성 분석 포함)",
      "heading": "파일별 세분성",
      "impact": "이 수준의 세부 정보는 코드를 건드리기 전에 제안된 변경 사항의 영향을 명확하게 보여줍니다. 팀 리더는 중요한 레거시 코드가 수정될지, 주요 변경 사항이 제안될지, 또는 플랜이 추가 검토가 필요한 파일을 건드리는지 즉시 식별할 수 있습니다.",
      "intro": "구현 플랜은 개발 작업을 프로젝트의 저장소 구조에 해당하는 정확한 파일 경로를 사용하여 파일별로 세분화하는 매우 세밀한 구조를 사용합니다. 이 세분성은 회귀를 방지하고 기업 환경에서 AI 코딩 에이전트를 자신 있게 도입하는 데 필수적입니다.",
      "modified": "수정됨(특정 줄 범위 및 설명된 변경 사항 포함)",
      "referenced": "참조됨(컨텍스트용이지만 수정되지 않음)",
      "transmission": "파일별 접근 방식은 또한 승인된 플랜을 코딩 에이전트에 정확하게 전송할 수 있게 해줍니다. \"인증 시스템 업데이트\"와 같은 모호한 지시 대신 에이전트는 정확한 사양을 받습니다: \"토큰 회전을 추가하기 위해 src/auth/session_manager.rs 45-67줄을 수정하고, 다음 구조로 src/auth/token_store.rs를 생성...\""
    },
    "hitl": {
      "approve": "승인:",
      "approveDesc": "명시적인 승인이 있어야만 플랜을 선택한 코딩 에이전트 또는 할당된 소프트웨어 개발자에게 안전하게 전송하여 실행할 수 있습니다.",
      "conclusion": "이 워크플로우는 모든 개발 노력이 기업 제품 요구 사항, 팀 워크플로우 및 비즈니스 목표와 일치하도록 보장합니다. 명시적인 사람의 승인 없이는 코드 변경이 발생하지 않습니다.",
      "edit": "편집:",
      "editDesc": "이해 관계자는 VS Code 편집 기능을 사용하여 단계를 직접 수정하고, 접근 방식을 조정하고, 제약 조건을 추가하거나, 위험한 작업을 제거할 수 있습니다.",
      "heading": "사람이 개입하는 거버넌스",
      "intro": "PlanToCode는 팀 리더와 이해 관계자가 AI 생성 구현 플랜의 모든 측면에 대한 완전한 제어를 유지하도록 보장하는 포괄적인 사람이 개입하는(HITL) 워크플로우를 구현합니다. 이 거버넌스 모델은 AI 코딩 에이전트가 자율적으로 작동할 때 발생할 수 있는 회귀, 버그 및 의도하지 않은 수정을 방지합니다.",
      "reject": "거부:",
      "rejectDesc": "요구 사항을 충족하지 않는 플랜은 완전히 거부할 수 있으며, 규정 준수 및 학습을 위해 전체 감사 추적이 유지됩니다.",
      "requestChanges": "변경 요청:",
      "requestChangesDesc": "팀은 AI 시스템에 수정을 요청하여 대체 접근 방식을 생성하거나 사용자 정의 지침으로 여러 플랜을 병합할 수 있습니다.",
      "review": "검토:",
      "reviewDesc": "플랜은 Monaco 편집기에서 열리며 검토자는 전체 구문 강조 및 전문 편집 도구를 사용하여 제안된 모든 변경 사항을 검토할 수 있습니다.",
      "workflow": "코드 수정이 시작되기 전에 모든 플랜은 구조화된 검토 워크플로우를 통과해야 합니다:"
    },
    "intro": "실행 전에 모든 플랜을 검토하고 승인하세요. 파일별 세분성을 갖춘 사람이 개입하는 거버넌스는 AI 생성 변경 사항이 기업 요구 사항 및 팀 워크플로우와 일치하도록 보장합니다.",
    "metaDescription": "AI 구현 계획 가이드. 실행 전에 파일별 플랜을 생성, 검토 및 승인합니다. 중복 및 잘못된 경로를 방지합니다.",
    "metaTitle": "구현 플랜 - AI 변경 사항 검토",
    "multiplePlans": {
      "description": "플랜은 병합, 삭제 또는 나중에 다시 열 수 있습니다. 패널은 선택된 플랜 식별자 목록을 유지하고, 플랜에 연결된 터미널 출력을 위한 전용 모달을 관리하며, 검토자가 뷰어를 닫지 않고 이전 플랜을 페이지할 수 있도록 탐색 도우미를 노출합니다. 터미널 액세스, 프롬프트 복사 컨트롤 및 병합 지침은 모두 동일한 작업 식별자를 공유하여 감사 기록이 일관되게 유지됩니다.",
      "heading": "여러 플랜 작업"
    },
    "ogDescription": "사람이 개입하는 거버넌스 및 파일별 검토 워크플로우가 코드 수정에 대한 완전한 제어로 안전한 AI 개발을 보장하는 방법을 이해하세요.",
    "ogTitle": "PlanToCode의 사람이 개입하는 구현 플랜",
    "plansOrigin": {
      "description": "각 플랜은 현재 세션의 백그라운드 작업에 해당합니다. 패널은 플랜 데이터를 구독하고, 현재 열려 있는 플랜을 추적하며, 이전 작업과 새 작업 간의 탐색을 노출합니다. 이 동작은 {code} 및 주변 패널 컴포넌트 내에 있습니다.",
      "heading": "플랜의 출처"
    },
    "readTime": "6분",
    "reviewingPlans": {
      "description": "플랜 콘텐츠는 Monaco Editor를 래핑하는 공유 {code}를 통해 렌더링됩니다. 뷰어는 일반적인 언어를 자동으로 감지하고, 클립보드에 복사 작업을 지원하며, 매우 큰 플랜을 가상화하고, 문자 수 및 구문 인식 강조와 같은 선택적 메트릭을 제공합니다.",
      "heading": "Monaco로 플랜 검토",
      "opening": "플랜이 열리면 패널은 작업 식별자로 활성 플랜을 확인하고 콘텐츠를 Monaco에 전달하며 검토자가 현재 열린 모달을 잃지 않고 인접한 작업 간에 이동할 수 있게 합니다."
    },
    "title": "구현 플랜",
    "meta": {
      "title": "Implementation Plans - Review AI Changes",
      "description": "Guide to AI implementation planning. Generate, review, and approve file-by-file plans before execution. Prevent duplicates and wrong paths."
    }
  },
  "modelConfiguration": {
    "category": "제품 가이드",
    "date": "2025-09-20",
    "description": "데스크톱 클라이언트의 작업 수준 모델 목록, 선택기 컨트롤 및 토큰 가드레일입니다.",
    "intro": "PlanToCode는 모델 선택을 작업 수준 결정으로 취급합니다. 각 워크플로우는 기본 모델과 허용 목록을 제공하며, 데스크톱 클라이언트는 활성 컨텍스트 창을 초과하는 프롬프트 전송을 방지하는 토글을 통해 이러한 옵션을 노출합니다.",
    "metaDescription": "PlanToCode가 작업별로 허용된 모델을 선택하고 프롬프트를 활성 컨텍스트 창 내에 유지하는 방법입니다.",
    "metaTitle": "모델 구성 및 가드레일 - PlanToCode",
    "ogDescription": "작업 수준 모델 설정, 선택기 토글 및 토큰 추정이 어떻게 함께 작동하는지 알아보세요.",
    "ogTitle": "모델 구성 및 가드레일 - PlanToCode",
    "promptEstimation": {
      "description": "토큰 수는 토큰 추정 명령을 통해 계산됩니다. 패널은 세션 ID, 작업 설명, 관련 파일 및 선택된 모델을 제출하여 백엔드가 시스템, 사용자 및 총 토큰 값을 반환할 수 있도록 합니다. 이 숫자는 선택기 가드레일에 직접 공급되며 팀이 다른 도구에 복사하기 전에 제한을 초과한 프롬프트를 발견할 수 있게 합니다.",
      "heading": "프롬프트 추정"
    },
    "readTime": "5분",
    "selectorToggle": {
      "description": "구현 플랜 패널은 {code}로 허용된 모델을 렌더링합니다. 토글은 허용된 각 모델을 표시하고, 활성 선택을 추적하며, 전환을 허용하기 전에 추정된 프롬프트와 계획된 출력 토큰이 모델의 광고된 컨텍스트 창 내에 맞는지 확인합니다.",
      "guardrails": "모델이 총 토큰 요구 사항을 지원할 수 없는 경우 토글은 버튼을 비활성화하고 계산된 초과를 툴팁으로 표시하여 검토자가 에이전트에 작업을 보내기 전에 안전한 한도 내에 머물도록 합니다.",
      "heading": "클라이언트의 선택기 토글"
    },
    "taskDefaults": {
      "description": "기본 모델 및 허용된 대안은 애플리케이션 구성에 서버 측에 저장됩니다. 구현 플랜, 병합, 프롬프트 생성 또는 음성 전사와 같은 각 작업 유형은 선호하는 모델, 허용된 옵션 목록 및 데스크톱 앱이 런타임에 읽는 토큰 제한을 정의합니다.",
      "heading": "작업 기반 기본값"
    },
    "title": "모델 구성",
    "meta": {
      "title": "모델 구성 - PlanToCode",
      "description": "How PlanToCode lets you pick allowed models per task and keeps prompts within the active context window."
    }
  },
  "terminalSessions": {
    "meta": {
      "title": "터미널 세션 - PlanToCode",
      "description": "Technical guide to PTY terminal implementation in PlanToCode. Learn how sessions persist, agent inactivity detection works, and recovery mechanisms."
    },
    "attentionDetection": {
      "conclusion": "이 접근 방식은 에이전트가 멈춘 이유를 추측하지 않고 작업을 완료했거나 안내가 필요한 시점을 추적하는 데 도움이 됩니다. 주의 표시기는 새 출력이 수신되면 자동으로 지워집니다.",
      "heading": "에이전트 주의 감지",
      "intro": "터미널은 2단계 비활성 감지 시스템을 통해 에이전트 활동을 모니터링합니다. 에이전트가 출력 생성을 중지하면 시스템이 점진적으로 무슨 일이 일어났는지 확인하도록 경고합니다:",
      "level1": "레벨 1(30초): 노란색 표시기와 함께 \"에이전트 유휴 - 작업이 완료되었을 수 있음\"",
      "level2": "레벨 2(2분): 빨간색 표시기 및 데스크톱 알림과 함께 \"에이전트 주의 필요 - 터미널 확인\""
    },
    "category": "제품 가이드",
    "date": "2025-09-22",
    "dependencyChecks": {
      "description": "명령을 시작하기 전에 터미널은 claude, cursor, codex, gemini와 같은 지원되는 CLI 도구의 존재를 확인합니다. 동일한 명령은 사용자가 실행될 환경을 알 수 있도록 기본 셸도 보고합니다. 이는 필요한 바이너리를 찾을 수 없는 세션으로 시작하는 것을 방지합니다.",
      "heading": "종속성 확인"
    },
    "description": "구현 플랜 터미널의 영구 PTY 세션, 에이전트 주의 감지 및 복구 동작입니다.",
    "intro": "상태 확인 및 로깅을 사용하여 영구 PTY에서 명령을 실행하세요. 필요할 때 음성 전사를 사용할 수 있습니다.",
    "lifecycle": {
      "description": "터미널이 열리면 UI 컴포넌트는 PTY 세션을 생성하고 버퍼링된 뷰를 통해 출력을 스트리밍합니다. 컴포넌트는 즉각적인 연결 상태를 표시하고, 키 입력을 PTY로 전달하며, 세션이 실패하면 자동으로 재시도합니다. 세션 메타데이터는 타임스탬프, 종료 코드, 작업 디렉터리 및 전체 출력 로그와 함께 SQLite에 저장되어 재시작 시 이전 컨텍스트를 재개할 수 있습니다.",
      "heading": "세션 수명 주기"
    },
    "metaDescription": "PlanToCode의 PTY 터미널 구현에 대한 기술 가이드입니다. 세션이 지속되는 방법, 에이전트 비활성 감지 작동 방식 및 복구 메커니즘을 알아보세요.",
    "metaTitle": "터미널 세션 - PlanToCode",
    "ogDescription": "플랜 터미널의 세션 영속성, 에이전트 주의 감지 및 복구를 이해하세요.",
    "ogTitle": "터미널 세션 - PlanToCode",
    "readTime": "6분",
    "title": "터미널 세션",
    "voiceRecovery": {
      "heading": "음성 전사 및 복구",
      "recovery": "PTY 세션이 연결이 끊어지면 터미널 인터페이스는 복구 컨트롤을 표시하고 지수 백오프로 연결을 재시도합니다. 상태 확인은 세션 상태를 계속 모니터링하고 연결 문제가 감지되면 자동 복구 작업을 제공합니다.",
      "voice": "터미널 모달 내에서 음성 전사는 음성을 캡처하여 터미널 입력 영역에 붙여넣을 수 있습니다. 녹음 훅은 프로젝트 수준 전사 설정을 조회하고, 녹음 상태를 추적하며, 인식된 텍스트를 활성 플랜 세션으로 스트리밍합니다."
    }
  },
  "textImprovement": {
    "category": "제품 가이드",
    "cta": {
      "description": "PlanToCode를 다운로드하여 구현 플랜을 생성하기 전에 음성 캡처, 비디오 컨텍스트 및 인라인 다시 쓰기를 결합하세요.",
      "heading": "데스크톱 앱에서 텍스트 개선 사용해 보기"
    },
    "date": "2025-09-21",
    "description": "PlanToCode가 포맷을 변경하지 않고 강조 표시된 텍스트를 다시 쓰고 결과를 작업 공간에 다시 연결하는 방법입니다.",
    "intro": "AI 컨텍스트로 텍스트를 개선하세요. 편집기에서 텍스트를 선택하고, 백그라운드 작업을 트리거하고, 포맷을 그대로 유지하는 개선된 콘텐츠를 얻으세요.",
    "metaDescription": "데스크톱 작업 공간이 강조 표시된 텍스트를 다시 쓰고, 포맷을 보존하며, 기능을 음성 및 비디오 입력에 연결하는 방법입니다.",
    "metaTitle": "텍스트 개선 - PlanToCode",
    "ogDescription": "텍스트 개선을 지원하는 선택 팝오버, 작업 대기열, 모델 구성 및 통합을 이해하세요.",
    "ogTitle": "텍스트 개선 - PlanToCode",
    "readTime": "7분",
    "selectionPopover": {
      "component": "팝오버 자체는 프로바이더 훅을 트리거하고 다시 쓰기가 실행되는 동안 로딩 표시기를 표시하는 {code}에 의해 렌더링되는 최소 컴포넌트입니다. 프로바이더가 전역 리스너를 등록하기 때문에 팝오버는 Monaco 플랜 뷰어, 플랜 터미널 받아쓰기 필드 및 추가 배선 없이 작업 설명 입력에 나타납니다.",
      "heading": "선택 팝오버 동작",
      "provider": "{code}는 표준 입력 및 Monaco 편집기에서 선택 이벤트를 수신합니다. 비어 있지 않은 텍스트를 강조 표시하면 커서 근처에 팝오버를 배치하고, 선택된 범위를 저장하며, 팝오버가 표시되어야 하는지 추적합니다. 버튼을 클릭하면 작업이 시작되고 결과가 반환될 때까지 컨트롤이 비활성화됩니다. 작업이 완료되면 프로바이더는 개선된 텍스트를 동일한 선택 항목에 다시 적용하고 세션 상태를 동기화 상태로 유지하기 위해 대기 중인 저장을 플러시합니다."
    },
    "title": "텍스트 개선",
    "triggerImprovement": {
      "action": "팝오버 버튼을 누르면 {code}가 호출됩니다. 작업은 선택을 검증하고, 세션 식별자가 존재하는지 확인하며, Tauri를 통해 Rust 명령 {code}를 호출합니다. 명령은 원본 텍스트를 포함하는 {code}를 빌드하고 활성 세션에 대한 백그라운드 작업을 대기열에 넣습니다.",
      "backend": "백엔드에서 {code}는 {code} 작업에 대해 구성된 모델을 해결하고, 선택을 XML 태그로 래핑하며, 스트리밍 없이 {code}를 통해 요청을 실행합니다. 모델 응답이 반환되면 UI에 개선된 텍스트를 다시 내보내기 전에 토큰 사용량, 비용 및 시스템 프롬프트 템플릿을 기록합니다. 기본 구성은 Claude Sonnet 4 및 Gemini 2.5 Flash를 승인된 모델로 제공하며, 온도 0.7에서 4,096개의 토큰으로 제한됩니다.",
      "heading": "개선을 트리거할 때 일어나는 일",
      "metadata": "백그라운드 작업 사이드바는 작업 메타데이터에 원본 텍스트를 기록하므로 다시 작성된 복사본과 함께 전송된 내용을 검토할 수 있습니다. 작업이 실행되는 동안 선택이 변경되면 프로바이더는 수동 편집을 덮어쓰지 않도록 텍스트 교체를 건너뜁니다."
    },
    "videoCapture": {
      "dialog": "화면 녹화는 비디오 분석 대화 상자를 통과하며, 이는 Gemini 비디오 분석 작업에 요청을 보내기 전에 의미론적 XML 태그로 래핑된 선택적 프롬프트 블록과 함께 현재 작업 설명을 결합합니다. 녹화 중 받아쓴 모든 메모는 분석이 완료되면 텍스트로 사용할 수 있으므로 결과 요약을 개선 팝오버를 통해 다시 공급하여 계획 전에 지침을 강화할 수 있습니다.",
      "features": "비디오 작업에는 프레임 속도 제어, 오디오 캡처 토글 및 비용 보고가 포함됩니다. 결과는 텍스트 개선과 동일한 백그라운드 작업 사이드바에 나타나 모든 프롬프트 준비 아티팩트를 한 곳에 보관합니다.",
      "heading": "비디오 캡처 및 프롬프트 스캐폴딩"
    },
    "voiceIntegration": {
      "heading": "음성 전사 통합",
      "hook": "음성 녹음은 {code} 훅을 사용합니다. 프로젝트별 전사 기본값을 로드하고, 마이크 액세스를 요청하며, 작업 설명 또는 터미널 받아쓰기 버퍼 내의 커서에 전사를 삽입합니다. 삽입된 텍스트는 즉시 강조 표시되어 동일한 개선 팝오버를 통해 전달할 수 있으며, 원본 전사 작업 식별자는 감사를 위해 개선 페이로드와 함께 저장됩니다.",
      "preferences": "언어, 모델 및 온도 기본 설정은 프로젝트 수준에서 지속되므로 팀이 복사본을 개선하기 전에 일관된 전사 품질을 얻습니다. 무음 감지는 잘못된 오디오 레벨에 대해 경고하며, 10분 제한은 대용량 페이로드로 개선 작업을 차단하는 대규모 녹음을 방지합니다."
    },
    "meta": {
      "title": "텍스트 개선 - PlanToCode",
      "description": "How the desktop workspace rewrites highlighted text, preserves formatting, and links the feature to voice and video inputs."
    }
  },
  "voiceTranscription": {
    "category": "제품 가이드",
    "date": "2025-09-22",
    "description": "음성 기반 프롬프트를 위한 녹음 수명 주기, 장치 관리 및 스트리밍 동작입니다.",
    "deviceManagement": {
      "description": "이 기능은 마이크 권한을 요청하고, 사용 가능한 오디오 입력을 열거하며, 사용자가 세션 중에 장치를 전환할 수 있도록 합니다. 오디오 레벨은 실시간으로 모니터링되어 마이크가 음소거되거나 연결이 끊어지면 UI가 무음 경고를 표시할 수 있습니다.",
      "heading": "장치 관리"
    },
    "intro": "음성 전사는 플랜 터미널 및 프롬프트 편집기를 포함하여 데스크톱 앱이 받아쓰기 컨트롤을 노출하는 모든 곳에서 사용할 수 있습니다. 이 기능은 오디오를 로컬로 녹음하고, 청크를 전사 서비스로 보내며, 수동 타이핑을 차단하지 않고 인식된 텍스트를 활성 입력 필드에 삽입합니다.",
    "metaDescription": "PlanToCode가 오디오를 녹음하고, gpt-4o-transcribe를 사용하여 실시간 전사를 스트리밍하고, 권한, 프로젝트 설정을 관리하는 방법입니다.",
    "metaTitle": "음성 전사 - PlanToCode",
    "ogDescription": "녹음 훅이 장치, 권한 및 스트리밍 텍스트를 관리하는 방법을 알아보세요.",
    "ogTitle": "음성 전사 - PlanToCode",
    "projectSettings": {
      "description": "녹음 세션이 시작되면 훅은 활성 프로젝트의 전사 구성을 조회합니다. 언어 코드, 선호 모델 및 기타 설정은 오디오 캡처 전에 검색되어 녹음이 프로젝트의 기본 설정을 따릅니다.",
      "heading": "프로젝트 인식 설정"
    },
    "readTime": "5분",
    "recordingWorkflow": {
      "description": "녹음 훅은 유휴, 녹음, 처리 및 오류 상태를 가진 상태 머신을 유지합니다. 기간을 추적하고, 무음 감지를 관리하며, 10분 후에 녹음이 자동으로 중지되도록 합니다. 청크는 버퍼링되어 전사 작업으로 전달되며, 이는 삽입을 위해 인식된 텍스트를 반환합니다.",
      "heading": "녹음 워크플로우"
    },
    "title": "음성 전사",
    "meta": {
      "title": "음성 전사 - PlanToCode",
      "description": "How PlanToCode records audio, streams real-time transcripts using gpt-4o-transcribe, manages permissions, project settings."
    }
  }
}
