{
  "meta": {
    "title": "문서 - PlanToCode",
    "description": "PlanToCode로 코드 변경을 계획하고 배포하는 방법을 알아보세요: 파일 탐색, 구현 계획, 터미널 세션, 모델 가드레일, 음성 기능."
  },
  "architecture": {
    "meta": {
      "title": "PlanToCode 아키텍처 개요",
      "description": "구현 계획, 워크플로우, 터미널 세션을 구동하는 데스크톱, 오케스트레이션, 영속성 계층."
    },
    "category": "아키텍처",
    "date": "2025-09-19",
    "description": "데스크톱 셸, 백그라운드 워크플로우, 공유 서비스가 어떻게 구성되어 있는지 설명합니다.",
    "frontend": {
      "heading": "프론트엔드 영역",
      "providers": "공유 프로바이더는 알림, 런타임 구성, 계획 상태를 처리합니다. 구현 계획 패널은 계획 메타데이터를 유지하고, 모달 가시성을 관리하며, 필요에 따라 토큰 추정치나 프롬프트 콘텐츠를 요청합니다.",
      "ui": "데스크톱 UI는 React 컴포넌트로 구축되었습니다. 구현 계획 콘텐츠는 대용량 계획을 가상화하고, 언어를 감지하며, 복사 작업을 지원하는 Monaco 기반 뷰어를 통해 표시되어 검토자가 성능 문제 없이 계획 텍스트를 검토할 수 있습니다. 터미널 세션은 PTY 출력에 연결되고 연결 상태 업데이트를 표시하는 버퍼링된 뷰 내에서 렌더링됩니다."
    },
    "intro": "PlanToCode는 React 프론트엔드를 갖춘 Tauri 데스크톱 애플리케이션입니다. UI는 구현 계획, 터미널, 구성 컨트롤을 렌더링하고, Rust 백엔드는 워크플로우, 토큰 추정, 영구 터미널 세션을 위한 명령을 노출합니다. 이 개요는 이러한 구성 요소들이 어떻게 함께 작동하는지 요약합니다.",
    "metaDescription": "구현 계획, 워크플로우, 터미널 세션을 구동하는 데스크톱, 오케스트레이션, 영속성 계층.",
    "metaTitle": "PlanToCode 아키텍처 개요",
    "ogDescription": "React 프론트엔드, Tauri 명령, 백그라운드 서비스가 데스크톱 앱 내에서 어떻게 협력하는지 알아보세요.",
    "ogTitle": "PlanToCode 아키텍처 개요",
    "persistence": {
      "database": "터미널 출력과 세션 메타데이터는 터미널 세션 저장소를 통해 SQLite에 저장됩니다. 각 레코드에는 식별자, 타임스탬프, 작업 디렉토리, 환경 변수, 축적된 로그가 포함되어 있어 재시작 시 이전 출력을 복구할 수 있습니다. 동일한 저장소는 세션 상태가 변경될 때 이벤트를 발생시킵니다.",
      "heading": "영속성 및 구성",
      "modelConfig": "모델 기본값은 애플리케이션 구성 테이블에 저장됩니다. 각 작업은 기본 모델, 허용된 대안 목록, 토큰 예산, 선택적 복사 버튼 프리셋을 정의합니다. React 레이어는 이러한 설정을 읽어 모델 선택기와 가드레일을 채웁니다."
    },
    "readTime": "7분",
    "tauriCommands": {
      "commands": "애플리케이션의 Rust 측은 워크플로우, 터미널 세션, 모델 도구에 대한 명령을 노출합니다. 워크플로우 명령은 Workflow Orchestrator를 통해 백그라운드 작업을 시작하고, 입력을 검증하며, 파일 탐색 파이프라인이 실행될 때 진행 이벤트를 발생시킵니다. 토큰 추정 명령은 현재 선택된 모델에 대한 프롬프트 크기를 계산합니다.",
      "heading": "Tauri 명령 및 서비스",
      "terminal": "터미널 명령은 PTY 프로세스를 관리하고, 원격 클라이언트를 추적하며, 세션을 시작하기 전에 지원되는 CLI 바이너리가 사용 가능한지 확인합니다. 상태 확인은 PTY 상태와 데이터베이스 레코드를 결합하여 세션이 여전히 활성 상태인지 보고합니다."
    },
    "title": "PlanToCode 아키텍처",
    "voicePipeline": {
      "description": "음성 전사는 미디어 권한, 마이크 선택, 스트리밍 전사 요청을 조정하는 React 훅으로 구현됩니다. 이 훅은 계획 터미널 및 프롬프트 편집기와 통합되어 인식된 텍스트를 활성 컴포넌트에 직접 삽입하고 전사가 실패하면 알림을 표시합니다.",
      "heading": "음성 전사 파이프라인"
    },
    "server": {
      "heading": "서버 계층",
      "description": "서버는 프로바이더 구성(암호화된 볼트의 API 키, 속도 제한, OpenAI, Anthropic, Google에 대한 라우팅 규칙), 모델 라우팅(요청 프록시, 자동 장애 조치, 로드 밸런싱, 사용자/프로젝트별 비용 추적), 청구(구독 관리, 사용량 측정, 할당량 적용, 비용 알림), 웹 검색 API(30일/7일 TTL로 결과 캐싱, 지리적 제한, JWT 인증)를 처리합니다."
    },
    "dataFlows": {
      "heading": "데이터 흐름",
      "description": "작업, 계획, 작업, 세션은 컴포넌트 간에 흐릅니다: (1) 작업 정제: React UI → TextImprovementPopover → Tauri 명령 → WorkflowOrchestrator → text_improvement 프롬프트 → SQLite → React 프로바이더가 텍스트 교체. (2) 파일 탐색: 구현 계획 패널 → Tauri 명령 → 4개의 순차 작업 → 진행 이벤트 → SQLite → UI 표시. (3) 구현 계획: 파일 탐색 → 계획 생성 → Tauri 명령 → LLM 스트리밍 → SQLite → Monaco 뷰어 → 검토/승인 → 내보내기. (4) 터미널 실행: PTY 세션 → SQLite → 명령 실행 → 출력 스트리밍 → 음성 전사 주입 → 에이전트 주의 감지 → 감사 로그."
    }
  },
  "deepResearch": {
    "meta": {
      "title": "심층 조사 - PlanToCode",
      "description": "웹 검색 워크플로우에 대한 기술 문서: API 통합, 쿼리 최적화, 결과 처리, 개발 워크플로우 통합."
    },
    "apiIntegration": {
      "heading": "API 통합 상세",
      "pipeline": {
        "description": "조사 결과는 서식과 컨텍스트를 유지하면서 의미 있는 정보를 추출하는 표준화된 처리 파이프라인을 통과합니다. 파이프라인은 다양한 콘텐츠 유형을 처리하고 개발 워크플로우를 위한 실행 가능한 인사이트로 결과를 종합합니다.",
        "heading": "콘텐츠 처리 파이프라인"
      },
      "providerConfig": {
        "description": "시스템은 OpenRouter를 통해 AI 언어 모델을 사용하여 지능형 웹 조사를 수행합니다. LLM은 작업 컨텍스트를 기반으로 대상화된 조사 쿼리를 생성하고 학습 데이터와 웹 검색 기능에서 결과를 종합합니다. 모델 선택 및 구성은 애플리케이션 설정을 통해 관리됩니다.",
        "heading": "AI 조사 구성"
      }
    },
    "architecture": {
      "description": "심층 조사 시스템은 2단계 워크플로우로 작동합니다: (1) WebSearchPromptsGeneration - AI가 작업과 프로젝트 컨텍스트를 분석하여 대상화된 조사 쿼리를 생성하고, (2) WebSearchExecution - LLM이 조사 프롬프트를 병렬로 실행하고 결과를 종합합니다. 각 단계는 안정성, 비용 효율성, 컨텍스트 관련성을 위해 설계되었습니다.",
      "heading": "아키텍처 개요"
    },
    "bestPractices": {
      "examples": {
        "description": "일반적인 통합 패턴은 특정 오류 디버깅부터 익숙하지 않은 API로 새 기능을 구현하는 것까지 웹 검색 결과가 다양한 개발 시나리오를 어떻게 향상시키는지 보여줍니다.",
        "heading": "통합 예제"
      },
      "heading": "모범 사례 및 예제",
      "strategies": {
        "description": "웹 검색 통합의 가치를 극대화하려면 쿼리 작성, 결과 해석, 개발 워크플로우에 결과 통합에 대한 검증된 전략을 따르세요.",
        "heading": "효과적인 검색 전략",
        "queryFormulation": {
          "constraints": "플랫폼 또는 환경 제약 조건 포함",
          "errors": "라이브러리 이름과 특정 오류 메시지 결합",
          "heading": "쿼리 작성",
          "practices": "패턴 검색에 \"모범 사례\" 또는 \"권장 접근 방식\" 사용",
          "versions": "관련이 있는 경우 특정 버전 번호 포함"
        },
        "resultEvaluation": {
          "crossReference": "여러 소스에서 솔루션 교차 참조",
          "dates": "시간에 민감한 정보의 경우 게시 날짜 확인",
          "heading": "결과 평가",
          "official": "서드파티 소스보다 공식 문서 우선",
          "verify": "개발 환경에서 코드 예제 검증"
        }
      }
    },
    "category": "기술 참조",
    "configuration": {
      "heading": "구성 및 사용자 정의",
      "preferences": {
        "description": "조사 동작은 모델 선택 및 작업 설정을 통해 구성됩니다. 조사 작업에 선호하는 AI 모델을 선택하고, 타임아웃을 구성하고, 컨텍스트에 포함할 파일을 선택하세요.",
        "filters": "모델 선택이 조사 품질과 비용을 결정",
        "heading": "조사 설정",
        "limits": "작업당 최대 12개의 조사 프롬프트 생성",
        "optionsHeading": "구성 가능한 옵션",
        "patterns": "더 나은 컨텍스트를 위해 관련 프로젝트 파일 포함",
        "sources": "컨텍스트를 위한 프로젝트 디렉토리 및 파일 선택",
        "triggers": "워크플로우 명령을 통해 수동으로 조사 시작"
      },
      "projectSettings": {
        "description": "조사 구성은 세션을 인식합니다. 시스템은 현재 세션의 프로젝트 디렉토리와 포함된 파일을 사용하여 컨텍스트를 제공합니다. 제외된 경로(node_modules, dist 등)는 AI에 표시되는 디렉토리 트리에서 자동으로 필터링됩니다.",
        "heading": "프로젝트별 설정"
      }
    },
    "costs": {
      "heading": "비용 고려사항",
      "optimization": {
        "description": "조사 비용은 지능형 프롬프트 생성을 통해 관리됩니다 - 시스템은 조사 프롬프트를 작업당 최대 12개로 제한합니다. 병렬 실행은 실제 소요 시간을 최소화합니다. 각 작업은 완전한 투명성을 위해 메타데이터에 토큰 사용량과 예상 비용을 추적합니다.",
        "heading": "비용 최적화"
      },
      "rateLimiting": {
        "cacheFirst": "중복 쿼리를 피하기 위해 세션별로 조사 결과 캐싱",
        "description": "심층 조사는 OpenRouter를 통해 구성된 AI 크레딧을 사용합니다. 각 조사 작업은 여러 병렬 LLM 호출을 생성하므로 비용은 생성된 조사 프롬프트 수에 따라 확장됩니다. 시스템은 투명성을 위해 작업별 토큰 사용량과 비용을 추적합니다.",
        "guidelinesHeading": "비용 관리 팁",
        "heading": "사용량 및 비용",
        "personal": "상세 비용 분석과 함께 조사 작업별 토큰 사용량 추적",
        "team": "OpenRouter 또는 PlanToCode 구독 크레딧을 통해 비용 관리",
        "throttling": "토큰 수와 예상 비용에 대한 작업 메타데이터 모니터링"
      }
    },
    "cta": {
      "description": "심층 조사 및 웹 검색 기능은 PlanToCode 데스크톱 애플리케이션에서 사용할 수 있습니다. 플랫폼에 맞는 빌드를 다운로드하여 개발 워크플로우에 웹 조사를 통합하기 시작하세요.",
      "heading": "심층 조사를 사용할 준비가 되셨나요?",
      "links": {
        "architecture": "시스템 아키텍처 보기",
        "buildYourOwn": "나만의 통합 구축"
      }
    },
    "date": "2025-09-20",
    "description": "PlanToCode가 웹 검색을 수행하고, 결과를 처리하고, 개발 워크플로우에 결과를 통합하는 방법.",
    "devIntegration": {
      "caching": {
        "description": "조사 결과는 작업 메타데이터에 저장되며 작업 상세 패널을 통해 액세스할 수 있습니다. 결과는 세션 기간 동안 유지되며 구현 계획을 만들거나 코딩 결정을 내릴 때 참조할 수 있습니다.",
        "heading": "결과 저장"
      },
      "contextAware": {
        "description": "조사 요청은 현재 세션의 컨텍스트로 자동 강화됩니다. 시스템은 프롬프트 생성 단계에서 프로젝트의 디렉토리 트리와 선택한 파일 콘텐츠를 포함하여 AI가 코드베이스에 특화된 조사 쿼리를 작성할 수 있도록 합니다.",
        "heading": "컨텍스트 인식 조사"
      },
      "heading": "개발 워크플로우 통합",
      "resultIntegration": {
        "description": "조사 결과는 구현 계획을 안내하는 데 사용할 수 있습니다. 조사 작업이 완료되면 결과는 후속 계획 작업에 통합할 수 있는 research_finding 태그로 형식화되어 구현이 현재 모범 사례와 정확한 문서로 안내되도록 합니다.",
        "heading": "결과 통합"
      }
    },
    "intro": "심층 조사 기능을 통해 PlanToCode는 지능형 AI 기반 조사를 수행하고, 관련 정보를 수집하며, 결과를 개발 워크플로우에 직접 통합할 수 있습니다. 이 시스템은 대규모 언어 모델을 사용하여 프로젝트 컨텍스트를 기반으로 대상화된 조사 쿼리를 생성하고, 병렬 조사 작업을 실행하며, 코드 생성 및 문제 해결 기능을 향상시키는 실행 가능한 인사이트를 종합합니다.",
    "metaDescription": "웹 검색 워크플로우에 대한 기술 문서: API 통합, 쿼리 최적화, 결과 처리, 개발 워크플로우 통합.",
    "metaTitle": "심층 조사 - PlanToCode",
    "ogDescription": "PlanToCode 내에서 웹 검색이 어떻게 작동하는지 이해하세요: 쿼리 생성부터 결과 처리 및 개발 워크플로우와의 통합까지.",
    "ogTitle": "심층 조사 - PlanToCode",
    "readTime": "8분",
    "title": "심층 조사 및 웹 검색",
    "troubleshooting": {
      "commonIssues": {
        "description": "대부분의 조사 문제는 LLM API 연결, 크레딧 부족, 또는 너무 광범위한 프롬프트에서 발생합니다. 시스템은 문제 해결을 위해 명확한 오류 메시지와 작업 상태 추적을 제공합니다.",
        "geographic": "모델 가용성",
        "geographicSolution": "일부 모델은 OpenRouter를 통해 지역 제한이 있을 수 있습니다",
        "heading": "일반적인 문제",
        "noResults": "조사 프롬프트가 생성되지 않음",
        "noResultsSolution": "더 구체적인 작업 설명을 제공하거나 컨텍스트를 위해 관련 파일을 포함하세요",
        "rateLimit": "API 오류",
        "rateLimitSolution": "OpenRouter API 상태 및 크레딧 잔액 확인"
      },
      "heading": "문제 해결 및 지원",
      "performance": {
        "description": "최적의 성능을 위해 명확하고 구체적인 작업 설명을 제공하세요. AI에게 더 나은 컨텍스트를 제공하기 위해 관련 프로젝트 파일을 포함하세요. 시스템은 총 실행 시간을 최소화하기 위해 조사 프롬프트를 병렬로 실행합니다.",
        "heading": "성능 최적화"
      }
    },
    "workflow": {
      "execution": {
        "blogs": "모범 사례 및 구현 패턴",
        "description": "조사 프롬프트는 AI 언어 모델에 의해 병렬로 실행됩니다. 각 프롬프트는 독립적으로 처리되어 시스템이 작업의 여러 측면에 대한 정보를 동시에 수집할 수 있습니다. 결과는 제목과 실행 가능한 인사이트가 포함된 구조화된 결과로 종합됩니다.",
        "documentation": "API 문서 및 기술 사양",
        "forums": "오류 해결 및 문제 해결 접근 방식",
        "github": "코드 예제 및 구현 패턴",
        "heading": "조사 실행",
        "releases": "버전 호환성 및 마이그레이션 안내",
        "sourcesHeading": "조사 집중 영역"
      },
      "heading": "조사 워크플로우 단계",
      "processing": {
        "deduplication": "여러 조사 프롬프트에서 결과 통합",
        "description": "조사 결과는 제목과 상세 결과가 포함된 JSON 형식으로 구조화됩니다. 시스템은 병렬 조사 작업의 결과를 집계하고, 성공 및 실패 횟수를 추적하며, 조사 결과의 요약을 제공합니다. 결과는 쉽게 액세스할 수 있도록 작업 메타데이터에 저장됩니다.",
        "extraction": "주요 결과 추출 및 통합을 위한 형식화",
        "heading": "결과 처리 및 종합",
        "scoring": "조사 주제 및 관련성별로 결과 정리",
        "snippets": "실행 가능한 인사이트 및 권장 사항 강조",
        "stepsHeading": "처리 단계",
        "timestamp": "타이밍 메트릭으로 조사 실행 추적"
      },
      "queryGeneration": {
        "api": "API 문서 및 라이브러리별 조사",
        "compatibility": "버전 호환성 및 마이그레이션 경로",
        "description": "조사 프롬프트는 작업 설명, 프로젝트 컨텍스트, 포함된 파일을 기반으로 AI에 의해 자동 생성됩니다. 시스템은 디렉토리 트리와 파일 콘텐츠를 통해 코드베이스 구조를 분석하여 대상화된 조사 쿼리를 작성합니다. 작업당 최대 12개의 집중 조사 프롬프트가 생성됩니다.",
        "errors": "오류 해결 및 디버깅 접근 방식",
        "heading": "프롬프트 생성",
        "practices": "모범 사례 및 권장 패턴",
        "security": "보안 고려 사항 및 취약점 인식",
        "typesHeading": "조사 주제"
      }
    },
    "visuals": {
      "pipeline": {
        "title": "심층 조사 파이프라인",
        "description": "2단계 워크플로우: 프롬프트 생성 및 병렬 조사 실행.",
        "imageSrc": "/images/docs/deep-research/workflow.svg",
        "imageAlt": "프롬프트 생성 및 실행 단계를 보여주는 심층 조사 파이프라인 다이어그램",
        "caption": "프롬프트 생성 및 병렬 실행 단계를 보여주는 심층 조사 워크플로우"
      },
      "workflow": {
        "title": "심층 조사 워크플로우",
        "description": "2단계 워크플로우: 프롬프트 생성 및 병렬 조사 실행.",
        "imageSrc": "/images/docs/deep-research/workflow.svg",
        "caption": "모든 처리 단계를 보여주는 심층 조사 워크플로우"
      }
    }
  },
  "fileDiscovery": {
    "meta": {
      "title": "파일 탐색 워크플로우 - PlanToCode",
      "description": "작업 실행을 위해 관련 파일을 식별하고 필터링하는 4단계 AI 워크플로우에 대한 종합적인 기술 가이드."
    },
    "apiUsage": {
      "heading": "API 사용 예제",
      "monitoring": "진행 상황 모니터링",
      "retrieving": "결과 검색",
      "starting": "워크플로우 시작"
    },
    "architecture": {
      "caching": "성능 최적화를 위한 중간 결과 캐싱",
      "costTracking": "AI 작업을 위한 비용 추적 및 타임아웃 관리",
      "distributed": "시스템은 각 단계가 독립적인 백그라운드 작업으로 실행되는 분산 작업 아키텍처를 사용하여 취소, 재시도 로직, 상세 진행 추적이 가능합니다. 사용자 인터페이스에 즉각적인 피드백을 제공하기 위해 실행 전반에 걸쳐 실시간 이벤트가 게시됩니다.",
      "errorHandling": "자동 재시도 메커니즘을 갖춘 포괄적인 오류 처리",
      "eventDriven": "WebSocket과 유사한 업데이트를 통한 이벤트 기반 진행 보고",
      "featuresHeading": "주요 아키텍처 특징:",
      "gitIntegration": "디렉토리 탐색으로 폴백하는 Git 통합",
      "heading": "워크플로우 아키텍처",
      "overview": "워크플로우는 순차적으로 실행되는 네 개의 별개 단계로 구성된 오케스트레이션된 백그라운드 작업 시스템으로 작동합니다. 각 단계는 이전 단계의 출력을 기반으로 하여 작업 요구 사항에 따라 파일 선택을 점진적으로 정제합니다."
    },
    "category": "기술 가이드",
    "configuration": {
      "exclusion": {
        "description": "탐색 프로세스에서 제외할 디렉토리와 파일 패턴을 정의합니다.",
        "heading": "제외 패턴"
      },
      "heading": "구성 옵션",
      "retry": {
        "description": "지수 백오프를 사용하여 실패한 단계에 대한 최대 재시도 횟수를 설정합니다.",
        "heading": "재시도 구성"
      },
      "timeout": {
        "description": "무한 대기를 방지하기 위해 전체 워크플로우 또는 개별 단계의 최대 실행 시간을 구성합니다.",
        "heading": "타임아웃 관리"
      },
      "workflowConfig": "워크플로우 구성"
    },
    "cta": {
      "description": "파일 탐색 워크플로우는 구현 계획 및 터미널 세션과 함께 데스크톱 클라이언트 내에서 실행됩니다.",
      "heading": "데스크톱 앱이 필요하신가요?",
      "links": {
        "architecture": "아키텍처 알아보기",
        "buildYourOwn": "나만의 파이프라인 구축"
      }
    },
    "date": "2025-09-21",
    "description": "작업 실행을 위해 관련 파일을 식별하고 필터링하는 4단계 AI 워크플로우에 대한 종합적인 기술 가이드.",
    "errorHandling": {
      "commonIssues": {
        "binaryDetection": "바이너리 파일 감지: 확장자 기반 및 콘텐츠 기반 바이너리 감지 모두 사용",
        "gitNotFound": "Git 저장소를 찾을 수 없음: 표준 제외 항목을 사용하여 디렉토리 탐색으로 폴백",
        "heading": "일반적인 문제",
        "networkTimeout": "네트워크 타임아웃: 일시적 실패에 대해 지수 백오프를 사용한 자동 재시도",
        "tokenLimit": "토큰 제한 초과: 지능형 배치를 구현하고 명확한 오류 메시지 제공"
      },
      "debugging": {
        "description": "워크플로우는 포괄적인 로깅, 성능 메트릭 내보내기, 문제 해결을 위한 단계 정보, 재시도 횟수, 중간 데이터를 포함한 상세 오류 컨텍스트를 제공합니다.",
        "heading": "디버깅 도구"
      },
      "errorCategories": {
        "billing": "청구 오류: 크레딧 부족 또는 결제 실패와 함께 실행 가능한 안내 제공",
        "heading": "오류 카테고리",
        "system": "시스템 오류: 파일 시스템 액세스, git 명령 실패, 또는 메모리 제약",
        "validation": "검증 오류: 잘못된 세션 ID, 누락된 작업 설명, 또는 잘못된 프로젝트 디렉토리",
        "workflow": "워크플로우 오류: 상세 컨텍스트 및 재시도 제안과 함께 단계별 실패"
      },
      "heading": "오류 처리 및 문제 해결"
    },
    "integration": {
      "desktop": {
        "description": "워크플로우는 Tauri 명령을 통해 데스크톱 애플리케이션과 원활하게 통합되어 네이티브 파일 시스템 액세스와 WorkflowTracker 클래스를 통한 이벤트 기반 업데이트를 제공합니다.",
        "heading": "데스크톱 애플리케이션"
      },
      "heading": "통합 패턴",
      "implementationPlans": {
        "description": "선택된 파일은 구현 계획 패널에 자동으로 제공되어 탐색 워크플로우를 다시 실행할 필요 없이 계획 생성이 동일한 최적화된 파일 컨텍스트를 사용하도록 합니다.",
        "heading": "구현 계획 통합"
      },
      "sessionManagement": {
        "description": "워크플로우 결과는 세션별로 캐시되어 동일한 세션 내의 여러 작업이 발견된 파일 컨텍스트를 재사용할 수 있으므로 반복적인 개발 워크플로우의 성능이 크게 향상됩니다.",
        "heading": "세션 관리"
      }
    },
    "intro": "PlanToCode는 계획을 세우거나 명령을 실행하기 전에 올바른 파일을 식별합니다. 4단계 워크플로우는 범위를 좁히고 컨텍스트를 간결하게 유지합니다.",
    "metaDescription": "작업 실행을 위해 관련 파일을 식별하고 필터링하는 4단계 AI 워크플로우에 대한 종합적인 기술 가이드.",
    "metaTitle": "파일 탐색 워크플로우 - PlanToCode",
    "ogDescription": "다단계 파일 탐색 워크플로우 아키텍처에 대한 기술 문서.",
    "ogTitle": "파일 탐색 워크플로우 - PlanToCode",
    "performance": {
      "costOptimization": {
        "description": "AI 단계는 API 응답에서 실제 비용을 추적하고, 토큰 사용량을 최소화하기 위해 지능형 배치를 구현하며, 비용 관리를 돕기 위해 실행 전 비용 추정치를 제공합니다.",
        "heading": "비용 최적화"
      },
      "heading": "성능 고려사항",
      "memory": {
        "description": "워크플로우는 파일 캐싱(30초 TTL), 배치 처리(배치당 100개 파일), 메모리 고갈을 방지하기 위한 중간 데이터 자동 정리를 통해 지능형 메모리 관리를 구현합니다.",
        "heading": "메모리 관리"
      },
      "monitoring": {
        "description": "내장된 성능 추적은 실행 시간, 메모리 사용량, 처리량 메트릭을 모니터링하고 과거 데이터 분석을 기반으로 최적화 권장 사항을 제공합니다.",
        "heading": "성능 모니터링"
      }
    },
    "readTime": "12분",
    "stages": {
      "heading": "4단계 워크플로우 프로세스",
      "stage1": {
        "description": "AI를 사용하여 작업 설명을 기반으로 후보 경로 목록에서 가장 관련성 높은 루트 디렉토리를 지능적으로 선택합니다. LLM은 기본 프로젝트 디렉토리와 후보 루트를 분석하여 작업과 관련된 파일을 포함할 가능성이 가장 높은 디렉토리를 결정합니다.",
        "heading": "1단계: 루트 폴더 선택",
        "technical": "기술 세부사항: 후보 루트 디렉토리(깊이 2까지)와 작업 설명을 받습니다. LLM은 작업 컨텍스트에 대해 각 경로를 평가하고 후속 단계에서 검색될 루트 디렉토리의 필터링된 목록을 반환합니다.",
        "inputOutput": "입력/출력: candidate_roots 배열과 task_description을 받습니다. 작업과 가장 관련성이 높은 AI 선택 디렉토리를 포함하는 root_directories 배열을 반환합니다."
      },
      "stage2": {
        "binaryDetection": "바이너리 감지: 바이너리 확장자(.jpg, .png, .pdf, .exe 등)가 있는 파일을 필터링하고 널 바이트 및 인쇄 불가능한 문자 비율로 바이너리 파일을 감지하는 콘텐츠 분석을 사용합니다.",
        "description": "AI를 사용하여 작업 설명과 디렉토리 구조를 기반으로 지능형 정규식 패턴 그룹을 생성합니다. 각 패턴 그룹에는 경로 패턴(긍정 및 부정)과 콘텐츠 패턴이 포함될 수 있습니다. 프로세서는 이러한 패턴을 적용하여 선택된 각 루트 디렉토리에서 파일을 필터링합니다.",
        "gitIntegration": "Git 통합: 선택된 각 디렉토리의 git 저장소 루트를 찾고 git_utils를 사용하여 추적 및 미추적 파일을 모두 포함하면서 .gitignore 규칙을 준수하는 모든 무시되지 않은 파일을 가져옵니다.",
        "heading": "2단계: 정규식 파일 필터",
        "technical": "기술 세부사항: 각 루트에 대한 디렉토리 트리를 생성하고, LLM을 호출하여 path_pattern, content_pattern, negative_path_pattern 필드가 있는 patternGroups를 생성합니다. 전방탐색/후방탐색 지원을 위해 fancy-regex를 사용합니다. 구성 가능한 동시성으로 루트를 병렬 처리합니다."
      },
      "stage3": {
        "aiProcessing": "AI 처리: 대규모 언어 모델을 사용하여 작업 요구 사항에 대해 파일 콘텐츠를 평가하고, 컨텍스트 윈도우를 효율적으로 관리하기 위해 실제 파일 크기와 토큰 추정치를 기반으로 지능형 청킹을 수행합니다.",
        "description": "AI 모델을 사용하여 파일 콘텐츠를 분석하고 특정 작업 설명과의 관련성을 평가합니다. 이 단계는 파일 콘텐츠를 읽고 LLM이 작업과 가장 관련성이 높은 파일을 식별하도록 하여 심층 콘텐츠 분석을 수행합니다.",
        "heading": "3단계: AI 파일 관련성 평가",
        "technical": "기술 세부사항: 파일 유형 인식 휴리스틱을 사용하여 파일당 토큰을 추정합니다(코드 ~3자/토큰, 구조화된 데이터 ~5자/토큰). 90k 토큰 임계값 미만을 유지하기 위해 콘텐츠 인식 청크를 생성합니다. 타임아웃을 피하기 위해 스트리밍으로 청크를 병렬 처리합니다. 파일 시스템에 대해 모든 LLM 제안 경로를 검증합니다."
      },
      "stage4": {
        "description": "이전에 식별된 파일과 해당 콘텐츠를 디렉토리 트리와 함께 LLM에 제공하여 추가 관련 파일을 발견합니다. AI는 임포트, 종속성, 프로젝트 구조를 분석하여 작업에 대한 컨텍스트를 향상시키는 관련 파일을 찾습니다.",
        "heading": "4단계: 확장 경로 검색",
        "relationship": "관계 분석: 이전에 식별된 모든 파일의 콘텐츠를 읽고 디렉토리 트리(사용 가능한 경우 선택된 루트로 범위 지정)와 함께 LLM에 제공합니다. AI는 임포트, 참조, 구조적 관계를 기반으로 추가 파일을 식별합니다.",
        "technical": "기술 세부사항: 선택된 루트 디렉토리에 대한 결합된 디렉토리 트리를 생성합니다. 모든 initial_paths 파일의 콘텐츠를 읽습니다. Cloudflare 타임아웃을 피하기 위해 스트리밍 LLM 호출을 사용합니다. 파일 시스템에 대해 발견된 경로를 검증하고 프로젝트 내 상대 경로로 정규화합니다."
      }
    },
    "stateManagement": {
      "eventDriven": {
        "description": "시스템은 워크플로우 상태 변경, 단계 완료, 오류 조건에 대한 실시간 이벤트를 게시합니다. 이러한 이벤트는 반응형 사용자 인터페이스와 외부 모니터링 시스템과의 통합을 가능하게 합니다.",
        "heading": "이벤트 기반 업데이트"
      },
      "heading": "워크플로우 상태 관리",
      "intermediateData": {
        "description": "각 단계는 디렉토리 트리 콘텐츠, 정규식 패턴, 필터링된 파일 목록 결과를 포함한 구조화된 중간 데이터 형식으로 출력을 저장합니다. 이 데이터는 디버깅에 액세스할 수 있으며 특정 단계에서 워크플로우를 재개하는 데 사용할 수 있습니다.",
        "heading": "중간 데이터 저장"
      },
      "transitions": {
        "description": "워크플로우는 명확하게 정의된 상태를 통해 진행됩니다: 생성됨 → 실행 중 → 일시 중지됨(선택사항) → 완료됨/실패함/취소됨. 각 상태 전환은 실시간 업데이트를 위해 모니터링할 수 있는 이벤트를 게시합니다.",
        "heading": "상태 전환"
      }
    },
    "visuals": {
      "pipeline": {
        "title": "파일 탐색 파이프라인",
        "description": "4단계 워크플로우: 루트 폴더 선택, 정규식 필터링, AI 관련성 평가, 확장 경로 탐색.",
        "imageSrc": "/images/docs/file-discovery/pipeline.svg",
        "caption": "4단계 모두를 보여주는 파일 탐색 파이프라인",
        "imageAlt": "4단계 파일 탐색 워크플로우를 보여주는 다이어그램: 루트 폴더 선택, 정규식 파일 필터, AI 파일 관련성 평가, 확장 경로 검색"
      }
    },
    "title": "파일 탐색 워크플로우",
    "sqliteStorage": {
      "heading": "SQLite 저장소",
      "description": "모든 워크플로우 상태, 중간 결과, 작업 메타데이터는 SQLite에 영속됩니다. 각 단계는 background_jobs 테이블에 출력을 저장하여 워크플로우 재개, 디버깅, 감사 추적이 가능합니다. 작업 레코드에는 각 AI 단계에 대한 토큰 사용량, 비용 추적, 시스템 프롬프트 템플릿이 포함됩니다."
    }
  },
  "hub": {
    "ctaDescription": "이 문서에 설명된 구현 플래너, 모델 가드레일, 터미널 세션, 전사 기능에 액세스하려면 PlanToCode를 다운로드하세요.",
    "ctaHeading": "이 워크플로우를 사용해 볼 준비가 되셨나요?",
    "ctaLinks": {
      "overview": "개요로 시작하기",
      "runtime": "런타임 워크스루"
    },
    "description": "PlanToCode로 코드 변경을 계획하고 배포하는 방법을 알아보세요: 파일 탐색, 구현 계획, 터미널 세션, 모델 가드레일, 음성.",
    "exploreHeading": "문서 탐색",
    "learnMore": "자세히 알아보기",
    "searchAriaLabel": "문서 검색",
    "searchPlaceholder": "문서 검색...",
    "searchShortcut": "⌘K",
    "title": "PlanToCode 문서"
  },
  "onThisPage": {
    "title": "이 페이지에서"
  },
  "sidebar": {
    "title": "문서"
  },
  "sections": {
    "architecture": {
      "title": "아키텍처 및 내부"
    },
    "inputs": {
      "title": "입력 및 캡처"
    },
    "planning": {
      "title": "계획 파이프라인"
    },
    "execution": {
      "title": "실행 및 자동화"
    },
    "research": {
      "title": "조사 및 모델"
    },
    "platform": {
      "title": "빌드 및 배포"
    }
  },
  "items": {
    "overview": {
      "title": "시스템 개요",
      "description": "여기서 시작: 시스템이 무엇을 하는지, 핵심 루프가 어떻게 작동하는지, 각 컴포넌트가 어디에 있는지."
    },
    "runtime-walkthrough": {
      "title": "런타임 워크스루",
      "description": "작업 입력부터 실행까지 전체 타임라인."
    },
    "architecture": {
      "title": "시스템 아키텍처",
      "description": "데스크톱 셸, Rust 서비스, 서버 API, 영속성 계층이 어떻게 함께 맞춰지는지."
    },
    "desktop-app": {
      "title": "데스크톱 앱 내부",
      "description": "Tauri v2 셸, Rust 명령 계층, PTY 세션, UI 상태 관리."
    },
    "server-api": {
      "title": "서버 API 및 LLM 프록시",
      "description": "인증, 프로바이더 라우팅, 모델 구성, WebSocket 엔드포인트."
    },
    "mobile-ios": {
      "title": "iOS 클라이언트 아키텍처",
      "description": "Swift 워크플로우, Auth0 로그인 흐름, 디바이스 링크 세션 관리."
    },
    "background-jobs": {
      "title": "백그라운드 작업 및 오케스트레이션",
      "description": "작업 레코드, 워크플로우 오케스트레이션, 프로세서, 이벤트 스트리밍."
    },
    "data-model": {
      "title": "데이터 모델 및 저장소",
      "description": "SQLite 엔티티, 관계, 상태 재수화 방법."
    },
    "decisions-tradeoffs": {
      "title": "기술 결정 및 트레이드오프",
      "description": "왜 Tauri, SQLite, 전용 LLM 프록시를 선택했으며 그 비용은 무엇인지."
    },
    "build-your-own": {
      "title": "나만의 파이프라인 구축",
      "description": "파일 탐색 및 계획 생성 워크플로우 설계를 위한 개념 가이드."
    },
    "meeting-ingestion": {
      "title": "회의 및 녹음 수집",
      "description": "녹음이 구조화된 작업 입력 및 아티팩트가 되는 방법."
    },
    "video-analysis": {
      "title": "비디오 분석",
      "description": "녹음에서 프레임 샘플링, 프롬프트, 분석 아티팩트."
    },
    "voice-transcription": {
      "title": "음성 전사",
      "description": "녹음 수명 주기, 프로젝트 인식 설정, 디바이스 관리."
    },
    "text-improvement": {
      "title": "텍스트 개선",
      "description": "선택 팝오버, 작업 큐, 프롬프트 정리를 위한 통합."
    },
    "file-discovery": {
      "title": "파일 탐색 워크플로우",
      "description": "각 작업에 대해 관련 경로를 수집하는 백그라운드 워크플로우."
    },
    "implementation-plans": {
      "title": "구현 계획",
      "description": "계획이 Monaco 뷰어로 스트리밍되고 계획 기록에 연결되는 방법."
    },
    "merge-instructions": {
      "title": "병합 지침",
      "description": "XML 태그가 지정된 소스 계획과 사용자 안내를 사용하여 여러 계획 초안을 병합하는 방법."
    },
    "prompt-types": {
      "title": "프롬프트 유형 및 템플릿",
      "description": "프롬프트 기반 작업 유형 및 템플릿 조립 카탈로그."
    },
    "terminal-sessions": {
      "title": "터미널 세션",
      "description": "영구 PTY 세션, CLI 감지, 복구 동작."
    },
    "copy-buttons": {
      "title": "복사 버튼",
      "description": "계획에서 터미널 및 외부 도구로의 템플릿 전달."
    },
    "deep-research": {
      "title": "심층 조사 및 웹 검색",
      "description": "웹 검색 워크플로우, API 통합, 쿼리 최적화, 개발 워크플로우 통합."
    },
    "provider-routing": {
      "title": "프로바이더 라우팅 및 스트리밍",
      "description": "프로바이더 요청이 어떻게 정규화, 스트리밍, 추적되는지."
    },
    "model-configuration": {
      "title": "모델 구성",
      "description": "작업별 허용 모델 및 선택기 토글의 토큰 가드레일."
    },
    "server-setup": {
      "title": "전용 서버 설정",
      "description": "Ansible 기반 인프라: 기본 강화, 앱 배포, 볼트 관리 비밀."
    },
    "tauri-v2": {
      "title": "Tauri v2 개발 가이드",
      "description": "Tauri v2를 위한 프로젝트 레이아웃, 명령, 기능 기반 권한."
    },
    "distribution-macos": {
      "title": "macOS 배포",
      "description": "서명, 공증, DMG 패키징, 업데이터 아티팩트."
    },
    "distribution-windows": {
      "title": "Windows 배포 및 스토어",
      "description": "NSIS 빌드, MSIX 패키징, Microsoft Store 제출."
    }
  },
  "implementationPlans": {
    "meta": {
      "title": "구현 계획 - AI 변경 검토",
      "description": "AI 구현 계획 가이드. 실행 전에 파일별 계획을 생성, 검토, 승인하세요. 중복 및 잘못된 경로를 방지하세요."
    },
    "category": "제품 가이드",
    "context": {
      "audit": "모든 메타데이터는 감사 목적으로 계획과 함께 유지됩니다. 기업 팀은 어떤 이해관계자가 어떤 계획을 검토했는지, 어떤 수정이 요청되었는지, 초기 작업 설명부터 파일 탐색을 거쳐 최종 승인된 계획까지의 전체 추론 체인을 추적할 수 있습니다.",
      "heading": "기업 거버넌스를 위한 컨텍스트 및 메타데이터",
      "storage": "패널은 후속 작업이 동일한 범위를 재사용할 수 있도록 파일 탐색 워크플로우 중에 선택된 저장소 루트를 저장합니다. 또한 워크플로우를 다시 계산하지 않고도 다운스트림 프롬프트를 생성하거나 복사할 수 있도록 프로젝트 디렉토리와 준비된 프롬프트 콘텐츠와 같은 계획별 메타데이터를 기록합니다.",
      "tokenEstimation": "토큰 추정은 프롬프트가 복사되기 전에 실행됩니다. 패널은 프로젝트 디렉토리, 선택된 파일, 현재 선택된 모델로 토큰 추정 명령을 호출하여 팀이 모델 제한 내에 유지할 수 있도록 시스템 및 사용자 프롬프트 합계를 모두 표시합니다."
    },
    "cta": {
      "claudeCodeLink": "Claude 계획 모드 워크플로우 보기",
      "codexLink": "Codex 계획 모드 워크플로우 보기",
      "cursorLink": "Cursor 계획 모드 워크플로우 보기",
      "description": "휴먼 인 더 루프 구현 계획은 PlanToCode 데스크톱 애플리케이션 내에서 사용할 수 있습니다. 플랫폼에 맞는 빌드를 다운로드하여 안전하고 관리되는 AI 지원 개발을 경험하세요.",
      "heading": "AI 코딩 에이전트를 안전하게 도입할 준비가 되셨나요?",
      "links": {
        "architecture": "시스템 아키텍처",
        "decisions": "결정 및 트레이드오프",
        "buildYourOwn": "나만의 파이프라인 구축",
        "fileDiscovery": "파일 탐색 워크플로우"
      }
    },
    "date": "2025-09-19",
    "description": "PlanToCode가 휴먼 인 더 루프 거버넌스, 세분화된 파일별 계획, 포괄적인 검토 워크플로우를 통해 AI 코딩 에이전트의 자신 있는 도입을 가능하게 하는 방법.",
    "fileGranularity": {
      "created": "생성됨 (완전한 파일 경로 및 초기 콘텐츠 구조 포함)",
      "declaredFiles": "계획의 각 단계는 어떤 파일이 다음과 같이 될지 명시적으로 선언합니다:",
      "deleted": "삭제됨 (정당성 및 종속성 분석 포함)",
      "heading": "파일별 세분성",
      "impact": "이 수준의 세부 사항은 코드가 변경되기 전에 제안된 변경 사항의 영향을 명확하게 합니다. 팀 리더는 중요한 레거시 코드가 수정될지, 브레이킹 체인지가 제안되었는지, 또는 계획이 추가 검토가 필요한 파일을 건드리는지 즉시 식별할 수 있습니다.",
      "intro": "구현 계획은 프로젝트의 저장소 구조에 해당하는 정확한 파일 경로와 함께 개발 작업을 파일별로 분류하는 고도로 세분화된 구조를 사용합니다. 이 세분성은 회귀를 방지하고 기업 환경에서 AI 코딩 에이전트의 자신 있는 도입을 가능하게 하는 데 기본적입니다.",
      "modified": "수정됨 (특정 줄 범위 및 변경 사항 설명 포함)",
      "referenced": "참조됨 (컨텍스트용이지만 수정되지 않음)",
      "transmission": "파일별 접근 방식은 또한 승인된 계획을 코딩 에이전트에 정확하게 전송할 수 있게 합니다. \"인증 시스템 업데이트\"와 같은 모호한 지침 대신 에이전트는 정확한 사양을 받습니다: \"토큰 로테이션을 추가하기 위해 src/auth/session_manager.rs 45-67줄 수정, 다음 구조로 src/auth/token_store.rs 생성...\""
    },
    "hitl": {
      "approve": "승인:",
      "approveDesc": "명시적 승인 후에만 계획을 선택한 코딩 에이전트 또는 지정된 소프트웨어 개발자에게 안전하게 전송하여 실행할 수 있습니다.",
      "conclusion": "이 워크플로우는 모든 개발 노력이 기업 제품 요구 사항, 팀 워크플로우, 비즈니스 목표와 일치하도록 보장합니다. 명시적 인간 승인 없이는 코드 변경이 발생하지 않습니다.",
      "edit": "편집:",
      "editDesc": "이해관계자는 VS Code 편집 기능을 사용하여 단계를 직접 수정하고, 접근 방식을 조정하고, 제약 조건을 추가하거나, 위험한 작업을 제거할 수 있습니다.",
      "heading": "휴먼 인 더 루프 거버넌스",
      "intro": "PlanToCode는 팀 리더와 이해관계자가 AI 생성 구현 계획의 모든 측면에 대해 완전한 통제력을 유지하도록 보장하는 포괄적인 휴먼 인 더 루프(HITL) 워크플로우를 구현합니다. 이 거버넌스 모델은 AI 코딩 에이전트가 자율적으로 작동할 때 발생할 수 있는 회귀, 버그, 의도하지 않은 수정을 방지합니다.",
      "reject": "거부:",
      "rejectDesc": "요구 사항을 충족하지 않는 계획은 완전히 거부할 수 있으며, 규정 준수 및 학습을 위해 전체 감사 추적이 유지됩니다.",
      "requestChanges": "변경 요청:",
      "requestChangesDesc": "팀은 AI 시스템에 수정을 요청하여 대체 접근 방식을 생성하거나 사용자 지정 지침으로 여러 계획을 병합할 수 있습니다.",
      "review": "검토:",
      "reviewDesc": "계획은 Monaco 편집기에서 열리며 검토자는 전체 구문 강조 및 전문 편집 도구로 제안된 모든 변경 사항을 검토할 수 있습니다.",
      "workflow": "모든 계획은 코드 수정이 시작되기 전에 구조화된 검토 워크플로우를 통과해야 합니다:"
    },
    "intro": "실행 전에 모든 계획을 검토하고 승인하세요. 파일별 세분성을 갖춘 휴먼 인 더 루프 거버넌스는 AI 생성 변경 사항이 기업 요구 사항 및 팀 워크플로우와 일치하도록 보장합니다.",
    "metaDescription": "AI 구현 계획 가이드. 실행 전에 파일별 계획을 생성, 검토, 승인하세요. 중복 및 잘못된 경로를 방지하세요.",
    "metaTitle": "구현 계획 - AI 변경 검토",
    "multiplePlans": {
      "description": "계획은 나중에 병합, 삭제 또는 다시 열 수 있습니다. 패널은 선택된 계획 식별자 목록을 유지하고, 계획에 연결된 터미널 출력을 위한 전용 모달을 관리하며, 검토자가 뷰어를 닫지 않고 이전 계획을 페이지할 수 있도록 탐색 도우미를 노출합니다. 터미널 액세스, 프롬프트 복사 컨트롤, 병합 지침은 모두 동일한 작업 식별자를 공유하므로 감사 기록이 일관되게 유지됩니다.",
      "heading": "여러 계획 작업"
    },
    "ogDescription": "휴먼 인 더 루프 거버넌스와 파일별 검토 워크플로우가 어떻게 코드 수정에 대한 완전한 제어와 함께 안전한 AI 개발을 보장하는지 이해하세요.",
    "ogTitle": "PlanToCode의 휴먼 인 더 루프 구현 계획",
    "plansOrigin": {
      "description": "각 계획은 현재 세션의 백그라운드 작업에 해당합니다. 패널은 계획 데이터를 구독하고, 현재 열려 있는 계획을 추적하며, 이전 작업과 새 작업 간의 탐색을 노출합니다. 이 동작은 {code} 및 주변 패널 컴포넌트 내에 있습니다.",
      "heading": "계획의 출처",
      "processor": "ImplementationPlanProcessor는 계획 생성을 처리합니다. 관련 파일을 읽고, 선택한 루트 디렉토리를 기반으로 선택적으로 디렉토리 트리를 생성하며, LLM을 위한 통합 프롬프트를 조립합니다.",
      "storage": "계획 응답은 planTitle, summary, sessionName, 토큰 사용량을 포함한 메타데이터와 함께 jobs 테이블에 저장됩니다. 원시 LLM 응답은 감사를 위해 보존됩니다.",
      "streaming": "계획은 실시간 진행 이벤트와 함께 LlmTaskRunner를 통해 스트리밍됩니다. 100k 토큰을 초과하는 프롬프트에 대해 토큰 경고가 기록되지만 처리는 전체 콘텐츠로 계속됩니다."
    },
    "readTime": "6분",
    "reviewingPlans": {
      "description": "계획 콘텐츠는 Monaco Editor를 래핑하는 공유 {code}를 통해 렌더링됩니다. 뷰어는 일반적인 언어를 자동으로 감지하고, 클립보드에 복사 작업을 지원하며, 매우 큰 계획을 가상화하고, 문자 수 및 구문 인식 강조 표시와 같은 선택적 메트릭을 제공합니다.",
      "heading": "Monaco로 계획 검토",
      "opening": "계획이 열리면 패널은 작업 식별자로 활성 계획을 확인하고, 콘텐츠를 Monaco에 전달하며, 검토자가 현재 열린 모달을 잃지 않고 인접 작업 간에 이동할 수 있도록 합니다."
    },
    "visuals": {
      "structure": {
        "title": "구현 계획 구조",
        "description": "파일별 세분성 및 메타데이터가 포함된 구현 계획의 XML 형식.",
        "imageSrc": "/images/docs/implementation-plans/structure.svg",
        "caption": "단계, 파일, 종속성 추적을 보여주는 계획 구조"
      }
    },
    "title": "구현 계획",
    "planProcessor": {
      "heading": "계획 생성 파이프라인",
      "description": "ImplementationPlanProcessor는 파일 콘텐츠를 로드하고, 컨텍스트를 구축하며, LLM 작업 러너를 통해 결과를 스트리밍하여 계획 생성을 오케스트레이션합니다.",
      "inputs": "세션 컨텍스트, 작업 설명, 선택된 관련 파일, 선택적 디렉토리 트리(include_project_structure 플래그를 통해 구성 가능), 외부 조사를 위한 웹 검색 플래그.",
      "prompt": "prompt_utils::build_unified_prompt를 사용하여 작업 설명, 전체 파일 콘텐츠(잘림 없음), 디렉토리 트리를 추정 토큰 수와 함께 모델별 형식으로 결합합니다.",
      "output": "원시 LLM 응답은 JobResultData::Text로 저장됩니다. 메타데이터에는 planTitle, summary, 토큰 사용량, 캐시 통계, 실제 비용이 포함됩니다.",
      "display": "응답은 진행 이벤트를 통해 UI로 스트리밍됩니다. 계획은 구문 강조 및 복사 작업을 지원하는 Monaco 기반 VirtualizedCodeViewer에서 렌더링됩니다."
    },
    "schema": {
      "heading": "계획 데이터 구조",
      "description": "구현 계획은 연관된 메타데이터와 함께 원시 LLM 응답으로 저장됩니다. 응답 텍스트는 생성된 그대로 정확히 보존되며, 구조화된 메타데이터는 계획 컨텍스트와 사용량을 추적합니다.",
      "fieldsHeading": "메타데이터 필드",
      "fields": [
        "planTitle - 계획의 생성된 또는 사용자 제공 제목",
        "summary - 계획의 사람이 읽을 수 있는 요약",
        "sessionName - 계획을 생성한 세션의 이름",
        "isStructured - 완료된 계획의 경우 항상 true",
        "isStreaming - 완료된 계획의 경우 false (생성 중에는 true)",
        "planData - agent_instructions(선택사항) 및 steps 배열 포함"
      ],
      "exampleHeading": "메타데이터 예제",
      "example": "{\n  \"planTitle\": \"Authentication System Refactor\",\n  \"summary\": \"Implementation plan generated\",\n  \"sessionName\": \"my-project\",\n  \"isStructured\": true,\n  \"isStreaming\": false,\n  \"planData\": {\n    \"agent_instructions\": null,\n    \"steps\": []\n  }\n}"
    }
  },
  "modelConfiguration": {
    "meta": {
      "title": "모델 구성 및 가드레일 - PlanToCode",
      "description": "PlanToCode가 작업별로 허용된 모델을 선택하고 프롬프트를 활성 컨텍스트 윈도우 내에서 유지하는 방법."
    },
    "category": "제품 가이드",
    "date": "2025-09-20",
    "description": "데스크톱 클라이언트의 작업 수준 모델 목록, 선택기 컨트롤, 토큰 가드레일.",
    "intro": "PlanToCode는 모델 선택을 작업 수준 결정으로 취급합니다. 각 워크플로우는 기본 모델과 허용 목록과 함께 제공되며, 데스크톱 클라이언트는 활성 컨텍스트 윈도우를 초과하는 프롬프트 전송을 방지하는 토글을 통해 이러한 옵션을 노출합니다.",
    "metaDescription": "PlanToCode가 작업별로 허용된 모델을 선택하고 프롬프트를 활성 컨텍스트 윈도우 내에서 유지하는 방법.",
    "metaTitle": "모델 구성 및 가드레일 - PlanToCode",
    "ogDescription": "작업 수준 모델 설정, 선택기 토글, 토큰 추정이 어떻게 함께 작동하는지 알아보세요.",
    "ogTitle": "모델 구성 및 가드레일 - PlanToCode",
    "promptEstimation": {
      "description": "토큰 수는 토큰 추정 명령을 통해 계산됩니다. 패널은 백엔드가 시스템, 사용자, 총 토큰 값을 반환할 수 있도록 세션 ID, 작업 설명, 관련 파일, 선택된 모델을 제출합니다. 이 수치는 선택기 가드레일에 직접 공급되어 팀이 다른 도구에 복사하기 전에 제한 초과 프롬프트를 발견할 수 있게 합니다.",
      "heading": "프롬프트 추정"
    },
    "readTime": "5분",
    "selectorToggle": {
      "description": "구현 계획 패널은 {code}로 허용된 모델을 렌더링합니다. 토글은 각 허용 모델을 표시하고, 활성 선택을 추적하며, 전환을 허용하기 전에 예상 프롬프트와 계획된 출력 토큰이 모델의 광고된 컨텍스트 윈도우 내에 맞는지 확인합니다.",
      "guardrails": "모델이 총 토큰 요구 사항을 지원할 수 없는 경우 토글은 버튼을 비활성화하고 계산된 초과분이 포함된 툴팁을 표시하여 검토자가 에이전트에 작업을 보내기 전에 안전한 한도 내에 있도록 합니다.",
      "heading": "클라이언트의 선택기 토글"
    },
    "taskDefaults": {
      "description": "기본 모델과 허용된 대안은 애플리케이션 구성에서 서버 측에 저장됩니다. 구현 계획, 병합, 프롬프트 생성, 음성 전사와 같은 각 작업 유형은 데스크톱 앱이 런타임에 읽는 선호 모델, 허용 옵션 목록, 토큰 제한을 정의합니다.",
      "heading": "작업 기반 기본값"
    },
    "title": "모델 구성"
  },
  "terminalSessions": {
    "meta": {
      "title": "터미널 세션 - PlanToCode",
      "description": "PlanToCode의 PTY 터미널 구현에 대한 기술 가이드. 세션 영속성, 에이전트 비활성 감지 작동 방식, 복구 메커니즘에 대해 알아보세요."
    },
    "attentionDetection": {
      "conclusion": "이 접근 방식은 에이전트가 왜 멈췄는지 추측하지 않고도 에이전트가 작업을 완료했거나 안내가 필요한 시점을 추적하는 데 도움이 됩니다. 주의 표시기는 새 출력이 수신되면 자동으로 지워집니다.",
      "heading": "에이전트 주의 감지",
      "intro": "터미널은 2단계 비활성 감지 시스템을 통해 에이전트 활동을 모니터링합니다. 에이전트가 출력 생성을 멈추면 시스템이 점진적으로 무슨 일이 일어났는지 확인하라고 알립니다:",
      "level1": "레벨 1(30초): 노란색 표시기와 함께 \"에이전트 유휴 상태 - 작업을 완료했을 수 있음\"",
      "level2": "레벨 2(2분): 빨간색 표시기 및 데스크톱 알림과 함께 \"에이전트 주의 필요 - 터미널 확인\""
    },
    "category": "제품 가이드",
    "date": "2025-09-22",
    "dependencyChecks": {
      "description": "명령을 시작하기 전에 터미널은 claude, cursor, codex, gemini와 같은 지원되는 CLI 도구의 존재를 확인합니다. 동일한 명령은 사용자가 어떤 환경이 실행될지 알 수 있도록 기본 셸도 보고합니다. 이는 필요한 바이너리를 찾을 수 없는 세션에서 시작하는 것을 방지합니다.",
      "heading": "종속성 확인"
    },
    "description": "구현 계획 터미널의 영구 PTY 세션, 에이전트 주의 감지, 복구 동작.",
    "intro": "상태 확인 및 로깅과 함께 영구 PTY에서 명령을 실행하세요. 필요할 때 음성 전사를 사용할 수 있습니다.",
    "lifecycle": {
      "description": "터미널이 열리면 UI 컴포넌트가 PTY 세션을 생성하고 버퍼링된 뷰를 통해 출력을 스트리밍합니다. 컴포넌트는 즉각적인 연결 상태를 표시하고, PTY에 키 입력을 전달하며, 세션이 실패하면 자동으로 재시도합니다. 세션 메타데이터는 타임스탬프, 종료 코드, 작업 디렉토리, 전체 출력 로그와 함께 SQLite에 저장되어 재시작 시 이전 컨텍스트를 재개할 수 있습니다.",
      "heading": "세션 수명 주기"
    },
    "metaDescription": "PlanToCode의 PTY 터미널 구현에 대한 기술 가이드. 세션 영속성, 에이전트 비활성 감지 작동 방식, 복구 메커니즘에 대해 알아보세요.",
    "metaTitle": "터미널 세션 - PlanToCode",
    "ogDescription": "계획 터미널에서 세션 영속성, 에이전트 주의 감지, 복구를 이해하세요.",
    "ogTitle": "터미널 세션 - PlanToCode",
    "readTime": "6분",
    "title": "터미널 세션",
    "voiceRecovery": {
      "heading": "음성 전사 및 복구",
      "recovery": "PTY 세션이 연결 해제되면 터미널 화면에 복구 컨트롤이 표시되고 지수 백오프로 연결을 재시도합니다. 상태 확인은 세션 상태를 계속 모니터링하고 연결 문제가 감지되면 자동 복구 작업을 제공합니다.",
      "voice": "터미널 모달 내에서 음성 전사는 음성을 캡처하여 터미널 입력 영역에 붙여넣을 수 있습니다. 녹음 훅은 프로젝트 수준 전사 설정을 조회하고, 녹음 상태를 추적하며, 인식된 텍스트를 활성 계획 세션으로 스트리밍합니다."
    }
  },
  "copyButtons": {
    "meta": {
      "title": "복사 버튼 - PlanToCode",
      "description": "템플릿 기반 복사 버튼이 계획에 대해 플레이스홀더를 확인하고 에이전트 실행을 위해 터미널 또는 클립보드에 전달하는 방법."
    },
    "category": "실행",
    "date": "2025-09-23",
    "readTime": "10분",
    "title": "복사 버튼",
    "description": "구현 계획에서 PTY 터미널 및 외부 도구로의 템플릿 기반 전달.",
    "intro": "복사 버튼은 활성 계획에 대해 템플릿 플레이스홀더를 확인한 다음 결과를 PTY 세션 또는 시스템 클립보드에 전달하여 계획과 실행을 연결합니다. 각 작업은 완전한 감사 추적을 위해 작업 메타데이터에 연결되어 팀이 에이전트에 정확히 무엇이 전송되었는지 추적할 수 있습니다.",
    "metaTitle": "복사 버튼 - PlanToCode",
    "metaDescription": "템플릿 기반 복사 버튼이 계획에 대해 플레이스홀더를 확인하고 에이전트 실행을 위해 터미널 또는 클립보드에 전달하는 방법.",
    "ogTitle": "복사 버튼 - PlanToCode",
    "ogDescription": "복사 버튼 템플릿, 플레이스홀더 확인, 터미널 전달에 대한 기술 가이드.",
    "visuals": {
      "templateFlow": {
        "title": "템플릿 확인 흐름",
        "description": "이 다이어그램은 복사 버튼 실행 파이프라인을 보여줍니다. 1단계 '버튼 클릭': 사용자가 계획 뷰어 또는 터미널 헤더에서 복사 버튼을 클릭합니다. 버튼 구성에는 레이블, 템플릿 문자열, 대상(터미널 또는 클립보드)이 포함됩니다. 2단계 '플레이스홀더 추출': 템플릿 프로세서가 {{IMPLEMENTATION_PLAN}}, {{STEP_CONTENT}}, {{TASK_DESCRIPTION}}과 같은 이중 중괄호 패턴을 스캔합니다. 3단계 '컨텍스트 확인': 리졸버가 계획 콘텐츠에 대한 작업 메타데이터를 쿼리한 다음 작업 설명 및 선택된 파일에 대한 세션 상태를 쿼리합니다. 누락된 플레이스홀더는 디버깅을 위해 출력에 보존됩니다. 4단계 '대상 전달': 터미널 대상의 경우 콘텐츠는 master.take_writer()를 통해 PTY 입력 버퍼에 기록됩니다. 클립보드 대상의 경우 콘텐츠는 Tauri 클립보드 API를 통해 복사됩니다. 토스트 알림이 콘텐츠 미리보기와 함께 작업을 확인합니다.",
        "imageSrc": "/images/docs/copy-buttons/templates.svg",
        "imageAlt": "복사 버튼 템플릿 확인을 보여주는 흐름",
        "caption": "템플릿 확인 흐름 다이어그램 플레이스홀더."
      }
    },
    "templateConfiguration": {
      "heading": "템플릿 구성 소스",
      "description": "복사 버튼 템플릿은 계층화된 구성 모델을 따릅니다. 서버 기본값은 기본 템플릿을 제공하고, 프로젝트 수준 재정의는 팀 워크플로우에 맞게 사용자 정의하며, 작업별 구성은 일회성 시나리오를 처리합니다.",
      "serverDefaults": {
        "heading": "서버 기본값",
        "description": "/api/config/desktop-runtime-config의 공유 템플릿. 버튼 레이블, 템플릿 문자열, 대상(터미널 또는 클립보드), 가시성 조건을 포함합니다."
      },
      "projectOverrides": {
        "heading": "프로젝트 재정의",
        "description": "SQLite project_settings 테이블에 저장된 템플릿. 팀 표준에 맞게 사용자 정의하기 위해 런타임에 서버 기본값과 병합됩니다."
      },
      "taskSpecific": {
        "heading": "작업별",
        "description": "특수 워크플로우를 위한 task_model_config별 템플릿. 전역 설정을 수정하지 않고 사용자 정의 전달 패턴을 활성화합니다."
      }
    },
    "placeholderResolution": {
      "heading": "플레이스홀더 확인",
      "description": "템플릿은 클릭 시 활성 계획 및 세션 컨텍스트에 대해 확인되는 이중 중괄호 플레이스홀더를 사용합니다. 주요 플레이스홀더는 {{IMPLEMENTATION_PLAN}} 및 {{TASK_DESCRIPTION}}입니다.",
      "placeholdersHeading": "사용 가능한 플레이스홀더",
      "placeholders": [
        {
          "placeholder": "{{IMPLEMENTATION_PLAN}}",
          "description": "LLM이 생성한 전체 구현 계획 콘텐츠"
        },
        {
          "placeholder": "{{TASK_DESCRIPTION}}",
          "description": "현재 세션의 작업 설명"
        }
      ],
      "resolutionOrder": "확인 순서: 먼저 작업 메타데이터, 그다음 계획 콘텐츠, 그다음 세션 컨텍스트. 정의되지 않은 플레이스홀더는 디버깅을 위해 출력에 보존됩니다.",
      "exampleTemplate": "예제 템플릿:\n\n{{IMPLEMENTATION_PLAN}}\n\n위의 구현 계획을 철저히 이해하세요. 아키텍처, 데이터 흐름, 이벤트 시퀀스를 분석하세요.\n\n작업: {{TASK_DESCRIPTION}}"
    },
    "processingPipeline": {
      "heading": "템플릿 처리 파이프라인",
      "description": "버튼을 클릭하면 템플릿 프로세서가 다단계 파이프라인을 실행합니다: 플레이스홀더 추출, 컨텍스트 조회, 값 대체, 출력 포맷팅.",
      "steps": [
        {
          "number": 1,
          "title": "플레이스홀더 추출",
          "description": "템플릿 문자열에서 {{...}} 패턴에 대한 정규식 스캔"
        },
        {
          "number": 2,
          "title": "컨텍스트 조회",
          "description": "값에 대한 작업 메타데이터, 계획 콘텐츠, 세션 상태 쿼리"
        },
        {
          "number": 3,
          "title": "값 대체",
          "description": "플레이스홀더를 확인된 값으로 대체하고 서식 유지"
        },
        {
          "number": 4,
          "title": "출력 포맷팅",
          "description": "대상별 이스케이프 적용(터미널의 경우 셸, 클립보드의 경우 일반)"
        }
      ],
      "chunking": {
        "heading": "대용량 계획 청킹",
        "description": "100KB를 초과하는 계획은 터미널 버퍼 또는 클립보드 제한 과부하를 피하기 위해 명확한 경계가 있는 순차 세그먼트로 자동 청킹됩니다. 각 청크에는 위치가 접두사로 붙습니다(예: '[Part 1/3]')."
      }
    },
    "terminalHandoff": {
      "heading": "PTY 터미널 전달",
      "description": "터미널 전달용으로 구성된 버튼은 PTY 세션 입력 버퍼에 직접 씁니다. 확인된 템플릿은 사용자가 입력한 것처럼 나타나 에이전트 실행을 즉시 트리거합니다.",
      "detailsHeading": "전달 세부사항",
      "details": [
        "master.take_writer()를 통해 PTY 입력 버퍼에 콘텐츠 기록",
        "여러 줄 입력 및 이스케이프 시퀀스 지원",
        "버퍼 오버플로를 피하기 위해 대용량 콘텐츠를 4KB 세그먼트로 청킹",
        "UI가 확인 미리보기로 처음 100자 표시"
      ],
      "codeExample": "// Terminal handoff implementation\nasync fn handoff_to_terminal(\n    session_id: &str,\n    content: &str,\n    template_id: &str,\n) -> Result<HandoffResult> {\n    // Get PTY writer for session\n    let writer = terminal_manager.get_writer(session_id)?;\n\n    // Write content to PTY input buffer\n    writer.write_all(content.as_bytes()).await?;\n\n    // Log the action for audit\n    copy_button_actions.insert(CopyButtonAction {\n        session_id: session_id.to_string(),\n        template_id: template_id.to_string(),\n        content_hash: sha256(content),\n        created_at: Utc::now(),\n    })?;\n\n    Ok(HandoffResult::Terminal { session_id })\n}"
    },
    "clipboardHandoff": {
      "heading": "클립보드 전달",
      "description": "클립보드용으로 구성된 버튼은 Tauri 클립보드 API를 사용하여 확인된 템플릿을 시스템 클립보드에 복사합니다. 이를 통해 IDE 터미널 또는 웹 기반 에이전트와 같은 외부 도구로 전달할 수 있습니다.",
      "crossPlatform": {
        "heading": "크로스 플랫폼 API",
        "description": "macOS, Windows, Linux에서 일관된 클립보드 액세스를 위해 tauri::api::clipboard::set_text()를 사용합니다."
      },
      "feedback": {
        "heading": "사용자 피드백",
        "description": "토스트 알림이 콘텐츠 미리보기와 대상 모델에 대한 토큰 수 추정치와 함께 복사를 확인합니다."
      }
    },
    "defaultButtons": {
      "heading": "기본 복사 버튼",
      "description": "PlanToCode는 일반적인 워크플로우를 다루는 여러 기본 복사 버튼과 함께 제공됩니다. 프로젝트 설정을 통해 사용자 정의하거나 확장할 수 있습니다.",
      "buttonsHeading": "내장 버튼",
      "buttons": [
        {
          "id": "parallel-agents",
          "label": "병렬 Claude 코딩 에이전트",
          "description": "동시에 실행되는 병렬 Claude 코딩 에이전트를 시작합니다. 각 에이전트는 자신의 책임에 대한 명시적 지침을 받습니다. 더 이상 사용되지 않는 기능을 완전히 제거하는 지침을 포함합니다."
        },
        {
          "id": "investigate-results",
          "label": "결과 조사",
          "description": "시작된 에이전트의 결과를 검토하고 완전한 구현을 확인합니다. 추가 에이전트를 시작하지 않고 수정된 파일을 읽고 변경 사항을 분석하여 자체 점검을 수행합니다."
        },
        {
          "id": "task-only",
          "label": "작업",
          "description": "컨텍스트를 위해 작업 설명만 복사합니다. {{TASK_DESCRIPTION}} 플레이스홀더를 사용합니다."
        },
        {
          "id": "task-and-plan",
          "label": "작업 + 계획",
          "description": "작업 설명과 구현 계획을 결합합니다. 에이전트가 목표와 실행 전략이 모두 필요할 때 전체 컨텍스트를 제공하는 데 유용합니다."
        },
        {
          "id": "plan-only",
          "label": "계획",
          "description": "구현 계획 콘텐츠만 복사합니다. 이미 작업 컨텍스트가 있고 실행 지침만 필요한 에이전트에 적합합니다."
        }
      ]
    },
    "customization": {
      "heading": "복사 버튼 사용자 정의",
      "description": "복사 버튼은 여러 수준에서 사용자 정의할 수 있습니다: 전역 기본값, 프로젝트 수준 재정의, 작업별 구성.",
      "globalDefaults": {
        "heading": "전역 기본값",
        "description": "/api/config/desktop-runtime-config의 서버 측 구성이 복사 버튼의 기본 세트를 정의합니다. 데스크톱 앱이 시작될 때 로드되고 오프라인 사용을 위해 캐시됩니다."
      },
      "projectSettings": {
        "heading": "프로젝트 수준 사용자 정의",
        "description": "각 프로젝트는 설정 패널을 통해 기본 버튼을 재정의할 수 있습니다. 프로젝트별 버튼은 SQLite에 저장되고 런타임에 서버 기본값과 병합됩니다."
      },
      "taskSettings": {
        "heading": "작업 수준 구성",
        "description": "개별 작업은 자체 복사 버튼 구성을 가질 수 있습니다. 이를 통해 구현 계획, 코드 검토, 문서 작업에 대해 다른 버튼 세트를 사용할 수 있습니다."
      },
      "editorDescription": "설정의 복사 버튼 편집기는 드래그 앤 드롭 재정렬, 인라인 레이블 편집, 템플릿 콘텐츠 수정을 허용합니다. 변경 사항은 디바운스되고 자동으로 저장됩니다."
    },
    "uiIntegration": {
      "heading": "UI 통합 및 안전",
      "description": "복사 버튼은 계획 뷰어와 터미널 헤더에 나타납니다. 각 버튼은 실행 전에 확인된 콘텐츠와 토큰 추정치가 포함된 미리보기 팝오버를 표시합니다.",
      "tokenEstimation": {
        "heading": "토큰 추정",
        "description": "토큰 추정은 검토자가 전달 전에 프롬프트가 대상 모델의 컨텍스트 윈도우에 맞는지 확인하는 데 도움이 됩니다. 미리보기와 함께 표시됩니다."
      },
      "previewModal": {
        "heading": "전체 미리보기 모달",
        "description": "미리보기 아이콘을 클릭하면 전체 확인된 템플릿, 구문 강조, 마지막 사용 이후 템플릿이 변경된 경우 차이점 보기가 포함된 모달이 열립니다."
      },
      "disabledState": {
        "heading": "비활성화 상태",
        "description": "필요한 컨텍스트가 없을 때(예: 활성 계획 없음, 세션 누락) 버튼이 비활성화됩니다. 툴팁은 버튼을 활성화하는 데 필요한 컨텍스트를 설명합니다."
      }
    },
    "auditTrail": {
      "heading": "작업 메타데이터 및 감사 추적",
      "description": "모든 복사 버튼 작업은 완전한 추적 가능성을 위해 작업 메타데이터에 연결됩니다. 감사 레코드에는 소스 계획, 대상 세션, 확인된 콘텐츠 해시, 사용자 컨텍스트가 포함됩니다.",
      "schemaHeading": "감사 스키마",
      "schema": "-- copy_button_actions table schema\nCREATE TABLE copy_button_actions (\n    action_id    TEXT PRIMARY KEY,\n    plan_id      TEXT NOT NULL REFERENCES implementation_plans(id),\n    job_id       TEXT REFERENCES background_jobs(id),\n    session_id   TEXT REFERENCES terminal_sessions(session_id),\n    template_id  TEXT NOT NULL,\n    content_hash TEXT NOT NULL,  -- SHA-256 for integrity verification\n    created_at   TEXT NOT NULL\n);\n\n-- Query to trace plan handoffs\nSELECT * FROM copy_button_actions\nWHERE plan_id = ?\nORDER BY created_at DESC;",
      "fieldsHeading": "감사 레코드 필드",
      "fields": [
        {
          "field": "action_id",
          "description": "이 전달 작업의 고유 식별자"
        },
        {
          "field": "plan_id",
          "description": "소스 구현 계획 참조"
        },
        {
          "field": "job_id",
          "description": "해당하는 경우 연관된 백그라운드 작업"
        },
        {
          "field": "session_id",
          "description": "대상 터미널 세션 또는 클립보드의 경우 null"
        },
        {
          "field": "template_id",
          "description": "사용된 템플릿 구성"
        },
        {
          "field": "content_hash",
          "description": "무결성을 위한 확인된 콘텐츠의 SHA-256"
        },
        {
          "field": "created_at",
          "description": "작업의 타임스탬프"
        }
      ],
      "retention": "보존: 감사 레코드는 기본적으로 90일 동안 유지되며 프로젝트 설정에서 구성 가능합니다."
    },
    "mobileIntegration": {
      "heading": "모바일 통합",
      "description": "복사 버튼은 일관된 동작으로 데스크톱과 모바일 클라이언트에서 작동합니다. iOS 클라이언트는 동일한 플레이스홀더 확인 로직을 사용하고 연결된 터미널로 콘텐츠를 보낼 수 있습니다.",
      "deviceLink": {
        "heading": "디바이스 링크 지원",
        "description": "모바일 디바이스가 데스크톱 세션에 연결되면 복사 버튼이 데스크톱 터미널을 직접 대상으로 할 수 있습니다. 확인된 콘텐츠는 디바이스 링크 WebSocket 연결을 통해 전송됩니다."
      },
      "mobileButtons": {
        "heading": "모바일 전용 버튼",
        "description": "모바일 클라이언트는 데스크톱과 동일한 버튼 사용자 정의를 지원합니다. 버튼 구성은 디바이스 간 일관성을 유지하기 위해 서버를 통해 동기화됩니다."
      }
    },
    "cta": {
      "heading": "실행으로의 전달 추적",
      "description": "터미널 세션은 복사 버튼 출력이 어디에 도착하고 어떻게 기록되는지 보여줍니다.",
      "terminalLink": "터미널 세션",
      "plansLink": "구현 계획"
    }
  },
  "textImprovement": {
    "meta": {
      "title": "Text improvement - PlanToCode",
      "description": "How the desktop workspace rewrites highlighted text, preserves formatting, and links the feature to voice and video inputs."
    },
    "category": "Product Guide",
    "cta": {
      "description": "Download PlanToCode to combine voice capture, video context, and inline rewriting before you generate implementation plans.",
      "heading": "Try text improvement in the desktop app",
      "links": {
        "architecture": "Architecture overview",
        "buildYourOwn": "Build your own"
      }
    },
    "date": "2025-09-21",
    "description": "How PlanToCode rewrites highlighted text without changing formatting and links the result back to your workspace.",
    "intro": "Refine text with AI context. Select text in any editor, trigger a background job, and get improved content that keeps your formatting intact.",
    "metaDescription": "How the desktop workspace rewrites highlighted text, preserves formatting, and links the feature to voice and video inputs.",
    "metaTitle": "Text improvement - PlanToCode",
    "ogDescription": "Understand the selection popover, job queue, model configuration, and integrations that power text improvement.",
    "ogTitle": "Text improvement - PlanToCode",
    "readTime": "7 min",
    "selectionPopover": {
      "component": "The popover itself is a minimal component rendered by {code}, which simply triggers the provider hook and shows a loading indicator while a rewrite is running. Because the provider registers global listeners, the popover appears in Monaco plan viewers, the plan terminal dictation field, and any task description inputs without extra wiring.",
      "heading": "Selection popover behaviour",
      "provider": "The {code} listens for selection events on standard inputs and Monaco editors. When you highlight non-empty text it positions a popover near the cursor, stores the selected range, and tracks whether the popover should be visible. Clicking the button kicks off the job and disables the control until the result returns. When the job completes the provider applies the improved text back into the same selection and flushes any pending saves to keep session state in sync."
    },
    "title": "Text Improvement",
    "triggerImprovement": {
      "action": "Pressing the popover button calls {code}. The action validates the selection, ensures a session identifier exists, and invokes the Rust command {code} via Tauri. The command builds a {code} containing the original text and queues a background job against the active session.",
      "backend": "On the backend, the {code} resolves the configured model for the {code} task, wraps the selection in XML tags, and runs the request through the {code} without streaming. When the model response returns it records token usage, cost, and the system prompt template before emitting the improved text back to the UI. The default configuration ships with Claude Sonnet 4.5 and Gemini 3 Pro as the approved models, capped at 4,096 tokens with a temperature of 0.7.",
      "heading": "What happens when you trigger an improvement",
      "metadata": "The background jobs sidebar records the original text in job metadata, so you can review what was sent alongside the rewritten copy. If the selection changes while a job is running, the provider skips replacing the text to avoid clobbering manual edits."
    },
    "videoCapture": {
      "dialog": "Screen recordings pass through the video analysis dialog, which combines your current task description with an optional prompt block wrapped in semantic XML tags before sending the request to the Gemini video analysis job. Any notes you dictate during the recording are available as text once analysis completes, so you can feed the resulting summary back through the improvement popover to tighten the instructions before planning.",
      "features": "Video jobs include frame-rate controls, audio capture toggles, and cost reporting. Results appear in the same background jobs sidebar as text improvements, keeping all prompt preparation artefacts in one place.",
      "heading": "Video capture and prompt scaffolding"
    },
    "voiceIntegration": {
      "heading": "Voice transcription integration",
      "hook": "Voice recordings use the {code} hook. It loads per-project transcription defaults, requests microphone access, and inserts transcripts at the cursor inside the task description or terminal dictation buffer. The inserted text can immediately be highlighted and passed through the same improvement popover, and the original transcription job identifier is stored with the improvement payload for auditing.",
      "preferences": "Language, model, and temperature preferences persist at the project level, so teams get consistent transcription quality before refining the copy. Silence detection warns about bad audio levels, and a ten-minute cap prevents oversized recordings from blocking improvement jobs with large payloads."
    },
    "visuals": {
      "popoverFlow": {
        "title": "Text improvement flow",
        "description": "Selection popover triggers improvement job and returns enhanced text.",
        "imageSrc": "/images/docs/text-improvement/flow.svg",
        "imageAlt": "Text improvement flow diagram"
      }
    },
    "processorDetails": {
      "heading": "Processor implementation details",
      "processor": "The {code} handles the text rewriting workflow on the Rust backend.",
      "stepsHeading": "Processing steps",
      "steps": [
        "Parse the incoming payload with original text and selection metadata",
        "Build the system prompt from the configured text_improvement template",
        "Submit the request to the LLM task runner without streaming",
        "Extract the improved text from the model response",
        "Record token usage, cost, and prompt template for billing",
        "Emit the result back to the UI via Tauri events"
      ]
    },
    "inlineRewriting": {
      "heading": "Inline rewriting behaviour",
      "description": "When the improved text returns, the provider automatically replaces the original selection. The rewriting preserves whitespace, line breaks, and any inline formatting present in the source. If the editor is Monaco-based, the change is applied as a single undo-able edit operation.",
      "contextsHeading": "Supported contexts",
      "contexts": [
        "Task description input fields",
        "Plan terminal dictation area",
        "Monaco plan viewers and editors",
        "Any standard HTML input or textarea"
      ]
    },
    "modelConfiguration": {
      "heading": "Model configuration",
      "description": "Text improvement uses the text_improvement task configuration from the desktop runtime config. You can override the default model and parameters in the settings panel.",
      "settingsHeading": "Configurable settings",
      "settings": [
        "Allowed models list (default: Claude Sonnet 4.5, Gemini 3 Pro)",
        "Maximum token limit (default: 4096)",
        "Temperature setting (default: 0.7)",
        "System prompt template override"
      ]
    },
    "keyFiles": {
      "heading": "Key implementation files",
      "items": [
        "desktop/src/contexts/TextImprovementProvider.tsx",
        "desktop/src/components/TextImprovementPopover.tsx",
        "desktop/src/actions/text-improvement/index.ts",
        "desktop/src-tauri/src/jobs/processors/text_improvement.rs",
        "server/src/config/task_model_config.rs"
      ]
    }
  },
  "voiceTranscription": {
    "meta": {
      "title": "음성 전사 - PlanToCode",
      "description": "PlanToCode가 오디오를 녹음하고, gpt-4o-transcribe를 사용하여 실시간 전사를 스트리밍하고, 권한 및 프로젝트 설정을 관리하는 방법."
    },
    "category": "제품 가이드",
    "date": "2025-09-22",
    "description": "음성 기반 프롬프트를 위한 녹음 수명 주기, 디바이스 관리, 스트리밍 동작.",
    "deviceManagement": {
      "description": "이 기능은 마이크 권한을 요청하고, 사용 가능한 오디오 입력을 열거하며, 사용자가 세션 중에 디바이스를 전환할 수 있게 합니다. 오디오 레벨은 실시간으로 모니터링되어 마이크가 음소거되거나 연결이 끊어지면 UI가 무음 경고를 표시할 수 있습니다.",
      "heading": "디바이스 관리",
      "monitoring": "실시간 오디오 레벨 모니터링은 녹음 중에 시각적 피드백을 표시합니다. 시스템은 무음 기간을 감지하고 마이크가 음소거되거나 연결이 끊어진 것처럼 보이면 사용자에게 경고하여 오디오가 전사를 위해 전송되기 전에 실패한 녹음을 방지합니다."
    },
    "intro": "음성 전사는 계획 터미널 및 프롬프트 편집기를 포함하여 데스크톱 앱이 받아쓰기 컨트롤을 노출하는 모든 곳에서 사용할 수 있습니다. 이 기능은 오디오를 로컬로 녹음하고, 전사 서비스에 청크를 보내며, 수동 입력을 차단하지 않고 활성 입력 필드에 인식된 텍스트를 삽입합니다.",
    "metaDescription": "PlanToCode가 오디오를 녹음하고, gpt-4o-transcribe를 사용하여 실시간 전사를 스트리밍하고, 권한 및 프로젝트 설정을 관리하는 방법.",
    "metaTitle": "음성 전사 - PlanToCode",
    "ogDescription": "녹음 훅이 디바이스, 권한, 스트리밍 텍스트를 관리하는 방법을 알아보세요.",
    "ogTitle": "음성 전사 - PlanToCode",
    "projectSettings": {
      "description": "녹음 세션이 시작되면 훅은 활성 프로젝트의 전사 구성을 조회합니다. 녹음이 프로젝트의 기본 설정을 따르도록 오디오를 캡처하기 전에 언어 코드, 선호 모델, 기타 설정이 검색됩니다.",
      "heading": "프로젝트 인식 설정",
      "storage": "프로젝트별 전사 기본 설정은 SQLite에 저장되며 선호 모델(gpt-4o-transcribe 또는 gpt-4o-mini-transcribe), 언어 코드, 온도 설정을 포함합니다. 이러한 기본 설정은 세션 간에 유지되고 청구 목적으로 서버와 동기화됩니다."
    },
    "readTime": "5분",
    "recordingWorkflow": {
      "description": "녹음 훅은 유휴, 녹음, 처리, 오류 상태가 있는 상태 머신을 유지합니다. 기간을 추적하고, 무음 감지를 관리하며, 10분 후에 녹음이 자동으로 중지되도록 합니다. 청크는 버퍼링되어 삽입을 위한 인식된 텍스트를 반환하는 전사 작업으로 전달됩니다.",
      "heading": "녹음 워크플로우",
      "statesHeading": "녹음 상태",
      "states": [
        "idle: 진행 중인 녹음 없음, 마이크 권한이 부여되었거나 부여되지 않았을 수 있음",
        "recording: MediaRecorder를 통해 오디오를 적극적으로 캡처 중, 기간 추적, 시각적 피드백 표시",
        "processing: 오디오 청크가 서버로 전송됨, gpt-4o-transcribe의 전사 응답 대기 중",
        "error: 권한 거부, 디바이스 연결 해제, 또는 전사 API 오류로 인해 녹음 실패"
      ]
    },
    "routingBehavior": {
      "heading": "다중 대상 라우팅",
      "description": "전사된 텍스트는 활성 컨텍스트에 따라 여러 대상으로 라우팅될 수 있습니다. insertTranscript 콜백은 결합 없이 유연한 라우팅을 가능하게 합니다. 라우팅 대상은 감사 추적을 위해 작업 메타데이터에 저장됩니다.",
      "destinations": [
        "작업 설명 편집기: 선택적 즉시 text_improvement 정제와 함께 커서 삽입",
        "터미널 받아쓰기 버퍼: 명령 실행(예: PTY에 'run npm test' 입력)",
        "회의 메모 모드: task_refinement가 실행 가능한 작업을 생성하여 축적된 버퍼가 SQLite에 자동 저장",
        "프롬프트 편집기: 애플리케이션 전체의 모든 텍스트 입력 필드에 직접 삽입"
      ]
    },
    "pipeline": {
      "heading": "전사 파이프라인",
      "hook": "{code} React 훅은 완전한 녹음 수명 주기를 관리합니다. Opus 코덱이 있는 WebM 형식으로 오디오 캡처를 위해 {code}를 초기화하고, 오디오 레벨을 모니터링하며, 디바이스 전환을 처리합니다.",
      "command": "데스크톱 앱은 서버 엔드포인트 {code}에 오디오 데이터를 보내기 위해 {code}를 호출합니다. 명령은 오디오 크기(최소 1KB, 최대 25MB), 기간, 온도(0.0-1.0), 프롬프트 길이(최대 1000자)를 검증합니다.",
      "constraints": "오디오 파일은 1KB에서 25MB 사이여야 합니다. 지원 형식: WAV, MP3, M4A, OGG, WebM, FLAC, AAC, MP4. 전사 모델은 명시적으로 지정해야 합니다 - 지원 모델은 OpenAI의 gpt-4o-transcribe 및 gpt-4o-mini-transcribe입니다."
    },
    "serverProcessing": {
      "heading": "서버 측 처리",
      "endpoint": "서버는 멀티파트 폼 데이터를 허용하는 {code}를 노출합니다. 모델의 프로바이더 구성에 따라 요청을 OpenAI 또는 Google로 라우팅하고, 사용자 크레딧을 검증하며, 오디오 기간을 기반으로 청구를 계산합니다.",
      "parametersHeading": "요청 매개변수",
      "parameters": [
        "file: 오디오 파일 데이터(필수) - WAV, MP3, M4A, OGG, WebM, FLAC, AAC, 또는 MP4",
        "model: 전사 모델 ID(필수) - openai/gpt-4o-transcribe 또는 openai/gpt-4o-mini-transcribe",
        "duration_ms: 밀리초 단위 녹음 기간(청구 계산에 필수)",
        "language: ISO 639-1 언어 코드(선택사항) - 특정 언어에 대한 정확도 향상",
        "prompt: 전사용 컨텍스트 힌트(선택사항, 최대 1000자) - 도메인별 어휘에 도움",
        "temperature: 샘플링 온도 0.0-1.0(선택사항, 기본값 0.0) - 낮은 값은 더 결정적인 출력을 생성"
      ]
    },
    "dataFlow": {
      "heading": "데이터 흐름",
      "description": "오디오 데이터는 브라우저에서 Tauri 명령 계층을 통해 서버로 흐르며, 서버는 적절한 전사 프로바이더로 요청을 프록시합니다.",
      "stepsHeading": "처리 단계",
      "steps": [
        "브라우저 MediaRecorder가 WebM/Opus 형식으로 오디오 청크를 캡처",
        "useVoiceTranscription 훅이 청크를 버퍼링하고 기간을 모니터링",
        "중지 시 오디오 blob이 바이트로 변환되어 transcribe_audio_command를 통해 전송",
        "Tauri 명령이 오디오 크기, 기간, 매개변수를 검증",
        "인증 토큰과 함께 서버 /api/audio/transcriptions 엔드포인트로 요청 전송",
        "서버가 사용자 크레딧을 검증하고 OpenAI 또는 Google 프로바이더로 라우팅",
        "프로바이더가 전사된 텍스트를 반환, 서버가 사용량을 기록하고 크레딧을 차감",
        "전사된 텍스트가 데스크톱으로 반환되어 콜백을 통해 삽입"
      ]
    },
    "keyFiles": {
      "heading": "주요 구현 파일",
      "items": [
        "desktop/src/hooks/useVoiceTranscription.ts",
        "desktop/src-tauri/src/commands/audio_commands.rs",
        "server/src/handlers/proxy/specialized/transcription.rs",
        "server/src/clients/openai/transcription.rs",
        "server/src/clients/google/transcription.rs"
      ]
    },
    "examples": {
      "heading": "사용 예제",
      "description": "일반적인 음성 전사 워크플로우는 시스템의 유연성을 보여줍니다:",
      "items": [
        "스프린트 계획: 작업 설명 생성을 위해 task_refinement로 파이프되는 전사가 포함된 회의 녹음",
        "터미널 명령: 받아쓰기가 전사되어 실행을 위해 PTY에 직접 입력",
        "버그 보고서: 구두 설명이 캡처되고, text_improvement로 정제된 후 task_refinement에 의해 처리",
        "아키텍처 논의: 비전 분석과 결합된 전사를 위해 오디오 트랙이 추출된 비디오 녹화"
      ]
    },
    "cta": {
      "heading": "계속 탐색하기",
      "description": "전사된 텍스트를 정제하는 방법과 회의 녹음을 실행 가능한 작업으로 처리하는 방법을 알아보세요.",
      "links": {
        "textImprovement": "텍스트 개선",
        "meetingIngestion": "회의 수집"
      }
    },
    "title": "음성 전사",
    "visuals": {
      "recordingFlow": {
        "title": "음성 전사 파이프라인",
        "description": "오디오 캡처, GPT-4o 전사 처리, 텍스트 라우팅 흐름.",
        "imageSrc": "/images/docs/voice-transcription/pipeline.svg",
        "imageAlt": "음성 전사 파이프라인 다이어그램",
        "caption": "오디오는 브라우저 캡처에서 Tauri 명령을 거쳐 서버 측 GPT-4o 전사로 흐릅니다."
      }
    }
  },
  "overview": {
    "meta": {
      "title": "시스템 개요 - PlanToCode",
      "description": "여기서 시작: PlanToCode가 무엇을 하는지, 핵심 루프가 어떻게 작동하는지, 각 컴포넌트가 저장소의 어디에 있는지."
    },
    "category": "개요",
    "date": "2025-09-25",
    "readTime": "15분",
    "title": "시스템 개요",
    "description": "시스템, 핵심 루프, 필수 종속성에 대한 간결한 맵.",
    "intro": "PlanToCode는 실행 전에 코드 변경을 계획하고 검증하는 데스크톱 워크스페이스입니다. 로컬 Rust 작업 엔진, React UI, LLM 호출을 위한 서버 프록시를 조정합니다. 시스템은 오프라인 우선 아키텍처를 따르며 데스크톱 앱은 로컬 상태를 위해 SQLite를 사용하여 독립적으로 작동하고, 서버는 인증, LLM 프로바이더 라우팅, 청구를 처리합니다. API 키로 구성된 외부 LLM 프로바이더가 없으면 계획 및 분석 파이프라인이 실행되지 않습니다.",
    "visuals": {
      "systemMap": {
        "title": "시스템 맵",
        "description": "데스크톱 앱, Rust 코어, 로컬 SQLite 저장소, 서버 프록시의 맵.",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "PlanToCode 시스템 맵 다이어그램",
        "caption": "데이터가 아래로 흐르고 이벤트가 위로 스트리밍되는 4계층 아키텍처."
      }
    },
    "systemLayers": {
      "heading": "시스템 계층",
      "description": "시스템은 잘 정의된 인터페이스를 통해 통신하는 네 개의 별개 계층으로 구성됩니다:",
      "items": [
        "프레젠테이션 계층: Monaco 편집기, 터미널 패널, 워크플로우 컨트롤이 있는 React UI (desktop/src/)",
        "명령 계층: IPC 및 상태 관리를 처리하는 React와 Rust를 연결하는 Tauri 명령 (desktop/src-tauri/src/commands/)",
        "처리 계층: Rust의 작업 프로세서, 워크플로우 오케스트레이터, 비즈니스 로직 (desktop/src-tauri/src/jobs/)",
        "영속성 계층: 로컬 상태를 위한 SQLite 저장소 및 인증/청구를 위한 서버 PostgreSQL (desktop/src-tauri/src/db_utils/)"
      ]
    },
    "coreLoop": {
      "heading": "실제 핵심 루프",
      "description": "모든 작업은 캡처부터 실행까지 잘 정의된 수명 주기를 통해 흐릅니다:",
      "steps": [
        "텍스트, 음성 전사(useVoiceTranscription 훅을 통해), 또는 비디오 녹화 분석에서 작업을 캡처합니다.",
        "TextImprovementProcessor를 통해 text_improvement 작업으로 작업 설명과 목표를 정제합니다.",
        "파일 탐색 워크플로우를 실행합니다: RootFolderSelectionProcessor가 디렉토리를 선택하고, RegexFileFilterProcessor가 패턴을 적용하고, FileRelevanceAssessmentProcessor가 콘텐츠에 점수를 매기고, ExtendedPathFinderProcessor가 컨텍스트를 확장합니다.",
        "ImplementationPlanProcessor를 통해 구현 계획을 생성합니다. 이는 XML 형식의 계획을 Monaco 뷰어로 스트리밍합니다.",
        "선택적으로 XML 태그가 지정된 소스 계획을 사용하여 ImplementationPlanMergeProcessor로 여러 계획 초안을 병합합니다.",
        "PTY 터미널 세션 또는 외부 에이전트용 복사 버튼 템플릿을 통해 승인된 계획을 실행하거나 내보냅니다.",
        "감사 가능성을 위해 모든 작업, 아티팩트, 터미널 로그를 SQLite(background_jobs, terminal_sessions 테이블)에 영속합니다."
      ]
    },
    "components": {
      "heading": "주요 컴포넌트",
      "description": "각 컴포넌트에는 특정 책임이 있으며 타입이 지정된 인터페이스를 통해 통신합니다:",
      "items": [
        "desktop/src/의 데스크톱 UI(React), Monaco 계획 뷰, 터미널 패널, 프로바이더(SessionProvider, TextImprovementProvider) 포함.",
        "desktop/src-tauri/의 Rust 코어(Tauri v2), 기능 기반 권한으로 명령, 작업, 영속성 처리.",
        "desktop/src-tauri/migrations/consolidated_schema.sql의 로컬 SQLite 스키마, 동시 액세스를 위한 WAL 모드.",
        "server/src/의 서버 프록시(Actix-Web), 인증, 프로바이더 라우팅, 스트리밍 응답, Stripe를 통한 청구.",
        "mobile/ios/Core/의 모바일 iOS 클라이언트, SwiftUI 인터페이스, Auth0 PKCE, WebSocket 디바이스 링크.",
        "infrastructure/ansible/의 인프라 자동화, Hetzner(EU) 및 InterServer(US) 전용 서버용."
      ]
    },
    "dependencies": {
      "heading": "필수 종속성",
      "description": "시스템에는 다음 외부 서비스 및 리소스가 필요합니다:",
      "items": [
        "계획 생성, 전사, 분석을 위한 외부 LLM 프로바이더(OpenAI, Anthropic, Google, X.AI, OpenRouter).",
        "데스크톱 및 모바일 세션을 위한 PKCE 흐름이 있는 Auth0 기반 인증.",
        "서버 측 사용자 계정, 청구 상태, 작업 큐를 위한 PostgreSQL 17 및 Redis 7+(자체 호스팅 배포).",
        "파일 탐색 워크플로우를 위한 git ls-files 또는 디렉토리 탐색을 통한 로컬 파일 시스템 액세스.",
        "음성 입력 처리를 위한 Whisper 호환 전사 엔드포인트."
      ]
    },
    "codeMap": {
      "heading": "저장소에서 동작이 있는 위치",
      "description": "주요 디렉토리 및 파일에 대한 빠른 참조:",
      "items": [
        "Tauri 명령: desktop/src-tauri/src/commands/ (35개 이상의 명령 모듈: job_commands.rs, workflow_commands.rs, terminal_commands.rs, session_commands.rs, auth0_commands.rs)",
        "워크플로우 오케스트레이션: desktop/src-tauri/src/jobs/workflow_orchestrator/ (definition_loader.rs, stage_scheduler.rs, event_emitter.rs, payload_builder.rs)",
        "작업 프로세서: desktop/src-tauri/src/jobs/processors/ (implementation_plan_processor.rs, text_improvement_processor.rs, root_folder_selection_processor.rs)",
        "SQLite 저장소: desktop/src-tauri/src/db_utils/ (background_job_repository/, session_repository.rs, terminal_repository.rs)",
        "서버 라우트: server/src/routes.rs (configure_routes, configure_public_auth_routes, configure_webhook_routes)",
        "LLM 프록시 핸들러: server/src/handlers/proxy_handlers.rs 및 server/src/handlers/proxy/ (router.rs, providers/)",
        "프로바이더 트랜스포머: server/src/handlers/provider_transformers/ (openai.rs, google.rs, anthropic.rs, xai.rs)",
        "iOS 워크플로우: mobile/ios/Core/Sources/Workflows/WorkflowManager.swift, MobileSessionManager 및 APIClient 포함",
        "인프라 플레이북: infrastructure/ansible/site-base.yml (강화, PostgreSQL, Redis) 및 site-app.yml (배포)"
      ]
    },
    "keyAbstractions": {
      "heading": "주요 추상화",
      "description": "이러한 핵심 개념을 이해하면 코드베이스를 탐색하는 데 도움이 됩니다:",
      "items": [
        "세션: task_description, included_files, 모델 기본 설정과 함께 sessions 테이블에 저장된 프로젝트 컨텍스트. UUID로 식별됨.",
        "백그라운드 작업: task_type, 프롬프트, 응답, 토큰 추적, 비용과 함께 background_jobs 테이블에 저장된 LLM 지원 작업.",
        "워크플로우: IntermediateData가 단계 간에 전달되는 WorkflowOrchestrator에 의해 조정되는 다단계 오케스트레이션 프로세스(예: file_finder_workflow).",
        "터미널 세션: output_log, 상태, 감사를 위한 선택적 job_id 링크와 함께 terminal_sessions에 저장된 PTY 프로세스.",
        "프로바이더: 요청 변환 및 응답 정규화가 있는 server/src/handlers/proxy/providers/의 LLM 서비스 추상화."
      ]
    },
    "dataFlowSummary": {
      "heading": "데이터 흐름 요약",
      "description": "일반적인 계획 작업에서 시스템을 통해 데이터가 이동하는 방법:",
      "items": [
        "사용자 입력은 React 컴포넌트를 통해 들어와 @tauri-apps/api/core invoke()를 통해 Tauri 명령으로 흐릅니다.",
        "명령은 background_jobs 레코드를 생성하고 작업 큐를 통해 작업 프로세서로 디스패치합니다.",
        "프로세서는 프롬프트를 빌드하고, 서버 LLM 프록시를 통해 요청을 보내며, Tauri 이벤트를 통해 응답을 스트리밍합니다.",
        "응답은 SQLite에 저장되고 UI 상태를 업데이트하는 React 프로바이더로 전송됩니다.",
        "터미널 실행은 PTY 출력을 UI로 스트리밍하고 세션 복구를 위해 로그를 영속합니다."
      ]
    }
  },
  "runtimeWalkthrough": {
    "meta": {
      "title": "런타임 워크스루 - PlanToCode",
      "description": "입력에서 계획 출력까지 작업의 전체 타임라인, 작업 유형 및 아티팩트 흐름 포함."
    },
    "category": "아키텍처",
    "date": "2025-09-25",
    "readTime": "12분",
    "title": "런타임 워크스루",
    "description": "작업 입력에서 계획 출력까지의 전체 런타임 타임라인.",
    "intro": "이 워크스루는 초기 캡처부터 파일 탐색, 계획 생성, 터미널 실행까지 단일 작업을 추적합니다. 각 단계는 특정 작업 유형에 매핑되며 SQLite에 저장되는 아티팩트를 생성합니다.",
    "visuals": {
      "timeline": {
        "title": "런타임 타임라인",
        "description": "작업 입력, 워크플로우 단계, 계획 출력을 보여주는 시각적 타임라인.",
        "imageSrc": "/images/docs/runtime-walkthrough/timeline.svg",
        "imageAlt": "런타임 타임라인 다이어그램",
        "caption": "작업 실행은 6단계를 거치며, 모든 아티팩트는 SQLite에 영속됩니다."
      },
      "walkthroughVideo": {
        "title": "런타임 워크스루 비디오",
        "description": "입력에서 계획 출력까지 전체 작업 실행의 비디오 데모.",
        "videoSrc": "",
        "posterSrc": "",
        "caption": "비디오 워크스루 플레이스홀더 - 전체 계획 워크플로우 데모를 녹화하세요."
      }
    },
    "timeline": {
      "heading": "상위 레벨 런타임 시퀀스",
      "description": "완전한 작업 실행은 다음 작업 시퀀스를 따릅니다:",
      "steps": [
        "사용자가 TaskDescriptionEditor 컴포넌트를 통해 데스크톱 UI에서 작업 설명을 입력하거나 받아씁니다.",
        "선택 사항: text_improvement 작업이 TextImprovementProcessor를 통해 원시 입력을 다듬습니다.",
        "사용자가 구현 계획 패널 start_file_finder_workflow 명령을 통해 파일 탐색 워크플로우를 트리거합니다.",
        "desktop/src-tauri/src/jobs/workflow_orchestrator/의 WorkflowOrchestrator가 워크플로우 레코드를 생성하고 1단계를 예약합니다.",
        "1단계 (root_folder_selection): RootFolderSelectionProcessor가 디렉토리 트리를 LLM에 보내고 선택된 루트를 IntermediateData.selectedRoots에 저장합니다.",
        "2단계 (regex_file_filter): RegexFileFilterProcessor가 패턴을 생성하고, git ls-files를 실행하고, 매치를 IntermediateData.locallyFilteredFiles에 저장합니다.",
        "3단계 (file_relevance_assessment): FileRelevanceAssessmentProcessor가 파일 내용을 청크하고, 관련성을 점수화하고, IntermediateData.aiFilteredFiles에 저장합니다.",
        "4단계 (extended_path_finder): ExtendedPathFinderProcessor가 임포트와 의존성으로 컨텍스트를 확장하고 IntermediateData.verifiedPaths에 저장합니다.",
        "UI가 event_emitter.rs를 통해 workflow-completed 이벤트를 받고 파일 선택 표시를 업데이트합니다.",
        "사용자가 generate_implementation_plan 명령으로 선택된 파일로 계획 생성을 트리거합니다.",
        "desktop/src-tauri/src/jobs/processors/implementation_plan_processor.rs의 ImplementationPlanProcessor가 job:stream-progress 이벤트를 통해 XML 계획 내용을 Monaco 뷰어로 스트리밍합니다.",
        "사용자가 VirtualizedCodeViewer 컴포넌트에서 계획을 검토하고, 직접 편집하거나 병합을 요청할 수 있습니다.",
        "승인된 계획은 복사 버튼 템플릿을 통해 터미널로 복사되거나 외부 에이전트용으로 내보내집니다.",
        "terminal_commands.rs의 터미널 세션이 PTY 출력을 캡처하고 에이전트 주의 상태를 감지합니다.",
        "모든 아티팩트는 감사 및 세션 복구를 위해 SQLite background_jobs 및 terminal_sessions 테이블에 영속됩니다."
      ]
    },
    "jobTypes": {
      "heading": "런타임의 작업 유형",
      "description": "각 task_type은 특정 프로세서에 매핑되며 고유한 아티팩트를 생성합니다:",
      "items": [
        "text_improvement: TextImprovementProcessor가 텍스트를 XML로 래핑하고, LLM에 전송하고, 다듬어진 텍스트를 반환합니다. background_jobs.response에 저장됩니다.",
        "root_folder_selection: RootFolderSelectionProcessor가 디렉토리 트리를 받고 선택된 디렉토리의 JSON 배열을 반환합니다.",
        "regex_file_filter: RegexFileFilterProcessor가 작업 설명에서 패턴을 생성하고 git 파일 목록에 적용합니다.",
        "file_relevance_assessment: FileRelevanceAssessmentProcessor가 파일 내용을 로드하고, 토큰 한도로 청크하고, 관련성을 점수화합니다.",
        "extended_path_finder: ExtendedPathFinderProcessor가 임포트/의존성을 분석하고 관련 파일로 컨텍스트를 확장합니다.",
        "implementation_plan: ImplementationPlanProcessor가 plan_step 요소가 포함된 XML 형식 계획을 스트리밍합니다.",
        "implementation_plan_merge: ImplementationPlanMergeProcessor가 source_plans XML 태그와 사용자 지시를 사용하여 계획을 결합합니다.",
        "video_analysis: /api/llm/video/analyze 엔드포인트를 통해 프레임 샘플링으로 화면 녹화를 처리합니다.",
        "web_search_prompts_generation: 심층 조사 워크플로우를 위한 research_task XML 블록을 생성합니다.",
        "web_search_execution: 조사 프롬프트를 병렬로 실행하고 결과를 집계합니다."
      ]
    },
    "inputCapture": {
      "heading": "작업 입력 캡처",
      "description": "작업은 여러 입력 표면을 통해 시스템에 들어옵니다:",
      "text": "작업 설명은 TaskDescriptionEditor에 입력하거나 붙여넣고 sessions.task_description에 영속되며 멀티 디바이스 동기화를 위해 device_id와 함께 task_description_history 테이블에 히스토리 항목을 생성합니다.",
      "voice": "음성 입력은 MediaRecorder API를 통해 녹음하고 /api/audio/transcriptions로 전송하고 커서 위치에 삽입하는 useVoiceTranscription 훅을 사용합니다.",
      "video": "비디오 분석은 VideoAnalysisDialog를 사용하여 화면 녹화를 캡처하고 /api/llm/video/analyze에 업로드하고 UI 상태 관찰을 추출합니다."
    },
    "workflowExecution": {
      "heading": "워크플로우 실행 세부사항",
      "description": "WorkflowOrchestrator가 다단계 워크플로우를 조정합니다:",
      "scheduling": "workflow_lifecycle_manager.rs가 워크플로우 레코드를 생성하고 stage_scheduler.rs가 워크플로우 JSON 정의에 따라 순차적으로 단계를 디스패치합니다.",
      "data": "workflow_types.rs의 IntermediateData 구조가 단계 간에 출력을 전달합니다: selectedRoots, rawRegexPatterns, locallyFilteredFiles, aiFilteredFiles, verifiedPaths.",
      "events": "event_emitter.rs가 React UI의 WorkflowTracker가 소비하는 workflow-status 및 workflow-stage Tauri 이벤트를 게시합니다."
    },
    "persistence": {
      "heading": "상태 영속",
      "description": "모든 아티팩트는 감사 및 복구를 위해 영속됩니다:",
      "jobs": "background_job_repository/가 session_id, task_type, status, prompt, response, tokens_sent/received, actual_cost와 함께 작업 레코드를 저장합니다.",
      "sessions": "session_repository.rs가 task_description, included_files, model_used, 히스토리 버전과 함께 sessions 테이블을 관리합니다.",
      "terminals": "terminal_repository.rs가 세션 복구를 위해 output_log, status, exit_code, working_directory와 함께 terminal_sessions를 영속합니다.",
      "rehydration": "앱 재시작 시 Rust 코어가 SQLite에서 세션 상태를 재수화하고, 오래된 실행 중인 작업을 실패로 표시하고, 터미널 출력 로그를 복원합니다."
    },
    "inputs": {
      "heading": "작업 입력 캡처",
      "capture": "작업은 여러 입력 표면을 통해 시스템에 들어옵니다: TaskDescriptionEditor의 입력된 텍스트, useVoiceTranscription 훅을 통한 음성 받아쓰기, VideoAnalysisDialog를 통한 비디오 분석.",
      "artifacts": "각 입력 유형은 SQLite에 저장된 아티팩트를 생성합니다 - sessions 테이블의 task_description, background_jobs의 전사 결과, 연관된 작업 메타데이터의 비디오 프레임."
    },
    "refinement": {
      "heading": "입력 다듬기",
      "jobs": "text_improvement 작업 유형은 TextImprovementProcessor를 통해 원시 입력을 다듬고, 텍스트를 XML로 래핑하고 문법, 명확성, 구조 개선을 위해 LLM에 전송합니다.",
      "storage": "다듬어진 텍스트는 background_jobs.response에 저장되며 React 프로바이더를 통해 sessions.task_description을 업데이트할 수 있습니다."
    },
    "discovery": {
      "heading": "파일 탐색 워크플로우",
      "workflow": "FileFinderWorkflow는 4개의 순차적 단계를 실행합니다: root_folder_selection이 디렉토리를 좁히고, regex_file_filter가 패턴을 적용하고, file_relevance_assessment가 내용을 점수화하고, extended_path_finder가 의존성으로 확장합니다.",
      "outputs": "각 단계는 프로세서 간에 전달되는 IntermediateData 구조에 결과를 저장하며, 최종 파일 선택은 sessions.included_files에 영속됩니다."
    },
    "planGeneration": {
      "heading": "계획 생성",
      "jobs": "implementation_plan 작업 유형은 ImplementationPlanProcessor를 사용하여 파일 경로, 작업 유형, 코드 변경을 포함하는 plan_step 요소가 있는 XML 형식 계획을 생성합니다.",
      "streaming": "계획 내용은 job:stream-progress Tauri 이벤트를 통해 UI로 스트리밍되며, 구문 강조와 함께 VirtualizedCodeViewer Monaco 컴포넌트에 표시됩니다."
    },
    "merge": {
      "heading": "계획 병합",
      "instructions": "implementation_plan_merge 작업은 source_plans XML 태그와 사용자 제공 병합 지시를 사용하여 여러 계획을 결합하고 충돌을 해결하고 변경을 통합합니다.",
      "outputs": "병합된 계획은 소스 계획에 대한 추적성을 유지하며 최종 background_jobs 레코드에 merged_from 메타데이터를 포함합니다."
    },
    "review": {
      "heading": "계획 검토",
      "editor": "계획은 검토를 위해 Monaco 기반 VirtualizedCodeViewer에서 열립니다. 사용자는 계획 텍스트를 직접 편집하거나, 수정을 요청하거나, 실행을 승인할 수 있습니다.",
      "audit": "모든 검토 작업은 타임스탬프와 사용자 컨텍스트와 함께 로깅되어 계획 진화의 감사 추적을 제공합니다."
    },
    "execution": {
      "heading": "실행 핸드오프",
      "terminal": "승인된 계획은 복사 버튼 템플릿을 통해 통합 터미널로 복사되거나, Claude Code, Cursor, Codex와 같은 외부 에이전트용으로 내보내집니다.",
      "logging": "terminal_commands.rs의 터미널 세션은 PTY 출력을 캡처하고, 에이전트 주의 상태를 감지하고, 모든 실행 활동을 terminal_sessions 테이블에 로깅합니다."
    },
    "state": {
      "heading": "상태 영속",
      "jobs": "모든 작업 아티팩트는 session_id, task_type, status, prompt, response, 토큰 수, 비용 추적과 함께 background_jobs 테이블에 영속됩니다.",
      "rehydration": "앱 재시작 시 Rust 코어가 SQLite에서 세션 상태를 재수화하고, 오래된 실행 중인 작업을 실패로 표시하고, 터미널 출력 로그를 복원합니다."
    },
    "jobMap": {
      "heading": "작업 유형 매핑",
      "items": [
        "text_improvement → TextImprovementProcessor → 다듬어진 작업 설명",
        "root_folder_selection → RootFolderSelectionProcessor → 선택된 디렉토리",
        "regex_file_filter → RegexFileFilterProcessor → 패턴 매칭된 파일",
        "file_relevance_assessment → FileRelevanceAssessmentProcessor → 점수화된 파일",
        "extended_path_finder → ExtendedPathFinderProcessor → 확장된 컨텍스트",
        "implementation_plan → ImplementationPlanProcessor → XML 계획 문서",
        "implementation_plan_merge → ImplementationPlanMergeProcessor → 병합된 계획"
      ]
    },
    "cta": {
      "heading": "아키텍처 탐색하기",
      "description": "컴포넌트가 어떻게 함께 맞춰지는지 자세히 이해하세요.",
      "links": {
        "architecture": "아키텍처 개요",
        "jobs": "백그라운드 작업",
        "desktop": "데스크톱 앱 내부",
        "dataModel": "데이터 모델",
        "plans": "구현 계획"
      }
    }
  },
  "desktopApp": {
    "meta": {
      "title": "데스크톱 앱 내부 - PlanToCode",
      "description": "Tauri 데스크톱 셸, Rust 명령 레이어, SQLite 영속, PTY 세션이 어떻게 함께 작동하는지."
    },
    "category": "데스크톱",
    "date": "2025-09-25",
    "readTime": "14분",
    "title": "데스크톱 앱 내부",
    "description": "Tauri v2 셸, Rust 명령 레이어, PTY 세션, UI 상태 관리.",
    "intro": "데스크톱 앱은 React UI를 실행하는 Tauri v2 셸(버전 2.9.1)입니다. Rust 서비스는 워크플로우, 터미널 세션, 구성을 위한 명령을 노출하면서 상태를 SQLite에 로컬로 영속합니다. 기능 기반 권한 모델은 파일 시스템 액세스, HTTP 요청, 셸 실행, 시스템 알림에 대한 세분화된 보안 제어를 제공합니다.",
    "visuals": {
      "shell": {
        "title": "데스크톱 셸 개요",
        "description": "계획 편집기, 터미널 탭, 작업 상태 사이드바를 보여주는 스크린샷.",
        "imageSrc": "/assets/images/demo-implementation-plans.jpg",
        "imageAlt": "PlanToCode 데스크톱 셸",
        "caption": "구현 계획 패널과 사이드바를 보여주는 데스크톱 앱."
      }
    },
    "projectLayout": {
      "heading": "프로젝트 레이아웃",
      "description": "데스크톱 애플리케이션은 표준 Tauri v2 구조를 따릅니다:",
      "items": [
        "desktop/src/: React UI 컴포넌트, 훅, 프로바이더, 데스크톱 특화 어댑터.",
        "desktop/src-tauri/: 명령, 작업, 리포지토리, 서비스를 포함하는 Rust 코어.",
        "desktop/src-tauri/src/lib.rs: 플러그인 등록과 AppState 관리가 있는 애플리케이션 진입점.",
        "desktop/src-tauri/src/commands/: 도메인별로 구성된 35개 이상의 Tauri 명령 핸들러 모듈.",
        "desktop/src-tauri/src/jobs/: 백그라운드 작업 프로세서, 워크플로우 오케스트레이션, 큐 관리.",
        "desktop/src-tauri/capabilities/: 보안 권한을 위한 JSON 기능 정의 (default.json, desktop-default.json, plantocode-api.json).",
        "desktop/src-tauri/migrations/: consolidated_schema.sql의 SQLite 스키마 마이그레이션."
      ]
    },
    "ui": {
      "heading": "React UI와 표면 영역",
      "description": "React UI는 작업 설명 편집기, 계획 뷰어, 터미널 패널을 렌더링합니다:",
      "components": [
        "TaskDescriptionEditor: 음성 전사 통합과 텍스트 개선 팝오버가 있는 다중 라인 입력.",
        "VirtualizedCodeViewer: 구문 강조와 복사 액션이 있는 Monaco 기반 계획 표시.",
        "TerminalSurface: 연결 상태, 에이전트 주의 표시기, 음성 입력이 있는 PTY 출력 버퍼.",
        "SessionProvider: 활성 세션, 파일 선택, 모델 기본 설정을 위한 전역 상태 관리.",
        "TextImprovementProvider: 인라인 재작성을 위한 선택 리스너와 팝오버 위치 지정.",
        "WorkflowTracker: 다단계 워크플로우를 위한 실시간 진행 표시."
      ]
    },
    "commands": {
      "heading": "Tauri 명령",
      "description": "desktop/src-tauri/src/commands/의 명령은 Rust 기능을 React UI에 노출합니다. 주요 모듈은 다음과 같습니다:",
      "modules": [
        "job_commands.rs: create_job, get_job, cancel_job, get_jobs_for_session, clear_job_history.",
        "workflow_commands.rs: start_file_finder_workflow, get_workflow_status, retry_workflow, pause_workflow, resume_workflow.",
        "terminal_commands.rs: create_terminal_session, send_terminal_input, resize_terminal, get_terminal_output, check_cli_availability.",
        "session_commands.rs: create_session, get_session, update_session, sync_task_description_history, sync_file_selection_history.",
        "auth0_commands.rs: initiate_login, complete_login, refresh_token, logout, get_user_info.",
        "implementation_plan_commands.rs: generate_implementation_plan, merge_implementation_plans, estimate_tokens.",
        "config_commands.rs: get_runtime_config, get_model_config, get_system_prompts, refresh_config_cache.",
        "settings_commands.rs: get_setting, set_setting, get_project_system_prompt, set_project_system_prompt."
      ]
    },
    "appState": {
      "heading": "AppState 관리",
      "description": "Rust 코어는 Tauri의 상태 시스템을 통해 애플리케이션 상태를 관리합니다:",
      "structure": "lib.rs의 AppState 구조체는 다음을 보유합니다: config_load_error (Option<String>), HTTP 클라이언트 (reqwest::Client), Mutex 뒤의 RuntimeConfig (서버 URL, 온보딩 상태), 인증을 위한 Auth0State.",
      "config": "RuntimeConfig는 server_url, onboarding_complete 플래그를 포함하며 set_runtime_config 명령을 통해 업데이트됩니다. ConfigCache는 프로젝트별 오버라이드와 함께 런타임 AI 구성을 저장합니다.",
      "tokens": "TokenManager는 OS 키링(keyring 크레이트를 통해)을 사용하여 access_token, refresh_token, jwt를 안전하게 저장하며 만료 전에 자동으로 갱신합니다."
    },
    "jobs": {
      "heading": "작업 프로세서와 워크플로우",
      "description": "desktop/src-tauri/src/jobs/의 작업 처리 아키텍처:",
      "queue": "queue.rs는 인메모리 대기 작업과 SQLite 영속으로 작업 큐를 관리합니다. 작업은 다음 상태를 거칩니다: idle, created, queued, acknowledged_by_worker, preparing, preparing_input, running, generating_stream, processing_stream, completed, failed, canceled.",
      "processors": "processors/ 디렉토리에는 작업 특화 프로세서가 있습니다: ImplementationPlanProcessor (스트리밍 계획), TextImprovementProcessor (인라인 재작성), RootFolderSelectionProcessor, RegexFileFilterProcessor, FileRelevanceAssessmentProcessor, ExtendedPathFinderProcessor.",
      "orchestrator": "workflow_orchestrator/가 다단계 워크플로우를 조정합니다: definition_loader.rs가 JSON 워크플로우 정의를 로드하고, stage_scheduler.rs가 단계를 디스패치하고, payload_builder.rs가 입력을 구성하고, event_emitter.rs가 진행 이벤트를 게시합니다.",
      "streaming": "processors/generic_llm_stream_processor.rs가 스트리밍 LLM 응답을 처리하고, job:stream-progress 이벤트를 발생시키고 background_jobs.response에 내용을 누적합니다."
    },
    "persistence": {
      "heading": "로컬 영속",
      "description": "desktop/src-tauri/migrations/consolidated_schema.sql의 SQLite 저장소:",
      "tables": [
        "sessions: id (UUID), name, project_directory, project_hash, task_description, included_files, force_excluded_files, model_used, 히스토리 버전.",
        "background_jobs: id (UUID), session_id (FK), task_type, status, prompt, response, tokens_sent/received, cache_read/write_tokens, actual_cost, metadata (JSON), server_request_id.",
        "terminal_sessions: id, job_id (nullable FK), session_id, status, process_pid, output_log, working_directory, environment_vars, last_output_at.",
        "task_description_history: 멀티 디바이스 동기화를 위한 session_id (FK), description, device_id, sequence_number, version.",
        "file_selection_history: session_id (FK), included_files, force_excluded_files, device_id, sequence_number.",
        "project_system_prompts: 프로젝트별 프롬프트 오버라이드를 위한 project_hash, task_type, system_prompt.",
        "key_value_store: 앱 설정을 위한 key, value (JSON), updated_at.",
        "error_logs: 클라이언트 측 오류 추적을 위한 timestamp, level, error_type, message, context, stack, metadata."
      ],
      "repositories": "db_utils/의 리포지토리가 타입화된 액세스를 제공합니다: background_job_repository/ (base.rs, worker.rs, metadata.rs, cleanup.rs로 모듈화), session_repository.rs, terminal_repository.rs, settings_repository.rs, error_log_repository.rs."
    },
    "terminal": {
      "heading": "터미널 세션",
      "description": "PTY 터미널 구현:",
      "commands": "terminal_commands.rs가 세션 라이프사이클을 관리합니다: create_terminal_session이 portable-pty 크레이트를 통해 PTY를 생성하고, send_terminal_input이 키 입력을 전달하고, resize_terminal이 크기를 조정하고, check_cli_availability가 도구 존재 여부(claude, cursor, codex, gemini)를 확인합니다.",
      "persistence": "terminal_repository.rs가 output_log (누적된 터미널 출력), status (idle/running/completed/failed/agent_requires_attention), exit_code, working_directory와 함께 세션을 영속합니다. 세션은 앱 재시작 후 복원될 수 있습니다.",
      "attention": "에이전트 주의 감지가 last_output_at 타임스탬프를 모니터링합니다. 레벨 1 (30초 유휴): 노란색 표시기. 레벨 2 (2분 유휴): 데스크톱 알림과 함께 빨간색 표시기."
    },
    "inputStability": {
      "heading": "작업 설명 안정성",
      "description": "작업 설명 편집기에는 커서 점프를 방지하는 안전장치가 포함되어 있습니다:",
      "items": [
        "원격 업데이트는 사용자가 입력하는 동안 대기열에 추가되고 유휴 상태 또는 블러 시 플러시됩니다.",
        "선택 상태는 추적되고 React 리렌더링 후 복원됩니다.",
        "백그라운드 라이터는 sessionActions.updateCurrentSessionFields를 호출하여 업데이트를 조정합니다.",
        "멀티 디바이스 동기화는 충돌 해결을 위해 sequence_number와 version 필드를 사용합니다."
      ]
    },
    "plugins": {
      "heading": "Tauri 플러그인",
      "description": "PlanToCode는 Tauri v2 플러그인 생태계를 사용합니다:",
      "list": [
        "tauri-plugin-http (2.5.2): API 호출을 위한 CSP 인식 fetch가 있는 HTTP 클라이언트.",
        "tauri-plugin-dialog (2.4.2): 네이티브 파일/폴더 선택기와 메시지 다이얼로그.",
        "tauri-plugin-shell (2.3.3): 외부 CLI 도구를 위한 셸 명령 실행.",
        "tauri-plugin-store (2.4.1): 앱 설정을 위한 영속적 키-값 저장소.",
        "tauri-plugin-notification (2.3.0): 에이전트 주의를 위한 데스크톱 알림.",
        "tauri-plugin-updater (2.9.0): 서명 검증이 있는 인앱 업데이트.",
        "tauri-plugin-single-instance (2.3.4): 단일 인스턴스 적용.",
        "tauri-plugin-process (2.3.1): 프로세스 재시작 기능."
      ]
    }
  },
  "serverApi": {
    "meta": {
      "title": "서버 API 및 LLM 프록시 - PlanToCode",
      "description": "데스크톱 및 모바일 클라이언트가 사용하는 인증, 프로바이더 라우팅, 모델 구성, WebSocket 엔드포인트."
    },
    "category": "서버",
    "date": "2025-09-25",
    "readTime": "12분",
    "title": "서버 API 및 LLM 프록시",
    "description": "인증, 프로바이더 라우팅, 모델 구성, 청구, WebSocket 엔드포인트.",
    "intro": "서버는 인증, 모델 구성, LLM 프록싱, 청구를 제공하는 Rust로 작성된 Actix-Web 서비스입니다. 데스크톱 및 모바일 클라이언트는 안전한 프로바이더 라우팅과 스트리밍 응답을 위해 이에 의존합니다. 서버는 두 지역의 전용 인프라에서 실행됩니다: Hetzner (EU) api-eu.plantocode.com과 InterServer (US) api-us.plantocode.com.",
    "visuals": {
      "flow": {
        "title": "서버 요청 흐름",
        "description": "클라이언트, API 라우트, LLM 프록시를 보여주는 다이어그램.",
        "imageSrc": "/images/docs/provider-routing/routing-map.svg",
        "imageAlt": "서버 요청 흐름 다이어그램",
        "caption": "서버 요청 흐름을 위한 플레이스홀더."
      }
    },
    "routeOrganization": {
      "heading": "라우트 구성",
      "description": "라우트는 세 가지 구성 함수로 server/src/routes.rs에 구성됩니다:",
      "functions": [
        "configure_routes(): /api 스코프 아래의 JWT 인증 라우트. auth, billing, config, providers, models, llm proxy, audio, system-prompts, consent, devices, notifications 포함.",
        "configure_public_auth_routes(): /auth 스코프 아래의 브라우저 기반 인증 흐름. Auth0 initiate-login, callback, logged-out 라우트 포함.",
        "configure_webhook_routes(): /webhooks 스코프 아래의 비인증 웹훅 엔드포인트. 현재 Stripe 웹훅 처리."
      ]
    },
    "auth": {
      "heading": "인증 엔드포인트",
      "description": "인증은 PKCE 흐름과 함께 Auth0를 사용합니다:",
      "routes": [
        "/auth/auth0/initiate-login (GET): code_challenge로 OAuth 흐름을 시작하고 Auth0로 리디렉션합니다.",
        "/auth/auth0/callback (GET): Auth0 리디렉션을 처리하고 코드를 토큰으로 교환합니다.",
        "/api/auth/userinfo (GET): Auth0에서 인증된 사용자 정보를 반환합니다.",
        "/api/auth/logout (POST): 토큰을 취소하고 세션을 지웁니다.",
        "/api/auth/account (DELETE): 연쇄 정리와 함께 계정 삭제.",
        "/api/auth0/refresh-app-token (POST): 리프레시 토큰을 사용하여 액세스 토큰을 갱신합니다."
      ],
      "implementation": "인증 핸들러는 server/src/handlers/auth0_handlers.rs와 server/src/handlers/auth/에 있습니다. JWT 검증은 JWKS 순환과 함께 services/auth/jwt.rs를 사용합니다. 취소된 토큰은 revoked_token_repository.rs에서 추적됩니다."
    },
    "llmProxy": {
      "heading": "LLM 프록시 및 스트리밍",
      "description": "LLM 프록시는 프로바이더 간 요청을 정규화하고 응답을 스트리밍합니다:",
      "routes": [
        "/api/llm/chat/completions (POST): 메인 채팅 완성 엔드포인트. 모델 ID에 따라 OpenAI, Anthropic, Google, X.AI, OpenRouter로 라우팅합니다.",
        "/api/llm/video/analyze (POST): 프레임 분석을 위한 멀티파트 비디오 업로드. 비디오 기능이 있는 google/* 모델 필요.",
        "/api/llm/cancel (POST): request_id로 진행 중인 스트리밍 요청을 취소합니다.",
        "/api/llm/status/{request_id} (GET): 요청 상태를 반환합니다 (active, completed, cancelled).",
        "/api/audio/transcriptions (POST): Whisper 호환 전사. 오디오 파일과 매개변수가 있는 멀티파트 업로드."
      ],
      "routing": "server/src/handlers/proxy/router.rs의 라우터가 모델 ID 접두사(openai/, anthropic/, google/, xai/, openrouter/)에 따라 프로바이더를 선택합니다. server/src/handlers/proxy/providers/의 프로바이더별 핸들러가 요청을 변환하고 응답을 정규화합니다.",
      "streaming": "스트리밍 응답은 streaming/sse_adapter.rs를 통해 Server-Sent Events (SSE)를 사용합니다. 프록시는 프로바이더에서 청크를 전달하고, 공통 형식으로 변환하고, 실시간으로 토큰 사용량을 추적합니다."
    },
    "providers": {
      "heading": "프로바이더 라우팅",
      "description": "server/src/handlers/proxy/providers/의 프로바이더 핸들러:",
      "handlers": [
        "openai.rs: OpenAI 및 OpenAI 호환 API (GPT-4, o1, o3).",
        "anthropic.rs: 프롬프트 캐싱 지원이 있는 Anthropic Claude 모델.",
        "google.rs: 비디오 분석 기능을 포함한 Google Gemini 모델.",
        "xai.rs: X.AI Grok 모델.",
        "openrouter.rs: 모델 라우팅을 위한 OpenRouter 집계."
      ],
      "transformers": "server/src/handlers/provider_transformers/의 요청/응답 변환기가 API 차이를 정규화합니다. 각 변환기가 처리하는 것: 요청 본문 형식, 인증 헤더, 스트리밍 청크 형식, 사용량 추출, 오류 정규화."
    },
    "config": {
      "heading": "구성 엔드포인트",
      "description": "구성 및 모델 메타데이터 엔드포인트:",
      "routes": [
        "/api/config/all-configurations (GET): 작업 유형별 모델 설정을 포함한 모든 애플리케이션 구성을 반환합니다.",
        "/api/config/desktop-runtime-config (GET): 데스크톱 특화 런타임 구성.",
        "/api/config/billing (GET/PUT): 청구 구성 관리.",
        "/api/providers (GET): 기능이 있는 사용 가능한 LLM 프로바이더 목록.",
        "/api/providers/with-counts (GET): 모델 수가 있는 프로바이더.",
        "/api/providers/by-capability/{capability} (GET): 기능별 프로바이더 필터링.",
        "/api/models (GET): 가격이 있는 모든 사용 가능한 모델.",
        "/api/models/{id} (GET): 단일 모델 세부사항.",
        "/api/models/by-provider/{provider_code} (GET): 특정 프로바이더의 모델.",
        "/api/models/estimate-cost (POST): 요청에 대한 비용 추정.",
        "/api/models/estimate-tokens (POST): 토큰 수 추정.",
        "/api/system-prompts/defaults (GET): 작업 유형별 기본 시스템 프롬프트."
      ]
    },
    "billing": {
      "heading": "청구 엔드포인트",
      "description": "Stripe와 통합된 크레딧 기반 청구 시스템:",
      "routes": [
        "/api/billing/dashboard (GET): 사용자 청구 대시보드 데이터.",
        "/api/billing/usage-summary (GET): 비용 분석이 있는 상세 사용량.",
        "/api/billing/credits/balance (GET): 현재 크레딧 잔액.",
        "/api/billing/credits/details (GET): 부여 및 구매를 포함한 크레딧 세부사항.",
        "/api/billing/credits/unified-history (GET): 거래 내역.",
        "/api/billing/checkout/credit-purchase (POST): 크레딧을 위한 Stripe 체크아웃 생성.",
        "/api/billing/checkout/setup (POST): 결제 방법을 위한 Stripe 설정 세션 생성.",
        "/api/billing/auto-top-off (GET/PUT): 자동 충전 설정 관리."
      ],
      "implementation": "청구 핸들러는 server/src/handlers/billing/에 있습니다. 크레딧 서비스는 services/credit_service.rs에 있습니다. Stripe 통합은 webhook_handlers.rs의 웹훅 처리와 함께 services/stripe_service.rs를 통해 이루어집니다."
    },
    "devices": {
      "heading": "디바이스 관리",
      "description": "디바이스 등록 및 푸시 알림:",
      "routes": [
        "/api/devices/register (POST): device_id로 데스크톱 디바이스 등록.",
        "/api/devices/mobile/register (POST): 플랫폼 정보로 모바일 디바이스 등록.",
        "/api/devices/{device_id}/heartbeat (POST): 존재 확인을 위한 디바이스 하트비트.",
        "/api/devices/{device_id}/push-token (POST): 푸시 알림 토큰 저장.",
        "/api/devices/{device_id}/connection-descriptor (GET): 디바이스 연결을 위한 WebSocket 연결 정보.",
        "/api/notifications/job-completed (POST): 완료된 작업에 대한 푸시 알림 전송.",
        "/api/notifications/job-progress (POST): 진행 알림 전송."
      ]
    },
    "websockets": {
      "heading": "WebSocket 엔드포인트",
      "description": "WebSocket을 통한 실시간 통신:",
      "endpoints": [
        "/ws/device-link: 데스크톱-모바일 디바이스 연결을 위한 릴레이. 연결된 디바이스 간 터미널 출력 스트리밍, 작업 상태 업데이트, RPC 명령 처리.",
        "/ws/events: 실시간 업데이트를 위한 일반 이벤트 스트림."
      ],
      "implementation": "디바이스 링크 릴레이는 server/src/handlers/device_link_ws.rs에 있습니다. 세션은 하트비트 모니터링과 재연결 지원이 있는 services/relay_session_store.rs에 의해 관리됩니다."
    },
    "serverStorage": {
      "heading": "서버 측 영속",
      "description": "server/src/db/repositories/의 리포지토리가 있는 PostgreSQL 데이터베이스:",
      "repositories": [
        "user_repository.rs: Auth0 sub에 연결된 사용자 계정.",
        "customer_billing_repository.rs: Stripe 고객 및 크레딧 상태.",
        "credit_transaction_repository.rs: 크레딧 거래 내역.",
        "provider_repository.rs: LLM 프로바이더 구성.",
        "system_prompts_repository.rs: 시스템 프롬프트 템플릿.",
        "consent_repository.rs: 법적 동의 추적.",
        "audit_log_repository.rs: 민감한 작업에 대한 감사 추적.",
        "revoked_token_repository.rs: JWT 취소 목록.",
        "api_key_repository.rs: 보안 해싱이 있는 API 키 관리."
      ]
    }
  },
  "backgroundJobs": {
    "meta": {
      "title": "백그라운드 작업 - PlanToCode",
      "description": "데스크톱 작업 엔진을 위한 작업 큐 아키텍처, 프로세서 유형, 상태 머신, 아티팩트 저장."
    },
    "category": "아키텍처",
    "date": "2025-09-25",
    "readTime": "14분",
    "title": "백그라운드 작업",
    "description": "작업 큐, 프로세서, 상태 머신, 이벤트 스트리밍, 아티팩트 저장.",
    "intro": "모든 LLM 기반 작업은 데스크톱 앱의 백그라운드 작업 시스템을 통해 실행됩니다. 작업 큐는 작업을 프로세서에 디스패치하고, 진행 이벤트를 스트리밍하고, 감사 및 복구를 위해 모든 프롬프트와 응답을 SQLite에 영속합니다. 이 아키텍처는 취소, 재시도, 비용 추적, 실시간 UI 업데이트를 가능하게 합니다.",
    "visuals": {
      "stateMachine": {
        "title": "작업 상태 머신",
        "description": "생성에서 완료 또는 실패까지의 작업 상태 전환을 보여주는 다이어그램.",
        "imageSrc": "/images/docs/background-jobs/state-machine.svg",
        "imageAlt": "작업 상태 머신 다이어그램",
        "caption": "작업 상태 머신 다이어그램을 위한 플레이스홀더."
      }
    },
    "jobRecord": {
      "heading": "작업 레코드 구조",
      "description": "각 작업은 다음 필드와 함께 SQLite에 background_jobs 행을 생성합니다:",
      "fields": [
        "id (TEXT PRIMARY KEY): 작업의 UUID.",
        "session_id (TEXT NOT NULL, FK): CASCADE DELETE와 함께 sessions.id 참조.",
        "task_type (TEXT DEFAULT 'unknown'): 프로세서 식별자 (예: implementation_plan, text_improvement, root_folder_selection).",
        "status (TEXT): 유효한 값에 대한 CHECK 제약 조건이 있는 현재 상태.",
        "prompt (TEXT NOT NULL): 감사를 위해 저장된 LLM에 전송된 전체 텍스트.",
        "response (TEXT): LLM 출력 또는 오류 메시지.",
        "error_message (TEXT): 실패 시 상세 오류 정보.",
        "tokens_sent (INTEGER DEFAULT 0): 프로바이더 응답의 입력 토큰 수.",
        "tokens_received (INTEGER DEFAULT 0): 출력 토큰 수.",
        "cache_read_tokens (INTEGER DEFAULT 0): 프로바이더 캐시에서 읽은 토큰 (Anthropic).",
        "cache_write_tokens (INTEGER DEFAULT 0): 캐시에 기록된 토큰.",
        "model_used (TEXT): 요청에 사용된 모델 식별자.",
        "actual_cost (REAL): 토큰 사용량과 모델 가격을 기반으로 계산된 비용.",
        "metadata (TEXT): 작업별 데이터, 워크플로우 ID, 단계 이름이 있는 JSON.",
        "system_prompt_template (TEXT): 시스템 프롬프트에 사용된 템플릿 식별자.",
        "server_request_id (TEXT): 서버 측 사용량 추적에 연결.",
        "created_at, updated_at, start_time, end_time (INTEGER): 타임스탬프.",
        "is_finalized (INTEGER DEFAULT 0): 최종 비용/사용량이 기록되었는지 여부."
      ]
    },
    "statusValues": {
      "heading": "상태 값과 전환",
      "description": "작업은 데이터베이스에서 추적되는 잘 정의된 상태를 거칩니다:",
      "statuses": [
        "idle: 처리 시작 전 초기 상태.",
        "created: 작업 레코드 생성됨, 아직 대기열에 없음.",
        "queued: 작업 큐에 추가됨, 프로세서 대기 중.",
        "acknowledged_by_worker: 프로세서가 작업을 픽업함.",
        "preparing: 프로세서가 입력(파일, 프롬프트)을 수집 중.",
        "preparing_input: LLM 요청 페이로드 빌드 중.",
        "running: LLM에 요청 전송됨, 응답 대기 중.",
        "generating_stream: 스트리밍 응답 진행 중.",
        "processing_stream: 스트리밍된 청크 처리 중.",
        "completed: 작업 성공적으로 완료됨.",
        "completed_by_tag: 스트림 종료 태그 감지로 완료됨.",
        "failed: error_message가 채워진 상태로 작업 실패.",
        "canceled: 사용자가 취소 요청."
      ],
      "transitions": "전환은 background_job_repository/worker.rs에서 적용됩니다. 유효하지 않은 전환은 거부됩니다. 상태 변경은 job:status-changed Tauri 이벤트를 발생시킵니다."
    },
    "orchestrator": {
      "heading": "워크플로우 오케스트레이터",
      "description": "다단계 워크플로우는 desktop/src-tauri/src/jobs/workflow_orchestrator/의 WorkflowOrchestrator에 의해 관리됩니다:",
      "modules": [
        "mod.rs: 메인 오케스트레이터 구조체와 워크플로우 실행 진입점.",
        "definition_loader.rs: 단계 순서와 프로세서 유형을 지정하는 워크플로우 JSON 정의 로드 (예: file_finder_workflow.json).",
        "stage_scheduler.rs: 단계를 순차적으로 예약하고 업스트림 완료를 대기.",
        "stage_job_manager.rs: 각 단계에 대한 background_job 레코드 생성.",
        "payload_builder.rs: IntermediateData에서 단계 입력 구성.",
        "data_extraction.rs: 완료된 단계 작업에서 출력 추출.",
        "event_emitter.rs: workflow-status 및 workflow-stage Tauri 이벤트 게시.",
        "state_updater.rs: 메모리와 데이터베이스에서 워크플로우 상태 업데이트.",
        "completion_handler.rs: 워크플로우 완료 및 정리 처리.",
        "failure_handler.rs: 단계 실패 및 재시도 결정 관리.",
        "retry_handler.rs: 지수 백오프로 재시도 로직 구현."
      ],
      "dataFlow": "워크플로우는 WorkflowIntermediateData(workflow_types.rs에 정의됨)를 사용하여 단계 간에 출력을 전달합니다: directoryTreeContent, selectedRoots, rawRegexPatterns, locallyFilteredFiles, aiFilteredFiles, verifiedPaths, unverifiedPaths."
    },
    "processors": {
      "heading": "작업 프로세서",
      "description": "각 task_type은 desktop/src-tauri/src/jobs/processors/의 프로세서에 매핑됩니다:",
      "implementations": [
        "implementation_plan_processor.rs: 선택된 파일 내용을 로드하고, 디렉토리 트리로 구조화된 프롬프트를 빌드하고, XML 계획을 UI로 스트리밍합니다. 스트리밍을 위해 generic_llm_stream_processor를 사용합니다.",
        "text_improvement_processor.rs: 선택을 XML 태그로 래핑하고, 비스트리밍 요청을 보내고, 개선된 텍스트를 반환합니다. LlmTaskRunner를 통해 실행됩니다.",
        "root_folder_selection_processor.rs: 디렉토리 트리를 LLM에 보내고 선택된 디렉토리의 JSON 배열 응답을 파싱합니다.",
        "RegexFileFilterProcessor (processors/mod.rs에 있음): 작업에서 정규식 패턴을 생성하고 git 파일 목록에 적용하고 바이너리를 필터링합니다.",
        "FileRelevanceAssessmentProcessor: 토큰 한도로 파일 내용을 청크하고, 배치로 관련성을 점수화하고, 관련 경로를 집계합니다.",
        "ExtendedPathFinderProcessor (path_finder_types.rs): 임포트/의존성을 분석하고, 관련 파일을 제안하고, 경로 존재를 검증합니다.",
        "web_search_prompts_generator_processor.rs: 심층 조사를 위한 research_task XML 블록을 생성합니다.",
        "web_search_executor_processor.rs: 서버 검색 API를 통해 조사 프롬프트를 병렬로 실행합니다.",
        "generic_llm_stream_processor.rs: 청크 누적, 이벤트 발생, 응답 최종화를 처리하는 재사용 가능한 스트리밍 프로세서."
      ]
    },
    "events": {
      "heading": "이벤트 스트리밍",
      "description": "작업 진행은 React UI가 소비하는 Tauri 이벤트를 발생시킵니다:",
      "eventTypes": [
        "job:status-changed: 페이로드 {jobId, status, error?}. 모든 상태 전환에서 발생.",
        "job:stream-progress: 페이로드 {jobId, content, tokensReceived}. 각 스트리밍 청크에 대해 발생.",
        "job:completed: 페이로드 {jobId, response, tokensTotal, cost}. 성공적 완료 시 발생.",
        "workflow-status: 페이로드 {workflowId, status, currentStage?}. 워크플로우 수준 상태 업데이트.",
        "workflow-stage: 페이로드 {workflowId, stageName, status}. 개별 단계 상태."
      ],
      "reactConsumption": "React 컴포넌트는 @tauri-apps/api/event의 listen()과 함께 useEffect를 통해 구독합니다. WorkflowTracker가 워크플로우 이벤트를 집계합니다. JobStatusIndicator가 실시간 상태를 표시합니다."
    },
    "retry": {
      "heading": "재시도 및 취소",
      "description": "작업 재시도 및 취소 메커니즘:",
      "retryLogic": "retry_handler.rs가 재시도 횟수와 지연을 관리합니다. 재시도는 구성 가능한 최대 시도 횟수로 지수 백오프를 사용합니다. 재시도 상태는 job.metadata.retryCount에 저장됩니다.",
      "cancellation": "취소는 generic_llm_stream_processor.rs에서 스트리밍 청크 사이에 확인되는 플래그를 설정합니다. 서버 측 취소는 request_id와 함께 /api/llm/cancel을 전송합니다.",
      "cleanup": "workflow_cleanup.rs가 불완전한 워크플로우의 정리를 처리합니다. 오래된 작업(앱 재시작 후 실행 중 상태)은 실패로 표시됩니다."
    },
    "artifacts": {
      "heading": "아티팩트 저장",
      "description": "작업 입력과 출력은 감사를 위해 완전히 영속됩니다:",
      "stored": [
        "prompt: 시스템 프롬프트와 사용자 내용을 포함한 완전한 LLM 프롬프트.",
        "response: 전체 LLM 응답 텍스트 또는 스트리밍 누적.",
        "metadata: 작업별 데이터가 있는 JSON (개선을 위한 원본 텍스트, 파일 목록, 워크플로우 컨텍스트).",
        "system_prompt_template: 서버 측 프롬프트 템플릿 버전에 연결하는 식별자.",
        "토큰 수와 비용: 청구 및 분석을 위해 프로바이더 응답에서 캡처."
      ],
      "access": "background_job_repository가 쿼리를 제공합니다: get_jobs_for_session, get_job_by_id, get_jobs_by_task_type, get_recent_jobs. 작업 히스토리는 BackgroundJobsSidebar 컴포넌트에 표시됩니다."
    },
    "costTracking": {
      "heading": "비용 추적",
      "description": "작업별 비용 추적으로 예산 관리가 가능합니다:",
      "calculation": "비용은 server/src/models/model_pricing.rs의 모델 가격을 사용하여 계산됩니다. 공식: (tokens_sent * input_price + tokens_received * output_price) 캐시 조정 포함.",
      "accumulation": "세션 수준 비용은 background_jobs에서 집계됩니다. UI는 세션 헤더에 누적 비용을 표시합니다.",
      "serverSync": "server_request_id가 청구 조정을 위해 데스크톱 작업을 서버 측 사용 레코드에 연결합니다."
    },
    "cta": {
      "heading": "데이터 모델 보기",
      "description": "작업, 세션, 터미널 출력을 저장하는 SQLite 스키마를 이해하세요.",
      "links": {
        "dataModel": "데이터 모델",
        "runtime": "런타임 워크스루"
      }
    }
  },
  "buildYourOwn": {
    "meta": {
      "title": "자체 파이프라인 구축하기 - PlanToCode",
      "description": "PlanToCode와 유사한 파일 탐색 및 계획 생성 워크플로우를 설계하기 위한 개념 가이드."
    },
    "category": "참조",
    "date": "2025-09-25",
    "readTime": "12분",
    "title": "자체 파이프라인 구축하기",
    "description": "파일 탐색 및 계획 생성 워크플로우를 설계하기 위한 개념 가이드.",
    "intro": "이 가이드는 PlanToCode의 핵심 아키텍처 패턴을 개념적 청사진으로 추출합니다. 유사한 시스템을 구축하거나 특정 설계 결정이 내려진 이유를 이해하려는 경우, 이 문서는 재사용하거나 적응할 수 있는 기본 패턴을 다룹니다.",
    "visuals": {
      "pipelineMap": {
        "title": "파이프라인 아키텍처 맵",
        "description": "작업 입력에서 계획 출력까지의 다단계 파이프라인 개요.",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "파이프라인 아키텍처 다이어그램",
        "caption": "파이프라인 아키텍처 다이어그램을 위한 플레이스홀더."
      }
    },
    "keyPatterns": {
      "heading": "핵심 아키텍처 패턴",
      "jobQueue": {
        "title": "작업 큐 패턴",
        "description": "모든 LLM 기반 작업은 상태 추적, 취소 지원, 재시도 로직을 갖춘 백그라운드 작업으로 실행됩니다. 작업은 SQLite에 영속되어 앱 재시작 시에도 상태가 유지됩니다.",
        "benefits": [
          "UI 응답성을 LLM 지연에서 분리",
          "스트리밍 중간에 취소 가능",
          "모든 작업의 감사 추적 제공",
          "지수 백오프로 재시도 지원"
        ],
        "pitfalls": [
          "작업 상태 관리가 복잡성 추가",
          "재시작 시 오래된 작업의 주의 깊은 처리 필요",
          "대규모 응답에 대한 스트림 누적이 메모리 소비"
        ]
      },
      "workflowOrchestrator": {
        "title": "워크플로우 오케스트레이터 패턴",
        "description": "다단계 워크플로우는 단계를 순차적으로 예약하고, 단계 간에 중간 데이터를 전달하고, 모든 단계에서 실패를 처리하는 오케스트레이터에 의해 조정됩니다.",
        "components": [
          "정의 로더가 워크플로우 JSON 스펙을 읽음",
          "단계 스케줄러가 순서대로 단계를 디스패치",
          "페이로드 빌더가 이전 출력에서 입력 구성",
          "이벤트 이미터가 UI 업데이트를 위한 진행 게시"
        ]
      },
      "repositoryPattern": {
        "title": "리포지토리 패턴",
        "description": "모든 영속은 SQLite 작업을 추상화하는 타입화된 리포지토리를 통해 이루어집니다. 이는 깔끔한 API를 제공하고, 테스팅을 가능하게 하며, 데이터베이스 액세스를 중앙화합니다.",
        "benefits": [
          "타입화된 액세스가 SQL 인젝션 방지",
          "리포지토리를 테스팅용으로 목 가능",
          "중앙화된 쿼리 최적화",
          "일관된 오류 처리"
        ]
      }
    },
    "steps": {
      "step1": {
        "title": "1. 작업 모델 정의하기",
        "description": "시스템에서 작업을 구성하는 것을 정의하는 것부터 시작하세요. PlanToCode는 작업 설명, 파일 선택, 모델 기본 설정이 있는 세션을 사용합니다.",
        "details": "히스토리 추적을 위한 버전 관리와 함께 전용 테이블에 작업 메타데이터를 저장하세요."
      },
      "step2": {
        "title": "2. 작업 큐 구축하기",
        "description": "작업을 저장소에 영속하고, 상태 이벤트를 발생시키고, 취소를 지원하는 작업 큐를 만드세요. 작업은 프롬프트, 응답, 토큰, 비용을 추적해야 합니다.",
        "details": "병렬 LLM 요청을 제어하기 위해 세마포어 기반 동시성 제한기를 사용하세요."
      },
      "step3": {
        "title": "3. 프로세서 구현하기",
        "description": "각 작업 유형은 프롬프트를 빌드하고, LLM을 호출하고, 응답을 파싱하는 프로세서가 필요합니다. 긴 출력에는 스트리밍을 사용하세요.",
        "details": "프로세서는 무상태여야 하며 작업 매개변수를 통해 모든 컨텍스트를 받아야 합니다."
      },
      "step4": {
        "title": "4. 워크플로우 오케스트레이터 만들기",
        "description": "다단계 워크플로우의 경우, 단계를 예약하고, 중간 데이터를 관리하고, 실패를 처리하는 오케스트레이터를 구축하세요.",
        "details": "코드 변경 없이 쉽게 수정할 수 있도록 워크플로우 정의를 JSON으로 저장하세요."
      },
      "step5": {
        "title": "5. 라우팅 레이어 추가하기",
        "description": "페이로드를 정규화하고, API 키를 관리하고, 사용량을 추적하는 서버 프록시를 통해 LLM 요청을 라우팅하세요.",
        "details": "프로바이더 자격 증명은 서버에 보관하세요; 데스크톱 클라이언트에 절대 포함하지 마세요."
      }
    },
    "architectureDecisions": {
      "heading": "아키텍처 결정",
      "decisions": [
        {
          "question": "로컬 데이터베이스를 사용해야 할까요, 서버 측 저장소를 사용해야 할까요?",
          "recommendation": "작업 상태와 아티팩트에는 로컬 SQLite를 사용하세요. 이것은 오프라인 작업과 빠른 쿼리를 가능하게 합니다. 청구 및 크로스 디바이스 상태에만 서버와 동기화하세요."
        },
        {
          "question": "스트리밍 vs 비스트리밍 응답?",
          "recommendation": "계획 생성과 점진적으로 표시되는 모든 출력에는 스트리밍을 사용하세요. 텍스트 개선과 같은 짧은 변환에는 비스트리밍을 사용하세요."
        },
        {
          "question": "LLM 프로바이더 실패를 어떻게 처리할까요?",
          "recommendation": "지수 백오프로 자동 재시도를 구현하세요. 복원력을 위해 OpenRouter와 같은 폴백 프로바이더를 고려하세요."
        },
        {
          "question": "파일 내용은 어디서 로드해야 할까요?",
          "recommendation": "프롬프트를 빌드하기 직전에 프로세서에서 파일 내용을 로드하세요. 이것은 최신 내용을 보장하고 작업 레코드에 큰 blob 저장을 피합니다."
        }
      ]
    },
    "customizeVsReuse": {
      "heading": "사용자 정의 vs 재사용할 것",
      "customize": [
        "특정 사용 사례를 위한 프롬프트 템플릿",
        "프로젝트 유형에 맞는 파일 탐색 패턴",
        "출력 형식 (XML, JSON, Markdown)",
        "작업 유형별 모델 선택"
      ],
      "reuse": [
        "상태 추적이 있는 작업 큐 아키텍처",
        "워크플로우 오케스트레이터 패턴",
        "영속을 위한 리포지토리 패턴",
        "스트리밍 응답 처리",
        "프로바이더 라우팅과 정규화"
      ]
    },
    "commonPitfalls": {
      "heading": "피해야 할 일반적인 함정",
      "items": [
        {
          "pitfall": "클라이언트에 API 키 포함",
          "solution": "자격 증명을 안전하게 관리하는 서버 프록시를 통해 모든 LLM 요청을 라우팅하세요."
        },
        {
          "pitfall": "작업 상태를 영속하지 않음",
          "solution": "감사 및 복구를 위해 전체 프롬프트와 응답과 함께 모든 작업을 저장하세요."
        },
        {
          "pitfall": "LLM 호출에서 UI 차단",
          "solution": "응답성 있는 인터페이스를 위해 이벤트 기반 UI 업데이트와 함께 백그라운드 작업을 사용하세요."
        },
        {
          "pitfall": "토큰 한도 무시",
          "solution": "전송 전에 토큰을 추정하고 컨텍스트 윈도우 내에 유지하기 위해 큰 입력을 청크하세요."
        },
        {
          "pitfall": "취소 지원 없음",
          "solution": "스트리밍 청크 사이에 취소 플래그를 확인하고 서버로 전파하세요."
        }
      ]
    },
    "artifacts": {
      "heading": "영속할 아티팩트",
      "items": [
        "LLM에 전송된 전체 프롬프트 (디버깅 및 감사용)",
        "스트리밍 누적을 포함한 완전한 응답",
        "프로바이더 응답의 토큰 수",
        "모델 가격을 기반으로 계산된 비용",
        "버전 관리를 위한 시스템 프롬프트 템플릿 식별자",
        "다단계 흐름을 위한 워크플로우 중간 데이터"
      ]
    },
    "implementationNotes": {
      "heading": "구현 노트",
      "items": [
        "동시 읽기/쓰기 액세스를 위해 WAL 모드로 SQLite 사용",
        "실행 중인 작업을 실패로 표시하는 정상 종료 구현",
        "작업 처리 전 외부 의존성에 대한 헬스 체크 추가",
        "디버깅을 위해 전체 컨텍스트와 함께 모든 LLM 오류 로깅",
        "중복 읽기를 피하기 위해 짧은 TTL로 파일 내용 캐싱 고려"
      ]
    }
  },
  "decisionsTradeoffs": {
    "meta": {
      "title": "기술적 결정과 트레이드오프 - PlanToCode",
      "description": "Tauri, SQLite, 전용 LLM 프록시를 선택한 이유와 그것이 만드는 운영상의 트레이드오프."
    },
    "category": "아키텍처",
    "date": "2025-09-25",
    "readTime": "10분",
    "title": "기술적 결정과 트레이드오프",
    "description": "Tauri, SQLite, 전용 LLM 프록시를 선택한 이유와 그 비용.",
    "intro": "모든 아키텍처는 트레이드오프를 수반합니다. 이 문서는 PlanToCode의 주요 기술 선택, 그것이 제공하는 이점, 그리고 도입하는 비용이나 제한을 설명합니다.",
    "visuals": {
      "tradeoffMatrix": {
        "title": "트레이드오프 매트릭스",
        "description": "기술 선택과 그 이점 및 비용의 시각적 비교.",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "기술 트레이드오프 매트릭스",
        "caption": "기술 스택 결정을 보여주는 시스템 아키텍처 개요."
      }
    },
    "sections": {
      "tauri": {
        "title": "데스크톱을 위한 Tauri v2",
        "description": "Tauri는 웹 기반 프론트엔드와 함께 Rust 백엔드를 제공하여, 네이티브 성능과 작은 바이너리 크기로 크로스 플랫폼 데스크톱 앱을 가능하게 합니다.",
        "benefits": [
          "작은 바이너리 크기 (~15MB vs Electron의 200MB+)",
          "파일 작업과 작업 처리를 위한 네이티브 Rust 성능",
          "세분화된 권한이 있는 기능 기반 보안 모델",
          "macOS, Windows, Linux를 위한 단일 코드베이스",
          "시스템 API 액세스 (PTY, 키체인, 알림)"
        ],
        "tradeoffs": [
          "Electron보다 작은 생태계",
          "백엔드 개발을 위한 Rust 학습 곡선",
          "플랫폼 간 WebView 렌더링 차이",
          "IPC 이슈 디버깅을 위한 덜 성숙한 도구"
        ],
        "implementation": "PlanToCode는 ~35개 명령 모듈, 기능 기반 권한, 셸, 다이얼로그, 알림을 위한 플러그인과 함께 Tauri 2.9.1을 사용합니다."
      },
      "sqlite": {
        "title": "로컬 영속을 위한 SQLite",
        "description": "SQLite는 세션, 작업, 터미널 출력, 설정을 포함한 모든 로컬 상태를 저장합니다. 이것은 오프라인 작업과 빠른 쿼리를 가능하게 합니다.",
        "benefits": [
          "구성이 필요 없는 임베디드 데이터베이스",
          "로컬 데이터에 대한 빠른 쿼리",
          "오프라인 작업 가능",
          "단일 파일 백업 및 복원",
          "동시 액세스를 위한 WAL 모드"
        ],
        "tradeoffs": [
          "내장된 복제 또는 동기화 없음",
          "큰 터미널 로그가 데이터베이스를 증가시킬 수 있음",
          "수동 스키마 마이그레이션 필요",
          "단일 라이터 제한 (WAL로 완화)"
        ],
        "implementation": "~10개 테이블이 있는 consolidated_schema.sql의 스키마. 리포지토리가 rusqlite로 타입화된 액세스를 제공합니다."
      },
      "llmProxy": {
        "title": "전용 LLM 프록시 서버",
        "description": "모든 LLM 요청은 API 키를 관리하고, 요청을 정규화하고, 사용량을 추적하고, 청구를 처리하는 서버 프록시를 통해 라우팅됩니다.",
        "benefits": [
          "API 키가 서버를 떠나지 않음",
          "모든 프로바이더에 대한 단일 요청 형식",
          "중앙화된 사용량 추적과 청구",
          "클라이언트 업데이트 없이 프로바이더 페일오버",
          "콘텐츠 필터링과 속도 제한"
        ],
        "tradeoffs": [
          "서버 인프라 필요",
          "요청에 네트워크 지연 추가",
          "서버가 단일 실패 지점이 됨",
          "프로바이더 통합 유지 필요"
        ],
        "implementation": "server/src/handlers/proxy/의 핸들러가 있는 Actix-Web 서버. provider_transformers/의 변환기가 요청을 정규화합니다."
      },
      "websocket": {
        "title": "모바일을 위한 WebSocket 릴레이",
        "description": "데스크톱과 모바일 클라이언트는 디바이스 연결, 터미널 스트리밍, 작업 동기화를 위해 WebSocket 릴레이를 통해 연결합니다.",
        "benefits": [
          "실시간 양방향 통신",
          "직접적인 P2P 네트워킹 필요 없음",
          "NAT와 방화벽을 통해 작동",
          "여러 연결된 디바이스 지원"
        ],
        "tradeoffs": [
          "지속적인 서버 연결 필요",
          "대규모 페이로드에 대한 릴레이 지연 추가",
          "연결 관리 복잡성",
          "재연결 및 하트비트 로직 필요"
        ],
        "implementation": "device_link_ws.rs가 세션 추적, 하트비트, 터미널 출력을 위한 PTC1 바이너리 프레이밍으로 릴레이를 구현합니다."
      }
    },
    "operational": {
      "heading": "운영상의 결과",
      "items": [
        "Tauri: 각 플랫폼에 대한 별도 빌드 필요. CI/CD가 크로스 컴파일하거나 플랫폼 특화 러너를 사용해야 함.",
        "SQLite: 데이터베이스 파일이 터미널 출력과 함께 증가. 장기 실행 인스턴스에 대한 주기적 정리 필요 가능.",
        "LLM 프록시: 서버 다운타임이 모든 LLM 작업을 차단. 프로덕션을 위한 모니터링과 중복성 필요.",
        "WebSocket: 재연결 로직이 복잡성 추가. 클라이언트가 연결 끊김을 우아하게 처리해야 함."
      ]
    },
    "securityBoundaries": {
      "heading": "보안 경계",
      "description": "아키텍처는 노출을 제한하는 명확한 보안 경계를 만듭니다:",
      "items": [
        "API 키는 서버 볼트에 저장, 클라이언트에 전송되지 않음",
        "JWT 토큰은 JWKS 순환과 함께 모든 요청에서 검증",
        "기능 기반 권한이 파일 시스템 액세스 제한",
        "LLM에 전송되는 콘텐츠는 명시적 사용자 승인 필요",
        "감사 로그가 사용자 컨텍스트와 함께 모든 LLM 요청 추적"
      ]
    },
    "whenToReconsider": {
      "heading": "재고할 때",
      "description": "요구사항이 크게 변경되면 이러한 결정을 다시 검토해야 할 수 있습니다:",
      "items": [
        "브라우저 전용 액세스가 필요한 경우, Tauri 대신 웹 기반 대안 고려",
        "멀티 디바이스 동기화가 중요한 경우, 서버 측 작업 저장 고려",
        "프로바이더 락인이 허용되는 경우, 직접 API 호출이 지연을 줄일 수 있음",
        "모바일이 주요인 경우, 디바이스 연결 대신 네이티브 앱 고려"
      ]
    }
  },
  "dataModel": {
    "meta": {
      "title": "데이터 모델 및 저장소 - PlanToCode",
      "description": "SQLite 엔티티, 관계, 앱 재시작 시 상태가 재수화되는 방법."
    },
    "category": "아키텍처",
    "date": "2025-09-25",
    "readTime": "10분",
    "title": "데이터 모델 및 저장소",
    "description": "SQLite 엔티티, 관계, 상태가 재수화되는 방법.",
    "intro": "PlanToCode는 모든 로컬 상태에 SQLite를 사용합니다. 이 문서는 스키마, 엔티티 관계, 앱 재시작 시 상태가 복원되는 방법을 설명합니다.",
    "sqlite": {
      "heading": "SQLite 구성",
      "description": "데이터베이스는 동시 읽기/쓰기 액세스를 위해 WAL 모드를 사용합니다. 파일은 Tauri 앱 데이터 디렉토리에 저장됩니다 (Linux에서 ~/.local/share/plantocode, macOS에서 ~/Library/Application Support/plantocode).",
      "migrations": "스키마 마이그레이션은 consolidated_schema.sql에 통합됩니다. 앱은 시작 시 스키마 버전을 확인하고 보류 중인 마이그레이션을 실행합니다."
    },
    "entities": {
      "heading": "핵심 엔티티",
      "items": [
        "sessions: 작업 설명, 파일 선택, 모델 기본 설정, 검색 설정, 비디오/병합 프롬프트, 히스토리 인덱스가 있는 프로젝트 컨텍스트",
        "background_jobs: 프롬프트, 응답, 토큰, 비용, is_finalized 플래그, error_message가 있는 LLM 기반 작업",
        "terminal_sessions: 출력 로그, 상태, 프로세스 정보가 있는 PTY 세션",
        "task_description_history: 작업 설명에 대한 버전 히스토리",
        "file_selection_history: 파일 선택에 대한 버전 히스토리",
        "project_system_prompts: 프로젝트별 프롬프트 오버라이드",
        "key_value_store: 앱 설정 및 구성",
        "error_logs: 클라이언트 측 오류 추적",
        "migrations: 타임스탬프와 함께 적용된 데이터베이스 마이그레이션 추적",
        "db_diagnostic_logs: 데이터베이스 진단 이슈와 오류 기록",
        "app_settings: 설명이 있는 애플리케이션 구성 키-값 쌍"
      ]
    },
    "visuals": {
      "schema": {
        "title": "엔티티 관계 다이어그램",
        "description": "SQLite 스키마와 관계의 시각적 표현.",
        "imageSrc": "/images/docs/data-model/schema.svg",
        "imageAlt": "데이터베이스 스키마 다이어그램",
        "caption": "데이터베이스 스키마 다이어그램을 위한 플레이스홀더."
      }
    },
    "relationships": {
      "heading": "엔티티 관계",
      "description": "엔티티는 연쇄 삭제 규칙이 있는 외래 키를 통해 연결됩니다:",
      "links": [
        "sessions → background_jobs: 일대다, 연쇄 삭제",
        "background_jobs → terminal_sessions: job_id를 통한 선택적 일대일 링크",
        "sessions → task_description_history: 버전 추적을 위한 일대다",
        "sessions → file_selection_history: 버전 추적을 위한 일대다"
      ]
    },
    "repositories": {
      "heading": "리포지토리 레이어",
      "description": "모든 데이터베이스 액세스는 desktop/src-tauri/src/db_utils/의 타입화된 리포지토리를 통해 이루어집니다:",
      "examples": [
        "background_job_repository/: base.rs, worker.rs, metadata.rs, cleanup.rs로 모듈화",
        "session_repository.rs: 히스토리 관리가 있는 세션 CRUD",
        "terminal_repository.rs: 터미널 세션 영속 및 출력 로깅",
        "settings_repository.rs: 키-값 설정 저장소"
      ]
    },
    "rehydration": {
      "heading": "상태 재수화",
      "description": "앱이 시작되면 SQLite에서 상태가 복원됩니다:",
      "sessions": "활성 세션은 작업 설명, 파일 선택, 모델 기본 설정과 함께 로드됩니다. 최근 세션은 세션 선택기에서 사용 가능합니다."
    },
    "retention": {
      "heading": "데이터 보존",
      "description": "구성 가능한 보존 기간에 따라 오래된 데이터가 정리됩니다:",
      "exports": "세션과 작업은 정리 전에 백업을 위해 내보낼 수 있습니다."
    },
    "cta": {
      "heading": "작업 처리 탐색하기",
      "description": "백그라운드 작업이 이 데이터 모델을 어떻게 사용하는지 확인하세요.",
      "links": {
        "jobs": "백그라운드 작업",
        "terminals": "터미널 세션"
      }
    }
  },
  "serverSetup": {
    "meta": {
      "title": "전용 서버 설정 - PlanToCode",
      "description": "Ansible 기반 인프라 설정: 기본 강화, PostgreSQL, Redis, 애플리케이션 배포."
    },
    "category": "배포",
    "date": "2025-09-25",
    "readTime": "12분",
    "title": "전용 서버 설정",
    "description": "Ansible 기반 인프라: 기본 강화, 앱 배포, vault 관리 시크릿.",
    "intro": "PlanToCode는 Ansible 플레이북을 통해 관리되는 전용 서버에서 실행됩니다. 이 문서는 인프라 설정, 보안 강화, 배포 프로세스를 다룹니다.",
    "layers": {
      "heading": "인프라 레이어",
      "description": "인프라는 각각 전용 플레이북에 의해 관리되는 레이어로 구성됩니다:",
      "items": [
        "기본 레이어: OS 강화, SSH 구성, 방화벽 규칙",
        "데이터베이스 레이어: 복제와 백업이 있는 PostgreSQL 17",
        "캐시 레이어: 세션 상태와 작업 큐를 위한 Redis 7+",
        "애플리케이션 레이어: systemd 서비스가 있는 Rust 서버 바이너리",
        "프록시 레이어: SSL 종료가 있는 Nginx 리버스 프록시"
      ]
    },
    "servers": {
      "heading": "서버 지역",
      "description": "PlanToCode는 지리적 중복성을 위해 두 지역에서 실행됩니다:",
      "items": [
        "EU 지역: Hetzner 전용 서버 (api-eu.plantocode.com)",
        "US 지역: InterServer 전용 서버 (api-us.plantocode.com)"
      ]
    },
    "requirements": {
      "heading": "서버 요구사항",
      "items": [
        "Debian 12 또는 Ubuntu 22.04 LTS",
        "4+ CPU 코어, 16GB+ RAM, 200GB+ SSD",
        "포트 22, 80, 443에 대한 방화벽 액세스가 있는 공용 IPv4",
        "Ansible 배포를 위한 SSH 키 액세스"
      ]
    },
    "hardening": {
      "heading": "기본 강화",
      "description": "site-base.yml이 보안 강화를 적용합니다:",
      "items": [
        "루트 SSH 로그인 비활성화, 키 인증 필요",
        "최소 열린 포트로 UFW 방화벽 구성",
        "무차별 대입 보호를 위한 fail2ban 설치",
        "자동 보안 업데이트 활성화",
        "감사 로깅 구성"
      ]
    },
    "postgresql": {
      "heading": "PostgreSQL 설정",
      "description": "PostgreSQL 17이 프로덕션 용도로 구성됩니다:",
      "items": [
        "PgBouncer를 통한 연결 풀링",
        "pg_dump를 통한 자동화된 일일 백업",
        "시점 복구를 위한 WAL 아카이빙",
        "모든 연결에 SSL 필수",
        "멀티 테넌트 데이터를 위한 행 수준 보안"
      ]
    },
    "redis": {
      "heading": "Redis 설정",
      "description": "Redis 7+가 캐싱과 세션 상태를 처리합니다:",
      "items": [
        "비밀번호 인증 필수",
        "내구성을 위한 AOF 영속",
        "퇴거 정책이 있는 메모리 제한",
        "연결을 위한 TLS 암호화"
      ]
    },
    "zeroDowntime": {
      "heading": "무중단 배포",
      "description": "배포는 롤링 업데이트 전략을 사용합니다:",
      "items": [
        "실행 중인 버전과 함께 새 바이너리 업로드",
        "새 버전이 준비되었는지 헬스 체크 확인",
        "정상 종료로 Systemd 재시작",
        "전환 중 로드 밸런서가 연결 드레인",
        "이전 바이너리 심볼릭 링크를 통한 롤백 가능"
      ]
    },
    "quickStart": {
      "heading": "빠른 시작",
      "steps": [
        "인프라 리포지토리 클론",
        "inventory.example을 inventory로 복사하고 호스트 구성",
        ".vault_pass에 vault 비밀번호 설정",
        "실행: ansible-playbook -i inventory site-base.yml",
        "실행: ansible-playbook -i inventory site-app.yml"
      ]
    },
    "vault": {
      "heading": "시크릿 관리",
      "description": "민감한 구성은 Ansible Vault를 사용합니다:",
      "items": [
        "데이터베이스 자격 증명",
        "LLM 프로바이더용 API 키",
        "SSL 인증서와 개인 키",
        "Auth0 클라이언트 시크릿",
        "Stripe 웹훅 시크릿"
      ]
    },
    "operations": {
      "heading": "일반 작업",
      "items": [
        "ansible-playbook -i inventory site-app.yml --tags deploy",
        "ansible-playbook -i inventory site-base.yml --tags backup",
        "ansible-playbook -i inventory site-app.yml --tags rollback",
        "ansible-playbook -i inventory site-base.yml --tags logs"
      ]
    },
    "ssl": {
      "heading": "SSL/TLS 구성",
      "description": "Let's Encrypt가 무료 SSL 인증서를 제공합니다:",
      "items": [
        "Nginx 플러그인으로 Certbot 구성",
        "cron 작업을 통한 자동 갱신",
        "HSTS 헤더 활성화",
        "TLS 1.2+ 전용, 최신 암호 스위트"
      ]
    },
    "security": {
      "heading": "보안 체크리스트",
      "items": [
        "모든 기본 비밀번호 변경됨",
        "SSH 키 순환 예약됨",
        "방화벽 규칙 감사됨",
        "보안 업데이트 자동화됨",
        "백업 복원 테스트됨"
      ]
    },
    "recovery": {
      "heading": "재해 복구",
      "description": "일반적인 실패 시나리오에 대한 복구 절차:",
      "items": [
        "데이터베이스 손상: 최신 pg_dump 백업에서 복원",
        "서버 장애: 새 서버 프로비저닝하고 플레이북 실행",
        "SSL 만료: 수동 certbot renew --force-renewal",
        "보안 침해: 모든 자격 증명 순환, 로그 감사"
      ]
    }
  },
  "tauriV2": {
    "meta": {
      "title": "Tauri v2 개발 가이드 - PlanToCode",
      "description": "Tauri v2를 위한 프로젝트 레이아웃, 명령, 기능, 개발 워크플로우."
    },
    "category": "배포",
    "date": "2025-09-25",
    "readTime": "10분",
    "title": "Tauri v2 개발 가이드",
    "description": "Tauri v2를 위한 프로젝트 레이아웃, 명령, 기능 기반 권한.",
    "intro": "PlanToCode는 데스크톱 애플리케이션에 Tauri v2를 사용합니다. 이 가이드는 프로젝트 구조, 명령 시스템, 기능 기반 권한, 개발 워크플로우를 다룹니다.",
    "projectLayout": {
      "heading": "프로젝트 레이아웃",
      "description": "데스크톱 애플리케이션은 표준 Tauri v2 관례를 따릅니다:",
      "items": [
        "desktop/src/: 컴포넌트, 훅, 프로바이더가 있는 React 프론트엔드",
        "desktop/src-tauri/: 명령, 작업, 서비스가 있는 Rust 백엔드",
        "desktop/src-tauri/src/lib.rs: 애플리케이션 진입점",
        "desktop/src-tauri/src/commands/: Tauri 명령 핸들러 (~35개 모듈)",
        "desktop/src-tauri/capabilities/: 권한 정의",
        "desktop/src-tauri/tauri.conf.json: Tauri 구성"
      ]
    },
    "configuration": {
      "heading": "Tauri 구성",
      "description": "tauri.conf.json이 애플리케이션을 구성합니다:",
      "items": [
        "앱 메타데이터를 위한 productName, version, identifier",
        "프론트엔드를 위한 build.beforeDevCommand와 beforeBuildCommand",
        "설치 프로그램을 위한 bundle 설정 (DMG, NSIS, AppImage)",
        "Content Security Policy를 위한 security.csp",
        "공식 플러그인을 위한 plugins 구성"
      ]
    },
    "capabilities": {
      "heading": "기능 기반 권한",
      "description": "Tauri v2는 앱이 액세스할 수 있는 것을 제어하기 위해 기능을 사용합니다:",
      "items": [
        "default.json: 모든 윈도우를 위한 기본 권한",
        "desktop-default.json: 데스크톱 특화 권한",
        "plantocode-api.json: PlanToCode 명령을 위한 커스텀 권한",
        "권한이 액세스 허용: 파일 시스템, 셸, http, 다이얼로그, 알림"
      ]
    },
    "plugins": {
      "heading": "Tauri 플러그인",
      "description": "PlanToCode는 여러 공식 Tauri 플러그인을 사용합니다:",
      "items": [
        "tauri-plugin-http: API 호출을 위한 HTTP 클라이언트",
        "tauri-plugin-dialog: 네이티브 파일/폴더 선택기",
        "tauri-plugin-shell: 셸 명령 실행",
        "tauri-plugin-store: 영속적 키-값 저장소",
        "tauri-plugin-notification: 데스크톱 알림",
        "tauri-plugin-updater: 인앱 업데이트",
        "tauri-plugin-single-instance: 단일 인스턴스 적용"
      ]
    },
    "appState": {
      "heading": "애플리케이션 상태",
      "description": "Tauri의 상태 시스템을 통해 관리되는 Rust 상태:",
      "items": [
        "AppState 구조체가 공유 상태 보유",
        "서버 URL과 기능 플래그를 위한 RuntimeConfig",
        "보안 자격 증명 저장을 위한 TokenManager",
        "AI 모델 구성을 위한 ConfigCache"
      ]
    },
    "commands": {
      "heading": "명령 생성하기",
      "description": "Tauri 명령이 Rust 함수를 프론트엔드에 노출합니다:",
      "items": [
        "async 함수에 #[tauri::command] 속성 사용",
        "오류 처리를 위해 Result<T, String> 반환",
        "State<AppState> 매개변수를 통해 상태 액세스",
        "lib.rs invoke_handler에 등록"
      ]
    },
    "singleInstance": {
      "heading": "단일 인스턴스",
      "description": "앱이 데이터 충돌을 방지하기 위해 단일 인스턴스를 적용합니다:",
      "items": [
        "tauri-plugin-single-instance가 감지 처리",
        "두 번째 실행은 기존 윈도우에 포커스",
        "딥 링크가 실행 중인 인스턴스로 전달"
      ]
    },
    "devWorkflow": {
      "heading": "개발 워크플로우",
      "description": "개발을 위한 일반 명령:",
      "items": [
        "pnpm tauri dev: 핫 리로드와 함께 개발 시작",
        "pnpm tauri build: 프로덕션 릴리스 빌드",
        "cargo test: Rust 테스트 실행",
        "cargo clippy: Rust 코드 린트"
      ]
    },
    "mobile": {
      "heading": "모바일 고려사항",
      "description": "Tauri v2는 모바일을 지원하지만, PlanToCode는 네이티브 Swift를 사용합니다:",
      "items": [
        "네이티브 경험을 위해 SwiftUI로 빌드된 iOS 앱",
        "데스크톱과 모바일 간 공유 API 계약",
        "WebSocket 릴레이를 통한 디바이스 연결"
      ]
    },
    "distribution": {
      "heading": "배포",
      "description": "각 플랫폼을 위한 빌드 아티팩트:",
      "items": [
        "macOS: 유니버설 바이너리가 있는 .dmg (Intel + Apple Silicon)",
        "Windows: NSIS 설치 프로그램과 MSIX 패키지",
        "Linux: 광범위한 호환성을 위한 AppImage"
      ]
    }
  },
  "distributionMacos": {
    "meta": {
      "title": "macOS 배포 - PlanToCode",
      "description": "macOS를 위한 코드 서명, 공증, DMG 패키징, 업데이터 구성."
    },
    "category": "배포",
    "date": "2025-09-25",
    "readTime": "10분",
    "title": "macOS 배포",
    "description": "서명, 공증, DMG 패키징, 업데이터 아티팩트.",
    "intro": "macOS에서 배포하려면 코드 서명, 공증, 적절한 패키징이 필요합니다. 이 문서는 PlanToCode의 전체 프로세스를 다룹니다.",
    "signing": {
      "heading": "코드 서명",
      "description": "모든 바이너리는 Apple Developer ID로 서명해야 합니다:",
      "items": [
        "앱 서명을 위한 Developer ID Application 인증서",
        "PKG 서명을 위한 Developer ID Installer 인증서",
        "CI 시크릿에 저장되고 키체인으로 가져온 인증서",
        "공증 호환성을 위해 활성화된 강화된 런타임"
      ]
    },
    "entitlements": {
      "heading": "권한",
      "description": "PlanToCode 기능에 필요한 권한:",
      "items": [
        "com.apple.security.cs.allow-jit",
        "com.apple.security.cs.allow-unsigned-executable-memory",
        "com.apple.security.device.audio-input",
        "com.apple.security.network.client",
        "com.apple.security.files.user-selected.read-write"
      ]
    },
    "build": {
      "heading": "빌드 프로세스",
      "description": "서명된 릴리스를 빌드하는 단계:",
      "steps": [
        "pnpm tauri build --target universal-apple-darwin 실행",
        "Tauri가 환경에서 APPLE_SIGNING_IDENTITY로 서명",
        "Intel + ARM을 위해 lipo로 유니버설 바이너리 생성",
        "커스텀 배경과 레이아웃으로 DMG 패키징"
      ]
    },
    "universalBinaries": {
      "heading": "유니버설 바이너리",
      "description": "PlanToCode는 유니버설 바이너리로 제공됩니다:",
      "items": [
        "단일 .app이 Intel과 Apple Silicon 모두 지원",
        "--target universal-apple-darwin으로 빌드",
        "약간 더 큰 바이너리지만 더 간단한 배포",
        "두 아키텍처 모두에서 네이티브 성능"
      ]
    },
    "notarization": {
      "heading": "공증",
      "description": "Gatekeeper 승인을 위해 Apple 공증이 필요합니다:",
      "items": [
        "Apple 공증 서비스에 DMG 제출",
        "App Store Connect 자격 증명과 함께 notarytool 사용",
        "스테이플링으로 공증 티켓을 DMG에 첨부",
        "프로세스는 일반적으로 1-5분 소요"
      ]
    },
    "updater": {
      "heading": "인앱 업데이트",
      "description": "tauri-plugin-updater가 자동 업데이트를 처리합니다:",
      "items": [
        "실행 시 업데이트 엔드포인트 확인",
        "백그라운드에서 새 버전 다운로드",
        "적용을 위해 재시작 프롬프트",
        "설치 전 서명 검증"
      ]
    },
    "latestJson": {
      "heading": "업데이트 매니페스트",
      "description": "latest.json이 사용 가능한 업데이트를 설명합니다:",
      "items": [
        "version: 시맨틱 버전 문자열",
        "platforms.darwin-universal: URL과 서명",
        "notes: markdown의 릴리스 노트",
        "pub_date: ISO 8601 게시 타임스탬프"
      ]
    },
    "pitfalls": {
      "heading": "일반적인 함정",
      "description": "자주 발생하는 이슈:",
      "items": [
        "CI 중 키체인 잠금: 서명 전에 잠금 해제",
        "공증 타임아웃: 지수 백오프로 재시도",
        "잘못된 서명: 권한이 기능과 일치하는지 확인",
        "Gatekeeper 거부: 공증이 올바르게 스테이플되었는지 확인"
      ]
    },
    "verification": {
      "heading": "검증 명령",
      "description": "서명과 공증을 검증하는 명령:",
      "items": [
        "codesign -dv --verbose=4 PlanToCode.app",
        "spctl --assess --verbose PlanToCode.app",
        "stapler validate PlanToCode.dmg",
        "xcrun notarytool log <submission-id>"
      ]
    }
  },
  "distributionWindows": {
    "meta": {
      "title": "Windows 배포 - PlanToCode",
      "description": "Windows를 위한 NSIS 설치 프로그램, MSIX 패키징, Microsoft Store 제출, 코드 서명."
    },
    "category": "배포",
    "date": "2025-09-25",
    "readTime": "10분",
    "title": "Windows 배포 및 스토어",
    "description": "NSIS 빌드, MSIX 패키징, Microsoft Store 제출.",
    "intro": "PlanToCode는 직접 다운로드(NSIS 설치 프로그램)와 Microsoft Store(MSIX 패키지) 모두를 통해 Windows에서 배포됩니다. 이 문서는 두 배포 방법을 다룹니다.",
    "prereqs": {
      "heading": "전제 조건",
      "description": "필수 도구와 인증서:",
      "items": [
        "코드 서명 인증서 (EV 또는 표준)",
        "signtool을 위한 Windows SDK",
        "설치 프로그램 빌드를 위한 NSIS",
        "Store 제출을 위한 MSIX Packaging Tool"
      ]
    },
    "nsisBuild": {
      "heading": "NSIS 설치 프로그램",
      "description": "Tauri는 기본적으로 NSIS 설치 프로그램을 빌드합니다:",
      "items": [
        "PlanToCode 브랜딩이 있는 커스텀 설치 프로그램 UI",
        "사용자별 설치 (관리자 필요 없음)",
        "시작 메뉴 및 데스크톱 바로 가기",
        "깨끗한 제거가 있는 언인스톨러"
      ]
    },
    "codeSigning": {
      "heading": "코드 서명",
      "description": "Authenticode를 사용한 Windows 코드 서명:",
      "items": [
        "Windows SDK의 signtool로 서명",
        "신뢰할 수 있는 TSA 서버의 타임스탬프",
        "EV 인증서가 SmartScreen 평판 제공",
        "CI가 인증서와 비밀번호에 시크릿 사용"
      ]
    },
    "msixPackaging": {
      "heading": "Microsoft Store를 위한 MSIX",
      "description": "MSIX가 Store 호환 패키징을 제공합니다:",
      "items": [
        "AppxManifest.xml이 기능 정의",
        "가상 파일 시스템 격리",
        "Store를 통한 자동 업데이트",
        "샌드박스 실행 환경"
      ]
    },
    "msixConfig": {
      "heading": "MSIX 구성",
      "description": "주요 AppxManifest 설정:",
      "items": [
        "Identity: Name, Publisher, Version",
        "Capabilities: internetClient, microphone",
        "Visual elements: Tiles, splash screen",
        "파일 연결 및 프로토콜 핸들러"
      ]
    },
    "msixSteps": {
      "heading": "MSIX 빌드 단계",
      "description": "MSIX 패키지를 만드는 프로세스:",
      "steps": [
        "pnpm tauri build로 릴리스 빌드",
        "올바른 identity로 AppxManifest.xml 생성",
        "MakeAppx.exe로 패키징",
        "SignTool로 서명",
        "Windows App Cert Kit으로 검증"
      ]
    },
    "store": {
      "heading": "Microsoft Store 제출",
      "description": "Store 제출 프로세스:",
      "items": [
        "Partner Center에서 앱 생성",
        "MSIX 패키지 업로드",
        "가격 구성 (IAP 크레딧이 있는 무료)",
        "인증을 위해 제출",
        "검토는 1-3 영업일 소요"
      ]
    },
    "updaterWindows": {
      "heading": "Windows 업데이트",
      "description": "각 배포를 위한 업데이트 메커니즘:",
      "items": [
        "NSIS: GitHub 릴리스와 함께 tauri-plugin-updater",
        "MSIX/Store: Microsoft Store를 통한 자동",
        "둘 다 실행 시 업데이트 확인"
      ]
    },
    "webview2": {
      "heading": "WebView2 런타임",
      "description": "Tauri는 Windows에서 WebView2를 사용합니다:",
      "items": [
        "설치 프로그램에 번들된 WebView2 부트스트래퍼",
        "Evergreen 버전 자동 업데이트",
        "격리를 위한 고정 버전 사용 가능",
        "Windows 10 1803+ 필수"
      ]
    },
    "troubleshooting": {
      "heading": "문제 해결",
      "description": "일반적인 Windows 배포 이슈:",
      "items": [
        "SmartScreen 경고: EV 인증서 사용 또는 평판 구축",
        "WebView2 누락: 부트스트래퍼 실행 확인",
        "Store 거부: 인증 보고서 세부사항 검토",
        "업데이트 실패: 서명과 매니페스트 버전 확인"
      ]
    }
  },
  "promptTypes": {
    "meta": {
      "title": "프롬프트 유형 및 템플릿 - PlanToCode",
      "description": "프롬프트 기반 작업 유형 카탈로그 및 템플릿 조립 프로세스."
    },
    "category": "참조",
    "date": "2025-09-25",
    "readTime": "8분",
    "title": "프롬프트 유형 및 템플릿",
    "description": "프롬프트 기반 작업 유형 카탈로그 및 템플릿 조립.",
    "intro": "PlanToCode의 모든 LLM 기반 작업은 템플릿에서 구축된 구조화된 프롬프트를 사용합니다. 이 문서는 작업 유형을 카탈로그화하고 프롬프트가 조립되는 방법을 설명합니다.",
    "catalog": {
      "heading": "작업 유형 카탈로그",
      "items": [
        {
          "job": "implementation_plan",
          "title": "구현 계획",
          "description": "XML 구조로 파일별 구현 계획을 생성합니다. 점진적 표시를 위해 스트리밍을 사용합니다."
        },
        {
          "job": "implementation_plan_merge",
          "title": "계획 병합",
          "description": "사용자 지침으로 여러 계획을 결합합니다. 소스 계획은 XML 태그로 래핑됩니다."
        },
        {
          "job": "text_improvement",
          "title": "텍스트 개선",
          "description": "서식을 유지하면서 선택한 텍스트를 다듬습니다. 빠른 결과를 위해 비스트리밍."
        },
        {
          "job": "root_folder_selection",
          "title": "루트 폴더 선택",
          "description": "디렉토리 트리를 분석하여 관련 프로젝트 루트를 선택합니다. JSON 배열을 반환합니다."
        },
        {
          "job": "regex_file_filter",
          "title": "Regex 파일 필터",
          "description": "작업 설명을 기반으로 파일 필터링을 위한 regex 패턴을 생성합니다."
        },
        {
          "job": "file_relevance_assessment",
          "title": "파일 관련성 평가",
          "description": "작업에 대한 파일 내용 관련성을 점수화합니다. 배치로 처리합니다."
        },
        {
          "job": "extended_path_finder",
          "title": "확장 경로 탐색기",
          "description": "임포트와 의존성을 통해 관련 파일을 발견합니다."
        },
        {
          "job": "web_search_prompts",
          "title": "웹 검색 프롬프트",
          "description": "딥 리서치 워크플로우를 위한 연구 쿼리를 생성합니다."
        },
        {
          "job": "video_analysis",
          "title": "비디오 분석",
          "description": "UI 상태와 액션 시퀀스를 위해 화면 녹화를 분석합니다."
        }
      ]
    },
    "templateStructure": {
      "heading": "템플릿 구조",
      "description": "프롬프트는 시스템 템플릿과 사용자 콘텐츠에서 조립됩니다:",
      "sampleLabel": "예시 템플릿 구조:",
      "sample": "<system_prompt>\n  You are an AI assistant that generates implementation plans.\n  [template content from server]\n</system_prompt>\n\n<task>\n  [user's task description]\n</task>\n\n<files>\n  [selected file paths and content]\n</files>\n\n<directory_tree>\n  [project structure]\n</directory_tree>"
    },
    "visuals": {
      "template": {
        "title": "프롬프트 조립 흐름",
        "description": "템플릿이 사용자 콘텐츠와 결합하여 완전한 프롬프트를 형성하는 방법.",
        "imageSrc": "/images/docs/implementation-plans/structure.svg",
        "imageAlt": "프롬프트 템플릿 조립 다이어그램",
        "caption": "프롬프트 조립 다이어그램을 위한 플레이스홀더."
      }
    },
    "assembly": {
      "heading": "조립 프로세스",
      "steps": [
        "프로세서가 작업 모델 구성에서 템플릿 ID를 검색",
        "시스템 프롬프트 템플릿이 서버 캐시에서 로드됨",
        "사용자 콘텐츠가 의미론적 XML 태그로 래핑됨",
        "컨텍스트(파일, 트리)가 작업 유형에 따라 추가됨",
        "완전한 프롬프트가 전송 전에 작업 레코드에 저장됨"
      ]
    },
    "serverConfig": {
      "heading": "서버 측 구성",
      "description": "템플릿과 모델 설정은 서버 측에서 구성됩니다:",
      "fields": "task_model_config 정의: default_model, allowed_models, system_prompt_template_id, max_tokens, temperature"
    },
    "tokenGuards": {
      "heading": "토큰 가드레일",
      "description": "각 작업 유형은 컨텍스트 오버플로우를 방지하기 위한 토큰 제한이 있습니다:",
      "items": [
        "max_tokens_input: 최대 프롬프트 크기",
        "max_tokens_output: 최대 응답 크기",
        "전송 전 검증으로 낭비되는 API 호출 방지",
        "UI에서 토큰 수를 표시하고 한도에 가까워지면 경고"
      ]
    },
    "versioning": {
      "heading": "템플릿 버전 관리",
      "description": "시스템 프롬프트 템플릿은 재현성을 위해 버전 관리됩니다. 각 작업은 사용된 템플릿 ID를 기록하여 템플릿 버전 간 결과의 감사 및 비교를 가능하게 합니다."
    },
    "designNotes": {
      "heading": "설계 노트",
      "items": [
        "XML 태그는 LLM 파싱을 위한 명확한 경계를 제공",
        "의미론적 명명(task, files, context)이 모델 이해를 돕음",
        "템플릿은 사용자 입력을 살균하여 인스트럭션 인젝션을 방지",
        "스트리밍 작업은 완료 감지를 위해 종료 태그를 사용"
      ]
    },
    "cta": {
      "heading": "작업 처리를 실제로 보기",
      "description": "이러한 프롬프트가 작업 시스템을 통해 어떻게 흐르는지 알아보세요.",
      "links": {
        "jobs": "백그라운드 작업",
        "merge": "병합 지침"
      }
    }
  },
  "mergeInstructionsDoc": {
    "meta": {
      "title": "병합 지침 - PlanToCode",
      "description": "XML 태그가 지정된 소스 계획과 사용자 가이드를 사용하여 여러 계획 초안을 병합하는 방법."
    },
    "category": "계획",
    "date": "2025-09-25",
    "readTime": "8분",
    "title": "병합 지침",
    "description": "XML 태그가 지정된 소스 계획과 사용자 가이드를 사용하여 여러 계획 초안을 병합하는 방법.",
    "intro": "결합해야 하는 여러 구현 계획이 있을 때, 병합 워크플로우를 통해 계획을 선택하고, 가이드를 제공하고, 각 소스의 최상의 요소를 통합하는 통합 계획을 생성할 수 있습니다.",
    "processor": {
      "heading": "ImplementationPlanMergeProcessor",
      "description": "ImplementationPlanMergeProcessor는 소스 계획 응답을 가져오고, XML 태그 섹션으로 래핑하고, LlmTaskRunner를 통해 병합된 결과를 스트리밍합니다.",
      "payload": "source_job_ids 배열, 선택적 merge_instructions 문자열을 받고, 세션에서 모델 구성을 상속합니다.",
      "storage": "병합된 계획은 source_job_ids, merge_instructions, source_count, merged_at 타임스탬프, 세션 컨텍스트를 포함한 메타데이터와 함께 JobResultData::Text로 저장됩니다."
    },
    "inputs": {
      "heading": "병합 입력",
      "items": [
        "소스 계획: 계획 목록에서 선택된 2-5개의 구현 계획",
        "병합 지침: 결합 방법에 대한 사용자 가이드(우선순위, 충돌 해결)",
        "모델 선택: 병합 생성을 위한 LLM 모델",
        "작업 컨텍스트: 참조용 원래 작업 설명"
      ]
    },
    "xmlFormat": {
      "heading": "XML 태그가 지정된 소스 계획",
      "description": "소스 계획은 순차적 식별자와 함께 XML 태그로 래핑됩니다:",
      "example": "<task_description>\n  [original task from session]\n</task_description>\n\n<source_plans>\n  <implementation_plan_1>\n    [full plan content from first source]\n  </implementation_plan_1>\n  <implementation_plan_2>\n    [full plan content from second source]\n  </implementation_plan_2>\n</source_plans>\n\n<user_instructions>\n  Prioritize API structure from plan 1.\n  Use database schema from plan 2.\n  Resolve conflicts by preferring newer patterns.\n</user_instructions>"
    },
    "prompt": {
      "heading": "병합 프롬프트 구조",
      "description": "병합 프롬프트는 지능적인 결합에 필요한 모든 컨텍스트를 포함합니다:",
      "sections": [
        "병합 가이드라인이 있는 시스템 프롬프트",
        "XML 태그의 소스 계획",
        "사용자의 병합 지침",
        "컨텍스트용 작업 설명",
        "출력 형식 요구사항"
      ]
    },
    "visuals": {
      "mergeWalkthrough": {
        "title": "병합 워크플로우 워크스루",
        "description": "선택에서 출력까지 전체 병합 프로세스를 보여주는 비디오.",
        "videoSrc": "/videos/docs/merge-instructions/walkthrough.mp4",
        "posterSrc": "/images/docs/merge-instructions/flow.svg",
        "caption": "병합 워크스루 비디오를 위한 플레이스홀더."
      },
      "mergeFlow": {
        "title": "병합 지침 흐름",
        "description": "XML 태그가 지정된 소스 계획으로 다중 모델 병합 워크플로우를 보여주는 다이어그램.",
        "imageSrc": "/images/docs/merge-instructions/flow.svg",
        "caption": "소스 선택, 지침 처리, 출력 생성을 보여주는 병합 흐름"
      }
    },
    "rules": {
      "heading": "병합 규칙",
      "description": "LLM은 계획을 병합할 때 다음 규칙을 따릅니다:",
      "examples": [
        "소스 계획에 지정된 대로 파일 경로를 정확히 유지",
        "모든 소스에서 충돌하지 않는 변경사항 결합",
        "충돌의 경우 명시적인 사용자 지침 따르기",
        "병합된 콘텐츠 전체에서 일관된 코드 스타일 유지",
        "소스 계획을 나타내는 출처 코멘트 포함"
      ]
    },
    "output": {
      "heading": "병합된 출력",
      "description": "병합된 계획은 개별 계획과 동일한 유연한 형식을 따라 LLM에서 원시 텍스트로 반환됩니다.",
      "provenance": "각 섹션에는 어떤 소스 계획이 콘텐츠에 기여했는지 나타내는 코멘트가 포함됩니다.",
      "metadata": "source_job_ids, merge_instructions, source_count, merged_at 타임스탬프, planTitle, summary, isStructured (false), sessionName이 작업 메타데이터에 저장됩니다."
    },
    "ui": {
      "heading": "UI 통합",
      "description": "구현 계획 패널은 병합 워크플로우를 지원합니다:",
      "audit": "병합된 계획은 완전한 감사 추적을 위해 소스 계획에 다시 연결됩니다."
    },
    "cta": {
      "heading": "계획 생성에 대해 알아보기",
      "description": "병합하기 전에 개별 계획이 어떻게 생성되는지 이해하세요.",
      "links": {
        "plans": "구현 계획",
        "runtime": "런타임 워크스루"
      }
    }
  },
  "meetingIngestionDoc": {
    "meta": {
      "title": "회의 및 녹화 수집 - PlanToCode",
      "description": "비디오 분석을 통해 녹화가 구조화된 작업 입력 및 아티팩트가 되는 방법."
    },
    "category": "입력",
    "date": "2025-09-25",
    "readTime": "8분",
    "title": "회의 및 녹화 수집",
    "description": "녹화가 구조화된 작업 입력 및 아티팩트가 되는 방법.",
    "intro": "PlanToCode는 회의 녹화와 화면 캡처를 처리하여 작업 관련 정보를 추출할 수 있습니다. 이 문서는 녹화에서 구조화된 아티팩트까지의 수집 워크플로우를 설명합니다.",
    "visuals": {
      "ingestionFlow": {
        "title": "녹화 수집 흐름",
        "description": "녹화가 전사 및 분석을 통해 흐르는 방법.",
        "imageSrc": "/images/docs/deep-research/workflow.svg",
        "imageAlt": "녹화 수집 흐름 다이어그램",
        "caption": "수집 흐름 다이어그램을 위한 플레이스홀더."
      }
    },
    "inputs": {
      "heading": "지원되는 입력",
      "description": "회의 수집 파이프라인은 다양한 녹화 형식을 수용합니다:",
      "items": [
        "화면 녹화 (MP4, WebM, MOV)",
        "Zoom, Meet, Teams의 회의 녹화",
        "오디오 전용 파일 (MP3, WAV, M4A)",
        "데스크톱에서 직접 화면 캡처"
      ]
    },
    "uploadProcess": {
      "heading": "업로드 프로세스",
      "description": "녹화는 멀티파트 폼 데이터를 통해 서버로 업로드됩니다:",
      "stepsHeading": "처리 단계",
      "steps": [
        "파일이 서버 임시 저장소에 업로드됨",
        "메타데이터 추출 (재생 시간, 형식, 해상도)",
        "전사를 위해 오디오 트랙 분리",
        "비주얼 분석을 위해 비디오 프레임 샘플링",
        "결과가 결합되어 클라이언트로 반환"
      ]
    },
    "normalization": {
      "heading": "형식 정규화",
      "description": "처리 전에 다양한 입력 형식이 정규화됩니다. 오디오는 Whisper 호환성을 위해 16kHz 모노 WAV로 변환됩니다. 비디오는 구성 가능한 프레임 샘플링으로 네이티브 해상도에서 처리됩니다.",
      "outputs": "정규화된 출력은 입력 형식에 관계없이 일관된 다운스트림 처리를 보장합니다."
    },
    "multimodalAnalysis": {
      "heading": "멀티모달 분석",
      "description": "오디오와 비디오가 모두 있는 녹화는 멀티모달 모델을 사용하여 분석됩니다. {code} 접두사가 있는 모델은 네이티브 비디오 이해를 지원합니다.",
      "combined": "오디오 전사와 비주얼 분석이 결합되어 녹화 콘텐츠에 대한 포괄적인 이해를 생성합니다."
    },
    "transcription": {
      "heading": "오디오 전사",
      "description": "오디오 트랙은 서버 API를 통해 OpenAI Whisper를 사용하여 전사됩니다.",
      "attribution": "화자 분리는 여러 음성이 감지될 때 텍스트를 다른 화자에게 귀속시키려고 시도합니다.",
      "featuresHeading": "전사 기능",
      "features": [
        "자동 감지가 있는 다국어 지원",
        "정렬을 위한 단어 수준 타임스탬프",
        "화자 분리 (다중 화자)",
        "구두점 및 서식 복원"
      ]
    },
    "frames": {
      "heading": "프레임 샘플링",
      "description": "비디오 프레임은 UI 상태 변경 및 사용자 작업을 캡처하기 위해 구성 가능한 간격으로 샘플링됩니다.",
      "timestamps": "각 프레임에는 오디오 전사와의 상관관계를 위한 타임스탬프가 포함됩니다."
    },
    "structuredExtraction": {
      "heading": "구조화된 추출",
      "description": "결합된 분석은 계획에 적합한 구조화된 출력을 생성합니다:",
      "extractedHeading": "추출된 요소",
      "items": [
        "언급된 액션 아이템 및 결정사항",
        "표시된 UI 요소 및 탐색 경로",
        "시연된 오류 상태 및 이슈",
        "구현을 위한 기술적 컨텍스트"
      ]
    },
    "artifacts": {
      "heading": "분석 아티팩트",
      "description": "회의 분석은 세션에 저장되는 여러 아티팩트를 생성합니다:",
      "items": [
        "meeting_transcript: 타임스탬프가 있는 전체 텍스트",
        "action_items: 추출된 작업 및 결정사항",
        "ui_observations: 비주얼 상태 변경",
        "combined_context: 병합된 분석 요약"
      ]
    },
    "keyFiles": {
      "heading": "주요 소스 파일",
      "items": [
        "desktop/src/components/meeting/MeetingUploader.tsx",
        "server/src/handlers/proxy/video_handler.rs",
        "server/src/services/video_processor.rs"
      ]
    },
    "handoff": {
      "heading": "계획 핸드오프",
      "description": "회의 분석 아티팩트는 작업 설명에 통합될 수 있습니다:",
      "pipeline": "결합된 컨텍스트는 파일 탐색 및 계획 생성 파이프라인으로 흘러가며 구현 계획을 위한 풍부한 컨텍스트를 제공합니다."
    },
    "cta": {
      "heading": "비디오 분석으로 계속",
      "description": "비디오 프레임이 어떻게 분석되는지 자세히 알아보세요.",
      "links": {
        "video": "비디오 분석",
        "textImprovement": "텍스트 개선"
      }
    }
  },
  "videoAnalysisDoc": {
    "meta": {
      "title": "비디오 분석 - PlanToCode",
      "description": "화면 녹화에서의 프레임 샘플링, 프롬프트, 분석 아티팩트."
    },
    "category": "입력",
    "date": "2025-09-25",
    "readTime": "6분",
    "title": "비디오 분석",
    "description": "녹화에서의 프레임 샘플링, 프롬프트, 분석 아티팩트.",
    "intro": "비디오 분석은 화면 녹화에서 UI 상태와 액션 시퀀스를 추출합니다. 이를 통해 사용자 워크플로우와 버그 재현 컨텍스트를 이해할 수 있습니다.",
    "visuals": {
      "frameNotes": {
        "title": "비디오 분석 파이프라인",
        "description": "프레임이 분석 모델을 통해 흐르는 방법.",
        "imageSrc": "/assets/images/demo-video-analysis.jpg",
        "imageAlt": "비디오 분석 인터페이스",
        "caption": "프레임 캡처 및 분석 옵션을 보여주는 비디오 분석 인터페이스."
      }
    },
    "apiEndpoint": {
      "heading": "API 엔드포인트",
      "endpoint": "비디오 분석은 서버의 {code}에서 처리됩니다. 엔드포인트는 비디오 파일과 분석 매개변수가 포함된 멀티파트 폼 데이터를 수용합니다.",
      "payloadHeading": "페이로드 필드",
      "payloadFields": [
        "video: 비디오 파일 (MP4, WebM, MOV)",
        "model: 분석을 위한 모델 식별자",
        "prompt: 선택적 커스텀 분석 프롬프트",
        "max_frames: 샘플링할 최대 프레임 수",
        "fps: 프레임 샘플링 속도"
      ]
    },
    "inputs": {
      "heading": "지원되는 입력 형식",
      "items": [
        "H.264 또는 H.265 코덱이 있는 MP4",
        "VP8 또는 VP9 코덱이 있는 WebM",
        "화면 녹화 도구의 MOV",
        "최대 파일 크기: 100MB"
      ]
    },
    "sampling": {
      "heading": "프레임 샘플링",
      "description": "프레임은 커버리지와 API 비용의 균형을 맞추기 위해 구성 가능한 간격으로 추출됩니다. 낮은 프레임 속도는 토큰 사용량을 줄이지만 빠른 변경을 놓칠 수 있습니다.",
      "fps": "기본 속도는 초당 1프레임입니다. 상세한 UI 분석의 경우 2-3 FPS가 필요할 수 있습니다.",
      "parametersHeading": "샘플링 매개변수",
      "parameters": [
        "fps: 추출할 초당 프레임 수 (0.5-5)",
        "max_frames: 최대 총 프레임 수 (10-100)",
        "start_time: 샘플링을 시작할 오프셋",
        "end_time: 샘플링을 중지할 오프셋"
      ]
    },
    "modelRequirements": {
      "heading": "모델 요구사항",
      "format": "비디오 분석에는 비전 지원 모델이 필요합니다. 모델 식별자는 {code} 형식을 따릅니다. 현재 {code} 모델만 네이티브 비디오 분석을 지원합니다.",
      "reasoning": "Google Gemini 모델은 비디오를 네이티브로 처리할 수 있지만, 다른 비전 모델은 프레임별 이미지 분석이 필요합니다."
    },
    "analysis": {
      "heading": "분석 프로세스",
      "description": "샘플링된 프레임은 분석 프롬프트와 함께 비전 모델로 전송됩니다. 모델은 UI 상태와 사용자 액션에 대한 구조화된 관찰을 생성합니다.",
      "prompting": "시스템 프롬프트는 모델이 녹화의 특정 측면에 집중하도록 안내합니다.",
      "promptElementsHeading": "프롬프트 요소",
      "promptElements": [
        "UI 인벤토리: 보이는 요소와 컨트롤 나열",
        "액션 시퀀스: 사용자 액션을 순서대로 설명",
        "오류 감지: 오류 상태와 메시지 식별",
        "탐색 경로: 화면 전환 추적"
      ]
    },
    "outputs": {
      "heading": "분석 출력",
      "items": [
        "frame_observations: 프레임별 UI 설명",
        "action_timeline: 사용자 액션의 정렬된 목록",
        "error_summary: 관찰된 오류 또는 이슈",
        "context_summary: 고수준 워크플로우 설명"
      ]
    },
    "billing": {
      "heading": "토큰 사용량 및 청구",
      "description": "비디오 분석은 프레임 수와 해상도에 따라 토큰을 소비합니다. 각 프레임은 이미지 토큰으로 처리됩니다.",
      "tracked": [
        "tokens_sent: 프롬프트 + 이미지 토큰",
        "tokens_received: 분석 응답 토큰",
        "actual_cost: 모델 가격에서 계산됨"
      ]
    },
    "storage": {
      "heading": "결과 저장소",
      "description": "분석 결과는 task_type 'video_analysis'로 background_jobs 테이블에 저장됩니다. 응답에는 JSON 형식의 전체 분석이 포함됩니다.",
      "reuse": "결과는 작업 설명에 통합되거나 계획 워크플로우에서 직접 사용될 수 있습니다."
    },
    "keyFiles": {
      "heading": "주요 소스 파일",
      "items": [
        "server/src/handlers/proxy/video_handler.rs",
        "server/src/services/video_processor.rs",
        "desktop/src/components/video/VideoAnalyzer.tsx"
      ]
    },
    "integration": {
      "heading": "계획과의 통합",
      "description": "비디오 분석 출력은 컨텍스트 인식 계획을 위해 작업 설명에 직접 피드될 수 있습니다.",
      "followup": "context_summary는 구현 계획의 시작점으로 특히 유용합니다."
    },
    "cta": {
      "heading": "회의 수집 보기",
      "description": "비디오 분석이 더 넓은 회의 수집 워크플로우에 어떻게 맞는지 알아보세요.",
      "links": {
        "meeting": "회의 수집",
        "runtime": "런타임 워크스루"
      }
    }
  },
  "mobileIos": {
    "meta": {
      "title": "iOS 클라이언트 아키텍처 - PlanToCode",
      "description": "iOS 컴패니언 앱을 위한 Swift 워크플로우, Auth0 로그인 흐름, 디바이스 링크 세션 관리."
    },
    "category": "아키텍처",
    "date": "2025-09-25",
    "readTime": "12분",
    "title": "iOS 클라이언트 아키텍처",
    "description": "Swift 워크플로우, Auth0 로그인 흐름, 디바이스 링크 세션 관리.",
    "intro": "PlanToCode iOS 앱은 연결된 데스크톱 세션에 연결하는 컴패니언 클라이언트입니다. 데스크톱을 기본 계획 작업 공간으로 유지하면서 터미널 출력, 작업 상태, 음성 전사에 대한 모바일 액세스를 제공합니다.",
    "visuals": {
      "app": {
        "title": "iOS 앱 인터페이스",
        "description": "디바이스 연결 및 터미널 뷰를 보여주는 iOS 앱 스크린샷.",
        "imageSrc": "/images/docs/overview/system-map.svg",
        "imageAlt": "PlanToCode iOS 앱 스크린샷",
        "caption": "iOS 앱 스크린샷을 위한 플레이스홀더."
      }
    },
    "packageStructure": {
      "heading": "Swift 패키지 구조",
      "description": "iOS 앱은 Swift 패키지로 구성됩니다:",
      "packages": [
        {
          "name": "Core",
          "path": "mobile/ios/Core/",
          "description": "비즈니스 로직 및 API 클라이언트",
          "components": [
            "WorkflowManager",
            "APIClient",
            "MobileSessionManager",
            "DeviceLinkClient"
          ]
        },
        {
          "name": "Security",
          "path": "mobile/ios/Security/",
          "description": "인증 및 자격 증명 저장소",
          "components": [
            "Auth0Manager",
            "KeychainHelper",
            "TokenStore"
          ]
        },
        {
          "name": "VibeUI",
          "path": "mobile/ios/VibeUI/",
          "description": "SwiftUI 컴포넌트 및 디자인 시스템",
          "components": [
            "TerminalView",
            "JobListView",
            "SettingsView",
            "DeviceLinkView"
          ]
        }
      ]
    },
    "auth": {
      "heading": "Auth0 PKCE 통합",
      "description": "iOS 앱은 보안 인증을 위해 PKCE 흐름과 함께 Auth0를 사용합니다:",
      "flow": [
        "사용자가 로그인을 탭하면 앱이 코드 검증자와 챌린지를 생성",
        "ASWebAuthenticationSession이 Auth0 로그인 페이지를 열음",
        "사용자가 인증하면 Auth0가 인증 코드와 함께 리디렉션",
        "앱이 코드 검증자를 사용하여 코드를 토큰으로 교환",
        "토큰이 iOS 키체인에 안전하게 저장됨"
      ],
      "tokenManagement": {
        "heading": "토큰 관리",
        "items": [
          "API 요청에 사용되는 액세스 토큰",
          "자동 갱신을 위해 저장된 리프레시 토큰",
          "만료 전에 토큰 갱신 트리거",
          "로그아웃 시 키체인에서 모든 토큰 삭제"
        ]
      }
    },
    "deviceLink": {
      "heading": "WebSocket 릴레이를 통한 디바이스 연결",
      "description": "iOS는 서버의 WebSocket 릴레이를 통해 데스크톱 세션에 연결합니다:",
      "protocol": {
        "heading": "연결 프로토콜",
        "steps": [
          "데스크톱이 링크 코드를 생성하고 QR을 표시",
          "iOS가 QR을 스캔하거나 코드를 수동 입력",
          "양쪽이 자격 증명으로 /ws/device-link에 연결",
          "서버가 검증하고 릴레이를 설정",
          "양방향 통신 활성화"
        ]
      },
      "messageTypes": {
        "heading": "메시지 유형",
        "items": [
          "terminal_output: 데스크톱 터미널의 PTY 출력",
          "job_status: 백그라운드 작업 상태 업데이트",
          "session_sync: 세션 상태 동기화",
          "rpc_command: 모바일에서 데스크톱으로의 명령"
        ]
      },
      "reconnection": {
        "heading": "재연결 처리",
        "description": "WebSocket 연결은 자동 재연결, 지수 백오프, 세션 상태 복구로 네트워크 중단을 처리합니다."
      }
    },
    "rpcRouting": {
      "heading": "RPC 명령 라우팅",
      "description": "iOS는 연결된 데스크톱에 명령을 보낼 수 있습니다:",
      "commands": {
        "heading": "지원되는 명령",
        "items": [
          "send_terminal_input: 터미널에 키 입력 전송",
          "request_job_status: 특정 작업의 상태 가져오기",
          "start_voice_transcription: 모바일에서 녹음 시작",
          "sync_session: 전체 세션 상태 요청"
        ]
      },
      "implementation": {
        "heading": "구현",
        "description": "명령은 WebSocket을 통해 전송되는 JSON-RPC 메시지입니다. 데스크톱은 명령을 검증하고 비동기적으로 결과를 반환합니다."
      }
    },
    "offlineQueue": {
      "heading": "오프라인 액션 큐",
      "description": "연결이 끊긴 동안 수행된 액션은 동기화를 위해 큐에 저장됩니다:",
      "architecture": {
        "heading": "큐 아키텍처",
        "items": [
          "액션이 로컬 SQLite 데이터베이스에 저장됨",
          "재연결 시 큐 처리",
          "서버 타임스탬프로 충돌 해결",
          "실패한 액션이 사용자에게 보고됨"
        ]
      },
      "supportedActions": {
        "heading": "지원되는 오프라인 액션",
        "items": [
          "음성 전사 녹음 (로컬에 저장)",
          "세션 노트 및 주석",
          "기본 설정 변경"
        ]
      }
    },
    "localStorage": {
      "heading": "SQLite 로컬 저장소",
      "description": "iOS는 로컬 영속을 위해 SQLite를 사용합니다:",
      "database": {
        "heading": "데이터베이스 스키마",
        "path": "~/Documents/plantocode.sqlite",
        "tables": [
          "linked_devices: 데스크톱 연결",
          "offline_queue: 대기 중인 동기화 액션",
          "cached_sessions: 최근 세션 데이터",
          "transcriptions: 로컬 음성 녹음"
        ]
      },
      "migrations": {
        "heading": "마이그레이션",
        "description": "스키마 버전은 user_version pragma에서 추적됩니다. 마이그레이션은 앱 시작 시 실행됩니다."
      }
    },
    "sessions": {
      "heading": "모바일 세션",
      "description": "MobileSessionManager가 세션 상태를 조정합니다:",
      "lifecycle": [
        "시작 시 마지막 활성 세션 로드",
        "가능한 경우 연결된 데스크톱에 연결",
        "WebSocket을 통해 세션 업데이트 구독",
        "오프라인 액세스를 위해 세션 데이터 캐시"
      ]
    },
    "workflows": {
      "heading": "워크플로우 진입점",
      "description": "모바일에서 액세스 가능한 주요 워크플로우:",
      "items": [
        "터미널 모니터링: 출력 보기, 입력 전송",
        "작업 상태: 백그라운드 작업 진행 추적",
        "음성 캡처: 모바일에서 녹음 및 전사",
        "세션 탐색: 계획 및 히스토리 검토"
      ]
    },
    "region": {
      "heading": "지역 설정",
      "description": "iOS는 API 라우팅을 위한 사용자 지역 기본 설정을 존중합니다:",
      "implementation": "지역은 UserDefaults에 저장되며, 모든 요청에 대해 api-eu.plantocode.com 또는 api-us.plantocode.com을 선택하는 데 사용됩니다."
    }
  },
  "providerRouting": {
    "meta": {
      "title": "프로바이더 라우팅 및 스트리밍 - PlanToCode",
      "description": "PlanToCode가 프록시를 통해 LLM 요청을 라우팅하고, 응답을 정규화하고, 토큰을 데스크톱 클라이언트로 스트리밍하는 방법."
    },
    "category": "리서치 및 모델",
    "date": "2025-09-24",
    "readTime": "10분",
    "title": "프로바이더 라우팅 및 스트리밍",
    "description": "정규화, 스트리밍, 사용량 추적으로 모든 외부 LLM 요청을 중재하는 라우팅 레이어.",
    "visuals": {
      "routingMap": {
        "title": "프로바이더 라우팅 맵",
        "description": "요청이 데스크톱 앱에서 프록시를 거쳐 프로바이더로 흐르는 방법의 다이어그램.",
        "imageSrc": "/images/docs/provider-routing/routing-map.svg",
        "imageAlt": "데스크톱에서 외부 프로바이더로의 프로바이더 라우팅 흐름 다이어그램",
        "caption": "프로바이더 라우팅 다이어그램을 위한 플레이스홀더."
      }
    },
    "cta": {
      "heading": "모델 구성으로 계속",
      "description": "모델 구성은 허용 목록과 토큰 가드레일이 UI에 어떻게 노출되는지 설명합니다.",
      "links": {
        "modelConfiguration": "모델 구성",
        "runtimeWalkthrough": "런타임 워크스루"
      }
    }
  }
}