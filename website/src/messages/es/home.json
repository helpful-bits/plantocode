{
  "capture": {
    "cards": {
      "taskRefinement": {
        "description": "Amplía las descripciones de tareas identificando requisitos implícitos, clarificando el comportamiento esperado y casos extremos, y agregando consideraciones técnicas.",
        "link": "Más información →",
        "title": "Refinamiento de Tareas"
      },
      "textEnhancement": {
        "description": "Mejora la gramática, estructura de oraciones, claridad y concisión manteniendo tu intención original, tono y nivel de detalle técnico.",
        "link": "Más información →",
        "title": "Mejora de Texto"
      },
      "voice": {
        "description": "Captura requisitos iniciales mediante entrada de voz, que luego puedes refinar manualmente para precisión y claridad.",
        "link": "Más información →",
        "title": "Dictado por Voz"
      }
    },
    "subtitle": "Cristaliza rápidamente ideas en especificaciones claras y accionables con dictado por voz y mejora potenciada por IA.",
    "title": "Captura y Refinamiento de Especificaciones"
  },
  "cta": {
    "badge": "Planificación de IA con Humano en el Ciclo",
    "buttons": {
      "download": "Descargar Gratis",
      "talk": "Hablar con un Experto"
    },
    "description": "Planifica, revisa y ejecuta cambios asistidos por IA desde un solo espacio de trabajo. Mantén modelos, prompts, archivos y salida del terminal alineados.",
    "features": {
      "instant": "Comienza a trabajar al instante",
      "noCard": "No se requiere tarjeta de crédito"
    },
    "title": "¿Listo para coordinar tu próximo plan de implementación?"
  },
  "faq": {
    "items": {
      "q1": {
        "a": "Sí. PlanToCode proporciona un flujo de trabajo con humano en el ciclo donde los líderes de equipo y partes interesadas pueden revisar los planes de implementación generados, editar detalles, solicitar modificaciones y aprobar cambios antes de que sean ejecutados por agentes de codificación o desarrolladores. Esto asegura gobernanza corporativa y previene regresiones.",
        "q": "¿Pueden las partes interesadas revisar y aprobar planes antes de la ejecución?"
      },
      "q10": {
        "a": "Absolutamente. Los planes se abren en un editor Monaco con resaltado de sintaxis, formato amigable para diff y ayudantes de portapapeles. Puedes ajustar el prompt, copiar pasos individuales y volver a ejecutar la generación sin salir del espacio de trabajo.",
        "q": "¿Puedo editar los planes generados por IA antes de la ejecución?"
      },
      "q11": {
        "a": "Selecciona dos o más planes, escribe la guía de fusión y envía. El resultado fusionado se guarda junto a los originales para que puedas comparar borradores, mantener notas o volver a ejecutar la fusión con diferentes instrucciones.",
        "q": "¿Cómo funcionan las instrucciones de fusión?"
      },
      "q12": {
        "a": "Prompt previews, model allowlists, token estimates, and terminal health checks surface issues before any command runs. Every job stores its inputs and outputs for review.",
        "q": "¿Por qué los ingenieros senior usan esto?"
      },
      "q13": {
        "a": "Describe la tarea (escribiendo o por voz) → ejecuta el flujo de trabajo del buscador de archivos → genera uno o más planes de implementación → edita o fusiona planes en el editor Monaco → lanza el terminal integrado para ejecutar el plan y monitorear los registros. Las sesiones y registros permanecen disponibles la próxima vez que abras la aplicación.",
        "q": "¿Cómo se ve un flujo de trabajo típico?"
      },
      "q14": {
        "a": "Si. El repo es source-available bajo Business Source License y los system prompts por defecto estan en el repo y se pueden editar en la app.",
        "q": "El codigo fuente y los system prompts estan disponibles?"
      },
      "q2": {
        "a": "Sube grabaciones de reuniones de Microsoft Teams o capturas de pantalla a PlanToCode. Modelos multimodales avanzados analizan tanto transcripciones de audio (incluyendo identificación de hablantes) como contenido visual (pantallas compartidas, documentos) para extraer requisitos de especificación. Tú revisas los conocimientos extraídos - decisiones, elementos de acción, puntos de discusión - y los incorporas en planes de implementación.",
        "q": "¿Cómo se convierten las reuniones de Teams en especificaciones?"
      },
      "q3": {
        "a": "Sí. Los planes de implementación desglosan cambios archivo por archivo con rutas exactas del repositorio correspondientes a la estructura de tu proyecto. Este enfoque granular asegura que sepas exactamente qué será modificado antes de la ejecución, proporcionando completa visibilidad y control.",
        "q": "¿Los planes mapean a archivos exactos en nuestro repositorio?"
      },
      "q4": {
        "a": "PlanToCode es un espacio de trabajo de planificación de escritorio. Ejecutas el flujo de trabajo de descubrimiento de archivos, revisas planes de implementación en un editor Monaco, ajustas prompts y luego lanzas el terminal desde la misma sesión. Las herramientas de chat te dan una sola respuesta; aquí preparas el trabajo antes de que nada se ejecute.",
        "q": "¿En qué se diferencia esto de los agentes de codificación basados en chat?"
      },
      "q5": {
        "a": "Sí. La aplicación asume que ya trabajas en repositorios grandes y te sientes cómodo con terminales, gráficos de dependencias y compensaciones arquitectónicas. El software mantiene el contexto organizado para que puedas aplicar tu juicio más rápido.",
        "q": "¿Necesito saber programar?"
      },
      "q6": {
        "a": "La configuración predeterminada incluye Gemini 3 Pro, GPT-5.2, Claude 4.5 Sonnet, o3, Grok 4, DeepSeek R1 y Kimi K2. Puedes cambiar de modelo por tarea desde el panel de configuración antes de enviar un trabajo.",
        "q": "¿Qué modelos de IA pueden generar planes?"
      },
      "q7": {
        "a": "El estado del proyecto, registros del terminal y borradores de planes se almacenan localmente en SQLite. Solo el prompt que apruebas más los archivos que seleccionas se envían a través de tu proxy de servidor configurado. El servidor Rust en este repositorio puede ser auto-hospedado cuando necesites mantener el tráfico en tu propia infraestructura.",
        "q": "¿Qué sucede con mi código fuente?"
      },
      "q8": {
        "a": "Each tab is a PTY session managed by the Rust backend. Output is streamed to the UI and stored in SQLite so you can review or resume later.",
        "q": "¿Qué herramientas CLI funcionan dentro del terminal?"
      },
      "q9": {
        "a": "Inicia el flujo de trabajo del buscador de archivos para generar patrones de búsqueda, puntuación de relevancia y listas de archivos priorizadas. Cada etapa se ejecuta como su propio trabajo en segundo plano para que puedas inspeccionar resultados antes de aplicar las selecciones a tu sesión.",
        "q": "¿Cómo maneja las bases de código grandes?"
      }
    },
    "subtitle": "Todo lo que necesitas saber sobre PlanToCode",
    "title": "Preguntas Frecuentes"
  },
  "features": {
    "cards": {
      "fileDiscovery": {
        "description": "Inicia trabajos en segundo plano escalonados para generación de patrones regex, puntuación de relevancia y corrección de rutas. Revisa cada etapa antes de aplicar los resultados a tu sesión.",
        "title": "Flujo de trabajo de descubrimiento de archivos"
      },
      "implementation": {
        "description": "Genera planes de implementación archivo por archivo con rutas exactas del repositorio. Revisa, edita y aprueba cambios antes de la ejecución para prevenir regresiones y asegurar alineación con requisitos.",
        "title": "Planes de implementación revisados por humanos"
      },
      "integratedTerminal": {
        "description": "Lanza claude, cursor, codex o gemini directamente en el terminal integrado. Monitoreo de salud, recuperación automática y manejo de redimensionamiento mantienen trabajos de larga duración estables.",
        "title": "Terminal PTY integrado con detección de CLI"
      },
      "meeting": {
        "description": "Sube reuniones de Microsoft Teams o grabaciones de pantalla. El análisis multimodal extrae especificaciones de transcripciones de audio y contenido visual para revisión e incorporación.",
        "title": "Ingestión de grabaciones de reuniones"
      },
      "mergePlans": {
        "description": "Selecciona múltiples planes, escribe guía de fusión y mantén la salida fusionada junto a los originales. Itera hasta que el enfoque coincida con tus estándares.",
        "title": "Fusionar planes con instrucciones"
      },
      "modelConfiguration": {
        "description": "Elige entre Gemini 3 Pro, GPT-5.2, Claude 4.5 Sonnet, Grok 4, DeepSeek R1 y Kimi K2 para planes de implementación. La configuración persiste por proyecto.",
        "title": "Configuración de modelo por tarea"
      },
      "monacoEditor": {
        "description": "Los planes se abren en un editor Monaco con resaltado de sintaxis, formato amigable para diff y ayudantes de portapapeles. Edita pasos, almacena borradores y mantén plantillas listas para la próxima tarea.",
        "title": "Editor de planes de implementación Monaco"
      },
      "persistentSessions": {
        "description": "La salida del terminal se almacena en un búfer circular de 5 MB y las sesiones de proyecto se recargan al inicio. Retoma el trabajo pendiente sin reconstruir el contexto.",
        "title": "Sesiones y registros persistentes"
      },
      "specification": {
        "description": "Dictado por voz para entrada rápida, mejora de texto para claridad y refinamiento de tareas para identificar requisitos implícitos y casos extremos.",
        "title": "Captura y refinamiento de especificaciones"
      },
      "textImprovement": {
        "description": "Resalta cualquier selección para ejecutar el trabajo de mejora de texto con Claude 4.5 Sonnet o Gemini 3 Flash. La reescritura preserva el formato y se aplica dentro de editores Monaco, entradas de tareas y dictado del terminal.",
        "title": "Ventana emergente de mejora de texto"
      },
      "tokenGuardrails": {
        "description": "Ve el prompt exacto, conteos estimados de tokens y advertencias de ventana de contexto antes de enviar un trabajo. Ajusta instrucciones con completa visibilidad.",
        "title": "Barreras de tokens y vista previa de prompts"
      },
      "voiceTranscription": {
        "description": "Graba descripciones de tareas o comandos de terminal y envíalos a través del servicio de transcripción. Configura valores predeterminados de idioma y temperatura para cada proyecto.",
        "title": "Pipeline de transcripción de voz"
      }
    },
    "linkText": "Más información",
    "subtitle": "Construido para desarrolladores que trabajan con bases de código grandes y heredadas. Si usas Claude Code, Cursor o Aider - esta es tu capa de planificación.",
    "title": "Mecanismos"
  },
  "governance": {
    "cards": {
      "filePlans": {
        "description": "Los planes de implementacion desglosan cambios por archivo y operacion para aclarar el alcance.",
        "title": "Planes archivo por archivo con rutas exactas"
      },
      "handoff": {
        "description": "Los planes aprobados se entregan a terminales o CLI de agentes con contexto y logs de auditoria.",
        "title": "Entrega de ejecucion"
      },
      "workflow": {
        "description": "Planes editables en desktop o movil; cada revision se conserva.",
        "title": "Revision, edicion y aprobacion"
      }
    },
    "subtitle": "Plans are artifacts you can review, edit, and approve before any agent runs. Logs and history keep changes traceable.",
    "title": "Revision de planes antes de la ejecucion"
  },
  "hero": {
    "cta": {
      "viewDemo": "Descargar PlanToCode",
      "howItWorks": "Ver el formato del plan"
    }
  },
  "integrations": {
    "cards": {
      "allIntegrations": {
        "description": "Aloja el servidor para controlar el enrutamiento de providers y usar tus propias keys.",
        "link": "Guia de configuracion del servidor ->",
        "title": "Self-hosting y BYOK"
      },
      "claudeCode": {
        "description": "Los prompts por defecto estan en el repo y la base del servidor para inspeccion y edicion.",
        "link": "Docs de tipos de prompts ->",
        "title": "System prompts visibles"
      },
      "cursor": {
        "description": "Todo el sistema esta en GitHub bajo Business Source License para auditar la arquitectura.",
        "link": "Ver repo de GitHub ->",
        "title": "Source available (BSL 1.1)"
      }
    },
    "subtitle": "System prompts, codigo fuente y self-hosting son visibles y documentados.",
    "title": "Transparencia y control"
  },
  "meetings": {
    "cards": {
      "insights": {
        "description": "Los conocimientos extraídos - decisiones resumidas, elementos de acción y puntos clave de discusión - se presentan en una interfaz intuitiva donde los líderes de equipo pueden revisar, seleccionar e incorporarlos en planes de implementación accionables.",
        "link": "Más información →",
        "title": "Revisar e Incorporar Conocimientos"
      },
      "multimodal": {
        "description": "Sube reuniones de Microsoft Teams o grabaciones de pantalla. Modelos multimodales avanzados analizan tanto transcripciones de audio (con identificación de hablantes) como contenido visual relevante (pantallas compartidas, documentos presentados, momentos clave) para extraer requisitos de especificación.",
        "link": "Más información →",
        "title": "Análisis Multimodal"
      }
    },
    "subtitle": "Transforma reuniones de Microsoft Teams y grabaciones de pantalla en requisitos de implementación accionables.",
    "title": "Ingestión de Reuniones y Grabaciones"
  },
  "pricing": {
    "card": {
      "description": "Comienza con precios basados en uso para validar resultados. Sin suscripciones. Solo costos transparentes de API.",
      "pricing": {
        "description": "Prueba el Editor de Planes, Instrucciones de Fusión, Integración de Terminal. Recarga automática cuando estés convencido.",
        "subtitle": "Paga solo por lo que usas.",
        "title": "Precios Basados en Uso"
      },
      "title": "Precios Transparentes"
    },
    "subtitle": "Paga solo por inferencia de IA con costos de tokens transparentes. Observa tu ROI en tiempo real - un incidente de producción evitado paga meses de uso.",
    "title": "Construido para Desarrollo Profesional"
  },
  "problems": {
    "cards": {
      "browseAll": {
        "description": "Explora flujos de trabajo para refactorizaciones, migraciones, respuesta a incidentes y más",
        "link": "Ver todos los flujos de trabajo →",
        "title": "Navegar Todos los Flujos de Trabajo"
      },
      "hardBugs": {
        "description": "Depura con contexto preservado, pasos reproducibles e historial de investigación completo",
        "link": "Más información →",
        "title": "Errores de Producción Difíciles"
      },
      "largeFeatures": {
        "description": "Planifica implementaciones complejas con conciencia arquitectónica y análisis de impacto",
        "link": "Más información →",
        "title": "Características Grandes"
      },
      "legacyRefactoring": {
        "description": "Moderniza bases de código legacy con refactorización asistida por IA que preserva la funcionalidad mientras mejora la estructura",
        "link": "Más información →",
        "title": "Refactorización de Código Legacy"
      },
      "libraryUpgrades": {
        "description": "Actualiza dependencias de manera segura con detección de cambios que rompen compatibilidad y planificación de migración",
        "link": "Más información →",
        "title": "Actualizaciones de Bibliotecas"
      },
      "preventDuplicates": {
        "description": "Detecta y previene código duplicado, componentes e implementaciones en tu base de código",
        "link": "Más información →",
        "title": "Prevenir Archivos Duplicados"
      },
      "safeRefactoring": {
        "description": "Refactoriza con confianza usando conciencia arquitectónica y análisis de impacto exhaustivo",
        "link": "Más información →",
        "title": "Refactorización Segura"
      }
    },
    "subtitle": "Soluciones reales para los problemas más difíciles en desarrollo de software",
    "title": "Resuelve Desafíos de Desarrollo Complejos"
  },
  "gallery": {
    "heading": "Workflow de revision de planes en la app",
    "intro": "See how file discovery, multi-model planning, merge instructions, and execution handoff keep agent work transparent and traceable.",
    "video": {
      "title": "Resumen del workflow plan-first",
      "description": "Un recorrido corto desde la captura de tarea hasta la revision del plan, merge instructions y execution handoff.",
      "bullets": [
        "Ejecuta varios borradores con el mismo contexto de archivos",
        "Fusiona las mejores ideas con instrucciones explicitas",
        "Revisa y edita planes en desktop o movil",
        "Entrega a Claude Code o a un terminal local con logs"
      ]
    },
    "cards": {
      "fileFinder": {
        "title": "Pipeline de descubrimiento de archivos",
        "description": "Un flujo de trabajo Rust de cuatro etapas: selección de raíz asistida por LLM, filtrado regex, puntuación de relevancia y búsqueda de rutas extendida para construir un conjunto de archivos enfocado.",
        "features": [
          "La selección de carpeta raíz usa el árbol de directorios y la descripción de la tarea",
          "El filtro regex genera grupos de patrones y aplica git ls-files",
          "La puntuación de relevancia divide el contenido de archivos con estimaciones de tokens",
          "El buscador de rutas extendido amplía el contexto con datos de archivos y árbol"
        ]
      },
      "fileFinderWorkflow": {
        "title": "Plan history and logs",
        "description": "Cada etapa del flujo de trabajo escribe resultados en background_jobs para que los conjuntos de archivos puedan reutilizarse entre sesiones e inspeccionarse después.",
        "features": [
          "Etapas del flujo de trabajo almacenadas como registros de trabajos",
          "Listas de archivos seleccionados persistidas como respuestas JSON",
          "Los included_files de sesión se reutilizan entre trabajos",
          "El historial SQLite sobrevive a los reinicios"
        ]
      },
      "videoAnalysis": {
        "title": "Optional screen recording analysis",
        "description": "Screen recordings can be sent to the /api/llm/video/analyze endpoint with a focus prompt and FPS hint to generate analysis summaries.",
        "features": [
          "Multipart upload includes durationMs and framerate",
          "Model format is provider/model (google/* required)",
          "Usage and cost recorded per job",
          "Summary stored in background_jobs response and can be applied to the task description"
        ]
      },
      "implementationPlans": {
        "title": "Generación de planes multi-modelo",
        "description": "ImplementationPlanProcessor transmite borradores de planes desde el contenido completo de archivos; los trabajos de fusión consolidan múltiples borradores en un solo plan.",
        "features": [
          "Los trabajos de plan incluyen contenido de archivos seleccionados + árbol de directorios",
          "Metadatos de plan estructurados capturados por trabajo",
          "El prompt de fusión usa <source_plans> y <user_instructions>",
          "El plan final se almacena junto con los borradores fuente"
        ]
      },
      "backgroundTasks": {
        "title": "Monitoreo de trabajos en segundo plano",
        "description": "Los procesadores de trabajos Rust transmiten progreso y transiciones de estado a la interfaz mientras persisten el historial de trabajos en SQLite.",
        "features": [
          "Created, queued, preparing, running, completed/failed/canceled",
          "Actualizaciones en streaming vía eventos Tauri",
          "Uso de tokens capturado por ejecución",
          "Cancelar trabajos de larga duración"
        ]
      },
      "settingsPrompts": {
        "title": "Configuración de prompts y modelos",
        "description": "La configuración de modelos en tiempo de ejecución se obtiene de `/api/config/desktop-runtime-config`; las anulaciones de prompts se almacenan en SQLite.",
        "features": [
          "Modelos permitidos y valores predeterminados por tarea",
          "Prompts del sistema servidos por la API del servidor",
          "Anulaciones de prompts a nivel de proyecto en project_system_prompts",
          "key_value_store local para preferencias de runtime"
        ]
      },
      "terminalVoiceRecording": {
        "title": "Botones de automatización de flujo de trabajo",
        "description": "Los botones de copiar insertan prompts basados en plantillas con contexto de tarea para transferencia a terminales o herramientas externas.",
        "features": [
          "Plantillas obtenidas de la configuración del modelo de tarea",
          "Marcadores de posición resueltos contra el plan activo",
          "Transferencia a sesiones PTY o portapapeles",
          "Acciones vinculadas a metadatos de trabajo para auditoría"
        ]
      },
      "mergeInstructionsWorkflow": {
        "title": "Instrucciones de fusión de planes",
        "description": "ImplementationPlanMergeProcessor fusiona múltiples borradores de planes usando planes fuente etiquetados con XML e instrucciones opcionales.",
        "features": [
          "Planes fuente obtenidos por ID de trabajo",
          "Instrucciones de fusión almacenadas en metadatos",
          "El contenido de archivos + árbol de directorios añaden contexto",
          "El plan fusionado se almacena junto con las entradas"
        ]
      },
      "billingTransactions": {
        "title": "Registro de uso y costos",
        "description": "Las entradas de uso del lado del servidor y los metadatos de trabajos capturan el uso de modelos a través de proveedores.",
        "features": [
          "Metadatos de tokens y costos por trabajo",
          "Entradas de uso conscientes del proveedor",
          "Los endpoints de facturación exponen resúmenes de uso",
          "Usage history for model spend"
        ]
      }
    },
    "viewFullSize": "Ver tamaño completo",
    "cta": {
      "title": "Listo para revisar planes antes de que los agentes ejecuten?",
      "description": "Descarga la app de escritorio para probar planificacion multimodelo, fusion de planes y execution handoff.",
      "primary": "Descargar PlanToCode",
      "secondary": "Ver el formato del plan"
    }
  },
  "technicalLanding": {
    "title": "PlanToCode: Revisar y fusionar planes de implementacion",
    "description": "PlanToCode convierte tareas en planes de implementacion estructurados que puedes leer, comparar y editar antes de que un agente ejecute. Genera varios borradores, fusiona el mejor enfoque y entrega a Claude Code o a tu terminal con todo el contexto.",
    "note": "En hosting usamos acceso de modelos gestionado; BYOK solo esta disponible en self-host.",
    "noteLink": "Guia de self-hosting",
    "repo": {
      "title": "Código fuente en GitHub",
      "description": "Este sitio es la portada del repositorio de PlanToCode. Desde aquí puedes ver el código, la documentación y la arquitectura.",
      "starsLabel": "estrellas de GitHub",
      "licenseLabel": "BSL 1.1"
    },
    "walkthroughTitle": "Paso a paso: cómo funcionan juntos los componentes",
    "walkthroughDescription": "Sigue un recorrido completo de cómo la aplicación de escritorio, el backend Rust/Tauri, la base de datos SQLite y el pipeline de orquestación LLM coordinan tareas y transmiten resultados a la interfaz.",
    "tags": [
      "Revision de planes",
      "Planificacion multimodelo",
      "Fusion de planes",
      "Lector de planes movil",
      "Source available (BSL)"
    ]
  }
}
