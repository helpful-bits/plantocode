{
  "hub": {
    "meta": {
      "title": "PlanToCode Feature Internals - System Components",
      "description": "Technical walkthrough of the components that implement planning, file discovery, multimodal input, and execution."
    },
    "badge": "Component docs",
    "cta": {
      "description": "Use these component docs to trace each subsystem to the processors, prompts, and UI surfaces that implement it.",
      "title": "Trace the implementation",
      "links": {
        "docs": "Open docs",
        "architecture": "Architecture overview"
      }
    },
    "description": "Component-level documentation for each subsystem, with pointers to the job processors, storage tables, and UI surfaces that drive behavior. Most stages rely on external LLM providers configured with your API keys.",
    "learnMore": "Open component",
    "title": "Component Documentation"
  },
  "meetings": {
    "meta": {
      "title": "Meeting & Recording Ingestion - System Walkthrough",
      "description": "How PlanToCode captures meetings and recordings, extracts requirements, and feeds them into planning workflows."
    },
    "badge": "Specification capture",
    "title": "Meeting & Recording Ingestion",
    "subtitle": "Multimodal pipeline that turns recorded discussions into structured requirements for planning. Analysis runs through the configured transcription and vision providers.",
    "ariaLabel": "Meeting and recording ingestion features",
    "cards": {
      "multimodal": {
        "title": "Multimodal extraction pipeline",
        "description": "Audio and key frames are processed to produce transcripts, UI context, and requirement notes for task refinement.",
        "link": "See video analysis"
      },
      "insights": {
        "title": "Curated insights for planning",
        "description": "Decisions, constraints, and action items are surfaced as selectable notes that feed the plan.",
        "link": "See text improvement"
      }
    },
    "benefits": {
      "title": "What the system outputs",
      "collaboration": {
        "title": "Decision log",
        "description": "Captures decisions and action items with timestamps for traceable planning."
      },
      "transcription": {
        "title": "Speaker-aware transcript",
        "description": "Transcribes audio with speaker segmentation so requirements keep attribution."
      },
      "visual": {
        "title": "Visual context frames",
        "description": "Summarizes screens and diagrams into notes used during task refinement."
      }
    },
    "howItWorks": {
      "title": "Pipeline steps",
      "step1": {
        "title": "Ingest recording",
        "description": "Upload a Teams or Zoom recording or a screen capture; the system normalizes formats and indexes the media."
      },
      "step2": {
        "title": "Multimodal analysis",
        "description": "Audio transcript and key frames are analyzed to extract requirements, constraints, and UI state."
      },
      "step3": {
        "title": "Attach to task",
        "description": "Outputs are attached to the task as structured notes before planning and file discovery."
      }
    },
    "relatedFeatures": {
      "title": "Related components",
      "videoAnalysis": {
        "title": "Video Analysis",
        "description": "Analyze screen recordings and capture UI context for planning."
      },
      "voiceTranscription": {
        "title": "Voice Transcription",
        "description": "Capture spoken requirements directly into the task input."
      },
      "textImprovement": {
        "title": "Text Improvement",
        "description": "Normalize raw notes into structured task descriptions."
      },
      "learnMore": "Learn more"
    },
    "cta": {
      "title": "Continue the pipeline",
      "description": "Follow the video analysis docs and the architecture overview to see how these notes flow into planning and execution.",
      "links": {
        "docs": "Video analysis docs",
        "architecture": "Architecture overview"
      }
    }
  },
  "fileDiscovery": {
    "benefits": {
      "costEffective": {
        "description": "Token-aware batching with cost tracking at each stage.",
        "title": "Token budgeting"
      },
      "multiStage": {
        "description": "Four-stage workflow with regex filtering, relevance assessment, and relationship analysis to identify relevant files.",
        "title": "Multi-stage pipeline"
      },
      "realTimeProgress": {
        "description": "Stage-by-stage progress updates emitted by background jobs.",
        "title": "Progress visibility"
      }
    },
    "capabilities": {
      "git": {
        "description": "Executes `git ls-files --cached --others --exclude-standard` to respect .gitignore rules. Falls back to git2 library if command fails.",
        "features": [
          "Git ls-files with .gitignore respect",
          "Binary file detection and filtering",
          "Extension-based exclusion (97 types)",
          "Content analysis for binary detection"
        ],
        "title": "Git Repository Integration"
      },
      "planIntegration": {
        "description": "Discovered files feed directly into the implementation planning system. Context is preserved and reused across sessions.",
        "features": [
          "Plan generation handoff",
          "Context preservation across sessions",
          "Multiple plan drafts per task",
          "Structured plan inputs"
        ],
        "title": "Implementation Plan Integration"
      },
      "title": "Advanced Discovery Capabilities",
      "tokenManagement": {
        "description": "Content-aware token estimation drives batching. Ratios for JSON/XML (5 chars/token), code (3 chars/token), and text (4 chars/token) guide chunking.",
        "features": [
          "Dynamic chunk sizing per file type",
          "2000-token prompt overhead reservation",
          "Batch processing (100 files default)",
          "30-second file caching TTL"
        ],
        "title": "Smart Token Management"
      },
      "workflow": {
        "description": "WorkflowOrchestrator manages lifecycle with lazy initialization, dependency scheduling, and orphaned job recovery. Each stage runs as an independent background job.",
        "features": [
          "Stage dependency management",
          "Event-driven progress updates via Tauri",
          "WorkflowIntermediateData persistence",
          "Exponential backoff retry logic"
        ],
        "title": "Distributed Workflow Orchestration"
      }
    },
    "cta": {
      "description": "Dive deeper into the file discovery internals, from orchestration to relevance scoring, and map the pipeline to the codebase.",
      "links": {
        "docs": "Read file discovery docs",
        "buildYourOwn": "Build your own pipeline"
      },
      "title": "Explore the internals"
    },
    "hero": {
      "badge": "File discovery workflow",
      "description": "PlanToCode stages file discovery as a Rust workflow that narrows, scores, and persists context before any plan generation.",
      "title": "File Discovery Pipeline"
    },
    "pipeline": {
      "title": "How the File Discovery Pipeline Works",
      "description": "Before any LLM call, the system builds a candidate index, applies deterministic filters, then uses relevance scoring to minimize tokens and noise.",
      "cards": {
        "index": {
          "title": "Index",
          "description": "Scan Git-tracked paths and build a local candidate set with directory hierarchy context."
        },
        "filter": {
          "title": "Filter",
          "description": "Apply regex patterns, ignore rules, and file-type heuristics to reduce the candidate pool."
        },
        "score": {
          "title": "Score",
          "description": "Run LLM-assisted relevance scoring and persist ranked results for later plan generation."
        }
      }
    },
    "performance": {
      "accuracy": {
        "description": "Multi-stage refinement with relevance assessment and relationship analysis captured per job.",
        "title": "Relevance Quality",
        "value": "Traceable"
      },
      "cost": {
        "description": "Token estimation and batching keep prompts small before LLM scoring.",
        "title": "Token Budgeting",
        "value": "Token-aware"
      },
      "speed": {
        "description": "Stage-by-stage jobs stream updates without blocking the UI.",
        "title": "Job Scheduling",
        "value": "Staged"
      },
      "title": "Operational Characteristics"
    },
    "workflow": {
      "stage1": {
        "description": "Analyzes the directory structure (up to 2 levels deep) to identify candidate project areas and select parent folders vs. subdirectories.",
        "features": [
          "Hierarchical directory analysis",
          "Parent/subdirectory selection heuristics",
          "Avoids redundant nested selections"
        ],
        "title": "Root Folder Selection"
      },
      "stage2": {
        "description": "Generates regex patterns and performs initial file filtering. Integrates with git to respect .gitignore rules and filter binary files.",
        "features": [
          "Dynamic regex pattern creation",
          "Git ls-files integration",
          "Binary file detection and exclusion"
        ],
        "title": "Regex Pattern Generation & Filtering"
      },
      "stage3": {
        "description": "LLM-based relevance scoring to assess file relevance to the task. Uses token-aware batching with content-aware estimation.",
        "features": [
          "Content-based relevance scoring",
          "Token-aware batching",
          "2000-token overhead management"
        ],
        "title": "File Relevance Assessment"
      },
      "stage4": {
        "description": "Discovers additional contextually relevant files through relationship analysis. Analyzes imports, configurations, and project structure to find related files.",
        "features": [
          "Import statement analysis",
          "Dependency graph traversal",
          "Configuration file discovery"
        ],
        "title": "Extended Path Discovery"
      },
      "title": "The 4-Stage Discovery Workflow"
    }
  },
  "mergeInstructions": {
    "capabilities": {
      "instructionControl": {
        "examples": [
          {
            "type": "Prioritization",
            "example": "\"Focus on Plan 2's security\""
          },
          {
            "type": "Structure",
            "example": "\"Organize by component\""
          },
          {
            "type": "Approach",
            "example": "\"Use Plan 1's database strategy\""
          },
          {
            "type": "Quality",
            "example": "\"Include comprehensive testing\""
          },
          {
            "type": "Scope",
            "example": "\"Exclude deployment steps\""
          },
          {
            "type": "Integration",
            "example": "\"Use example from docs\""
          },
          {
            "type": "Resolution",
            "example": "\"Prefer microservices over monolith\""
          }
        ],
        "title": "How instructions guide the merge"
      },
      "title": "Merge processor capabilities",
      "whatAIDoes": {
        "items": [
          "Parses source plans into a structured step schema",
          "Aligns steps by tags, file paths, and intent",
          "Flags conflicts for explicit resolution",
          "Records source plan IDs for each merged step",
          "Stores merge instructions and prompt inputs with the job",
          "Incorporates external examples when provided",
          "Keeps output scoped to the original task"
        ],
        "title": "What the merge processor does"
      }
    },
    "cta": {
      "description": "See how merge instructions, plan tagging, and conflict resolution are represented in the implementation-plan pipeline.",
      "links": {
        "docs": "Implementation plan docs",
        "planMode": "Plan generation flow"
      },
      "title": "Review the merge pipeline in the docs"
    },
    "features": {
      "architecturalAnalysis": {
        "description": "Plans are parsed into a structured schema so steps can be aligned and compared before merging.",
        "title": "Structured plan parsing"
      },
      "solidResolution": {
        "description": "Conflicts are resolved with explicit rules rather than leaving everything to a single model response.",
        "title": "Conflict resolution rules"
      },
      "sourceTraceability": {
        "description": "Merged output retains links back to source plans so reviewers can trace decisions to specific inputs.",
        "title": "Traceable merge output"
      }
    },
    "hero": {
      "badge": "Plan Merge Pipeline",
      "description": "PlanToCode generates multiple implementation plans, then merges them into a single draft using structured prompts and explicit merge instructions.",
      "title": "Merge instructions and plan consolidation"
    },
    "example": {
      "heading": "Example merged output with source traceability:",
      "steps": [
        "Step 1: Set up database schema [src:P1 step 3]",
        "Step 2: Implement authentication [src:P2 step 1, P3 step 2]",
        "Step 3: Create API endpoints [src:P3 step 4 - cleaner approach]",
        "Step 4: Add error handling [src:EMERGENT - combining P1, P2 patterns]",
        "Step 5: Implement caching [src:P1 step 7, optimized with P2 insights]"
      ]
    },
    "implementation": {
      "aiPrompt": {
        "description": "Structured prompt enforces merge rules and traceability.",
        "features": [
          "Merge role prompt",
          "Explicit conflict resolution criteria",
          "Mandatory source attribution",
          "Step alignment guidance",
          "Validation checks"
        ],
        "title": "Merge prompt template"
      },
      "backend": {
        "description": "ImplementationPlanMergeProcessor orchestrates the merge pipeline.",
        "features": [
          "Fetches raw XML from source plans",
          "Extracts relevant file contexts",
          "Generates project structure tree",
          "Builds comprehensive LLM prompt",
          "Streams response with progress updates"
        ],
        "title": "Backend Processing"
      },
      "frontend": {
        "description": "Rich UI for plan selection and instruction input.",
        "features": [
          "MergePlansSection with collapsible UI",
          "FloatingMergeInstructions (draggable)",
          "Text enhancement support during editing",
          "Debounced state management",
          "Session persistence for instructions"
        ],
        "title": "Frontend Components"
      },
      "metadata": {
        "description": "Complete audit trail and debugging capability.",
        "features": [
          "Source job IDs preserved",
          "Full prompt stored for debugging",
          "Merge instructions tracked",
          "File operations extracted",
          "Priority 2 job scheduling"
        ],
        "title": "Metadata & Storage"
      },
      "title": "Technical Implementation Details"
    },
    "process": {
      "deepAnalysis": {
        "description": "Plans are compared step-by-step so overlapping work is merged and conflicting approaches are surfaced explicitly.",
        "features": [
          "Identifies unique insights from each plan",
          "Aligns steps by tags and semantics",
          "Preserves important architectural decisions",
          "Flags conflicts for explicit resolution"
        ],
        "title": "Plan alignment and comparison"
      },
      "instructions": {
        "description": "Merge instructions guide how the processor resolves conflicts or prioritizes specific plan elements.",
        "examples": [
          "Prioritization: \"Focus on security from Plan 2\"",
          "Structure: \"Group by subsystem\"",
          "Approach: \"Use Plan 1's database strategy\"",
          "Scope: \"Exclude deployment steps\""
        ],
        "title": "Merge Instruction Processing"
      },
      "multiModel": {
        "description": "ImplementationPlanProcessor can request multiple plans across models or prompts, keeping each draft isolated for later comparison.",
        "features": [
          "Each plan stored with metadata",
          "Relevant files captured per plan",
          "Project context included in prompts",
          "Multiple drafts available for review"
        ],
        "title": "Plan draft generation"
      },
      "synthesis": {
        "description": "ImplementationPlanMergeProcessor composes a single draft and records references back to source plans.",
        "features": [
          "Source references preserved",
          "Merge guidance stored with output",
          "Conflict resolution decisions logged",
          "Single draft for review and editing"
        ],
        "title": "Merged draft with traceability"
      },
      "title": "The merge pipeline"
    },
    "value": {
      "architecturalSynthesis": {
        "description": "Merging is performed with structured prompts so the final plan reconciles overlapping steps instead of concatenating drafts.",
        "title": "Structured merge output"
      },
      "completeTraceability": {
        "description": "Merge notes capture which draft contributed each step so reviewers can trace decisions.",
        "title": "Traceable merge output"
      },
      "solidPractices": {
        "description": "Conflicts are resolved using explicit criteria and review guidance rather than silent overwrites.",
        "title": "Explicit conflict resolution"
      },
      "title": "Why structured merging matters"
    }
  },
  "planMode": {
    "copyButtons": {
      "examples": {
        "serverConfigured": {
          "button": "Button: \"Parallel agent workflows\"",
          "hint": "+ Custom instructions...",
          "template": "Template: \"{{IMPLEMENTATION_PLAN}}\""
        },
        "stepExtraction": {
          "copyAll": "Copy All Steps",
          "copyStep": "Copy Step 3",
          "copyWithInstructions": "Copy with Instructions"
        }
      },
      "serverConfigured": {
        "description": "Dynamic copy buttons configured server-side with template placeholders.",
        "title": "Server-Configured Buttons"
      },
      "stepExtraction": {
        "description": "Copy individual steps or full plans using the structured plan format.",
        "title": "Structured Step Extraction"
      },
      "title": "Configurable Copy Button System"
    },
    "cta": {
      "description": "Follow how plans are generated, reviewed, merged, and handed off to execution, with audit trails for each step.",
      "links": {
        "mergePlans": "Merge pipeline",
        "terminal": "Terminal sessions"
      },
      "title": "Trace the plan pipeline"
    },
    "editing": {
      "monaco": {
        "description": "Monaco-based editor for plan review with syntax highlighting and structured diffs.",
        "features": [
          "XML syntax highlighting",
          "Find & replace with regex",
          "Multi-cursor editing",
          "Auto-save to database"
        ],
        "title": "Monaco Editor Integration"
      },
      "terminal": {
        "description": "Execute steps in persistent PTY sessions with logs recorded alongside the plan.",
        "features": [
          "Persistent terminal sessions",
          "Voice transcription input",
          "Copy plan/steps to terminal",
          "Session health monitoring"
        ],
        "title": "Integrated Terminal Execution"
      },
      "title": "Editing and execution surfaces"
    },
    "features": {
      "intelligentGeneration": {
        "description": "Loads file contents and directory context, then applies per-task model configuration before generating plans.",
        "title": "Plan generation pipeline"
      },
      "monacoEditor": {
        "description": "Monaco editor with XML syntax highlighting. Edits are auto-saved to the database.",
        "title": "Monaco Editor"
      },
      "terminalExecution": {
        "description": "Execute plans in the integrated terminal or export steps to external tools.",
        "title": "Execution handoff"
      }
    },
    "fileByFile": {
      "description": "Plans are structured as file-by-file changes so scope and dependencies are visible before execution.",
      "exactPaths": {
        "description": "Each step includes explicit file paths, operations, and ordering.",
        "title": "Exact File Paths"
      },
      "preventRegressions": {
        "description": "Review scope and dependency impact before running commands.",
        "features": [
          "Impact assessment",
          "Change review checkpoints",
          "Legacy code safeguards"
        ],
        "title": "Change impact review"
      },
      "title": "File-by-file plan structure"
    },
    "generation": {
      "fullContext": {
        "description": "Full file contents are loaded with warnings when token budgets are exceeded.",
        "features": [
          "Complete file content, no truncation",
          "Parallel file loading",
          "Token warnings at >100k tokens",
          "Directory tree generation"
        ],
        "title": "Full Context Loading"
      },
      "multiModel": {
        "description": "Multiple models can be configured per project with temperature and context limits.",
        "features": [
          "Configured model allowlist per project",
          "Project-specific model settings",
          "Token estimation before execution",
          "Context window validation"
        ],
        "title": "Multi-model configuration"
      },
      "streaming": {
        "description": "Plan generation streams output with progress updates and job status tracking.",
        "features": [
          "Streaming output with progress bars",
          "Syntax highlighting during streaming",
          "Token count updates during generation",
          "Background job status tracking"
        ],
        "title": "Streaming output"
      },
      "title": "Plan generation with full context",
      "xmlFormat": {
        "description": "Plans use structured XML with numbered steps, enabling programmatic manipulation and extraction.",
        "features": [
          "<step number=\"X\"> organization",
          "Title and description per step",
          "File operations tracking",
          "Step-by-step extraction support"
        ],
        "title": "Structured XML Format"
      }
    },
    "guides": {
      "claudeCode": {
        "description": "Export plans into IDEs or external tools when you need a guided execution surface.",
        "link": "Open IDE handoff notes",
        "name": "IDE handoff"
      },
      "codex": {
        "description": "Use plan outputs to drive CLI agents or scripts with explicit scope and steps.",
        "link": "Open CLI execution notes",
        "name": "CLI execution"
      },
      "cursor": {
        "description": "Combine integrated terminal execution with external tools for hybrid execution.",
        "link": "Open hybrid execution notes",
        "name": "Hybrid execution"
      },
      "title": "Execution environments"
    },
    "hero": {
      "badge": "Implementation plan pipeline",
      "description": "Plan generation and merging rely on external LLM providers configured with your API keys; review and execution remain local.",
      "title": "Implementation planning pipeline"
    },
    "humanInLoop": {
      "approve": {
        "description": "Approved plans can be exported or executed in the integrated terminal with logs attached.",
        "title": "Approve and hand off"
      },
      "description": "Plans are reviewed, edited, and approved before execution so scope and dependencies are explicit.",
      "edit": {
        "description": "Edit steps, reorder work, add constraints, and keep the plan aligned with repo structure.",
        "title": "Edit and refine plans"
      },
      "review": {
        "description": "Plans open in Monaco for review; execution is a separate, explicit action.",
        "title": "Review before execution"
      },
      "title": "Human-in-the-loop review"
    },
    "technical": {
      "noTruncation": {
        "description": "Full file contents are loaded with warnings when token budgets are exceeded.",
        "title": "Full-context loading"
      },
      "persistence": {
        "description": "Plans are stored with job metadata and prompt history for traceability.",
        "title": "SQLite persistence"
      },
      "templates": {
        "description": "Server-side prompts with project overrides and placeholders for context fields.",
        "title": "Prompt templates"
      },
      "title": "Implementation details"
    },
    "workflow": {
      "steps": [
        {
          "title": "File discovery stage",
          "description": "File discovery identifies relevant paths and persists selections for later steps."
        },
        {
          "title": "Plan drafts (multiple models or prompts)",
          "description": "Run multiple models or prompts and compare structured drafts."
        },
        {
          "title": "Review and edit in Monaco",
          "description": "Review and edit steps with Monaco, then save revisions."
        },
        {
          "title": "Merge with instructions",
          "description": "Merge drafts with guidance and preserve provenance for review."
        },
        {
          "title": "Execute in terminal",
          "description": "Execute steps in a persistent terminal session with logs recorded."
        }
      ],
      "title": "Planning pipeline"
    },
    "references": {
      "architecture": {
        "description": "System boundaries, IPC, and background jobs.",
        "title": "Architecture overview"
      },
      "buildYourOwn": {
        "description": "Design the pipeline stages in your own project.",
        "title": "Build your own pipeline"
      },
      "implementationPlans": {
        "description": "Plan format, storage, and review flow.",
        "title": "Implementation plan format"
      },
      "link": "Open docs",
      "title": "Related references"
    }
  },
  "textImprovement": {
    "capabilities": {
      "contextAware": {
        "description": "Prompt payloads can include file tree, selected files, and project settings.",
        "title": "Context-aware refinement"
      },
      "customizable": {
        "description": "Per-project templates with placeholders and policy limits.",
        "title": "Customizable system prompts"
      },
      "instant": {
        "description": "Non-streaming responses applied inline with conflict detection.",
        "title": "Inline application"
      },
      "mentalModel": {
        "description": "Iterative refinement lets you converge on exact requirements.",
        "title": "Iterative refinement"
      },
      "title": "Core mechanics"
    },
    "cta": {
      "description": "See the prompt templates, payload fields, and how outputs feed the planning pipeline.",
      "links": {
        "docs": "Text improvement docs",
        "architecture": "Architecture overview"
      },
      "title": "Continue in the docs"
    },
    "faq": {
      "codeEditor": {
        "answer": "Yes. The selection popover appears in task description fields and Monaco editors.",
        "question": "Does it work inside the editors?"
      },
      "conflicts": {
        "answer": "The job aborts to avoid overwriting; you can re-run after updating the text.",
        "question": "What if the text changes mid-run?"
      },
      "customize": {
        "answer": "Yes. Templates are stored per project with placeholders for file context and instructions.",
        "question": "Can I customize the prompts?"
      },
      "model": {
        "answer": "The model is configurable per project; defaults are documented in the settings panel.",
        "question": "Which model does it use?"
      }
    },
    "hero": {
      "badge": "Stage 1: Text enhancement and task refinement",
      "credits": "Prompt templates and job metadata are documented for traceability.",
      "description": "Two prompt types turn raw task notes into structured, implementation-ready requirements. Text Enhancement cleans language; Task Refinement expands constraints and edge cases using project context.",
      "installButton": "Read the docs",
      "subtitle": "Outputs are stored with the task and feed directly into file discovery and plan generation.",
      "title": "Specification Capture: Text Enhancement and Task Refinement"
    },
    "howItWorks": {
      "steps": [
        {
          "step": "Select text or task description",
          "description": "Highlight text in a task description or plan note to open the refinement popover."
        },
        {
          "step": "Choose a prompt type",
          "description": "Run Text Enhancement for clarity or Task Refinement for completeness and constraints."
        },
        {
          "step": "Capture context",
          "description": "The job bundles task text, project settings, and optional file context for the prompt."
        },
        {
          "step": "Apply and store results",
          "description": "Refined text replaces the selection and is stored with job metadata for traceability."
        }
      ],
      "title": "Pipeline steps"
    },
    "painPoints": {
      "mentalModels": {
        "description": "Design intent, edge cases, and non-functional requirements need to be explicit before planning.",
        "title": "Constraints must be explicit"
      },
      "rewriting": {
        "description": "Manual cleanup often changes intent and loses details that matter in downstream plans.",
        "title": "Manual cleanup can drift intent"
      },
      "title": "Why this stage exists",
      "vague": {
        "description": "Loose task text yields brittle plans because constraints and acceptance criteria are missing.",
        "title": "Unstructured notes produce ambiguous prompts"
      }
    },
    "promptTypes": {
      "note": "Both prompts write results back to the task and store job metadata for traceability.",
      "taskRefinement": {
        "description": "Expands requirements with constraints, edge cases, and acceptance criteria using project context.",
        "features": [
          "Surfaces implicit requirements",
          "Adds validation and rollback notes",
          "Highlights affected components",
          "Prepares inputs for file discovery"
        ],
        "title": "Task Refinement (task_refinement job)"
      },
      "textEnhancement": {
        "description": "Lightweight prompt for grammar, clarity, and structure without changing meaning.",
        "features": [
          "Keeps original intent and terminology",
          "Normalizes style for review",
          "Preserves code identifiers",
          "Returns a single replacement block"
        ],
        "title": "Text Enhancement (text_improvement job)"
      },
      "title": "Two prompt types in the pipeline"
    },
    "useCases": {
      "clarify": {
        "description": "Turn a vague note into a structured spec with constraints and acceptance criteria.",
        "title": "Clarify ambiguous requirements"
      },
      "expand": {
        "description": "Expand shorthand into full requirements with dependencies and validation steps.",
        "title": "Expand shorthand notes"
      },
      "refine": {
        "description": "Normalize and polish text before review and file discovery.",
        "title": "Refine for review"
      },
      "title": "Example outcomes"
    }
  },
  "voiceTranscription": {
    "accuracy": {
      "bottomLine": "Summary: Accuracy and latency directly affect how much cleanup is needed before refinement jobs.",
      "about": "About the evaluation context",
      "models": {
        "aws": "Language coverage and diarization settings stored with job metadata.",
        "google": "Latency and word-error-rate tracked per run.",
        "gpt": "Primary speech-to-text provider configured per project.",
        "whisper": "Optional baseline model used for comparison when enabled."
      },
      "title": "Accuracy Benchmarks"
    },
    "capabilities": {
      "multiLanguage": {
        "description": "The configured transcription provider supports multiple languages. Project settings select the default language.",
        "title": "Multiple Language Support"
      },
      "perProject": {
        "description": "Set project defaults for language, temperature, and transcription model. Integrates with text_improvement and task_refinement prompts.",
        "title": "Per-Project Configuration"
      },
      "terminalDictation": {
        "description": "Dictate commands into the active PTY session; the transcript is inserted into the terminal input buffer.",
        "title": "Terminal Dictation (Stage 5)"
      },
      "title": "Key Capabilities"
    },
    "cta": {
      "description": "Stage 1 captures requirements by voice; Stage 5 lets you dictate commands into PTY sessions. The docs walk through the job flow and storage model.",
      "links": {
        "docs": "Voice transcription docs",
        "textImprovement": "Text enhancement and refinement"
      },
      "title": "Voice transcription in the pipeline"
    },
    "example": {
      "competitor": {
        "label": "Baseline transcription",
        "text": "Create a Postgres replica in us-east with 2 CPUs, 8GB RAM, and enable replication; set wal level logical and max senders equals ten."
      },
      "comparisonTitle": "Token-level comparison",
      "errorSummary": "Errors \u2014 Substitutions: {sub}, Deletions: {del}, Insertions: {ins}. Small errors can flip units or flags.",
      "impact": "Impact: Mishearing \"read-replica\" as \"replica\", dropping region suffix \"-1\", or changing \"wal_level=logical\" can lead to incorrect deployments or data flows.",
      "primaryBadge": "reference-aligned",
      "primaryLabel": "Primary transcription model",
      "gpt": "Create a Postgres read-replica in us-east-1 with 2 vCPU, 8 GB RAM, and enable logical replication; set wal_level=logical and max_wal_senders=10.",
      "reference": "Create a Postgres read-replica in us-east-1 with 2 vCPU, 8GB RAM, and enable logical replication; set wal_level=logical and max_wal_senders=10.",
      "title": "Transcription comparison"
    },
    "faq": {
      "customize": {
        "answer": "Yes. You can configure language and model settings per project. Settings persist across sessions and are reused by transcription jobs.",
        "question": "Can I customize transcription settings per project?"
      },
      "languages": {
        "answer": "Supported languages depend on the configured transcription provider. You can set a default language per project.",
        "question": "Which languages are supported for voice transcription?"
      },
      "model": {
        "answer": "The transcription model is configured per project from the provider allowlist.",
        "question": "Which model is used for transcription?"
      },
      "offline": {
        "answer": "No. Voice transcription requires an internet connection to send audio to the configured provider.",
        "question": "Does voice transcription work offline?"
      },
      "whereToUse": {
        "answer": "Voice transcription works in two places: (1) Task description panel - dictate implementation requirements (Stage 1), and (2) Terminal modal - dictate commands that are appended to your active shell session (Stage 5).",
        "question": "Where can I use voice transcription in the app?"
      }
    },
    "hero": {
      "badge": "Stage 1 & Stage 5 Voice Input",
      "description": "Dictate tasks and commands; audio is sent to the configured transcription provider and stored as task artifacts or PTY input. Voice transcription respects per-project settings and feeds text_improvement and task_refinement jobs.",
      "title": "Voice transcription for specification capture and terminal control"
    },
    "workflow": {
      "stage1": {
        "description": "Dictate tasks to capture constraints, context, and intent; transcripts become inputs for refinement jobs.",
        "title": "Stage 1: Dictating Tasks"
      },
      "stage5": {
        "description": "Dictate terminal commands while reviewing output or diffs; the command is inserted into the PTY input.",
        "title": "Stage 5: Terminal Voice Control"
      },
      "integration": {
        "description": "Voice respects per-project language and temperature settings. Transcripts feed into text_improvement for grammar polish and task_refinement for completeness expansion.",
        "title": "Integration with Text Enhancement Prompts"
      },
      "title": "Voice Transcription Across Stages"
    },
    "nextSteps": {
      "description": "Voice transcription is Stage 1 input in the planning pipeline. After capturing raw thoughts, text_improvement cleans grammar and task_refinement expands completeness, preparing specs for Stage 2 file discovery.",
      "link": "Learn about text_improvement and task_refinement",
      "taskRefinement": {
        "description": "Expand descriptions with implied requirements, edge cases, and technical considerations. Prepares specs for FileFinderWorkflow.",
        "title": "Task Refinement (Stage 1 \u2192 2)"
      },
      "textEnhancement": {
        "description": "Polish grammar, improve clarity, and preserve intent for review.",
        "title": "Text Enhancement (Stage 1)"
      },
      "title": "Refine Voice Transcripts Before File Discovery"
    },
    "painPoints": {
      "captureIdeas": {
        "description": "Dictation preserves context at discovery time and creates transcript artifacts for refinement jobs.",
        "title": "Capture context at discovery time"
      },
      "contextSwitching": {
        "description": "Dictation writes directly into the active task or terminal field so the session context stays intact.",
        "title": "Keep input in the active surface"
      },
      "handsBusy": {
        "description": "Voice capture keeps input flowing during code review, debugging, or sketching; transcripts stay linked to the task or session.",
        "title": "Hands-free input during active review"
      },
      "title": "Why voice capture exists in intake"
    },
    "useCases": {
      "codeReview": {
        "outcome": "Transcript artifacts are ready for text_improvement and task_refinement.",
        "scenario": "While reviewing a diff, dictate refactor requirements into the task panel; the transcript is stored with the task.",
        "title": "Dictate refactor notes during review (Stage 1)"
      },
      "fasterEntry": {
        "outcome": "Notes are queued for task_refinement to normalize into specs.",
        "scenario": "After QA, dictate multiple bug reports; each transcript is stored as a task note.",
        "title": "Batch capture for repeated reports"
      },
      "handsFree": {
        "outcome": "Captured text is stored as task input and can be refined later.",
        "scenario": "During a debugging session, dictate related issues without leaving the terminal or editor.",
        "title": "Capture issues during debug (Stage 1)"
      },
      "terminalCommands": {
        "outcome": "The command and output are logged to the session history.",
        "scenario": "While monitoring output, dictate a command into the active PTY input buffer.",
        "title": "Dictated commands in PTY (Stage 5)"
      },
      "title": "Pipeline examples"
    }
  },
  "integratedTerminal": {
    "cta": {
      "description": "A terminal surface tied to planning artifacts, with persistent PTY sessions and SQLite-backed history.",
      "links": {
        "docs": "Read technical docs",
        "voice": "Explore voice commands"
      },
      "title": "Trace the terminal pipeline"
    },
    "features": {
      "integratedPlanning": {
        "description": "Execute implementation plans and copy steps into the terminal with plan/job IDs preserved in the session log.",
        "title": "Integrated with Planning"
      },
      "persistent": {
        "description": "Sessions persist in SQLite so terminal context can be rehydrated across restarts.",
        "title": "Persistent Sessions"
      },
      "title": "Terminal surface capabilities",
      "voiceSupport": {
        "description": "Copy buttons and voice dictation insert commands into PTY sessions while keeping the plan view intact.",
        "title": "Voice and Copy Support"
      }
    },
    "hero": {
      "badge": "Integrated PTY Terminal",
      "description": "Execute plan steps in persistent PTY sessions; output streams to the UI and persists in SQLite session logs.",
      "title": "Job-centric terminal that keeps context"
    }
  },
  "videoAnalysis": {
    "meta": {
      "title": "Video Analysis Pipeline - PlanToCode",
      "description": "Multimodal ingestion pipeline for recordings: frame extraction, transcript analysis, and structured task artifacts."
    },
    "capabilities": {
      "fileUpload": {
        "description": "Upload existing recordings and normalize formats for analysis.",
        "features": [
          "MP4, WebM, MOV, AVI support",
          "Drag-and-drop upload",
          "Chunked processing"
        ],
        "title": "Recording upload"
      },
      "fpsControl": {
        "description": "Tune FPS to balance detail, cost, and latency; settings can be stored per project.",
        "features": [
          "1-2 FPS for long recordings",
          "3-5 FPS for most recordings",
          "6-10 FPS for rapid UI changes"
        ],
        "title": "Frame extraction control"
      },
      "gemini": {
        "description": "Select model for cost vs depth; usage is tracked with the job metadata.",
        "features": [
          "Model selection per run",
          "Usage and cost tracking",
          "Consistent structured outputs"
        ],
        "title": "Model selection"
      },
      "screenRecording": {
        "description": "Local capture with synchronized audio and video stored alongside the task.",
        "features": [
          "Full screen or window capture",
          "Audio and video sync",
          "Stored with the task id"
        ],
        "title": "Screen recording"
      },
      "title": "Pipeline controls"
    },
    "cta": {
      "description": "Connect video artifacts to the rest of the planning pipeline: deep research and file discovery.",
      "links": {
        "fileDiscovery": "File discovery pipeline",
        "research": "Deep research stage"
      },
      "title": "Continue in the pipeline"
    },
      "faq": {
        "formats": {
          "answer": "MP4, WebM, MOV, and AVI are supported. Frames are extracted locally based on your FPS setting before analysis.",
          "question": "Which video formats are supported?"
        },
        "fps": {
          "answer": "1-2 FPS for long recordings, 3-5 FPS for most recordings, 6-10 FPS for rapid UI changes. Higher FPS increases cost and detail.",
          "question": "What FPS settings should I use?"
        },
        "model": {
          "answer": "Fast models trade depth for cost and latency; deep models capture more context for complex flows. Choose per run based on the task.",
          "question": "Which model should I choose?"
        },
      "optimization": {
        "answer": "Lower FPS, trim to relevant segments, and choose fast analysis when deep context is not required.",
        "question": "How can I optimize analysis costs?"
      }
    },
    "hero": {
      "badge": "Stage 1 input: Video and audio ingestion",
      "description": "Ingest screen recordings or meeting videos, extract frames and transcripts, run multimodal analysis through configured providers, and store structured task artifacts for planning.",
      "title": "Multimodal video analysis for requirements capture"
    },
    "howItWorks": {
      "steps": [
        {
          "title": "Capture or upload video",
          "description": "Record in-app or upload MP4/WebM/MOV/AVI files. Videos are stored locally before analysis."
        },
        {
          "title": "Extract frames and transcript",
          "description": "Frame extraction runs at the configured FPS and audio is transcribed with timestamps."
        },
        {
          "title": "Run multimodal analysis",
          "description": "The analysis prompt combines transcript + frames to produce structured outputs."
        },
        {
          "title": "Attach to the task pipeline",
          "description": "Artifacts are attached to the task and feed task_refinement and file discovery."
        }
      ],
      "title": "How the pipeline runs"
    },
    "insights": {
      "actionItems": {
        "description": "Action items with owners, dependencies, and links to timestamps and frames.",
        "title": "Action items"
      },
      "decisions": {
        "description": "Decisions captured with context and source timestamps.",
        "title": "Decisions"
      },
      "description": "Analysis results are stored as structured artifacts with references to timestamps and frames so reviewers can promote them into plan inputs.",
      "discussionPoints": {
        "description": "Open questions and alternatives linked to the original segment.",
        "title": "Discussion points"
      },
      "title": "Structured outputs"
    },
    "models": {
      "flash": {
        "description": "Lower cost and latency for straightforward UI flows and documentation.",
        "features": [
          "Fast turnaround",
          "Lower cost per frame",
          "Good for simple flows"
        ],
        "title": "Fast analysis model"
      },
      "pro": {
        "description": "Deeper context for complex UI issues and nuanced workflows.",
        "features": [
          "Richer reasoning",
          "Better for complex flows",
          "Higher cost per frame"
        ],
        "title": "Deep analysis model"
      },
      "title": "Model tradeoffs"
    },
    "multimodal": {
      "audioTranscript": {
        "description": "Transcribe audio with timestamps and speaker cues, then feed the transcript into analysis prompts.",
        "features": [
          "Timestamped transcript",
          "Speaker markers when available",
          "Links to frame ranges"
        ],
        "title": "Audio transcript extraction"
      },
      "title": "Audio and visual extraction",
      "visualContent": {
        "description": "Sample frames at configurable FPS and extract on-screen text, UI states, and key moments.",
        "features": [
          "Frame sampling and keyframe selection",
          "OCR and UI state capture",
          "Frame ids linked to insights"
        ],
        "title": "Visual frame analysis"
      }
    },
    "painPoints": {
      "incompleteNotes": {
        "description": "Screenshare changes, error dialogs, and diagrams rarely make it into structured artifacts without frame references.",
        "title": "Manual notes omit frame references"
      },
      "requirementsLost": {
        "description": "Text notes miss on-screen context, timing, and the exact UI state; frame extraction preserves that context.",
        "title": "UI state lives in recordings"
      },
      "reviewTime": {
        "description": "Long recordings are condensed into timestamped artifacts with frame references.",
        "title": "Raw recordings are expensive to review"
      },
      "title": "Why multimodal ingestion exists"
    },
    "useCases": {
      "bugCapture": {
        "description": "Extract error states, UI transitions, and reproduction steps with timestamps.",
        "title": "Bug timeline artifacts"
      },
      "onboarding": {
        "description": "Generate structured walkthrough notes with referenced frames.",
        "title": "Walkthrough summaries"
      },
      "title": "Example outputs",
      "uiDemo": {
        "description": "Capture UI patterns and states with linked timestamps and frames.",
        "title": "UI state capture"
      }
    }
  },
  "copyButtons": {
    "meta": {
      "title": "Copy Buttons - Template Handoff",
      "description": "Copy buttons apply prompt templates with placeholders like {{IMPLEMENTATION_PLAN}} and {{TASK_DESCRIPTION}} to standardize execution handoff."
    },
    "concept": {
      "dragDrop": {
        "description": "Drag-and-drop ordering for button sets. Organize buttons by execution stage or priority.",
        "title": "Drag-and-drop ordering"
      },
      "serverConfigured": {
        "description": "Template prompts with placeholders: {{IMPLEMENTATION_PLAN}}, {{TASK_DESCRIPTION}}, {{PROJECT_CONTEXT}}. Server-side defaults with project-specific overrides.",
        "title": "Template Placeholders"
      },
      "terminal": {
        "description": "Send templated commands to persistent terminal sessions (Stage 5). Chunked sending for large XML plans.",
        "title": "Terminal integration (Stage 5)"
      }
    },
    "configuration": {
      "projectSettings": {
        "description": "Copy buttons stored in task settings with project-level overrides and server-side defaults.",
        "features": [
          "SQLite database persistence",
          "Server-managed default configurations",
          "Project directory scoping",
          "Configuration updates"
        ],
        "title": "Project-Specific Settings"
      },
      "title": "Configuration & Management",
      "visualUI": {
        "description": "Configuration editor with drag-drop reordering, debounced input handling, and preview.",
        "features": [
          "Drag handles for visual reordering",
          "300ms debounced input processing",
          "Read-only mode for system buttons",
          "Template ordering support"
        ],
        "title": "Visual Configuration UI"
      }
    },
    "cta": {
      "description": "Copy buttons insert structured plan content into templated prompts for consistent execution handoff.",
      "links": {
        "planMode": "See Stage 3 planning & Stage 4 merge",
        "terminal": "Explore Stage 5 terminal integration"
      },
      "title": "Template-driven execution handoff"
    },
    "exampleConfig": {
      "title": "Example button configuration:",
      "footer": "\u2192 Button runs the configured template",
      "templateBody": "{{IMPLEMENTATION_PLAN}}\n\nReview the plan. Read the files mentioned, understand them and launch parallel coding agents that run at the same time..."
    },
    "exampleLabels": {
      "button": "Button:",
      "dynamic": "Dynamic:",
      "label": "Label:",
      "purpose": "Purpose:",
      "result": "Result:",
      "template": "Template:"
    },
    "exampleValues": {
      "investigationButton": "\"Investigate Results\"",
      "investigationPurpose": "Thorough validation workflows",
      "parallelButton": "\"Parallel agent template\"",
      "parallelPurpose": "Complex multi-agent setup instructions",
      "projectContextTemplate": "{{PROJECT_CONTEXT}}",
      "projectDynamic": "Project-aware instructions",
      "stepResult": "Focused step execution",
      "stepTemplate": "{{STEP_CONTENT}}"
    },
    "hero": {
      "badge": "Template handoff",
      "description": "Copy buttons insert {{IMPLEMENTATION_PLAN}}, {{TASK_DESCRIPTION}}, and path context into predefined templates.",
      "title": "Template prompts with plan substitution"
    },
    "technical": {
      "architecture": {
        "heading": "# Copy button system architecture",
        "note": "[Extend with new placeholders and templates as needed]",
        "sections": {
          "execution": "## 4. Execution flow",
          "processing": "## 2. Template processing",
          "storage": "## 1. Configuration storage",
          "ui": "## 3. UI integration"
        },
        "execution": "Button click triggers template processing \u2192 Placeholder substitution with plan content \u2192 Terminal session validation \u2192 Chunked content transmission",
        "processing": "Regex-based placeholder matching \u2192 Dynamic content substitution \u2192 Context-aware data extraction \u2192 Error handling for undefined values",
        "storage": "CopyButtonConfig[] in task settings \u2192 Project-specific database storage \u2192 Server-side default configurations \u2192 Configuration synchronization",
        "ui": "Implementation plan cards \u2192 Content viewing modals \u2192 Terminal interface headers \u2192 Drag-drop configuration editor"
      },
      "title": "Technical Implementation"
    },
    "templateSystem": {
      "placeholders": {
        "description": "Template prompts with {{PLACEHOLDER}} substitution. Context-aware processing with implementation plans from Stage 3/4.",
        "examples": [
          "{{IMPLEMENTATION_PLAN}} - Full merged plan XML",
          "{{STEP_CONTENT}} - Selected step content",
          "{{TASK_DESCRIPTION}} - Stage 1 requirements",
          "{{PROJECT_CONTEXT}} - File paths, structure"
        ],
        "title": "Placeholder Substitution"
      },
      "processor": {
        "description": "Template processor injects XML plans, task descriptions, and governance constraints into predefined prompts.",
        "features": [
          "Regex-based placeholder matching",
          "XML plan formatting and escaping",
          "Multi-line governance instruction support",
          "Graceful undefined handling"
        ],
        "title": "Unified Prompt Processing"
      },
      "title": "Template system"
    },
    "terminalIntegration": {
      "oneClick": {
        "description": "Copy buttons integrate with Stage 5 terminal sessions and insert plan context into the active PTY with logging.",
        "features": [
          "Automatic paste to active terminal session",
          "Chunked sending for large XML plans",
          "Session health monitoring",
          "Clipboard fallback for safety"
        ],
        "title": "Stage 5 execution handoff"
      },
      "title": "Stage 5 Terminal Execution"
    },
    "useCases": {
      "customTeam": {
        "description": "Team-specific governance constraints with {{PROJECT_CONTEXT}} and coding standards.",
        "title": "Team governance templates"
      },
      "investigation": {
        "description": "Standardized review prompts for Stage 3 implementation plan results.",
        "title": "Investigation and review"
      },
      "parallel": {
        "description": "Example button: \"Parallel agent template\" inserts the plan XML and governance instructions.",
        "title": "Parallel agent templates"
      },
      "stepByStep": {
        "description": "Extract individual implementation steps with {{STEP_CONTENT}}. Execute step-by-step with full plan context.",
        "title": "Step-by-step execution"
      },
      "title": "Example configurations"
    }
  },
  "deepResearch": {
    "meta": {
      "title": "Deep Research - Web Search Pipeline",
      "description": "Background research jobs fetch migration guides and API docs, then attach summaries to tasks and plans when additional context is needed."
    },
    "advanced": {
      "features": [
        {
          "title": "Migration guide retrieval",
          "description": "Fetches official migration guides and breaking changes for framework upgrades (e.g., Next.js 14 \u2192 15 or React 17 \u2192 18)."
        },
        {
          "title": "API documentation retrieval",
          "description": "Background jobs pull API documentation, SDK changes, and version compatibility notes for external services."
        },
        {
          "title": "Background Processing",
          "description": "Long-running research tasks execute in the background with progress updates."
        },
        {
          "title": "Plan Context Integration",
          "description": "Research findings attach to task descriptions or implementation plans and feed into plan prompts."
        },
        {
          "title": "Pattern extraction",
          "description": "Summarizes recommended patterns, anti-patterns, and gotchas from official documentation and community sources."
        },
        {
          "title": "On-demand research",
          "description": "Runs research only when needed, with query gating and provider limits."
        }
      ],
      "title": "Research helper capabilities"
    },
    "aiCapabilities": {
      "multiModel": {
        "description": "Supports multiple configured models for research tasks with different prompts or scopes.",
        "models": [
          "Configured provider models",
          "Research-specific prompt variants",
          "Per-task allowlists",
          "Context window limits"
        ],
        "title": "Multi-model routing"
      },
      "parallel": {
        "description": "Execute multiple research tasks simultaneously with result aggregation and synthesis.",
        "features": [
          "Concurrent execution",
          "Progress tracking",
          "Error handling",
          "Result synthesis"
        ],
        "title": "Parallel execution"
      },
      "projectContext": {
        "description": "Uses project structure, technology stack, and dependencies to contextualize research prompts.",
        "features": [
          "File structure signals",
          "Technology stack detection",
          "Dependency mapping",
          "Context tokens in prompts"
        ],
        "title": "Project context integration"
      },
      "title": "Research job controls"
    },
    "cta": {
      "description": "Use this stage for migrations or complex upgrades. Background jobs fetch sources, summarize findings, and attach notes to tasks and plans.",
      "links": {
        "planMode": "See Stage 3 implementation planning",
        "textImprovement": "Explore Stage 1 text enhancement"
      },
      "title": "Research pipeline for migrations and upgrades"
    },
    "developmentFocus": {
      "contextFiltering": {
        "description": "Research scope tailored to the migration scenario: relevant framework versions, API changes, and compatibility notes.",
        "features": [
          "Framework version compatibility checking",
          "Breaking change identification",
          "Migration path recommendations",
          "Deprecated API alternatives"
        ],
        "title": "Migration-Focused Filtering"
      },
      "implementationReady": {
        "description": "Research results formatted for implementation plans, including code examples, migration scripts, and upgrade steps.",
        "features": [
          "Migration code snippet extraction",
          "Upgrade script templates",
          "Breaking change workarounds",
          "Rollback strategy notes"
        ],
        "title": "Implementation-Ready Migration Insights"
      },
      "title": "Migration-focused research"
    },
    "features": {
      "parallelExecution": {
        "description": "Execute multiple provider queries concurrently (migration guides, upgrade docs, compatibility notes).",
        "title": "Parallel search execution"
      },
      "projectIntegration": {
        "description": "Research findings attach to task descriptions or implementation plans and inform plan prompts with sources and constraints.",
        "title": "Task and plan integration"
      },
      "queryGeneration": {
        "description": "Queries are generated from migration context, API upgrades, and library version changes, with multiple angles when needed.",
        "title": "Query planning"
      }
    },
    "hero": {
      "badge": "Background research stage",
      "description": "Background jobs generate search queries, fetch migration guides and API docs, then attach summaries and citations to tasks and plans.",
      "title": "Deep research pipeline for migrations and upgrades"
    },
    "intelligence": {
      "contextIntegration": {
        "description": "Findings attach to the task description and feed plan prompts with sources and constraints.",
        "features": [
          "Structured research notes",
          "Constraints and compatibility flags",
          "Links back to sources",
          "Plan prompt attachment"
        ],
        "title": "Task and plan integration"
      },
      "execution": {
        "description": "Research jobs run queries across providers, normalize responses, and track usage per job.",
        "features": [
          "Parallel execution with progress updates",
          "Provider routing and retry handling",
          "Result normalization and deduplication",
          "Usage and cost metadata per job"
        ],
        "title": "Search execution"
      },
      "queryExpansion": {
        "description": "Expands the initial task into provider-specific search queries based on versions, APIs, and constraints.",
        "features": [
          "Version- and dependency-aware queries",
          "Multiple query variants for coverage",
          "Provider-specific syntax tuning",
          "Rate-limit aware batching"
        ],
        "title": "Query planning"
      },
      "synthesis": {
        "description": "Summarizes results into structured notes with citations and version context.",
        "features": [
          "Citation-linked summaries",
          "Version-specific recommendations",
          "Task-context tags",
          "Plan-ready excerpts"
        ],
        "title": "Result synthesis"
      },
      "title": "Research pipeline stages"
    },
    "process": {
      "stage1": {
        "description": "Generate queries from task context, version targets, and constraints. The query set is stored with the job for traceability.",
        "title": "Query generation stage"
      },
      "stage2": {
        "description": "Execute provider searches, extract results, and store summaries with citations and metadata.",
        "title": "Search execution stage"
      },
      "title": "Two-stage research process"
    }
  },
  "features": {
    "copyButtons": {
      "description": "Template-based prompt buttons that inject plan snippets, file lists, and task inputs.",
      "slug": "/docs/copy-buttons",
      "title": "Copy Buttons"
    },
    "deepResearch": {
      "description": "Parallel research stages that gather external context and attach notes before planning.",
      "slug": "/docs/deep-research",
      "title": "Deep Research"
    },
    "fileDiscovery": {
      "description": "Multi-stage file discovery pipeline that scores and persists relevant files before planning.",
      "slug": "/docs/file-discovery",
      "title": "File Discovery",
      "meta": {
        "title": "File Discovery Pipeline - PlanToCode",
        "description": "Multi-stage workflow that indexes, filters, and scores files before LLM planning."
      }
    },
    "integratedTerminal": {
      "description": "PTY-backed terminal sessions with persistent logs and job binding.",
      "slug": "/docs/terminal-sessions",
      "title": "Integrated Terminal"
    },
    "mergeInstructions": {
      "description": "Plan merge processor that reconciles multiple plan drafts into one structured sequence.",
      "slug": "/docs/merge-instructions",
      "title": "Plan Merge Instructions",
      "meta": {
        "title": "Plan Merge Processor - Structured Merge",
        "description": "Structured merge of multiple plans with explicit instructions and traceable step alignment."
      }
    },
    "planMode": {
      "description": "Structured implementation plans with reviewable steps and links back to jobs.",
      "slug": "/docs/implementation-plans",
      "title": "Implementation Plans",
      "meta": {
        "title": "Implementation Planning Pipeline - PlanToCode",
        "description": "Generate structured, reviewable implementation plans before execution."
      }
    },
    "textImprovement": {
      "description": "Text improvement and task refinement prompts that normalize requirements.",
      "slug": "/docs/text-improvement",
      "title": "Task Refinement & Text Improvement",
      "meta": {
        "title": "Task Refinement & Text Improvement",
        "description": "Normalize task descriptions and expand missing constraints before planning."
      }
    },
    "videoAnalysis": {
      "description": "Multimodal ingestion of recordings with frame extraction, transcripts, and structured task artifacts.",
      "slug": "/docs/video-analysis",
      "title": "Video Analysis Pipeline"
    },
    "voiceTranscription": {
      "description": "Speech-to-text capture for requirements and terminal commands.",
      "slug": "/docs/voice-transcription",
      "title": "Voice to Text",
      "meta": {
        "title": "Voice Transcription Pipeline",
        "description": "Capture spoken requirements with transcript insertion and session context."
      }
    }
  }
}
