{
  "hub": {
    "meta": {
      "title": "PlanToCode Features - AI Development Planning Tools",
      "description": "Explore powerful features: file discovery, multi-model planning, voice transcription, video analysis, merge instructions, and integrated terminal execution."
    },
    "badge": "Powerful Features",
    "cta": {
      "button": "Download PlanToCode",
      "description": "Download PlanToCode and start planning your code changes with confidence.",
      "title": "Ready to Experience Safe AI Development?"
    },
    "description": "Comprehensive tools for planning, reviewing, and executing complex code changes. From file discovery to terminal execution, everything you need for safe AI-assisted development.",
    "learnMore": "Learn more",
    "title": "AI Development Planning Features"
  },
  "fileDiscovery": {
    "benefits": {
      "costEffective": {
        "description": "Token-optimized workflow with intelligent batching. Cost tracking built into every stage.",
        "title": "Cost-Effective Operation"
      },
      "multiStage": {
        "description": "4-stage AI workflow with regex filtering, relevance assessment, and relationship analysis to identify the most relevant files.",
        "title": "Multi-Stage Intelligence"
      },
      "realTimeProgress": {
        "description": "Live progress tracking with stage-by-stage updates. See exactly what the AI is discovering.",
        "title": "Real-Time Progress"
      }
    },
    "capabilities": {
      "git": {
        "description": "Executes `git ls-files --cached --others --exclude-standard` to respect .gitignore rules. Falls back to git2 library if command fails.",
        "features": [
          "Git ls-files with .gitignore respect",
          "Binary file detection and filtering",
          "Extension-based exclusion (97 types)",
          "Content analysis for binary detection"
        ],
        "title": "Git Repository Integration"
      },
      "planIntegration": {
        "description": "Discovered files feed directly into the implementation planning system. Context is preserved and optimized for plan generation, ensuring comprehensive and accurate results.",
        "features": [
          "Seamless plan generation integration",
          "Context preservation across sessions",
          "Multi-model plan generation support",
          "Architectural synthesis preparation"
        ],
        "title": "Implementation Plan Integration"
      },
      "title": "Advanced Discovery Capabilities",
      "tokenManagement": {
        "description": "Content-aware token estimation optimizes batching. Different ratios for JSON/XML (5 chars/token), code (3 chars/token), and text (4 chars/token) ensure efficient processing.",
        "features": [
          "Dynamic chunk sizing per file type",
          "2000-token prompt overhead reservation",
          "Batch processing (100 files default)",
          "30-second file caching TTL"
        ],
        "title": "Smart Token Management"
      },
      "workflow": {
        "description": "WorkflowOrchestrator manages lifecycle with lazy initialization, dependency scheduling, and orphaned job recovery. Each stage runs as an independent background job.",
        "features": [
          "Stage dependency management",
          "Event-driven progress updates via Tauri",
          "WorkflowIntermediateData persistence",
          "Exponential backoff retry logic"
        ],
        "title": "Distributed Workflow Orchestration"
      }
    },
    "cta": {
      "description": "Let AI navigate your codebase intelligently. From repository analysis to implementation-ready context, this is how file discovery should work - smart, efficient, cost-effective.",
      "links": {
        "docs": "Read technical documentation",
        "planMode": "See implementation planning"
      },
      "title": "Experience Intelligent File Discovery"
    },
    "hero": {
      "badge": "AI-powered repository navigation",
      "description": "PlanToCode maps impacted files before you run anything. You get a focused context you can trust.",
      "title": "Find what matters in your codebase automatically"
    },
    "performance": {
      "accuracy": {
        "description": "Multi-stage refinement with AI-powered relevance assessment and relationship analysis.",
        "title": "Accuracy Rate",
        "value": "High"
      },
      "cost": {
        "description": "Per workflow run. Smart token optimization keeps costs minimal while maximizing discovery quality.",
        "title": "Typical Cost",
        "value": "$0.10-0.15"
      },
      "speed": {
        "description": "Depends on repository size and complexity. Real-time progress tracking with stage-by-stage updates.",
        "title": "Processing Time",
        "value": "Variable"
      },
      "title": "Cost-Effective and Fast"
    },
    "workflow": {
      "stage1": {
        "description": "AI analyzes your directory structure (up to 2 levels deep) to identify relevant project areas. Uses hierarchical intelligence to select parent folders vs. subdirectories.",
        "features": [
          "Hierarchical directory analysis",
          "Smart parent/subdirectory selection",
          "Avoids redundant nested selections"
        ],
        "title": "Root Folder Selection"
      },
      "stage2": {
        "description": "Generates intelligent regex patterns and performs initial file filtering. Integrates with git to respect .gitignore rules and filter binary files.",
        "features": [
          "Dynamic regex pattern creation",
          "Git ls-files integration",
          "Binary file detection and exclusion"
        ],
        "title": "Regex Pattern Generation & Filtering"
      },
      "stage3": {
        "description": "Deep content analysis using LLM to assess file relevance to your task. Uses intelligent batching with content-aware token estimation for optimal processing.",
        "features": [
          "Content-based relevance scoring",
          "Intelligent token-aware batching",
          "2000-token overhead management"
        ],
        "title": "AI File Relevance Assessment"
      },
      "stage4": {
        "description": "Discovers additional contextually relevant files through relationship analysis. Analyzes imports, configurations, and project structure to find related files.",
        "features": [
          "Import statement analysis",
          "Dependency graph traversal",
          "Configuration file discovery"
        ],
        "title": "Extended Path Discovery"
      },
      "title": "The 4-Stage Discovery Process"
    }
  },
  "mergeInstructions": {
    "capabilities": {
      "instructionControl": {
        "examples": [
          {
            "type": "Prioritization",
            "example": "\"Focus on Plan 2's security\""
          },
          {
            "type": "Structure",
            "example": "\"Organize by component\""
          },
          {
            "type": "Approach",
            "example": "\"Use Plan 1's database strategy\""
          },
          {
            "type": "Quality",
            "example": "\"Include comprehensive testing\""
          },
          {
            "type": "Scope",
            "example": "\"Exclude deployment steps\""
          },
          {
            "type": "Integration",
            "example": "\"Use example from docs\""
          },
          {
            "type": "Resolution",
            "example": "\"Prefer microservices over monolith\""
          }
        ],
        "title": "How Instructions Control Synthesis"
      },
      "title": "Actual System Capabilities",
      "whatAIDoes": {
        "items": [
          "Studies all source plans to identify unique insights",
          "Resolves architectural conflicts using SOLID principles",
          "Creates emergent solutions beyond simple combination",
          "Adds inline source markers for every decision",
          "Validates architectural coherence throughout",
          "Handles external example integration",
          "Maintains relevance to original task"
        ],
        "title": "What the AI Actually Does"
      }
    },
    "cta": {
      "description": "Beyond merging - intelligent architectural analysis with SOLID principles. This is how plan synthesis should work - intelligent, traceable, emergent.",
      "links": {
        "demo": "Watch it in action",
        "planMode": "Explore plan generation"
      },
      "title": "Experience True Architectural Synthesis"
    },
    "features": {
      "architecturalAnalysis": {
        "description": "Not just concatenation. AI deeply analyzes each plan's architecture, identifying unique insights and approaches.",
        "title": "Genuine Architectural Analysis"
      },
      "solidResolution": {
        "description": "Conflicts resolved using software engineering best practices. Creates architecturally sound solutions.",
        "title": "SOLID Principle Resolution"
      },
      "sourceTraceability": {
        "description": "Every merged element includes inline attribution markers showing exactly which source plan it came from.",
        "title": "Source Traceability [src:P1]"
      }
    },
    "hero": {
      "badge": "Architectural Synthesis with Source Traceability",
      "description": "AI performs deep architectural analysis of multiple plans, resolves conflicts using SOLID principles, and synthesizes emergent solutions. Every decision includes source attribution [src:P1 step 2] for complete traceability.",
      "title": "Beyond Simple Merging: Architectural Synthesis"
    },
    "implementation": {
      "aiPrompt": {
        "description": "Sophisticated prompt enforces quality and traceability.",
        "features": [
          "Expert software architect persona",
          "SOLID principle conflict resolution",
          "Mandatory source attribution",
          "Emergent solution creation",
          "Quality validation gates"
        ],
        "title": "AI System Prompt"
      },
      "backend": {
        "description": "ImplementationPlanMergeProcessor orchestrates the entire synthesis.",
        "features": [
          "Fetches raw XML from source plans",
          "Extracts relevant file contexts",
          "Generates project structure tree",
          "Builds comprehensive LLM prompt",
          "Streams response with real-time updates"
        ],
        "title": "Backend Processing"
      },
      "frontend": {
        "description": "Rich UI for plan selection and instruction input.",
        "features": [
          "MergePlansSection with collapsible UI",
          "FloatingMergeInstructions (draggable)",
          "Real-time text enhancement support",
          "Debounced state management",
          "Session persistence for instructions"
        ],
        "title": "Frontend Components"
      },
      "metadata": {
        "description": "Complete audit trail and debugging capability.",
        "features": [
          "Source job IDs preserved",
          "Full prompt stored for debugging",
          "Merge instructions tracked",
          "File operations extracted",
          "Priority 2 job scheduling"
        ],
        "title": "Metadata & Storage"
      },
      "title": "Technical Implementation Details"
    },
    "process": {
      "deepAnalysis": {
        "description": "AI performs comprehensive analysis before synthesis, not simple concatenation.",
        "features": [
          "Identifies unique insights from each plan",
          "Resolves conflicts using SOLID principles",
          "Preserves valuable architectural decisions",
          "Creates emergent solutions beyond sources"
        ],
        "title": "Deep Architectural Analysis"
      },
      "instructions": {
        "description": "Your instructions directly control the synthesis. AI understands complex architectural guidance.",
        "examples": [
          "Prioritization: \"Focus on security from Plan 2\"",
          "Structure: \"Organize chronologically\"",
          "Approach: \"Use Plan 1's database strategy\"",
          "Scope: \"Exclude testing, focus on core\""
        ],
        "title": "Intelligent Instruction Processing"
      },
      "multiModel": {
        "description": "Run GPT-5.1 and Gemini multiple times. Each run tackles large context differently, surfacing complementary implementation details.",
        "features": [
          "Each plan stored with complete metadata",
          "Relevant files automatically extracted",
          "Project structure context included",
          "Temperature variations for diversity"
        ],
        "title": "Multi-Model Plan Generation"
      },
      "synthesis": {
        "description": "Creates comprehensive solution with complete source attribution for every decision.",
        "features": [
          "Inline markers: [src:P1 step 2, P3 step 5]",
          "External example integration support",
          "Quality validation checkpoints",
          "Architectural coherence maintained"
        ],
        "title": "Synthesis with Full Traceability"
      },
      "title": "The Architectural Synthesis Process"
    },
    "value": {
      "architecturalSynthesis": {
        "description": "Not concatenation. AI performs deep architectural analysis and creates emergent solutions that go beyond any single source plan.",
        "title": "Architectural Synthesis"
      },
      "completeTraceability": {
        "description": "Every decision includes [src:P1 step 2] markers. Know exactly where each architectural choice originated.",
        "title": "Complete Traceability"
      },
      "solidPractices": {
        "description": "Conflicts resolved using software engineering principles, not arbitrary choices. Architecturally sound results.",
        "title": "SOLID Engineering Practices"
      },
      "title": "The Real Value: Beyond Simple Merging"
    }
  },
  "planMode": {
    "copyButtons": {
      "serverConfigured": {
        "description": "Dynamic copy buttons configured server-side with template placeholders.",
        "title": "Server-Configured Buttons"
      },
      "stepExtraction": {
        "description": "Copy individual steps or full plans with automatic content extraction.",
        "title": "Smart Step Extraction"
      },
      "title": "Configurable Copy Button System"
    },
    "cta": {
      "description": "From AI-powered generation to human review to controlled execution. This is how corporate teams adopt AI coding agents confidently—with human-in-the-loop governance, file-by-file granularity, and full control at every step.",
      "links": {
        "mergePlans": "Learn about architectural synthesis",
        "terminal": "See terminal integration"
      },
      "title": "Experience Safe, Human-Controlled AI Development"
    },
    "editing": {
      "monaco": {
        "description": "Full VS Code editor experience. Not a text area - a professional code editor with all features.",
        "features": [
          "XML syntax highlighting",
          "Find & replace with regex",
          "Multi-cursor editing",
          "Auto-save to database"
        ],
        "title": "Monaco Editor Integration"
      },
      "terminal": {
        "description": "Execute plans directly in persistent terminal sessions. Voice input, health monitoring, full control.",
        "features": [
          "Persistent terminal sessions",
          "Voice transcription input",
          "Copy plan/steps to terminal",
          "Session health monitoring"
        ],
        "title": "Integrated Terminal Execution"
      },
      "title": "Professional Editing & Execution"
    },
    "features": {
      "intelligentGeneration": {
        "description": "Full file content loading (no truncation). Smart directory trees. Multi-model support with project configs.",
        "title": "Intelligent Generation"
      },
      "monacoEditor": {
        "description": "VS Code's editor with XML syntax highlighting. Real-time editing with auto-save to database.",
        "title": "Monaco Editor"
      },
      "terminalExecution": {
        "description": "Execute plans directly in integrated terminal. Copy steps or full plans. Voice transcription support.",
        "title": "Terminal Execution"
      }
    },
    "fileByFile": {
      "description": "Plans break down development tasks with exact file paths corresponding to your project's repository structure. This granularity makes the impact of changes crystal clear and prevents regressions, bugs, and unintended modifications that can occur with autonomous coding agents.",
      "exactPaths": {
        "description": "Every step specifies exact file paths from your repository. No ambiguity about which files will be modified, created, or deleted.",
        "title": "Exact File Paths"
      },
      "preventRegressions": {
        "description": "See exactly which legacy code will be touched. Identify potential breaking changes before they happen. Confident adoption of AI coding agents.",
        "features": [
          "Clear impact assessment",
          "Breaking change detection",
          "Legacy code protection"
        ],
        "title": "Prevent Regressions"
      },
      "title": "File-by-File Granularity for Maximum Safety"
    },
    "generation": {
      "fullContext": {
        "description": "Unlike other systems, we load complete file contents. No preemptive truncation - just smart warnings.",
        "features": [
          "Complete file content, no truncation",
          "Parallel file loading for speed",
          "Token warnings at >100k tokens",
          "Smart directory tree generation"
        ],
        "title": "Full Context Loading"
      },
      "multiModel": {
        "description": "Choose from multiple AI models with project-specific configurations and temperature settings.",
        "features": [
          "GPT-5.1, Claude Sonnet 4, Gemini 3 Pro",
          "Project-specific model settings",
          "Real-time token estimation",
          "Context window validation"
        ],
        "title": "Multi-Model Architecture"
      },
      "streaming": {
        "description": "Watch plans generate in real-time with live progress bars and streaming content updates.",
        "features": [
          "Live streaming with progress bars",
          "Real-time syntax highlighting",
          "Token count updates during generation",
          "Background job status tracking"
        ],
        "title": "Real-Time Streaming"
      },
      "title": "AI-Powered Plan Generation with Full Context",
      "xmlFormat": {
        "description": "Plans use structured XML with numbered steps, enabling programmatic manipulation and extraction.",
        "features": [
          "<step number=\"X\"> organization",
          "Title and description per step",
          "File operations tracking",
          "Step-by-step extraction support"
        ],
        "title": "Structured XML Format"
      }
    },
    "guides": {
      "claudeCode": {
        "description": "Enhance Claude Code's native Plan Mode with multi-model synthesis and file discovery.",
        "link": "Open the Claude Code planning workflow guide",
        "name": "Claude Code planning workflow"
      },
      "codex": {
        "description": "Pre-plan Codex runs with file discovery, multi-model merges, and approval modes.",
        "link": "Open the Codex CLI planning workflow guide",
        "name": "Codex CLI planning workflow"
      },
      "cursor": {
        "description": "Give Cursor Composer full architectural awareness, including WSL-safe execution.",
        "link": "Open the Cursor plan workflow guide",
        "name": "Cursor plan workflow"
      },
      "title": "Guides for your IDE plan mode"
    },
    "hero": {
      "badge": "Complete Implementation Planning System",
      "description": "Human-in-the-loop governance with file-by-file granularity for safe AI-assisted development",
      "title": "Implementation plans: generate - edit - execute"
    },
    "humanInLoop": {
      "approve": {
        "description": "When satisfied, securely transmit the approved plan to your chosen coding agent or assigned developer. Full audit trail maintained.",
        "title": "Approve & Transmit"
      },
      "description": "Team leads and stakeholders retain full control to review, edit, and approve every aspect of implementation plans before any code changes begin. This ensures all development efforts align with corporate product requirements, team workflows, and business objectives.",
      "edit": {
        "description": "Full editing capabilities with VS Code features. Adjust approaches, add constraints, remove risky steps. The plan is yours to perfect.",
        "title": "Edit & Modify Plans"
      },
      "review": {
        "description": "Every AI-generated plan opens in Monaco editor for thorough review. No autonomous execution—you see and approve every proposed change.",
        "title": "Review Before Execution"
      },
      "title": "Human-in-the-Loop Governance"
    },
    "technical": {
      "noTruncation": {
        "description": "Full file content loaded. Warns at >100k tokens but doesn't truncate. You get complete context.",
        "title": "No Truncation Policy"
      },
      "persistence": {
        "description": "Plans stored with metadata, cost tracking, and full prompt history. Everything is auditable.",
        "title": "Database Persistence"
      },
      "templates": {
        "description": "Server-side prompts with project overrides. Unified prompt processor with smart placeholders.",
        "title": "Template System"
      },
      "title": "Under the Hood"
    },
    "workflow": {
      "steps": [
        {
          "title": "AI File Discovery",
          "description": "Smart file finder identifies relevant files. Select root directories for focused context. No truncation."
        },
        {
          "title": "Multi-Model Generation",
          "description": "Run models multiple times (3x GPT-5.1, 2x Gemini). Each run surfaces complementary implementation details. Real-time streaming with progress tracking."
        },
        {
          "title": "Edit in Monaco",
          "description": "Professional editing with VS Code features. Add steps, modify approaches, restructure plans."
        },
        {
          "title": "Architectural Synthesis",
          "description": "Merge multiple plans with custom instructions. SOLID principle resolution, source traceability."
        },
        {
          "title": "Execute in Terminal",
          "description": "Run your plan in integrated terminal. Voice commands, persistent sessions, real results."
        }
      ],
      "title": "The Complete Planning Workflow"
    }
  },
  "textImprovement": {
    "capabilities": {
      "contextAware": {
        "description": "AI understands your project structure, included files, and custom instructions when refining text.",
        "title": "Context-aware refinement"
      },
      "customizable": {
        "description": "Define per-project prompts with placeholders for file contents, directory tree, and custom instructions.",
        "title": "Customizable system prompts"
      },
      "instant": {
        "description": "Non-streaming processing for speed. Results applied directly with conflict detection to protect your edits.",
        "title": "Instant application"
      },
      "mentalModel": {
        "description": "Iterative refinement helps AI understand your intent. Select → refine → refine again until perfect.",
        "title": "Mental model capture"
      },
      "title": "Key capabilities"
    },
    "cta": {
      "description": "Stop struggling with vague requirements. Capture ideas with voice, refine them with AI prompts, and create specifications that development teams can confidently implement.",
      "links": {
        "demo": "Watch the demo",
        "voice": "See voice features"
      },
      "title": "Start capturing clear specifications with AI"
    },
    "faq": {
      "codeEditor": {
        "answer": "Yes. Works in task description fields and Monaco code editors. Select text → popover appears → choose action.",
        "question": "Does it work in code editors?"
      },
      "conflicts": {
        "answer": "Conflict detection prevents overwriting your edits. If text changed during processing, the improvement is skipped with a warning.",
        "question": "What if I edit text while improvement is running?"
      },
      "customize": {
        "answer": "Yes. Define per-project system prompts with placeholders for file contents, directory tree, custom instructions, and more.",
        "question": "Can I customize the improvement prompts?"
      },
      "model": {
        "answer": "Default: Claude Sonnet 3.5 via OpenRouter. You can configure different models per project in settings.",
        "question": "Which AI model does text improvement use?"
      }
    },
    "hero": {
      "badge": "Specification Capture Mode • Two AI Prompt Types",
      "credits": "$5 free credits • Pay-as-you-go • Works on macOS and Windows",
      "description": "Specification Capture Mode provides TWO DISTINCT AI prompt types designed to help corporate teams capture and refine requirements that development teams can confidently implement.",
      "installButton": "Install PlanToCode",
      "subtitle": "Text Enhancement improves clarity and grammar. Task Refinement expands completeness and implementation readiness. Both are essential tools for corporate teams managing complex development workflows and detailed requirements gathering.",
      "title": "Specification Capture Mode"
    },
    "howItWorks": {
      "steps": [
        {
          "step": "Select text in task description",
          "description": "Highlight any text in your task description or code editor. A popover appears instantly."
        },
        {
          "step": "Choose \"Improve\" or \"Refine Task\"",
          "description": "Improve: Quick style/clarity fixes. Refine Task: Deep contextual enhancement with project files."
        },
        {
          "step": "AI processes with full context",
          "description": "Claude Sonnet 3.5 analyzes with project files, directory structure, and customizable prompts."
        },
        {
          "step": "Refined text applied inline",
          "description": "Improved text replaces selection automatically. Preserves formatting and cursor position."
        }
      ],
      "title": "How it works"
    },
    "painPoints": {
      "mentalModels": {
        "description": "What you envision doesn't match what gets written down, leading to implementation drift.",
        "title": "Mental models get lost in translation"
      },
      "rewriting": {
        "description": "Manual refinement of ambiguous descriptions slows down planning and creates misalignment.",
        "title": "Rewriting task descriptions wastes time"
      },
      "title": "Why corporate teams use Specification Capture Mode",
      "vague": {
        "description": "AI generates code based on unclear task descriptions, missing critical constraints and edge cases.",
        "title": "Vague requirements lead to wrong implementations"
      }
    },
    "promptTypes": {
      "note": "Both prompt types leverage large language models to enhance content while preserving the original intent and core meaning of user input. This ensures your specifications remain true to your vision while becoming clearer and more complete.",
      "taskRefinement": {
        "description": "Expands task descriptions by identifying implied requirements, filling in overlooked gaps, clarifying expected behavior and edge cases, and adding technical considerations to make tasks more complete and implementation-ready.",
        "features": [
          "Identifies implied requirements",
          "Clarifies edge cases and constraints",
          "Adds technical implementation details",
          "Makes tasks actionable for developers"
        ],
        "title": "Task Refinement"
      },
      "textEnhancement": {
        "description": "Improves grammar, sentence structure, clarity, and conciseness while maintaining the user's original intent, tone, and technical detail level. Perfect for polishing rough drafts and voice transcriptions.",
        "features": [
          "Preserves original meaning and intent",
          "Fixes grammar and punctuation",
          "Improves sentence flow and readability",
          "Maintains technical accuracy"
        ],
        "title": "Text Enhancement"
      },
      "title": "Two Distinct AI Prompt Types"
    },
    "useCases": {
      "clarify": {
        "description": "Turn \"fix the auth bug\" into specific steps with edge cases, affected services, and validation checks.",
        "title": "Clarify vague requirements before planning"
      },
      "expand": {
        "description": "Convert shorthand like \"refactor user svc\" into detailed task with constraints, dependencies, and rollback plan.",
        "title": "Expand abbreviated notes into full context"
      },
      "refine": {
        "description": "Ensure task descriptions are clear for reviewers and downstream implementation.",
        "title": "Refine task descriptions for team alignment"
      },
      "title": "Common use cases"
    }
  },
  "voiceTranscription": {
    "accuracy": {
      "bottomLine": "Bottom line: Fewer errors mean fewer ambiguous tickets and less rework. gpt-4o-transcribe helps teams capture precise, implementation-ready specifications on the first try.",
      "models": {
        "aws": "AWS Transcribe — managed speech recognition by Amazon Web Services.",
        "google": "Google Speech-to-Text v2 — cloud speech recognition by Google.",
        "gpt": "OpenAI gpt-4o-transcribe — advanced multilingual speech model optimized for accuracy and latency.",
        "whisper": "Whisper large-v2 — open-source large-model baseline for comparison."
      },
      "title": "Accuracy Benchmarks"
    },
    "capabilities": {
      "multiLanguage": {
        "description": "OpenAI transcription supports multiple languages. Respects per-project settings configured in your workspace.",
        "title": "Multiple Language Support"
      },
      "perProject": {
        "description": "Set project defaults for language, temperature, and transcription model. Integrates with text_improvement and task_refinement prompts.",
        "title": "Per-Project Configuration"
      },
      "terminalDictation": {
        "description": "Dictate commands directly to your terminal session (Stage 5). Keep your eyes on code while controlling the terminal with your voice.",
        "title": "Terminal Dictation (Stage 5)"
      },
      "title": "Key Capabilities"
    },
    "cta": {
      "description": "Stage 1 specification capture with voice, then refine with AI. Stage 5 terminal control while reviewing code. Voice transcription bridges thinking and execution across the workflow.",
      "links": {
        "terminal": "See Stage 5 terminal integration",
        "textImprovement": "Explore text enhancement prompts"
      },
      "title": "Start Capturing Specifications with Voice"
    },
    "example": {
      "competitor": {
        "label": "Competitor Model",
        "text": "Create a Postgres replica in us-east with 2 CPUs, 8GB RAM, and enable replication; set wal level logical and max senders equals ten."
      },
      "gpt": "Create a Postgres read-replica in us-east-1 with 2 vCPU, 8 GB RAM, and enable logical replication; set wal_level=logical and max_wal_senders=10.",
      "reference": "Create a Postgres read-replica in us-east-1 with 2 vCPU, 8GB RAM, and enable logical replication; set wal_level=logical and max_wal_senders=10.",
      "title": "Illustrative Example: Capturing Specifications"
    },
    "faq": {
      "customize": {
        "answer": "Yes. You can configure language and model settings for each project. Settings are stored in the project configuration and shared across team members.",
        "question": "Can I customize transcription settings per project?"
      },
      "languages": {
        "answer": "OpenAI transcription supports multiple languages. You can set a default language per project.",
        "question": "Which languages are supported for voice transcription?"
      },
      "model": {
        "answer": "We use OpenAI transcription for accurate results.",
        "question": "Which AI model is used for transcription?"
      },
      "offline": {
        "answer": "No, voice transcription requires an internet connection to send audio to OpenAI Whisper API. The transcription happens in real-time with minimal latency.",
        "question": "Does voice transcription work offline?"
      },
      "whereToUse": {
        "answer": "Voice transcription works in two places: (1) Task description panel - dictate implementation requirements (Stage 1), and (2) Terminal modal - dictate commands that are appended to your active shell session (Stage 5).",
        "question": "Where can I use voice transcription in the app?"
      }
    },
    "hero": {
      "badge": "Stage 1 & Stage 5 Voice Input",
      "description": "Dictate tasks while thinking aloud → clean structured requirements. Dictate terminal commands while keeping eyes on code. Voice transcription respects per-project settings and integrates with text_improvement + task_refinement prompts.",
      "title": "Voice transcription for specification capture and terminal control"
    },
    "workflow": {
      "title": "Voice in the 5-Stage Workflow",
      "stage1": {
        "title": "Stage 1: Dictating Tasks",
        "description": "Capture requirements by speaking naturally. Voice transcription converts your thoughts to text, which flows through text_improvement (grammar polish) and task_refinement (expand completeness, surface edge cases). The result is a clear specification ready for Stage 2 file discovery."
      },
      "stage5": {
        "title": "Stage 5: Terminal Voice Control",
        "description": "Dictate commands directly into the integrated terminal while your hands are on the keyboard reviewing code. Say 'run npm test' or 'git status' and watch commands appear in your PTY session. Keep eyes on code, voice on control."
      },
      "integration": {
        "title": "Integration with text_improvement + task_refinement",
        "description": "Voice transcripts automatically feed into the text_improvement and task_refinement prompts. This two-phase refinement ensures rough verbal descriptions become precise, implementation-ready specifications before FileFinderWorkflow begins."
      }
    },
    "nextSteps": {
      "description": "Voice transcription is Stage 1 input in Intelligence-Driven Development. After capturing raw thoughts, text_improvement cleans grammar and task_refinement expands completeness - preparing specs for Stage 2 file discovery.",
      "link": "Learn about text_improvement and task_refinement",
      "taskRefinement": {
        "description": "Expand descriptions with implied requirements, edge cases, and technical considerations. Prepares specs for FileFinderWorkflow.",
        "title": "Task Refinement (Stage 1 → 2)"
      },
      "textEnhancement": {
        "description": "Polish grammar, improve clarity, and enhance readability while preserving your original intent. Makes voice transcripts professional.",
        "title": "Text Enhancement (Stage 1)"
      },
      "title": "Refine Voice Transcripts Before File Discovery"
    },
    "painPoints": {
      "captureIdeas": {
        "description": "Stakeholders think faster than they type. Requirements and context get lost while fingers catch up. Voice lets you capture the complete specification before critical details fade.",
        "title": "Capture ideas before they fade"
      },
      "contextSwitching": {
        "description": "Stop what you are doing to open a note app, type, then return. Every switch breaks concentration. Voice stays in the same workspace.",
        "title": "Context switching kills momentum"
      },
      "handsBusy": {
        "description": "Reviewing code? Debugging? Drawing architecture diagrams? Your hands are occupied but you need to log the task. Voice transcription keeps you in flow.",
        "title": "Hard to describe while hands are busy"
      },
      "title": "Why Voice Accelerates Specification Capture"
    },
    "workflow": {
      "stage1": {
        "description": "Dictate tasks while thinking aloud. Raw voice input captures complete requirements - mental models, constraints, context - without the cognitive load of typing.",
        "title": "Stage 1: Dictating Tasks"
      },
      "stage5": {
        "description": "Dictate terminal commands while reviewing code, monitoring logs, or analyzing diffs. Keep your eyes on what matters while controlling execution.",
        "title": "Stage 5: Terminal Voice Control"
      },
      "integration": {
        "description": "Voice respects per-project language and temperature settings. Transcripts feed into text_improvement for grammar polish and task_refinement for completeness expansion.",
        "title": "Integration with Text Enhancement Prompts"
      },
      "title": "Voice Transcription Across Stages"
    },
    "useCases": {
      "codeReview": {
        "outcome": "Task created with full context, zero typing, no context switch. Ready for text_improvement polish.",
        "scenario": "Code review reveals a refactoring opportunity. Your hands are on the diff, eyes on the screen. Voice captures the task description.",
        "title": "Dictate while reviewing code (Stage 1)"
      },
      "fasterEntry": {
        "outcome": "10x faster task entry. QA feedback processed in minutes instead of hours. Refine with task_refinement before file discovery.",
        "scenario": "You have 10 similar bugs to log after QA testing. Typing each one takes 2 minutes. Voice transcription takes 20 seconds.",
        "title": "Faster task entry for repetitive work"
      },
      "handsFree": {
        "outcome": "Ideas logged instantly. Return to debugging without breaking flow. Polish transcripts with text_improvement.",
        "scenario": "You are deep in a debugging session. You spot three related issues that need fixing. Speak them into the voice recorder without leaving your terminal.",
        "title": "Capture ideas hands-free (Stage 1)"
      },
      "terminalCommands": {
        "outcome": "Commands entered correctly while eyes stay on logs. Stage 5 terminal control without context switching.",
        "scenario": "Monitoring build output when you need a complex docker command. Dictate it while watching the logs - terminal inserts it correctly.",
        "title": "Terminal commands without looking away (Stage 5)"
      },
      "title": "Real Use Cases"
    }
  },
  "integratedTerminal": {
    "cta": {
      "description": "A terminal built for planning and execution—integrated, persistent, and fast.",
      "links": {
        "docs": "Read technical docs",
        "voice": "Explore voice commands"
      },
      "title": "Experience the Terminal That Never Loses Context"
    },
    "features": {
      "integratedPlanning": {
        "description": "Execute implementation plans and copy steps directly to the terminal without leaving the application.",
        "title": "Integrated with Planning"
      },
      "persistent": {
        "description": "Your terminal sessions stay with your work, preserving context between tasks and restarts.",
        "title": "Persistent Sessions"
      },
      "title": "A Terminal Built for Your Workflow",
      "voiceSupport": {
        "description": "Use one-click copy-paste for commands or dictate them directly using voice input to move faster.",
        "title": "Voice and Copy Support"
      }
    },
    "hero": {
      "badge": "Integrated PTY Terminal",
      "description": "Run your plan in a persistent terminal. Built for fast, focused execution.",
      "title": "Job-centric terminal that keeps context"
    }
  },
  "videoAnalysis": {
    "capabilities": {
      "fileUpload": {
        "description": "Upload existing Teams/Zoom recordings, customer demos, or screen captures. Supports all common video formats.",
        "features": [
          "MP4, WebM, MOV, AVI formats",
          "Drag-and-drop interface",
          "Teams/Zoom recording compatibility"
        ],
        "title": "Meeting Recording Upload"
      },
      "fpsControl": {
        "description": "Adjust frame extraction rate to balance analysis detail with cost. Higher FPS captures rapid UI changes, lower for cost optimization.",
        "features": [
          "1-2 FPS: Cost-effective meeting overview",
          "3-5 FPS: Balanced screen share analysis",
          "6-10 FPS: Detailed UI demo capture"
        ],
        "title": "FPS Control (1-10 FPS)"
      },
      "gemini": {
        "description": "Powered by Google Gemini 3 Pro or Flash for multimodal analysis. Extracts decisions, action items, and visual context from meetings.",
        "features": [
          "Audio transcription + frame analysis",
          "Decision point extraction",
          "Action item identification with timestamps"
        ],
        "title": "Gemini Multimodal Analysis"
      },
      "screenRecording": {
        "description": "Capture live meetings, presentations, or demo flows directly in the app. Record while presenting tasks from Jira or corporate tools.",
        "features": [
          "One-click screen + audio capture",
          "Record full screen or specific windows",
          "Automatic format optimization for Gemini"
        ],
        "title": "Screen Recording Built-In"
      },
      "title": "Powerful Analysis Capabilities"
    },
    "cta": {
      "description": "Advanced Stage 1 input: Feed Teams/Zoom meetings or screen recordings. Multimodal AI analyzes audio AND frames to extract requirements, decisions, action items. Results feed into task_refinement and FileFinderWorkflow.",
      "links": {
        "fileDiscovery": "Explore Stage 2 file discovery",
        "research": "See optional research helper"
      },
      "title": "Transform Meeting Recordings into Stage 1 Requirements"
    },
    "faq": {
      "formats": {
        "answer": "PlanToCode supports MP4, WebM, MOV, and AVI video formats. Videos are processed locally and frames are extracted based on your FPS settings before being sent to Gemini Vision for analysis. Most screen recording tools output compatible formats by default.",
        "question": "Which video formats are supported?"
      },
      "fps": {
        "answer": "FPS recommendations based on use case: 1-2 FPS for general bug reports, long recordings, and cost optimization - captures key moments without excessive frames. 3-5 FPS for balanced analysis for most use cases - good for UI walkthroughs and standard bug captures. 6-10 FPS for detailed UI interactions, animation issues, and rapid state changes - higher cost but more comprehensive.",
        "question": "What FPS settings should I use?"
      },
      "model": {
        "answer": "Use Gemini 2.5 Flash for straightforward bug captures, quick UI demos, and documentation where speed and cost matter. Choose Gemini 3 Pro for complex UI issues, detailed pattern analysis, and when you need deeper contextual understanding. Pro provides more nuanced insights but costs more per frame.",
        "question": "Which AI model should I choose?"
      },
      "optimization": {
        "answer": "Cost optimization strategies: Use lower FPS settings (1-2 FPS) for longer videos or simple analysis. Choose Gemini Flash over Pro when detailed analysis isn't critical. Trim videos to relevant sections only before uploading. Use screen recording to capture only necessary interactions rather than uploading long recordings.",
        "question": "How can I optimize analysis costs?"
      }
    },
    "hero": {
      "badge": "Advanced Stage 1 Input - Multimodal Analysis",
      "description": "Feed Teams/Zoom or screen recordings. AI extracts requirements, decisions, action items from audio AND frames (UI states, error messages). Resulting notes feed into task_refinement and later stages.",
      "title": "Meeting & Recording Analysis for Requirements Extraction"
    },
    "howItWorks": {
      "steps": [
        {
          "title": "Record or Upload Meeting/Demo",
          "description": "Capture Microsoft Teams meetings, Zoom calls, or screen presentations while presenting tasks from Jira or similar corporate tools. Upload existing recordings. Supports MP4, WebM, MOV, and AVI for compatibility with corporate tools."
        },
        {
          "title": "Gemini Multimodal Analysis (Audio + Visual)",
          "description": "Video is processed at your chosen FPS (1-10). Gemini 3 Pro or Flash analyzes audio transcripts AND frames - capturing spoken decisions, visual UI states, error messages, and interaction patterns simultaneously."
        },
        {
          "title": "Extract Requirements, Decisions, Action Items",
          "description": "AI extracts key decisions with speaker attribution, concrete action items with owners, discussion points with context, and visual elements like error messages or UI states from screen shares."
        },
        {
          "title": "Feed into Task Refinement & FileFinderWorkflow",
          "description": "Complete analysis auto-attaches to your task description. Use task_refinement to expand completeness, then FileFinderWorkflow (Stage 2) to discover impacted files. Video analysis enriches Stage 1 input."
        }
      ],
      "title": "How Multimodal Meeting Analysis Works"
    },
    "insights": {
      "actionItems": {
        "description": "Concrete action items with owners and implicit dependencies identified",
        "title": "Action Items"
      },
      "decisions": {
        "description": "Key decisions extracted with context and attributed to specific speakers",
        "title": "Summarized Decisions"
      },
      "description": "After processing your meeting recording, the system analyzes both audio transcripts and visual content (shared screens, documents, key moments) to extract actionable insights. The extracted insights - summarized decisions, action items, and key discussion points - are presented in an intuitive interface where team leads can review, select, and incorporate them into actionable implementation plans.",
      "discussionPoints": {
        "description": "Important context, concerns raised, and alternative approaches discussed",
        "title": "Discussion Points"
      },
      "title": "Extracting Actionable Insights"
    },
    "models": {
      "flash": {
        "description": "Fast, cost-effective analysis for straightforward bug captures and documentation. Ideal for high-volume usage.",
        "features": [
          "Lower cost per frame",
          "Faster processing time",
          "Good for simple UI analysis"
        ],
        "title": "Gemini 2.5 Flash"
      },
      "pro": {
        "description": "Comprehensive analysis with deeper insights. Best for complex UI issues, detailed pattern recognition, and advanced debugging.",
        "features": [
          "Advanced pattern recognition",
          "Deeper contextual understanding",
          "Better for complex UI flows"
        ],
        "title": "Gemini 3 Pro"
      },
      "title": "Choose Your Analysis Model"
    },
    "multimodal": {
      "audioTranscript": {
        "description": "Complete audio transcription of meeting discussions. Extract key requirements, decisions, and action items from meeting audio.",
        "features": [
          "Complete audio transcription",
          "Decision point extraction",
          "Action item identification"
        ],
        "title": "Audio Transcript Analysis"
      },
      "title": "Multimodal Analysis of Meetings",
      "visualContent": {
        "description": "AI analyzes shared screens, presented documents, and key visual moments. Captures UI mockups, architecture diagrams, and other visual context critical for requirements.",
        "features": [
          "Screen share content extraction",
          "Document and diagram analysis",
          "Key moment identification"
        ],
        "title": "Visual Content Analysis"
      }
    },
    "painPoints": {
      "incompleteNotes": {
        "description": "Note-takers can't capture everything—who said what, what was shown on screen, subtle requirement changes. Important context gets lost between meetings and implementation.",
        "title": "Manual Meeting Notes Are Incomplete"
      },
      "requirementsLost": {
        "description": "Critical decisions and requirements discussed in meetings are forgotten or misinterpreted. Manual note-taking misses context, speaker intent, and visual references.",
        "title": "Requirements Get Lost in Meetings"
      },
      "reviewTime": {
        "description": "Teams spend hours reviewing meeting recordings manually to extract key decisions. Requirements buried in hour-long calls are hard to find and document.",
        "title": "Review Time Wastes Team Resources"
      },
      "title": "Why Meeting Analysis Matters for Corporate Teams"
    },
    "useCases": {
      "bugCapture": {
        "description": "Record the bug as it happens. AI extracts error messages, identifies UI states before and after the issue, and captures interaction patterns leading to the bug.",
        "title": "Bug Capture with Full Context"
      },
      "onboarding": {
        "description": "Record feature walkthroughs and generate automatic documentation. AI creates step-by-step guides with screenshots and descriptions from your recordings.",
        "title": "Onboarding Documentation"
      },
      "title": "Real-World Use Cases",
      "uiDemo": {
        "description": "Analyze customer demos, user session recordings, or design walkthroughs. Extract UI patterns, user behavior insights, and improvement opportunities.",
        "title": "UI Demo Analysis"
      }
    }
  },
  "copyButtons": {
    "meta": {
      "title": "Copy Buttons - Bridge Planning and Execution",
      "description": "Copy buttons encapsulate best-practice prompts with placeholders like {{IMPLEMENTATION_PLAN}}, {{TASK_DESCRIPTION}}, paths. Ensures consistent, governance-compliant instructions across sessions."
    },
    "comparison": {
      "plantocode": {
        "items": [
          "One-click governance-compliant workflows",
          "{{IMPLEMENTATION_PLAN}} substitution",
          "Best-practice prompt templates",
          "Context-aware XML plan injection",
          "Persistent team workflows"
        ],
        "title": "PlanToCode Copy Buttons"
      },
      "title": "What Makes This Different",
      "traditional": {
        "items": [
          "Manual copy-paste of plan XML",
          "Inconsistent instructions across sessions",
          "Forgotten governance constraints",
          "Error-prone manual template edits",
          "Lost best-practice workflows"
        ],
        "title": "Traditional Copy-Paste"
      }
    },
    "concept": {
      "dragDrop": {
        "description": "Visual workflow management with drag-drop reordering. Organize buttons by execution priority or workflow stage.",
        "title": "Drag-Drop Reordering"
      },
      "serverConfigured": {
        "description": "Best-practice templates with placeholders: {{IMPLEMENTATION_PLAN}}, {{TASK_DESCRIPTION}}, {{PROJECT_CONTEXT}}. Server-side defaults with project-specific overrides.",
        "title": "Template Placeholders"
      },
      "terminal": {
        "description": "One-click execution in persistent terminal sessions (Stage 5). Chunked sending for large XML plans.",
        "title": "Terminal Integration (Stage 5)"
      }
    },
    "configuration": {
      "projectSettings": {
        "description": "Copy buttons stored in task settings with project-level overrides and server-side defaults.",
        "features": [
          "SQLite database persistence",
          "Server-managed default configurations",
          "Project directory scoping",
          "Real-time configuration updates"
        ],
        "title": "Project-Specific Settings"
      },
      "title": "Configuration & Management",
      "visualUI": {
        "description": "Intuitive editor with drag-drop reordering, debounced input handling, and real-time preview.",
        "features": [
          "Drag handles for visual reordering",
          "300ms debounced input processing",
          "Read-only mode for system buttons",
          "Customization workflow support"
        ],
        "title": "Visual Configuration UI"
      }
    },
    "cta": {
      "description": "Bridge between planning and execution. Copy buttons ensure governance-compliant instructions with {{IMPLEMENTATION_PLAN}} substitution. Example: 'Apply this merged plan with Claude Code Plan Mode' - inserts template + XML plan.",
      "links": {
        "planMode": "See Stage 3 planning & Stage 4 merge",
        "terminal": "Explore Stage 5 terminal integration"
      },
      "title": "Best-Practice Workflows, One Click"
    },
    "hero": {
      "badge": "Bridge Planning and Execution - Template System",
      "description": "Copy buttons encapsulate best-practice prompts with {{IMPLEMENTATION_PLAN}}, {{TASK_DESCRIPTION}}, paths. Example button: 'Apply this merged plan with Claude Code Plan Mode' - inserts template + XML plan.",
      "title": "Best-practice prompts with plan substitution"
    },
    "technical": {
      "architecture": {
        "execution": "Button click triggers template processing → Placeholder substitution with plan content → Terminal session validation → Chunked content transmission",
        "processing": "Regex-based placeholder matching → Dynamic content substitution → Context-aware data extraction → Error handling for undefined values",
        "storage": "CopyButtonConfig[] in task settings → Project-specific database storage → Server-side default configurations → Real-time synchronization",
        "ui": "Implementation plan cards → Content viewing modals → Terminal interface headers → Drag-drop configuration editor"
      },
      "title": "Technical Implementation"
    },
    "templateSystem": {
      "placeholders": {
        "description": "Best-practice templates with {{PLACEHOLDER}} substitution. Context-aware processing with implementation plans from Stage 3/4.",
        "examples": [
          "{{IMPLEMENTATION_PLAN}} - Full merged plan XML",
          "{{STEP_CONTENT}} - Selected step content",
          "{{TASK_DESCRIPTION}} - Stage 1 requirements",
          "{{PROJECT_CONTEXT}} - File paths, structure"
        ],
        "title": "Placeholder Substitution"
      },
      "processor": {
        "description": "Advanced template engine injects XML plans, task descriptions, and governance constraints into pre-configured prompts.",
        "features": [
          "Regex-based placeholder matching",
          "XML plan formatting and escaping",
          "Multi-line governance instruction support",
          "Graceful undefined handling"
        ],
        "title": "Unified Prompt Processing"
      },
      "title": "Best-Practice Template System"
    },
    "terminalIntegration": {
      "oneClick": {
        "description": "Copy buttons integrate with Stage 5 terminal sessions. One click = full governance-compliant workflow execution with plan context.",
        "features": [
          "Automatic paste to active terminal session",
          "Chunked sending for large XML plans",
          "Session health monitoring",
          "Clipboard fallback for safety"
        ],
        "title": "One-Click Stage 5 Execution"
      },
      "title": "Stage 5 Terminal Execution"
    },
    "useCases": {
      "customTeam": {
        "description": "Team-specific governance constraints with {{PROJECT_CONTEXT}} and coding standards. Ensures consistent compliance.",
        "title": "Custom Team Governance Workflows"
      },
      "investigation": {
        "description": "Standardized review processes for Stage 3 implementation plan results. Example button: 'Investigate Results' with thorough validation workflow.",
        "title": "Investigation & Review"
      },
      "parallel": {
        "description": "Example button: 'Apply this merged plan with Claude Code Plan Mode' - inserts template + {{IMPLEMENTATION_PLAN}} XML. Launches agents with governance instructions.",
        "title": "Parallel Agent Workflows with Plan Context"
      },
      "stepByStep": {
        "description": "Extract individual implementation steps with {{STEP_CONTENT}}. Execute step-by-step with full plan context.",
        "title": "Step-by-Step Execution"
      },
      "title": "Real-World Use Cases"
    }
  },
  "deepResearch": {
    "meta": {
      "title": "Deep Research - Optional Helper Stage for Migration & Upgrades",
      "description": "Background research jobs fetch framework migration guides, best practices, API docs. Attach summarized findings back to tasks/plans. Use cases: Next.js major version upgrade, Stripe API migration."
    },
    "advanced": {
      "features": [
        {
          "title": "Framework Migration Intelligence",
          "description": "AI fetches official migration guides, breaking changes, and best practices for major framework version upgrades like Next.js 14 → 15 or React 17 → 18."
        },
        {
          "title": "API Documentation Research",
          "description": "Background jobs pull latest API documentation, SDK changes, and version compatibility notes for services like Stripe, AWS, or Twilio."
        },
        {
          "title": "Background Processing",
          "description": "Long-running research tasks execute in the background with real-time progress updates. No blocking the main workflow."
        },
        {
          "title": "Plan Context Integration",
          "description": "Research findings automatically attach to task descriptions or implementation plans. Influences implementation_plan prompt with authoritative sources."
        },
        {
          "title": "Best Practice Extraction",
          "description": "AI identifies and summarizes recommended patterns, anti-patterns, and gotchas from official documentation and community sources."
        },
        {
          "title": "Cost-Optimized Research",
          "description": "Intelligent model selection and query optimization. Research only when needed - not every task requires it."
        }
      ],
      "title": "Optional Research Helper Capabilities"
    },
    "aiCapabilities": {
      "multiModel": {
        "description": "Leverages multiple AI models to execute research tasks with different perspectives and expertise areas.",
        "models": [
          "OpenAI GPT Models",
          "Anthropic Claude",
          "Google Gemini",
          "Specialized Research Models"
        ],
        "title": "Multi-Model Research"
      },
      "parallel": {
        "description": "Execute multiple research tasks simultaneously with intelligent result aggregation and synthesis.",
        "features": [
          "Concurrent Execution",
          "Progress Tracking",
          "Error Recovery",
          "Result Synthesis"
        ],
        "title": "Parallel Processing"
      },
      "projectContext": {
        "description": "AI analyzes your project structure, technology stack, and codebase to generate highly relevant research.",
        "features": [
          "File Structure Analysis",
          "Technology Stack Detection",
          "Dependency Mapping",
          "Context-Aware Insights"
        ],
        "title": "Project Context Analysis"
      },
      "title": "AI Research Capabilities"
    },
    "cta": {
      "description": "Optional helper stage for complex migrations and upgrades. Background jobs fetch authoritative sources, summarize findings, attach to plans. Research influences implementation_plan prompt when you need it.",
      "links": {
        "planMode": "See Stage 3 implementation planning",
        "textImprovement": "Explore Stage 1 text enhancement"
      },
      "title": "Accelerate Migrations with Background Research"
    },
    "developmentFocus": {
      "contextFiltering": {
        "description": "Research scope tailored to your migration scenario - only relevant framework versions, API changes, and compatible patterns.",
        "features": [
          "Framework version compatibility checking",
          "Breaking change identification",
          "Migration path recommendations",
          "Deprecated API alternatives"
        ],
        "title": "Migration-Focused Filtering"
      },
      "implementationReady": {
        "description": "Research results formatted for implementation plans. Code examples, migration scripts, and step-by-step upgrade paths.",
        "features": [
          "Migration code snippet extraction",
          "Upgrade script templates",
          "Breaking change workarounds",
          "Rollback strategy notes"
        ],
        "title": "Implementation-Ready Migration Insights"
      },
      "title": "Development-Focused Research"
    },
    "features": {
      "parallelExecution": {
        "description": "Execute multiple research tasks concurrently - fetch Next.js migration guide, React upgrade docs, and TypeScript compatibility notes simultaneously.",
        "title": "Parallel Background Research"
      },
      "projectIntegration": {
        "description": "Research findings attach to task descriptions or implementation plans. Influences implementation_plan prompt with authoritative sources and best practices.",
        "title": "Plan & Task Integration"
      },
      "queryGeneration": {
        "description": "AI generates context-aware research queries for framework migrations, API upgrades, and library version changes. Multi-angle exploration for complete coverage.",
        "title": "Migration-Focused Query Generation"
      }
    },
    "hero": {
      "badge": "Optional Helper Stage - Background Research",
      "description": "Background jobs fetch framework migration guides, best practices, API docs. Use cases: Next.js major version upgrade, Stripe API version upgrade. Research influences implementation_plan prompt.",
      "title": "Deep research for migrations and upgrades"
    },
    "intelligence": {
      "contextIntegration": {
        "description": "Research results are automatically integrated with your task description, enriching it with relevant findings and recommendations.",
        "features": [
          "Automatic task enhancement",
          "Structured result formatting",
          "Implementation plan integration",
          "Development workflow alignment"
        ],
        "title": "Context Integration"
      },
      "execution": {
        "description": "Sophisticated AI models execute research tasks in parallel, providing comprehensive analysis and insights.",
        "features": [
          "Parallel research task execution",
          "Streaming results with progress tracking",
          "Context-aware analysis and synthesis",
          "Development-focused insights"
        ],
        "title": "AI Research Execution"
      },
      "queryExpansion": {
        "description": "AI analyzes your initial query and generates strategic variations for comprehensive research coverage.",
        "features": [
          "Context-aware query variations",
          "Semantic synonym expansion",
          "Domain-specific terminology",
          "Multi-perspective research angles"
        ],
        "title": "Smart Query Expansion"
      },
      "synthesis": {
        "description": "Advanced AI models analyze your project context and generate targeted research insights tailored to your development needs.",
        "features": [
          "Project-aware research generation",
          "Context-sensitive analysis",
          "Development-focused insights",
          "Implementation-ready recommendations"
        ],
        "title": "AI Research Synthesis"
      },
      "title": "Research Intelligence Engine"
    },
    "process": {
      "stage1": {
        "description": "AI analyzes your task description and project context to generate sophisticated research queries. Creates multiple strategic research angles for comprehensive coverage.",
        "title": "Research Query Generation"
      },
      "stage2": {
        "description": "Multiple AI models execute research tasks concurrently, each focusing on different aspects of your requirements. Results are synthesized into actionable development insights.",
        "title": "Parallel Research Execution"
      },
      "title": "Two-Stage AI Research Process"
    }
  },
  "features": {
    "copyButtons": {
      "description": "Transform any prompt into a reusable button with smart placeholders and drag-drop",
      "slug": "/features/copy-buttons",
      "title": "Copy Buttons"
    },
    "deepResearch": {
      "description": "AI-powered research with sophisticated queries and parallel research tasks",
      "slug": "/features/deep-research",
      "title": "Deep Research"
    },
    "fileDiscovery": {
      "description": "Intelligent multi-stage workflow that discovers and selects relevant files from your codebase",
      "slug": "/features/file-discovery",
      "title": "AI File Discovery",
      "meta": {
        "title": "AI file discovery - find impacted files",
        "description": "Multi-stage AI workflow that discovers and selects relevant files. Cost-effective at $0.10-0.15 per workflow with real-time progress tracking."
      }
    },
    "integratedTerminal": {
      "description": "Persistent terminal sessions with health monitoring and command review",
      "slug": "/features/integrated-terminal",
      "title": "Integrated Terminal"
    },
    "mergeInstructions": {
      "description": "AI analyzes multiple implementation plans, resolves conflicts, creates emergent solutions",
      "slug": "/features/merge-instructions",
      "title": "Architectural Plan Synthesis",
      "meta": {
        "title": "Plan Synthesis - Multi-Model Merging",
        "description": "Architectural synthesis beyond simple merging. AI analyzes plans, resolves conflicts with SOLID principles, and creates emergent solutions with traceability."
      }
    },
    "planMode": {
      "description": "Generate file-by-file implementation plans with AI. Review and approve every change before execution",
      "slug": "/features/plan-mode",
      "title": "Implementation Plans",
      "meta": {
        "title": "AI Implementation Plans - Human-in-Loop",
        "description": "Generate file-by-file AI plans. Review every change before execution. Prevent regressions in legacy code. Safe AI development."
      }
    },
    "textImprovement": {
      "description": "Refine specifications with AI text enhancement and task refinement prompts",
      "slug": "/features/text-improvement",
      "title": "Specification Capture Mode",
      "meta": {
        "title": "Spec Capture Mode - AI Text Enhancement",
        "description": "Refine specifications with two AI prompts: Text Enhancement for clarity, Task Refinement for completeness. Create actionable specs for development teams."
      }
    },
    "videoAnalysis": {
      "description": "Multimodal AI analyzes audio and visual content to extract actionable requirements",
      "slug": "/features/video-analysis",
      "title": "Meeting & Recording Analysis"
    },
    "voiceTranscription": {
      "description": "Capture specifications hands-free with voice transcription in multiple languages",
      "slug": "/features/voice-transcription",
      "title": "Voice to Text",
      "meta": {
        "title": "Voice to text for rapid specification capture",
        "description": "Hands-free specification capture with voice. Accurate transcription inserts text where you work. Configure per project, supports multiple languages."
      }
    }
  }
}
