{
  "home": {
    "meta": {
      "title": "PlanToCode - Plan review for coding agents",
      "description": "PlanToCode turns tasks into reviewable implementation plans you can compare, merge, and hand off. Hosted uses managed providers; self-hosting supports BYOK."
    }
  },
  "about": {
    "meta": {
      "description": "What PlanToCode does, how the planning pipeline works, and why the system is structured around reviewable plans.",
      "title": "About PlanToCode – Purpose and Scope"
    }
  },
  "evolution": {
    "meta": {
      "title": "System Evolution and Tradeoffs - PlanToCode",
      "description": "How PlanToCode evolved, why specific technologies were chosen, and what tradeoffs those decisions created."
    }
  },
  "aboutPage": {
    "hero": {
      "title": "What PlanToCode Is For",
      "description": "PlanToCode is a desktop planning workspace that turns tasks into reviewable implementation plans. It connects file discovery, plan generation, and execution handoff into one tracked pipeline."
    },
    "reference": {
      "title": "Reference architecture focus",
      "description": "The system wires together a Tauri shell, a Rust backend, SQLite persistence, and an LLM proxy layer. This page explains how those parts fit together so you can learn from the architecture."
    },
    "governance": {
      "title": "Safety, Governance, and Guardrails",
      "description": "Governance is a core architectural decision: plans are artifacts that can be reviewed, edited, and approved before execution."
    },
    "stack": {
      "title": "Where This Fits in Your Stack",
      "description": "PlanToCode sits alongside your editor and local tools. It assumes Git workflows and external LLM providers, then routes plans and execution through the same session history."
    }
  },
  "architecturePage": {
    "hero": {
      "title": "Architecture Overview",
      "description": "PlanToCode is a Tauri desktop application with a Rust backend, a React/Next.js frontend, and a SQLite-backed local database. Planning and analysis depend on LLM providers managed by the server; self-hosting supports your own keys. This page explains how those pieces fit together so you can reason about or adapt the design."
    },
    "visuals": {
      "systemMap": {
        "title": "System map snapshot",
        "description": "This diagram depicts the PlanToCode system architecture as four interconnected layers arranged vertically. Top Layer - Desktop Frontend: A React/Next.js box containing components (Plan Viewer, Terminal Panel, Session Manager) connected via labeled arrows \"invoke()\" and \"listen()\" to Tauri IPC Bridge. Second Layer - Rust Backend: Contains WorkflowOrchestrator (scheduling multi-stage jobs), TerminalSessionManager (PTY lifecycle), and JobProcessors (FileDiscovery, PlanGeneration, TextImprovement, DeepResearch). Arrows show \"spawn()\" to job threads and \"emit()\" events back to UI. Third Layer - Persistence: SQLite database cylinder showing tables: sessions, background_jobs, terminal_sessions. Bidirectional arrows labeled \"read/write\" connect to Rust services. Fourth Layer - External Services: Server box with Auth (/api/auth), LLM Proxy (/api/llm/*), and Usage Tracking; arrows point outward to Provider icons (OpenAI, Anthropic, Google, OpenRouter) with \"route()\" labels. Data flows: Task input flows down through layers; LLM responses stream back up via SSE; job status updates propagate via Tauri events. Key labels include \"HTTPS/WSS\" on server connections, \"SQLite\" on persistence, and \"FFI\" on Rust-to-system calls.",
        "imageSrc": "/images/architecture/system-map.svg",
        "imageAlt": "Diagram showing PlanToCode system map",
        "caption": "Four-layer architecture with data flowing down and events streaming back up."
      }
    },
    "sections": {
      "shell": {
        "title": "Tauri Shell and Desktop Frontend",
        "description": "The desktop app bundles a React UI inside a Tauri shell. Frontend code calls Rust commands for tasks like file system access, terminal sessions, and background job orchestration."
      },
      "core": {
        "title": "Rust Core and SQLite Persistence",
        "description": "The Rust core manages background jobs, PTY sessions, and durable state. SQLite stores sessions, job history, and terminal session logs as the local record of work."
      },
      "jobs": {
        "title": "Background Job Orchestration",
        "description": "A workflow orchestrator schedules multi-stage jobs (file discovery, plan generation, research). Each stage is a Rust processor that can call out to LLM providers, read or write to the project, and emit streaming updates back to the UI."
      },
      "llm": {
        "title": "Multi-Model LLM Integration",
        "description": "The server layer routes requests to different providers, normalizes responses, and tracks usage. The desktop app receives a unified streaming API regardless of provider."
      }
    },
    "communication": {
      "title": "How the Pieces Communicate",
      "description": "Commands flow from the React UI into Tauri, which invokes Rust functions. Long-running work is executed as background jobs that stream updates (including partial LLM tokens) back to the UI. SQLite is the durable local store so sessions and terminal history can be replayed or resumed.",
      "followup": "For a deeper dive, read the architecture documentation and the build-your-own guides that map these concepts to code modules."
    },
    "meta": {
      "title": "System Architecture - PlanToCode",
      "description": "Detailed overview of the PlanToCode architecture: Tauri shell, Rust backend, SQLite persistence, and multi-model LLM orchestration."
    }
  },
  "evolutionPage": {
    "hero": {
      "title": "Evolution and Tradeoffs",
      "description": "This page outlines the major architectural decisions behind PlanToCode and how the system changed as new workflows and constraints appeared."
    },
    "visuals": {
      "timeline": {
        "title": "Architecture timeline",
        "description": "This horizontal timeline diagram shows the evolution of PlanToCode across five major phases. Phase 1 'Editor Plugin Era' (leftmost): VS Code extension icon with features listed (inline suggestions, basic file context). Arrow labeled 'Limitation: No execution control' points to Phase 2. Phase 2 'Standalone Shell': Tauri desktop app icon with features (dedicated UI, local SQLite, PTY sessions). Arrow labeled 'Added: Job orchestration' points to Phase 3. Phase 3 'Multi-Stage Workflows': Workflow diagram icon showing connected stages (FileDiscovery, Scoring, Planning, Execution). Arrow labeled 'Added: Review gates' points to Phase 4. Phase 4 'Multi-Provider LLM': Server routing icon with provider logos (OpenAI, Anthropic, Google, OpenRouter) showing unified API normalization. Arrow labeled 'Added: Model flexibility' points to Phase 5. Phase 5 'Current Architecture' (rightmost): Complete system icon showing Desktop + Server + Mobile components. Below the timeline, key architectural decisions are annotated: 'Tauri over Electron' at Phase 2, 'SQLite as local truth' at Phase 2, 'Background job queue' at Phase 3, 'Server-side provider routing' at Phase 4, 'Cross-platform sync' at Phase 5. Tradeoff callouts include 'Binary size vs. ecosystem' (Tauri), 'Local-first vs. cloud sync' (SQLite), 'Latency vs. flexibility' (LLM routing).",
        "imageSrc": "/images/evolution/timeline.png",
        "imageAlt": "Timeline of PlanToCode system evolution",
        "caption": "Placeholder for an evolution timeline graphic."
      }
    },
    "origins": {
      "title": "Project Origins",
      "description": "PlanToCode began as an experiment in separating planning from execution: use LLMs to propose concrete implementation plans, then execute them via local tools and terminals. Early prototypes were editor-centric; over time, the architecture moved toward a dedicated desktop shell with tighter control over file access and job orchestration."
    },
    "choices": {
      "title": "Technology Choices",
      "items": [
        {
          "title": "Tauri over Electron:",
          "description": "Chosen for a smaller binary, a Rust backend, and a more constrained security model. It also enables shared logic between CLI-like workflows and the desktop app."
        },
        {
          "title": "SQLite as the local source of truth:",
          "description": "A file-based database is easy to ship, snapshot, and inspect. It stores sessions, job metadata, and terminal history so workflows can be resumed or reviewed."
        },
        {
          "title": "Multi-provider LLM routing:",
          "description": "The server supports multiple providers and models, normalizing responses and tracking usage centrally. This makes it easier to swap models without rewriting the desktop client."
        }
      ]
    },
    "sourceAvailable": {
      "title": "What the system focuses on",
      "description": "The focus is on planning-first workflows: file discovery, multi-model plan generation, review, and execution handoff. These stages depend on external LLM providers for scoring and drafting, while the desktop app handles review, storage, and execution logs."
    }
  },
  "changelog": {
    "meta": {
      "title": "Changelog - Latest Updates",
      "description": "Release notes for PlanToCode, highlighting architecture, workflow, and system changes."
    },
    "hero": {
      "title": "Changelog",
      "subtitle": "Release notes focused on architecture changes, workflow updates, and system improvements."
    },
    "changes": {
      "added": "Added",
      "improved": "Improved",
      "fixed": "Fixed",
      "removed": "Removed"
    },
    "footer": {
      "title": "Follow updates",
      "subtitle": "Track release notes and architecture changes as the system evolves.",
      "followX": "Follow updates on X",
      "joinCommunity": "Join the community"
    }
  },
  "downloads": {
    "cta": {
      "architect": "Architecture overview",
      "docs": "Terminal docs",
      "footer": "Managed provider access on hosted • Local session storage",
      "professional": "Implementation plan docs",
      "title": "Need implementation context?"
    },
    "hero": {
      "subtitle": "Run PlanToCode locally to explore file discovery, plan generation, review gates, and execution handoff. Hosted uses managed providers; self-hosting supports BYOK.",
      "title": "Download PlanToCode"
    },
    "macos": {
      "professional": {
        "description": "Apple-notarized and code signed. Local CLI integration with persistent PTY sessions and session restore.",
        "title": "Signed and notarized"
      },
      "requirements": {
        "internet": "Internet connection and PlanToCode server access required (BYOK only for self-host)",
        "os": "macOS 11.0 (Big Sur) or later",
        "processor": "Apple Silicon (M1/M2/M3/M4) processor",
        "ram": "4GB RAM minimum (8GB recommended)",
        "title": "System Requirements"
      },
      "subtitle": "Native macOS with Persistent Terminal Sessions",
      "title": "macOS"
    },
    "meta": {
      "description": "Download PlanToCode for macOS and Windows to explore the planning workflow locally. Hosted uses managed providers; self-hosting supports BYOK.",
      "title": "Download PlanToCode - macOS & Windows"
    },
    "trust": {
      "planning": {
        "description": "Multi-model plan generation plus merge instructions produce structured, reviewable change sets.",
        "title": "Structured planning"
      },
      "pricing": {
        "description": "Token estimates run before each API call, with usage recorded per job.",
        "title": "Usage tracking"
      },
      "professional": {
        "description": "Codebase-aware file discovery narrows large repos into a focused file set before planning.",
        "title": "File discovery workflow"
      },
      "terminal": {
        "description": "Integrated PTY sessions provide a controlled execution surface for plan handoff and command logs.",
        "title": "Execution surface"
      },
      "title": "System characteristics"
    },
    "windows": {
      "integration": {
        "description": "WSL-aware workflows — paths align between PlanToCode and local shells or CLI tools. PowerShell and Command Prompt support with health monitoring and auto-recovery.",
        "title": "WSL-Aware Terminal Integration"
      },
      "requirements": {
        "internet": "Internet connection and PlanToCode server access required (BYOK only for self-host)",
        "os1": "Windows 10 version 1903 (Build 18362) or later",
        "os2": "Windows 11 supported",
        "processor": "x64 or ARM64 processor",
        "ram": "4GB RAM minimum (8GB recommended)",
        "title": "System Requirements"
      },
      "subtitle": "Microsoft Store with WSL Support",
      "title": "Windows"
    },
    "mobile": {
      "button": "Download on App Store",
      "connected": {
        "description": "Control your desktop PlanToCode sessions remotely. Review plans, manage terminals, and stay productive on the go.",
        "title": "Remote Control"
      },
      "features": {
        "design": "Native iOS/iPadOS design language",
        "monitor": "Monitor terminal sessions remotely",
        "review": "Review and edit implementation plans on the go",
        "sync": "Sync with desktop workspace seamlessly",
        "title": "Features",
        "voice": "Voice transcription for quick idea capture"
      },
      "subtitle": "Remote Control for iPhone & iPad",
      "title": "iOS Mobile App"
    }
  },
  "securityNotarization": {
    "meta": {
      "title": "macOS Notarization and Gatekeeper - PlanToCode",
      "description": "How the macOS build is signed and notarized, how Gatekeeper verifies it, and where to read Apple's docs.",
      "imageAlt": "PlanToCode macOS notarization and Gatekeeper overview"
    },
    "hero": {
      "title": "macOS notarization",
      "subtitle": "The macOS build is signed and notarized by Apple. Notarization validates developer identity and scans the build for malicious content; Gatekeeper uses the notarization ticket when the app is first opened."
    },
    "links": {
      "gatekeeper": {
        "label": "Apple Support:",
        "text": "Gatekeeper and runtime protection"
      },
      "notarize": {
        "label": "Apple Developer:",
        "text": "Notarizing macOS software before distribution"
      }
    },
    "footer": {
      "text": "If Gatekeeper blocks first launch, use Finder -> Open to approve the app, or visit",
      "link": "Downloads"
    }
  },
  "legal": {
    "meta": {
      "title": "Select Your Region - Legal Documents | PlanToCode",
      "description": "Choose your region (EU/UK or United States) to view applicable legal documents including terms of service, privacy policy, and regional compliance requirements."
    },
    "restricted": {
      "meta": {
        "title": "451 - Service Not Available in Your Region",
        "description": "This service is not available in your geographic region."
      }
    }
  },
  "howItWorks": {
    "cta": {
      "links": {
        "architecture": "Architecture overview",
        "buildYourOwn": "Build your own pipeline",
        "docs": "Read documentation",
        "workflows": "Implementation plan docs"
      },
      "subtitle": "Follow the pipeline end to end, then trace each stage to the internal processors and data flows.",
      "title": "Continue the technical walkthrough"
    },
    "hero": {
      "badge": "Technical pipeline walkthrough",
      "subtitle": "A step-by-step view of how inputs become plans, and plans become executed changes. LLM access is required (managed on hosted, BYOK on self-host).",
      "title": "How the pipeline works"
    },
    "keyFeatures": {
      "deploy": {
        "description": "Self-host the proxy server to control provider routing and API keys. Hosted uses managed provider access and usage tracking.",
        "title": "Deployment flexibility"
      },
      "governance": {
        "description": "Review, edit, merge, and approve plans before any execution step is triggered.",
        "title": "Human-in-the-loop governance"
      },
      "sessions": {
        "description": "PTY sessions and logs persist locally so long-running work can be resumed.",
        "title": "Persistent sessions"
      },
      "title": "Key pipeline properties"
    },
    "meta": {
      "description": "Technical walkthrough of the planning pipeline: capture inputs, discover files, generate plans, merge, and execute.",
      "title": "How It Works - Planning Pipeline"
    },
    "workflow": {
      "exampleMergeInstructions": "Example merge instructions:",
      "step1": {
        "description": "Capture requirements from recordings, screen captures, or voice notes. Screen recordings are analyzed by the video analysis job and produce a summary you can attach to the task.",
        "meetings": {
          "description": "Upload meeting recordings or design reviews. The analysis uses video and audio to summarize decisions, issues, and UI context.",
          "title": "Meeting Recordings"
        },
        "links": {
          "meeting": "Meeting ingestion details",
          "voice": "Voice transcription details"
        },
        "screen": {
          "description": "Record workflows, bugs, or UI walkthroughs. The analysis summary can be attached to the task description.",
          "title": "Screen Recordings"
        },
        "subtitle": "Stage 1: Voice, video, notes become specifications",
        "title": "Capture Ideas and Context",
        "voice": {
          "description": "Dictate requirements directly into the task input. Speech-to-text runs through the configured provider and inserts text into the active field.",
          "title": "Voice Dictation"
        }
      },
      "step2": {
        "description": "Transform raw transcripts and notes into clear specifications using two prompt types: text_improvement for clarity and task_refinement for completeness.",
        "subtitle": "Stage 2: text_improvement and task_refinement prompts",
        "taskRefinement": {
          "description": "Expands task descriptions by identifying implied requirements, filling in overlooked gaps, clarifying expected behavior and edge cases, and adding technical considerations for implementation readiness.",
          "title": "Task Refinement"
        },
        "textEnhancement": {
          "description": "Improves grammar, sentence structure, clarity, and conciseness while maintaining original intent and technical detail. Useful for polishing transcripts and notes.",
          "title": "Text Enhancement"
        },
        "links": {
          "specCapture": "Specification capture details"
        },
        "title": "Refine into Precise Specifications"
      },
      "step3": {
        "description": "FileFinderWorkflow runs staged indexing, filtering, and relevance scoring. The plan processor generates structured implementation_plan documents with explicit file paths, operation types, and line ranges for review.",
        "features": {
          "dependencies": "Dependency and impact notes captured per plan",
          "models": "Model allowlists configured per project",
          "multiple": "Multiple draft plans for comparison",
          "operations": "Clear operation types (modify, create, delete)",
          "paths": "Exact file paths from your repository structure",
          "ranges": "Specific line ranges and modification details"
        },
        "links": {
          "fileDiscovery": "File discovery pipeline",
          "planGeneration": "Plan generation details"
        },
        "subtitle": "Stage 3: FileFinderWorkflow + implementation_plan generation",
        "title": "Discover Files and Generate Plans"
      },
      "step4": {
        "capabilities": {
          "approve": "Approve before execution",
          "editing": "Direct editing of all plan steps and details",
          "editor": "Monaco editor with syntax highlighting",
          "merge": "Merge multiple plans with custom instructions",
          "modifications": "Request modifications or alternative approaches",
          "visibility": "Complete visibility into proposed changes"
        },
        "description": "Plans open in Monaco for review. You can edit steps directly, merge drafts with custom guidance, or delete drafts you do not want to keep. No code changes occur without explicit human approval, keeping scope and dependencies explicit.",
        "links": {
          "governance": "Review and governance",
          "merge": "Plan merging details"
        },
        "subtitle": "Stage 4: Side-by-side review + implementation_plan_merge",
        "title": "Review and Merge Plans"
      },
      "step5": {
        "description": "After approval, execute via the integrated terminal or export the plan into external tools. Copy buttons insert plan context into templated commands, and every run is logged to session history.",
        "links": {
          "terminal": "Terminal integration details",
          "planDocs": "Implementation plan format"
        },
        "subtitle": "Stage 5: Execution handoff and terminal sessions",
        "title": "Execute and record changes",
        "tools": {
          "audit": "Execution history stored in SQLite",
          "claude": "External tool handoff via templated prompts",
          "codex": "IDE or CLI export with structured steps",
          "cursor": "Template-driven copy buttons with plan context",
          "sessions": "Persistent terminal sessions with recovery",
          "terminal": "Integrated terminal with voice dictation"
        }
      },
      "title": "The complete pipeline"
    }
  },
  "support": {
    "button": "Contact Support",
    "hero": {
      "subtitle": "Get help with PlanToCode",
      "title": "Support"
    },
    "meta": {
      "description": "Help with installation, troubleshooting, and documentation questions.",
      "title": "PlanToCode Support"
    },
    "resources": {
      "changelog": "Changelog",
      "feedback": "Feedback",
      "help": "Help Center",
      "roadmap": "Roadmap",
      "title": "FeatureBase Resources"
    }
  },
  "schedule": {
    "footer": "Can't find a time? Email us at"
  }
}
