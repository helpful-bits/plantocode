{
  "technicalLanding": {
    "title": "PlanToCode: Review and merge implementation plans",
    "description": "PlanToCode turns tasks into structured implementation plans you can read, compare, and edit before any agent runs. Generate multiple drafts, merge the best approach, and hand off to Claude Code or your terminal with full context while logs stay in PlanToCode.",
    "note": "Hosted uses managed model access; BYOK is available only for self-hosting.",
    "noteLink": "Self-hosting guide",
    "walkthroughTitle": "Step-by-step: how the pieces work together",
    "walkthroughDescription": "Follow an end-to-end walkthrough of how the desktop app, Rust/Tauri backend, SQLite database, and LLM orchestration pipeline coordinate tasks and stream results back to the UI.",
    "tags": [
      "Plan review",
      "Multi-model planning",
      "Plan merge",
      "Mobile plan reader",
      "Source available (BSL)"
    ]
  },
  "gallery": {
    "heading": "Plan review workflow in the app",
    "intro": "See how file discovery, multi-model planning, merge instructions, and execution handoff keep agent work transparent and traceable.",
    "video": {
      "title": "Plan-first workflow overview",
      "description": "A short walkthrough from task intake to plan review, merge instructions, and execution handoff.",
      "bullets": [
        "Run multiple plan drafts against the same file context",
        "Merge the best ideas with explicit instructions",
        "Review and edit plans on desktop or mobile",
        "Hand off to Claude Code or a local terminal while logs stay in PlanToCode"
      ]
    },
    "cards": {
      "fileFinder": {
        "title": "File Discovery Pipeline",
        "description": "A four-stage Rust workflow: LLM-assisted root selection, regex filtering, relevance scoring, and extended path finding to build a focused file set.",
        "features": [
          "Root folder selection uses the directory tree and task prompt",
          "Regex filter generates pattern groups and applies git ls-files",
          "Relevance scoring chunks file contents with token estimates",
          "Extended path finder expands context with file + tree data"
        ]
      },
      "fileFinderWorkflow": {
        "title": "Plan history and logs",
        "description": "Plans, merge drafts, and job outputs are stored in SQLite so you can review what happened before and after execution.",
        "features": [
          "Workflow stages stored as job records",
          "Plan drafts and merges persisted per session",
          "Terminal output logged alongside plan artifacts",
          "Session history survives restarts"
        ]
      },
      "videoAnalysis": {
        "title": "Optional screen recording analysis",
        "description": "Screen recordings can be sent to the /api/llm/video/analyze endpoint with a focus prompt and FPS hint to generate analysis summaries.",
        "features": [
          "Multipart upload includes durationMs and framerate",
          "Model format is provider/model (google/* required)",
          "Usage and cost recorded per job",
          "Summary stored in background_jobs response and can be applied to the task description"
        ]
      },
      "implementationPlans": {
        "title": "Multi-model plan drafts",
        "description": "Run the same task through multiple models and compare drafts before merging or execution.",
        "features": [
          "Plan jobs include selected file contents + directory tree",
          "Explicit file operations with exact paths",
          "Structured plan metadata captured per draft",
          "Merge prompt uses <source_plans> and <user_instructions>",
          "Final plan stored alongside source drafts"
        ]
      },
      "backgroundTasks": {
        "title": "Background Job Monitoring",
        "description": "Rust job processors stream progress and state transitions to the UI while persisting job history in SQLite.",
        "features": [
          "Created, queued, preparing, running, completed/failed/canceled",
          "Streaming updates via Tauri events",
          "Token usage captured per run",
          "Cancel long-running jobs"
        ]
      },
      "settingsPrompts": {
        "title": "System prompts and model control",
        "description": "See and edit system prompts, choose models per task, and understand exactly what is sent.",
        "features": [
          "Per-task allowed models and defaults",
          "System prompts served by the server API",
          "Project-level prompt overrides in project_system_prompts",
          "Local key_value_store for runtime preferences"
        ]
      },
      "terminalVoiceRecording": {
        "title": "Claude Code handoff",
        "description": "Copy buttons format plan context for Claude Code, Cursor, or custom CLIs so execution stays grounded in the current plan.",
        "features": [
          "Templates sourced from task model config",
          "Placeholders resolved against the active plan",
          "Preferred CLI settings include Claude Code, Cursor, Codex, Gemini, or custom",
          "Actions keep handoff consistent with the active plan"
        ]
      },
      "mergeInstructionsWorkflow": {
        "title": "Plan merge instructions",
        "description": "Provide merge guidance, keep source traceability, and store the merged plan alongside its inputs.",
        "features": [
          "Source plans pulled by job ID",
          "Merge instructions stored in metadata",
          "File contents + directory tree add context",
          "Merged plan stored alongside inputs",
          "Mobile voice dictation for merge instructions"
        ]
      },
      "billingTransactions": {
        "title": "Usage and Cost Ledger",
        "description": "Server-side usage entries and job metadata capture model usage across providers.",
        "features": [
          "Per-job token and cost metadata",
          "Provider-aware usage entries",
          "Billing endpoints expose usage summaries",
          "Usage history for model spend"
        ]
      }
    },
    "viewFullSize": "View full size",
    "cta": {
      "title": "Ready to review plans before agents run?",
      "description": "Download the desktop app to try multi-model planning, plan merge, and execution handoff.",
      "primary": "Download PlanToCode",
      "secondary": "See the plan format"
    }
  },
  "governance": {
    "cards": {
      "filePlans": {
        "description": "Implementation plans break down changes by file and operation so scope is explicit.",
        "title": "File-by-file plans with exact paths"
      },
      "handoff": {
        "description": "Approved plans are handed to terminals or agent CLIs with full context while logs stay in PlanToCode.",
        "title": "Execution handoff"
      },
      "workflow": {
        "description": "Plans can be revised, annotated, and approved on desktop or mobile. Every revision is preserved.",
        "title": "Review, edit, approve"
      }
    },
    "subtitle": "Plans are artifacts you can review, edit, and approve before any agent runs. Logs and history keep changes traceable.",
    "title": "Plan review before execution"
  },
  "integrations": {
    "cards": {
      "allIntegrations": {
        "description": "Run the server yourself to control provider routing and supply your own API keys.",
        "link": "Server setup guide ->",
        "title": "Self-hosting and BYOK"
      },
      "claudeCode": {
        "description": "Default prompts are stored in the repo and server database so you can inspect them and override per project in the app.",
        "link": "Prompt types docs ->",
        "title": "System prompts you can read"
      },
      "cursor": {
        "description": "The full system is on GitHub under the Business Source License so you can audit the architecture.",
        "link": "View GitHub repo ->",
        "title": "Source available (BSL 1.1)"
      }
    },
    "subtitle": "System prompts, source code, and self-hosting details are visible and documented.",
    "title": "Transparency and control"
  },
  "faq": {
    "items": {
      "q1": {
        "q": "Do I need an external LLM provider?",
        "a": "Yes. Planning, merge, transcription, and analysis run through LLM providers. The hosted app uses managed provider access; self-hosting lets you supply your own keys."
      },
      "q10": {
        "q": "Can I edit plans before execution?",
        "a": "Yes. Plans open in a Monaco editor on desktop and render as Markdown on mobile so you can edit, comment, and rerun generation."
      },
      "q11": {
        "q": "How do merge instructions work?",
        "a": "Select two or more plan drafts, add merge guidance (typing or voice on mobile), and the merge processor stores the merged result alongside the originals."
      },
      "q12": {
        "q": "What guardrails exist before execution?",
        "a": "Prompt previews, model allowlists, token estimates, and terminal health checks surface issues before any command runs. Every job stores its inputs and outputs for review."
      },
      "q13": {
        "q": "What does a typical workflow look like?",
        "a": "Describe the task -> run file discovery -> generate multiple plans -> review or merge -> hand off to Claude Code or the integrated terminal. Each step is tracked as a job with stored artifacts."
      },
      "q14": {
        "q": "Is the source code and system prompts available?",
        "a": "Yes. The repo is source-available under the Business Source License, and the default system prompts are shipped in the repo and editable in the app."
      },
      "q2": {
        "q": "What gets sent to LLM providers?",
        "a": "Only the task prompt and the files or excerpts you select are sent. Local project state, terminal logs, and plan drafts remain in the SQLite database unless you explicitly export them."
      },
      "q3": {
        "q": "Do plans map to exact files in the repo?",
        "a": "Yes. Plans are structured around explicit file paths and operations (create, modify, delete) so you can review scope before execution."
      },
      "q4": {
        "q": "How is this different from chat-based coding agents?",
        "a": "Chat tools produce a single response. PlanToCode separates planning from execution: file discovery, multi-model plans, review and merge, then handoff to terminals or agent CLIs with stored artifacts."
      },
      "q5": {
        "q": "Can I run it without an LLM provider?",
        "a": "Not for planning or analysis. Hosted includes managed provider access; self-hosting requires your own keys."
      },
      "q6": {
        "q": "Which models are supported?",
        "a": "Models are configured on the server and per task. You can run multiple plan drafts across the allowed models and choose what to merge or execute."
      },
      "q7": {
        "q": "Where is project state stored?",
        "a": "Plans, job history, and terminal output are stored locally in SQLite. You can resume sessions because the job records and artifacts persist across restarts."
      },
      "q8": {
        "q": "How does the integrated terminal work?",
        "a": "Each tab is a PTY session managed by the Rust backend. Output is streamed to the UI and stored in SQLite so you can review or resume later."
      },
      "q9": {
        "q": "How does it handle large codebases?",
        "a": "File discovery is a multi-stage pipeline that filters and scores candidate paths before any plan generation. Each stage is stored as a background job so you can inspect results."
      }
    },
    "subtitle": "Common questions about the planning pipeline, data flow, and execution handoff.",
    "title": "Workflow questions"
  },
  "hero": {
    "cta": {
      "viewDemo": "Download PlanToCode",
      "howItWorks": "See plan format"
    }
  }
}
