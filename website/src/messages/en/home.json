{
  "capture": {
    "cards": {
      "taskRefinement": {
        "description": "Expand task descriptions by identifying implied requirements, clarifying expected behavior and edge cases, and adding technical considerations.",
        "link": "Learn more →",
        "title": "Task Refinement"
      },
      "textEnhancement": {
        "description": "Improve grammar, sentence structure, clarity, and conciseness while maintaining your original intent, tone, and technical detail level.",
        "link": "Learn more →",
        "title": "Text Enhancement"
      },
      "voice": {
        "description": "Capture initial requirements through voice input, which you can then refine manually for precision and clarity.",
        "link": "Learn more →",
        "title": "Voice Dictation"
      }
    },
    "subtitle": "Rapidly crystallize ideas into clear, actionable specifications with voice dictation and AI-powered enhancement.",
    "title": "Specification Capture & Refinement"
  },
  "cta": {
    "badge": "Human-in-the-loop AI Planning",
    "buttons": {
      "download": "Download for Free",
      "talk": "Talk to an Architect"
    },
    "description": "Plan, review, and run AI-assisted changes from one workspace. Keep models, prompts, files, and terminal output aligned.",
    "features": {
      "instant": "Start working instantly",
      "noCard": "No credit card required"
    },
    "title": "Ready to coordinate your next implementation plan?"
  },
  "faq": {
    "items": {
      "q1": {
        "a": "Yes. PlanToCode provides a human-in-the-loop workflow where team leads and stakeholders can review generated implementation plans, edit details, request modifications, and approve changes before they are executed by coding agents or developers. This ensures corporate governance and prevents regressions.",
        "q": "Can stakeholders review and approve plans before execution?"
      },
      "q10": {
        "a": "Absolutely. Plans open in a Monaco editor with syntax highlighting, diff-friendly formatting, and clipboard helpers. You can tweak the prompt, copy individual steps, and rerun generation without leaving the workspace.",
        "q": "Can I edit AI-generated plans before execution?"
      },
      "q11": {
        "a": "Select two or more plans, write the merge guidance, and submit. The merged result is saved alongside the originals so you can compare drafts, keep notes, or rerun the merge with different instructions.",
        "q": "How do merge instructions work?"
      },
      "q12": {
        "a": "Token estimates, prompt previews, terminal health monitoring, and persistent sessions reduce rework. You decide when to run commands and which model to trust, while the app handles orchestration details.",
        "q": "Why do senior engineers use this?"
      },
      "q13": {
        "a": "Describe the task (typing or voice) → run the file finder workflow → generate one or more implementation plans → edit or merge plans in the Monaco editor → launch the built-in terminal to execute the plan and monitor logs. Sessions and logs stay available the next time you open the app.",
        "q": "What does a typical workflow look like?"
      },
      "q2": {
        "a": "Upload Microsoft Teams meeting recordings or screen captures to PlanToCode. Advanced multimodal models analyze both audio transcripts (including speaker identification) and visual content (shared screens, documents) to extract specification requirements. You review the extracted insights - decisions, action items, discussion points - and incorporate them into implementation plans.",
        "q": "How do Teams meetings become specifications?"
      },
      "q3": {
        "a": "Yes. Implementation plans break down changes on a file-by-file basis with exact repository paths corresponding to your project structure. This granular approach ensures you know exactly what will be modified before execution, providing complete visibility and control.",
        "q": "Do plans map to exact files in our repo?"
      },
      "q4": {
        "a": "PlanToCode is a desktop planning workspace. You run the file discovery workflow, review implementation plans in a Monaco editor, adjust prompts, and then launch the terminal from the same session. Chat tools hand you a single reply; here you stage the work before anything runs.",
        "q": "How is this different from chat-based coding agents?"
      },
      "q5": {
        "a": "Yes. The app assumes you already work in large repositories and are comfortable with terminals, dependency graphs, and architecture trade-offs. The software keeps context organized so you can apply your judgment faster.",
        "q": "Do I need to know how to code?"
      },
      "q6": {
        "a": "The default configuration ships with Gemini 2.5 Pro, GPT-5, Claude 4.5 Sonnet, o3, Grok 4, DeepSeek R1, and Kimi K2. You can switch models per task from the settings panel before submitting a job.",
        "q": "Which AI models can generate plans?"
      },
      "q7": {
        "a": "Project state, terminal logs, and plan drafts are stored locally in SQLite. Only the prompt you approve plus the files you select are sent through your configured server proxy. The Rust server in this repo can be self-hosted when you need to keep traffic on your own infrastructure.",
        "q": "What happens to my source code?"
      },
      "q8": {
        "a": "The terminal boots the same shell you use on the host machine and auto-detects claude, cursor, codex, and gemini binaries. You can still run any other tooling manually - the PTY session is a regular shell with voice dictation available when you need hands-free input.",
        "q": "Which CLI tools work inside the terminal?"
      },
      "q9": {
        "a": "Start the file finder workflow to generate search patterns, relevance scoring, and prioritized file lists. Each stage runs as its own background job so you can inspect results before applying the selections to your session.",
        "q": "How does it cope with large codebases?"
      }
    },
    "subtitle": "Everything you need to know about PlanToCode",
    "title": "Frequently Asked Questions"
  },
  "features": {
    "cards": {
      "fileDiscovery": {
        "description": "Start staged background jobs for regex pattern generation, relevance scoring. Review each stage before applying the results to your session.",
        "title": "File discovery workflow"
      },
      "implementation": {
        "description": "Generate file-by-file implementation plans with exact repository paths. Review, edit, and approve changes before execution to prevent regressions and ensure alignment with requirements.",
        "title": "Human-reviewed implementation plans"
      },
      "integratedTerminal": {
        "description": "Launch claude, cursor, codex, or gemini directly in the built-in terminal. Health monitoring, auto-recovery, and resize handling keep long-running jobs stable.",
        "title": "Integrated PTY terminal with CLI detection"
      },
      "meeting": {
        "description": "Upload Microsoft Teams meetings or screen recordings. Multimodal analysis extracts specifications from audio transcripts and visual content for review and incorporation.",
        "title": "Meeting recording ingestion"
      },
      "mergePlans": {
        "description": "Select multiple plans, write merge guidance, and keep the merged output alongside the originals. Iterate until the approach matches your standards.",
        "title": "Merge plans with instructions"
      },
      "modelConfiguration": {
        "description": "Choose from Gemini 2.5 Pro, GPT-5, Claude 4.5 Sonnet, Grok 4, DeepSeek R1, and Kimi K2 for implementation plans. Settings persist per project.",
        "title": "Model configuration per task"
      },
      "monacoEditor": {
        "description": "Plans open in a Monaco editor with syntax highlighting, diff-friendly formatting, and clipboard helpers. Edit steps, store drafts, and keep templates ready for the next task.",
        "title": "Monaco implementation plan editor"
      },
      "persistentSessions": {
        "description": "Terminal output is stored in a 5 MB ring buffer and project sessions reload on start-up. Pick up outstanding work without rebuilding context.",
        "title": "Persistent sessions and logs"
      },
      "specification": {
        "description": "Voice dictation for rapid input, text enhancement for clarity, and task refinement to identify implied requirements and edge cases.",
        "title": "Specification capture & refinement"
      },
      "textImprovement": {
        "description": "Highlight any selection to run the text-improvement job with Claude 4.5 Sonnet or Gemini 2.5 Flash. The rewrite preserves formatting and applies inside Monaco editors, task inputs, and terminal dictation.",
        "title": "Text improvement popover"
      },
      "tokenGuardrails": {
        "description": "View the exact prompt, estimated token counts, and context window warnings before you submit a job. Adjust instructions with full visibility.",
        "title": "Token guardrails & prompt preview"
      },
      "voiceTranscription": {
        "description": "Record task descriptions or terminal commands and send them through the transcription service. Configure language and temperature defaults for each project.",
        "title": "Voice transcription pipeline"
      }
    },
    "linkText": "Learn more",
    "subtitle": "Built for developers tackling large & legacy codebases. If you use Claude Code, Cursor, or Aider - this is your planning layer.",
    "title": "Mechanisms"
  },
  "governance": {
    "cards": {
      "filePlans": {
        "description": "Implementation plans break down changes on a file-by-file basis with exact repository paths, ensuring complete visibility into what will be modified.",
        "title": "File-by-file Plans with Exact Paths"
      },
      "handoff": {
        "description": "Once approved, plans are securely transmitted to your chosen coding agent or assigned to developers, preventing regressions and ensuring alignment with requirements.",
        "title": "Safe Handoff to Agents"
      },
      "workflow": {
        "description": "Team leads and stakeholders can review proposed changes, directly edit plan details, request modifications, and approve plans before execution.",
        "title": "Review, Edit & Approve Workflow"
      }
    },
    "subtitle": "Maintain full control over AI-generated implementation plans. Review, edit, approve, and audit every step before execution.",
    "title": "Human-in-the-loop Governance"
  },
  "hero": {
    "cta": {
      "demo": "Try Interactive Demo →",
      "download": "Download for Free",
      "howItWorks": "See how it works"
    },
    "panel1": {
      "description": "Generate search patterns, run relevance scoring, and review staged results before including files in your plan.",
      "descriptionDesktop": "Surface the right files before you write prompts.",
      "features": {
        "context": "Context optimization",
        "patterns": "Pattern groups",
        "progress": "Real-time progress",
        "relevance": "Relevance scores",
        "stage": "Stage reviews"
      },
      "link": "See how it works",
      "linkDesktop": "Learn more",
      "title": "File discovery workflow"
    },
    "panel2": {
      "description": "Generate implementation plans from GPT-5, Gemini 2.5 Pro, Claude 4 Sonnet, Grok 4, and DeepSeek R1 and merge the best ideas.",
      "link": "Explore the workflow",
      "models": {
        "claude": "Claude Sonnet 4",
        "gemini": "Gemini 2.5 Pro",
        "gpt5": "GPT-5"
      },
      "title": "Multi-model planning"
    },
    "panel3": {
      "description": "Launch claude, cursor, codex, or gemini without leaving the workspace. Health monitoring and recovery keep long jobs running.",
      "link": "Terminal details",
      "terminal": {
        "line1": "$ codex | claude | cursor | gemini",
        "line2": "> Voice transcription available",
        "line3": "> Prompt preview before run",
        "line4": "> Token guardrails in place",
        "line5": "> Logs persist locally"
      },
      "title": "Integrated terminal"
    },
    "srOnly": {
      "description": "PlanToCode helps you find the right files, generate and merge implementation plans, then run them in a persistent terminal. You see scope before you run anything. Plans are editable and traceable.",
      "heading": "Plan software changes before you code"
    },
    "subtitle": "AI generates detailed implementation plans with exact file paths. You review and approve every change before execution. Zero risk, full control.",
    "title": "Plan Complex Changes Without Breaking Production"
  },
  "integrations": {
    "cards": {
      "allIntegrations": {
        "description": "Explore all supported AI coding tools and integration patterns",
        "link": "View integrations →",
        "title": "All Integrations"
      },
      "claudeCode": {
        "description": "Run Claude Code in persistent terminals with full session recording and health monitoring",
        "link": "Setup guide →",
        "title": "Claude Code Integration"
      },
      "cursor": {
        "description": "Give Cursor Composer architectural context and file discovery capabilities",
        "link": "Setup guide →",
        "title": "Cursor Enhancement"
      }
    },
    "subtitle": "Enhance Claude Code, Cursor, and Codex CLI with architectural planning",
    "title": "Works With Your Favorite AI Tools"
  },
  "meetings": {
    "cards": {
      "insights": {
        "description": "Extracted insights - summarized decisions, action items, and key discussion points - are presented in an intuitive interface where team leads can review, select, and incorporate them into actionable implementation plans.",
        "link": "Learn more →",
        "title": "Review & Incorporate Insights"
      },
      "multimodal": {
        "description": "Upload Microsoft Teams meetings or screen recordings. Advanced multimodal models analyze both audio transcripts (with speaker identification) and relevant visual content (shared screens, presented documents, key moments) to extract specification requirements.",
        "link": "Learn more →",
        "title": "Multimodal Analysis"
      }
    },
    "subtitle": "Transform Microsoft Teams meetings and screen recordings into actionable implementation requirements.",
    "title": "Meeting & Recording Ingestion"
  },
  "pricing": {
    "card": {
      "description": "Start with usage-based pricing to validate results. No subscriptions. Just transparent API costs.",
      "pricing": {
        "description": "Test Plan Editor, Merge Instructions, Terminal Integration. Auto top-off when you're convinced.",
        "subtitle": "Pay only for what you use.",
        "title": "Usage-Based Pricing"
      },
      "title": "Transparent Pricing"
    },
    "subtitle": "Pay only for AI inference with transparent token costs. Watch your ROI in real-time - one saved production incident pays for months of usage.",
    "title": "Built for Professional Development"
  },
  "problems": {
    "cards": {
      "browseAll": {
        "description": "Explore workflows for refactors, migrations, incident response, and more",
        "link": "View all workflows →",
        "title": "Browse All Workflows"
      },
      "hardBugs": {
        "description": "Debug with preserved context, reproducible steps, and complete investigation history",
        "link": "Learn more →",
        "title": "Hard Production Bugs"
      },
      "largeFeatures": {
        "description": "Plan complex implementations with architectural awareness and impact analysis",
        "link": "Learn more →",
        "title": "Large Features"
      },
      "libraryUpgrades": {
        "description": "Safely update dependencies with breaking change detection and migration planning",
        "link": "Learn more →",
        "title": "Library Upgrades"
      }
    },
    "subtitle": "Real solutions for the hardest problems in software development",
    "title": "Solve Complex Development Challenges"
  }
}
