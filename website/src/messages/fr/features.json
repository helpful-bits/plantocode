{
  "hub": {
    "meta": {
      "title": "Fonctionnalités de planification du développement IA | PlanToCode",
      "description": "Fonctionnalités de PlanToCode : plans d'implémentation, découverte de fichiers, intégration terminale, amélioration de texte. Fonctionne avec Claude Code, Cursor, Codex."
    },
    "badge": "Fonctionnalités puissantes",
    "cta": {
      "description": "Téléchargez PlanToCode et commencez à planifier vos modifications de code en toute confiance.",
      "title": "Prêt à découvrir le développement IA sécurisé ?",
      "links": {
        "docs": "Open docs",
        "architecture": "Architecture overview"
      },
      "button": "Télécharger PlanToCode"
    }
  },
  "fileDiscovery": {
    "benefits": {
      "costEffective": {
        "description": "Token-aware batching with cost tracking at each stage.",
        "title": "Token budgeting"
      },
      "multiStage": {
        "description": "Four-stage workflow with regex filtering, relevance assessment, and relationship analysis to identify relevant files.",
        "title": "Multi-stage pipeline"
      },
      "realTimeProgress": {
        "description": "Stage-by-stage progress updates emitted by background jobs.",
        "title": "Progress visibility"
      }
    },
    "capabilities": {
      "git": {
        "description": "Executes `git ls-files --cached --others --exclude-standard` to respect .gitignore rules. Falls back to git2 library if command fails.",
        "features": [
          "Git ls-files with .gitignore respect",
          "Binary file detection and filtering",
          "Extension-based exclusion list for common binary types",
          "Content analysis for binary detection"
        ],
        "title": "Git Repository Integration"
      },
      "planIntegration": {
        "description": "Discovered files feed directly into the implementation planning system. Context is preserved and reused across sessions.",
        "features": [
          "Plan generation handoff",
          "Context preservation across sessions",
          "Multiple plan drafts per task",
          "Structured plan inputs"
        ],
        "title": "Implementation Plan Integration"
      },
      "title": "Advanced Discovery Capabilities",
      "tokenManagement": {
        "description": "Content-aware token estimation drives batching. Ratios for JSON/XML (5 chars/token), code (3 chars/token), and text (4 chars/token) guide chunking.",
        "features": [
          "Dynamic chunk sizing per file type",
          "2000-token prompt overhead reservation",
          "Token-budgeted batching (size varies by content and limits)",
          "Chunking based on estimated tokens, not fixed file counts"
        ],
        "title": "Smart Token Management"
      },
      "workflow": {
        "description": "WorkflowOrchestrator manages lifecycle with lazy initialization, dependency scheduling, and orphaned job recovery. Each stage runs as an independent background job.",
        "features": [
          "Stage dependency management",
          "Event-driven progress updates via Tauri",
          "WorkflowIntermediateData persistence",
          "Exponential backoff retry logic"
        ],
        "title": "Distributed Workflow Orchestration"
      }
    },
    "cta": {
      "links": {
        "docs": "Read file discovery docs"
      },
      "title": "Explore the internals"
    },
    "hero": {
      "badge": "File discovery workflow",
      "description": "PlanToCode stages file discovery as a Rust workflow that narrows, scores, and persists context before any plan generation.",
      "title": "File Discovery Pipeline"
    },
    "pipeline": {
      "title": "How the File Discovery Pipeline Works",
      "description": "Before any LLM call, the system builds a candidate index, applies deterministic filters, then uses relevance scoring to minimize tokens and noise.",
      "cards": {
        "index": {
          "title": "Index",
          "description": "Scan Git-tracked paths and build a local candidate set with directory hierarchy context."
        },
        "filter": {
          "title": "Filter",
          "description": "Apply regex patterns, ignore rules, and file-type heuristics to reduce the candidate pool."
        },
        "score": {
          "title": "Score",
          "description": "Run LLM-assisted relevance scoring and persist ranked results for later plan generation."
        }
      }
    },
    "performance": {
      "accuracy": {
        "description": "Multi-stage refinement with relevance assessment and relationship analysis captured per job.",
        "title": "Relevance Quality",
        "value": "Traceable"
      },
      "cost": {
        "description": "Token estimation and batching keep prompts small before LLM scoring.",
        "title": "Token Budgeting",
        "value": "Token-aware"
      },
      "speed": {
        "description": "Stage-by-stage jobs stream updates without blocking the UI.",
        "title": "Job Scheduling",
        "value": "Staged"
      },
      "title": "Operational Characteristics"
    },
    "workflow": {
      "stage1": {
        "description": "Analyzes the directory structure (up to 2 levels deep) to identify candidate project areas and select parent folders vs. subdirectories.",
        "features": [
          "Hierarchical directory analysis",
          "Parent/subdirectory selection heuristics",
          "Avoids redundant nested selections"
        ],
        "title": "Root Folder Selection"
      },
      "stage2": {
        "description": "Generates regex patterns and performs initial file filtering. Integrates with git to respect .gitignore rules and filter binary files.",
        "features": [
          "Dynamic regex pattern creation",
          "Git ls-files integration",
          "Binary file detection and exclusion"
        ],
        "title": "Regex Pattern Generation & Filtering"
      },
      "stage3": {
        "description": "LLM-based relevance scoring to assess file relevance to the task. Uses token-aware batching with content-aware estimation.",
        "features": [
          "Content-based relevance scoring",
          "Token-aware batching",
          "2000-token overhead management"
        ],
        "title": "File Relevance Assessment"
      },
      "stage4": {
        "description": "Discovers additional contextually relevant files through relationship analysis. Analyzes imports, configurations, and project structure to find related files.",
        "features": [
          "Import statement analysis",
          "Dependency graph traversal",
          "Configuration file discovery"
        ],
        "title": "Extended Path Discovery"
      },
      "title": "The 4-Stage Discovery Workflow"
    }
  },
  "mergeInstructions": {
    "capabilities": {
      "instructionControl": {
        "examples": [
          {
            "type": "Priorisation",
            "example": "\"Concentrez-vous sur la sécurité du Plan 2\""
          },
          {
            "type": "Structure",
            "example": "\"Organisez par composant\""
          },
          {
            "type": "Approche",
            "example": "\"Utilisez la stratégie de base de données du Plan 1\""
          },
          {
            "type": "Qualité",
            "example": "\"Incluez des tests complets\""
          },
          {
            "type": "Portée",
            "example": "\"Excluez les étapes de déploiement\""
          },
          {
            "type": "Intégration",
            "example": "\"Utilisez l'exemple de la documentation\""
          },
          {
            "type": "Résolution",
            "example": "\"Préférez les microservices au monolithe\""
          }
        ],
        "title": "Comment les instructions contrôlent la synthèse"
      },
      "title": "Capacités réelles du système",
      "whatAIDoes": {
        "items": [
          "Étudie tous les plans sources pour identifier les insights uniques",
          "Résout les conflits architecturaux en utilisant les principes SOLID",
          "Crée des solutions émergentes au-delà de la simple combinaison",
          "Ajoute des marqueurs de source en ligne pour chaque décision",
          "Valide la cohérence architecturale tout au long",
          "Gère l'intégration d'exemples externes",
          "Maintient la pertinence par rapport à la tâche originale"
        ],
        "title": "Ce que l'IA fait réellement"
      }
    },
    "cta": {
      "description": "Au-delà de la fusion - analyse architecturale intelligente avec principes SOLID. C'est ainsi que la synthèse de plans devrait fonctionner - intelligente, traçable, émergente.",
      "links": {
        "docs": "Implementation plan docs",
        "planMode": "Explorer la génération de plans",
        "demo": "Voir en action"
      },
      "title": "Découvrez la véritable synthèse architecturale"
    },
    "features": {
      "architecturalAnalysis": {
        "description": "Pas juste une concaténation. L'IA analyse en profondeur l'architecture de chaque plan, identifiant les insights et approches uniques.",
        "title": "Analyse architecturale véritable"
      },
      "solidResolution": {
        "description": "Conflits résolus en utilisant les meilleures pratiques d'ingénierie logicielle. Crée des solutions architecturalement solides.",
        "title": "Résolution selon principes SOLID"
      },
      "sourceTraceability": {
        "description": "Chaque élément fusionné inclut des marqueurs d'attribution en ligne montrant exactement de quel plan source il provient.",
        "title": "Traçabilité de source [src:P1]"
      }
    },
    "hero": {
      "badge": "Synthèse architecturale avec traçabilité de source",
      "description": "L'IA effectue une analyse architecturale approfondie de plusieurs plans, résout les conflits en utilisant les principes SOLID et synthétise des solutions émergentes. Chaque décision inclut l'attribution de source [src:P1 étape 2] pour une traçabilité complète.",
      "title": "Au-delà de la simple fusion : synthèse architecturale"
    },
    "example": {
      "heading": "Example merged output with source traceability:",
      "steps": [
        "Step 1: Set up database schema [src:P1 step 3]",
        "Step 2: Implement authentication [src:P2 step 1, P3 step 2]",
        "Step 3: Create API endpoints [src:P3 step 4 - cleaner approach]",
        "Step 4: Add error handling [src:EMERGENT - combining P1, P2 patterns]",
        "Step 5: Implement caching [src:P1 step 7, optimized with P2 insights]"
      ]
    },
    "implementation": {
      "aiPrompt": {
        "description": "Prompt sophistiqué qui applique qualité et traçabilité.",
        "features": [
          "Persona d'architecte logiciel expert",
          "Résolution de conflits selon principes SOLID",
          "Attribution de source obligatoire",
          "Création de solutions émergentes",
          "Portes de validation de qualité"
        ],
        "title": "Prompt système IA"
      },
      "backend": {
        "description": "ImplementationPlanMergeProcessor orchestre toute la synthèse.",
        "features": [
          "Récupère le XML brut des plans sources",
          "Extrait les contextes de fichiers pertinents",
          "Génère l'arbre de structure du projet",
          "Construit un prompt LLM complet",
          "Diffuse la réponse avec mises à jour en temps réel"
        ],
        "title": "Traitement backend"
      },
      "frontend": {
        "description": "Interface riche pour la sélection de plans et la saisie d'instructions.",
        "features": [
          "MergePlansSection avec interface repliable",
          "FloatingMergeInstructions (déplaçable)",
          "Support d'amélioration de texte en temps réel",
          "Gestion d'état avec anti-rebond",
          "Persistance de session pour les instructions"
        ],
        "title": "Composants frontend"
      },
      "metadata": {
        "description": "Full job history for traceability and debugging.",
        "features": [
          "IDs de jobs sources préservés",
          "Prompt complet stocké pour débogage",
          "Instructions de fusion suivies",
          "Opérations de fichiers extraites",
          "Planification de job priorité 2"
        ],
        "title": "Métadonnées et stockage"
      },
      "title": "Détails d'implémentation technique"
    },
    "process": {
      "deepAnalysis": {
        "description": "L'IA effectue une analyse complète avant la synthèse, pas une simple concaténation.",
        "features": [
          "Identifie les insights uniques de chaque plan",
          "Résout les conflits en utilisant les principes SOLID",
          "Préserve les décisions architecturales précieuses",
          "Crée des solutions émergentes au-delà des sources"
        ],
        "title": "Analyse architecturale approfondie"
      },
      "instructions": {
        "description": "Vos instructions contrôlent directement la synthèse. L'IA comprend les orientations architecturales complexes.",
        "examples": [
          "Priorisation : \"Concentrez-vous sur la sécurité du Plan 2\"",
          "Structure : \"Organisez chronologiquement\"",
          "Approche : \"Utilisez la stratégie de base de données du Plan 1\"",
          "Portée : \"Excluez les tests, concentrez-vous sur le cœur\""
        ],
        "title": "Traitement intelligent des instructions"
      },
      "multiModel": {
        "description": "Exécutez GPT-5.2 et Gemini plusieurs fois. Chaque exécution aborde le contexte large différemment, révélant des détails d'implémentation complémentaires.",
        "features": [
          "Chaque plan stocké avec métadonnées complètes",
          "Fichiers pertinents automatiquement extraits",
          "Contexte de structure de projet inclus",
          "Variations de température pour la diversité"
        ],
        "title": "Génération de plan multi-modèles"
      },
      "synthesis": {
        "description": "Crée une solution complète avec attribution de source complète pour chaque décision.",
        "features": [
          "Marqueurs en ligne : [src:P1 étape 2, P3 étape 5]",
          "Support d'intégration d'exemple externe",
          "Points de contrôle de validation de qualité",
          "Cohérence architecturale maintenue"
        ],
        "title": "Synthèse avec traçabilité complète"
      },
      "title": "Le processus de synthèse architecturale"
    },
    "value": {
      "architecturalSynthesis": {
        "description": "Pas de concaténation. L'IA effectue une analyse architecturale approfondie et crée des solutions émergentes qui vont au-delà de tout plan source unique.",
        "title": "Synthèse architecturale"
      },
      "completeTraceability": {
        "description": "Chaque décision inclut des marqueurs [src:P1 étape 2]. Sachez exactement d'où provient chaque choix architectural.",
        "title": "Traçabilité complète"
      },
      "solidPractices": {
        "description": "Conflits résolus en utilisant les principes d'ingénierie logicielle, pas des choix arbitraires. Résultats architecturalement solides.",
        "title": "Pratiques d'ingénierie SOLID"
      },
      "title": "La vraie valeur : au-delà de la simple fusion"
    }
  },
  "planMode": {
    "copyButtons": {
      "examples": {
        "serverConfigured": {
          "button": "Button: \"Parallel Claude Coding Agents\"",
          "hint": "+ Custom instructions...",
          "template": "Template: \"{{IMPLEMENTATION_PLAN}}\""
        },
        "stepExtraction": {
          "copyAll": "Copy All Steps",
          "copyStep": "Copy Step 3",
          "copyWithInstructions": "Copy with Instructions"
        }
      },
      "serverConfigured": {
        "description": "Server-configured copy buttons with template placeholders.",
        "title": "Server-Configured Buttons"
      },
      "stepExtraction": {
        "description": "Copy individual steps or full plans using the structured plan format.",
        "title": "Structured Step Extraction"
      },
      "title": "Configurable Copy Button System"
    },
    "cta": {
      "description": "Follow how plans are generated, reviewed, merged, and handed off to execution, with job history for each step.",
      "links": {
        "mergePlans": "Merge pipeline",
        "terminal": "Terminal sessions"
      },
      "title": "Trace the plan pipeline"
    },
    "editing": {
      "monaco": {
        "description": "Expérience complète d'éditeur VS Code. Pas une zone de texte - un éditeur de code professionnel avec toutes les fonctionnalités.",
        "features": [
          "Coloration syntaxique XML",
          "Rechercher et remplacer avec regex",
          "Édition multi-curseur",
          "Sauvegarde automatique en base de données"
        ],
        "title": "Intégration de l'éditeur Monaco"
      },
      "terminal": {
        "description": "Exécutez les plans directement dans des sessions de terminal persistantes. Saisie vocale, surveillance de santé, contrôle total.",
        "features": [
          "Sessions de terminal persistantes",
          "Entrée de transcription vocale",
          "Copier plan/étapes vers le terminal",
          "Surveillance de santé de session"
        ],
        "title": "Exécution de terminal intégré"
      },
      "title": "Édition et exécution professionnelles"
    },
    "features": {
      "intelligentGeneration": {
        "description": "Chargement complet du contenu des fichiers (pas de troncature). Arborescences de répertoires intelligentes. Support multi-modèles avec configs de projet.",
        "title": "Génération intelligente"
      },
      "monacoEditor": {
        "description": "Éditeur de VS Code avec coloration syntaxique XML. Édition en temps réel avec sauvegarde automatique en base de données.",
        "title": "Éditeur Monaco"
      },
      "terminalExecution": {
        "description": "Exécutez les plans directement dans le terminal intégré. Copiez des étapes ou des plans complets. Support de transcription vocale.",
        "title": "Exécution dans le terminal"
      }
    },
    "fileByFile": {
      "description": "Les plans décomposent les tâches de développement avec des chemins de fichiers exacts correspondant à la structure du dépôt de votre projet. Cette granularité rend l'impact des modifications parfaitement clair et évite les régressions, bugs et modifications involontaires qui peuvent survenir avec les agents de codage autonomes.",
      "exactPaths": {
        "description": "Chaque étape spécifie des chemins de fichiers exacts depuis votre dépôt. Aucune ambiguïté sur les fichiers qui seront modifiés, créés ou supprimés.",
        "title": "Chemins de fichiers exacts"
      },
      "preventRegressions": {
        "description": "Voyez exactement quel code legacy sera touché. Identifiez les modifications potentiellement destructives avant qu'elles ne se produisent. Adoption confiante des agents de codage IA.",
        "features": [
          "Évaluation claire de l'impact",
          "Détection des modifications destructives",
          "Protection du code legacy"
        ],
        "title": "Prévention des régressions"
      },
      "title": "Granularité fichier par fichier pour une sécurité maximale"
    },
    "generation": {
      "fullContext": {
        "description": "Contrairement à d'autres systèmes, nous chargeons le contenu complet des fichiers. Pas de troncature préventive - juste des avertissements intelligents.",
        "features": [
          "Contenu de fichier complet, pas de troncature",
          "Chargement de fichiers parallèle pour la vitesse",
          "Avertissements de tokens à >100k tokens",
          "Génération intelligente d'arborescence de répertoires"
        ],
        "title": "Chargement de contexte complet"
      },
      "multiModel": {
        "description": "Choisissez parmi plusieurs modèles d'IA avec configurations spécifiques au projet et paramètres de température.",
        "features": [
          "GPT-5.2, Claude Sonnet 4, Gemini 3 Pro",
          "Paramètres de modèle spécifiques au projet",
          "Estimation de tokens en temps réel",
          "Validation de fenêtre de contexte"
        ],
        "title": "Architecture multi-modèles"
      },
      "streaming": {
        "description": "Regardez les plans se générer en temps réel avec barres de progression en direct et mises à jour de contenu en streaming.",
        "features": [
          "Streaming en direct avec barres de progression",
          "Coloration syntaxique en temps réel",
          "Mises à jour du nombre de tokens pendant la génération",
          "Suivi de statut de job en arrière-plan"
        ],
        "title": "Streaming en temps réel"
      },
      "title": "Génération de plan pilotée par l'IA avec contexte complet",
      "xmlFormat": {
        "description": "Les plans utilisent XML structuré avec étapes numérotées, permettant la manipulation et l'extraction programmatiques.",
        "features": [
          "Organisation <step number=\"X\">",
          "Titre et description par étape",
          "Suivi des opérations de fichiers",
          "Support d'extraction étape par étape"
        ],
        "title": "Format XML structuré"
      }
    },
    "guides": {
      "claudeCode": {
        "description": "Améliorez le Plan Mode natif de Claude Code avec synthèse multi-modèles et découverte de fichiers.",
        "link": "Ouvrir le guide de workflow de planification Claude Code",
        "name": "Workflow de planification Claude Code"
      },
      "codex": {
        "description": "Pré-planifiez les exécutions Codex avec découverte de fichiers, fusions multi-modèles et modes d'approbation.",
        "link": "Ouvrir le guide de workflow de planification Codex CLI",
        "name": "Workflow de planification Codex CLI"
      },
      "cursor": {
        "description": "Donnez à Cursor Composer une conscience architecturale complète, incluant l'exécution sûre WSL.",
        "link": "Ouvrir le guide de workflow de plan Cursor",
        "name": "Workflow de plan Cursor"
      },
      "title": "Guides pour le mode plan de votre IDE"
    },
    "hero": {
      "badge": "Système complet de planification d'implémentation",
      "description": "Gouvernance humain-dans-la-boucle avec granularité fichier par fichier pour un développement assisté par IA sécurisé",
      "title": "Plans d'implémentation : générer - éditer - exécuter"
    },
    "humanInLoop": {
      "approve": {
        "description": "Lorsque vous êtes satisfait, transmettez de manière sécurisée le plan approuvé à votre agent de codage choisi ou au développeur assigné. Piste d'audit complète maintenue.",
        "title": "Approuver et transmettre"
      },
      "description": "Les chefs d'équipe et parties prenantes conservent le contrôle total pour réviser, éditer et approuver chaque aspect des plans d'implémentation avant que toute modification de code ne commence. Cela garantit que tous les efforts de développement s'alignent sur les exigences produit de l'entreprise, les workflows d'équipe et les objectifs commerciaux.",
      "edit": {
        "description": "Capacités d'édition complètes avec fonctionnalités VS Code. Ajustez les approches, ajoutez des contraintes, supprimez les étapes risquées. Le plan est le vôtre à perfectionner.",
        "title": "Éditer et modifier les plans"
      },
      "review": {
        "description": "Chaque plan généré par l'IA s'ouvre dans l'éditeur Monaco pour une révision approfondie. Pas d'exécution autonome — vous voyez et approuvez chaque modification proposée.",
        "title": "Révision avant exécution"
      },
      "title": "Gouvernance humain-dans-la-boucle"
    },
    "technical": {
      "noTruncation": {
        "description": "Contenu de fichier complet chargé. Avertit à >100k tokens mais ne tronque pas. Vous obtenez le contexte complet.",
        "title": "Politique de non-troncature"
      },
      "persistence": {
        "description": "Plans stockés avec métadonnées, suivi des coûts et historique complet des prompts. Tout est auditable.",
        "title": "Persistance en base de données"
      },
      "templates": {
        "description": "Prompts côté serveur avec surcharges de projet. Processeur de prompt unifié avec placeholders intelligents.",
        "title": "Système de modèles"
      },
      "title": "Sous le capot"
    },
    "workflow": {
      "steps": [
        {
          "title": "Découverte de fichiers IA",
          "description": "Le chercheur de fichiers intelligent identifie les fichiers pertinents. Sélectionnez les répertoires racine pour un contexte ciblé. Pas de troncature."
        },
        {
          "title": "Génération multi-modèles",
          "description": "Exécutez les modèles plusieurs fois (3x GPT-5.2, 2x Gemini). Chaque exécution révèle des détails d'implémentation complémentaires. Streaming en temps réel avec suivi de progression."
        },
        {
          "title": "Éditer dans Monaco",
          "description": "Édition professionnelle avec fonctionnalités VS Code. Ajoutez des étapes, modifiez les approches, restructurez les plans."
        },
        {
          "title": "Synthèse architecturale",
          "description": "Fusionnez plusieurs plans avec instructions personnalisées. Résolution selon principes SOLID, traçabilité de source."
        },
        {
          "title": "Exécuter dans le terminal",
          "description": "Exécutez votre plan dans le terminal intégré. Commandes vocales, sessions persistantes, résultats réels."
        }
      ],
      "title": "Le workflow complet de planification"
    },
    "references": {
      "architecture": {
        "description": "System boundaries, IPC, and background jobs.",
        "title": "Architecture overview"
      },
      "buildYourOwn": {
        "description": "Design the pipeline stages in your own project.",
        "title": "Build your own pipeline"
      },
      "implementationPlans": {
        "description": "Plan format, storage, and review flow.",
        "title": "Implementation plan format"
      },
      "link": "Open docs",
      "title": "Related references"
    }
  },
  "textImprovement": {
    "capabilities": {
      "contextAware": {
        "description": "L'IA comprend la structure de votre projet, les fichiers inclus et les instructions personnalisées lors du raffinement de texte.",
        "title": "Raffinement contextuel"
      },
      "customizable": {
        "description": "Définissez des prompts par projet avec placeholders pour le contenu des fichiers, l'arborescence de répertoires et les instructions personnalisées.",
        "title": "Prompts système personnalisables"
      },
      "instant": {
        "description": "Traitement sans streaming pour la vitesse. Résultats appliqués directement avec détection de conflit pour protéger vos modifications.",
        "title": "Application instantanée"
      },
      "mentalModel": {
        "description": "Le raffinement itératif aide l'IA à comprendre votre intention. Sélectionnez → raffinez → raffinez à nouveau jusqu'à la perfection.",
        "title": "Capture du modèle mental"
      },
      "title": "Capacités clés"
    },
    "cta": {
      "links": {
        "docs": "Text improvement docs",
        "demo": "Voir la démo",
        "voice": "Voir les fonctionnalités vocales"
      },
      "title": "Commencez à capturer des spécifications claires avec l'IA"
    },
    "faq": {
      "codeEditor": {
        "answer": "Oui. Fonctionne dans les champs de description de tâche et les éditeurs de code Monaco. Sélectionnez du texte → le popover apparaît → choisissez une action.",
        "question": "Fonctionne-t-il dans les éditeurs de code ?"
      },
      "conflicts": {
        "answer": "La détection de conflit empêche l'écrasement de vos modifications. Si le texte a changé pendant le traitement, l'amélioration est ignorée avec un avertissement.",
        "question": "Que se passe-t-il si je modifie le texte pendant l'exécution de l'amélioration ?"
      },
      "customize": {
        "answer": "Oui. Définissez des prompts système par projet avec placeholders pour le contenu des fichiers, l'arborescence de répertoires, les instructions personnalisées, etc.",
        "question": "Puis-je personnaliser les prompts d'amélioration ?"
      },
      "model": {
        "answer": "Par défaut : Claude Sonnet 3.5 via OpenRouter. Vous pouvez configurer différents modèles par projet dans les paramètres.",
        "question": "Quel modèle d'IA utilise l'amélioration de texte ?"
      }
    },
    "hero": {
      "badge": "Mode de capture de spécifications • Deux types de prompts IA",
      "credits": "5$ de crédits gratuits • Paiement à l'usage • Fonctionne sur macOS et Windows",
      "description": "Le Mode de capture de spécifications fournit DEUX TYPES DISTINCTS de prompts IA conçus pour aider les équipes d'entreprise à capturer et affiner les exigences que les équipes de développement peuvent implémenter en toute confiance.",
      "installButton": "Installer PlanToCode",
      "subtitle": "L'Amélioration de texte améliore la clarté et la grammaire. Le Raffinement de tâche étend l'exhaustivité et la préparation à l'implémentation. Les deux sont des outils essentiels pour les équipes d'entreprise gérant des workflows de développement complexes et une collecte détaillée des exigences.",
      "title": "Mode de capture de spécifications"
    },
    "howItWorks": {
      "steps": [
        {
          "step": "Sélectionnez du texte dans la description de tâche",
          "description": "Surlignez n'importe quel texte dans votre description de tâche ou éditeur de code. Un popover apparaît instantanément."
        },
        {
          "step": "Choisissez \"Améliorer\" ou \"Raffiner la tâche\"",
          "description": "Améliorer : Corrections rapides de style/clarté. Raffiner la tâche : Amélioration contextuelle approfondie avec fichiers de projet."
        },
        {
          "step": "L'IA traite avec le contexte complet",
          "description": "Claude Sonnet 3.5 analyse avec les fichiers du projet, la structure de répertoires et les prompts personnalisables."
        },
        {
          "step": "Texte raffiné appliqué en ligne",
          "description": "Le texte amélioré remplace automatiquement la sélection. Préserve le formatage et la position du curseur."
        }
      ],
      "title": "Comment ça fonctionne"
    },
    "painPoints": {
      "mentalModels": {
        "description": "Ce que vous imaginez ne correspond pas à ce qui est écrit, conduisant à une dérive d'implémentation.",
        "title": "Les modèles mentaux se perdent dans la traduction"
      },
      "rewriting": {
        "description": "Le raffinement manuel de descriptions ambiguës ralentit la planification et crée un désalignement.",
        "title": "La réécriture des descriptions de tâches fait perdre du temps"
      },
      "title": "Pourquoi les équipes d'entreprise utilisent le Mode de capture de spécifications",
      "vague": {
        "description": "L'IA génère du code basé sur des descriptions de tâches floues, manquant les contraintes critiques et les cas limites.",
        "title": "Les exigences vagues mènent à de mauvaises implémentations"
      }
    },
    "promptTypes": {
      "note": "Les deux types de prompts exploitent de grands modèles de langage pour améliorer le contenu tout en préservant l'intention originale et le sens essentiel de la saisie utilisateur. Cela garantit que vos spécifications restent fidèles à votre vision tout en devenant plus claires et plus complètes.",
      "taskRefinement": {
        "description": "Étend les descriptions de tâches en identifiant les exigences implicites, en comblant les lacunes négligées, en clarifiant le comportement attendu et les cas limites, et en ajoutant des considérations techniques pour rendre les tâches plus complètes et prêtes pour l'implémentation.",
        "features": [
          "Identifie les exigences implicites",
          "Clarifie les cas limites et les contraintes",
          "Ajoute des détails d'implémentation techniques",
          "Rend les tâches exploitables pour les développeurs"
        ],
        "title": "Raffinement de tâche"
      },
      "textEnhancement": {
        "description": "Améliore la grammaire, la structure des phrases, la clarté et la concision tout en maintenant l'intention originale de l'utilisateur, le ton et le niveau de détail technique. Parfait pour polir les brouillons et les transcriptions vocales.",
        "features": [
          "Préserve le sens et l'intention d'origine",
          "Corrige la grammaire et la ponctuation",
          "Améliore le flux et la lisibilité des phrases",
          "Maintient la précision technique"
        ],
        "title": "Amélioration de texte"
      },
      "title": "Deux types distincts de prompts IA"
    },
    "useCases": {
      "clarify": {
        "description": "Transformez \"corriger le bug d'auth\" en étapes spécifiques avec cas limites, services affectés et vérifications de validation.",
        "title": "Clarifier les exigences vagues avant la planification"
      },
      "expand": {
        "description": "Convertissez l'abréviation comme \"refactor user svc\" en tâche détaillée avec contraintes, dépendances et plan de rollback.",
        "title": "Étendre les notes abrégées en contexte complet"
      },
      "refine": {
        "description": "Assurez-vous que les descriptions de tâches sont claires pour les réviseurs et l'implémentation en aval.",
        "title": "Raffiner les descriptions de tâches pour l'alignement d'équipe"
      },
      "title": "Cas d'usage courants"
    }
  },
  "voiceTranscription": {
    "accuracy": {
      "bottomLine": "Summary: Audio quality and the configured model drive accuracy. Review transcribed text before planning.",
      "about": "About transcription quality",
      "models": {
        "aws": "Transcription runs through the configured provider; there is no offline or on-device mode.",
        "google": "Additional providers can be enabled by self-hosted admins via the allowlist.",
        "gpt": "Primary transcription model is configured per project from the server allowlist.",
        "whisper": "No diarization or speaker labels are produced in the current pipeline."
      },
      "title": "Accuracy factors"
    },
    "capabilities": {
      "multiLanguage": {
        "description": "The configured transcription provider supports multiple languages. Project settings select the default language.",
        "title": "Multiple Language Support"
      },
      "perProject": {
        "description": "Set project defaults for language, temperature, and transcription model. Integrates with text_improvement and task_refinement prompts.",
        "title": "Per-Project Configuration"
      },
      "terminalDictation": {
        "description": "Dictate commands into the active PTY session; the transcript is inserted into the terminal input buffer.",
        "title": "Terminal Dictation (Stage 5)"
      },
      "title": "Key Capabilities"
    },
    "cta": {
      "links": {
        "docs": "Voice transcription docs"
      },
      "title": "Voice transcription in the pipeline"
    },
    "example": {
      "competitor": {
        "label": "Baseline transcription",
        "text": "Create a Postgres replica in us-east with 2 CPUs, 8GB RAM, and enable replication; set wal level logical and max senders equals ten."
      },
      "comparisonTitle": "Token-level comparison",
      "errorSummary": "Errors — Substitutions: {sub}, Deletions: {del}, Insertions: {ins}. Small errors can flip units or flags.",
      "impact": "Impact: Mishearing \"read-replica\" as \"replica\", dropping region suffix \"-1\", or changing \"wal_level=logical\" can lead to incorrect deployments or data flows.",
      "primaryBadge": "reference-aligned",
      "primaryLabel": "Primary transcription model",
      "gpt": "Create a Postgres read-replica in us-east-1 with 2 vCPU, 8 GB RAM, and enable logical replication; set wal_level=logical and max_wal_senders=10.",
      "reference": "Create a Postgres read-replica in us-east-1 with 2 vCPU, 8GB RAM, and enable logical replication; set wal_level=logical and max_wal_senders=10.",
      "title": "Transcription comparison"
    },
    "faq": {
      "customize": {
        "answer": "Yes. You can configure language and model settings per project. Settings persist across sessions and are reused by transcription jobs.",
        "question": "Can I customize transcription settings per project?"
      },
      "languages": {
        "answer": "Supported languages depend on the configured transcription provider. You can set a default language per project.",
        "question": "Which languages are supported for voice transcription?"
      },
      "model": {
        "answer": "The transcription model is configured per project from the provider allowlist.",
        "question": "Which model is used for transcription?"
      },
      "offline": {
        "answer": "No. Voice transcription requires an internet connection to send audio to the configured provider.",
        "question": "Does voice transcription work offline?"
      },
      "whereToUse": {
        "answer": "Voice transcription works in two places: (1) Task description panel - dictate implementation requirements (Stage 1), and (2) Terminal modal - dictate commands that are appended to your active shell session (Stage 5).",
        "question": "Where can I use voice transcription in the app?"
      }
    },
    "hero": {
      "badge": "Stage 1 & Stage 5 Voice Input",
      "description": "Dictate tasks and commands; audio is sent to the configured transcription provider and inserted into the task description or PTY input. Voice transcription respects per-project settings and feeds text_improvement and task_refinement jobs.",
      "title": "Voice transcription for specification capture and terminal control"
    },
    "workflow": {
      "stage1": {
        "description": "Dictate tasks to capture constraints, context, and intent; transcribed text becomes input for refinement jobs.",
        "title": "Stage 1: Dictating Tasks"
      },
      "stage5": {
        "description": "Dictate terminal commands while reviewing output or diffs; the command is inserted into the PTY input.",
        "title": "Stage 5: Terminal Voice Control"
      },
      "integration": {
        "description": "Voice respects per-project language and temperature settings. Transcribed text feeds into text_improvement for grammar polish and task_refinement for completeness expansion.",
        "title": "Integration with Text Enhancement Prompts"
      },
      "title": "Voice Transcription Across Stages"
    },
    "nextSteps": {
      "description": "Voice transcription is Stage 1 input in the planning pipeline. After capturing dictated text, text_improvement cleans grammar and task_refinement expands completeness, preparing specs for Stage 2 file discovery.",
      "link": "Learn about text_improvement and task_refinement",
      "taskRefinement": {
        "description": "Expand descriptions with implied requirements, edge cases, and technical considerations. Prepares specs for FileFinderWorkflow.",
        "title": "Task Refinement (Stage 1 → 2)"
      },
      "textEnhancement": {
        "description": "Polish grammar, improve clarity, and preserve intent for review.",
        "title": "Text Enhancement (Stage 1)"
      },
      "title": "Refine Dictated Text Before File Discovery"
    },
    "painPoints": {
      "captureIdeas": {
        "description": "Dictation preserves context at discovery time and creates clean text inputs for refinement jobs.",
        "title": "Capture context at discovery time"
      },
      "contextSwitching": {
        "description": "Dictation writes directly into the active task or terminal field so the session context stays intact.",
        "title": "Keep input in the active surface"
      },
      "handsBusy": {
        "description": "Voice capture keeps input flowing during code review, debugging, or sketching; dictated text stays in the task or session.",
        "title": "Hands-free input during active review"
      },
      "title": "Why voice capture exists in intake"
    },
    "useCases": {
      "codeReview": {
        "outcome": "Transcribed text is ready for text_improvement and task_refinement.",
        "scenario": "While reviewing a diff, dictate refactor requirements into the task panel; the dictated text is stored in the task description.",
        "title": "Dictate refactor notes during review (Stage 1)"
      },
      "fasterEntry": {
        "outcome": "Dictated notes are queued for task_refinement to normalize into specs.",
        "scenario": "After QA, dictate multiple bug reports; each dictation becomes task input you can refine.",
        "title": "Batch capture for repeated reports"
      },
      "handsFree": {
        "outcome": "Captured text is stored as task input and can be refined later.",
        "scenario": "During a debugging session, dictate related issues without leaving the terminal or editor.",
        "title": "Capture issues during debug (Stage 1)"
      },
      "terminalCommands": {
        "outcome": "The command and output are logged to the session history.",
        "scenario": "While monitoring output, dictate a command into the active PTY input buffer.",
        "title": "Dictated commands in PTY (Stage 5)"
      },
      "title": "Pipeline examples"
    }
  },
  "integratedTerminal": {
    "cta": {
      "description": "Un terminal conçu pour la planification et l'exécution — intégré, persistant et rapide.",
      "links": {
        "docs": "Lire la documentation technique",
        "voice": "Explorer les commandes vocales"
      },
      "title": "Découvrez le terminal qui ne perd jamais le contexte"
    },
    "features": {
      "integratedPlanning": {
        "description": "Exécutez les plans d'implémentation et copiez les étapes directement dans le terminal sans quitter l'application.",
        "title": "Intégré à la planification"
      },
      "persistent": {
        "description": "Vos sessions de terminal restent avec votre travail, préservant le contexte entre les tâches et les redémarrages.",
        "title": "Sessions persistantes"
      },
      "title": "Un terminal conçu pour votre workflow",
      "voiceSupport": {
        "description": "Utilisez le copier-coller en un clic pour les commandes ou dictez-les directement en utilisant la saisie vocale pour aller plus vite.",
        "title": "Support vocal et de copie"
      }
    },
    "hero": {
      "badge": "Terminal PTY intégré",
      "description": "Exécutez votre plan dans un terminal persistant. Conçu pour une exécution rapide et ciblée.",
      "title": "Terminal centré sur les jobs qui garde le contexte"
    },
    "meta": {
      "title": "Integrated Terminal - Persistent PTY Sessions",
      "description": "Persistent terminal sessions with health monitoring and command review. Execute implementation plans directly with voice transcription support."
    }
  },
  "videoAnalysis": {
    "meta": {
      "title": "Video Analysis Pipeline - PlanToCode",
      "description": "Adaptive analysis of screen recordings guided by system prompts and your focus prompt."
    },
    "capabilities": {
      "fileUpload": {
        "description": "Upload existing recordings or capture new ones for analysis.",
        "features": [
          "MP4, WebM, MOV, AVI support",
          "Local recording stored before upload",
          "Long recordings split into chunks"
        ],
        "title": "Recording upload"
      },
      "fpsControl": {
        "description": "FPS is a sampling hint that trades detail for cost; for large files the provider may ignore it.",
        "features": [
          "0.1 to 20 FPS selection in the UI",
          "Lower FPS reduces token usage",
          "Long recordings may be chunked for analysis"
        ],
        "title": "Frame rate hint"
      },
      "gemini": {
        "description": "Video analysis uses Google Gemini video models configured per project; usage is tracked with job metadata.",
        "features": [
          "Allowed models set by server config",
          "Per-project model defaults",
          "Usage and cost tracking"
        ],
        "title": "Model selection"
      },
      "screenRecording": {
        "description": "Local capture with synchronized audio and video stored alongside the task.",
        "features": [
          "Full screen or window capture",
          "Audio and video sync",
          "Stored with the task id"
        ],
        "title": "Screen recording"
      },
      "title": "Pipeline controls"
    },
    "cta": {
      "description": "Connect video artifacts to the rest of the planning pipeline: deep research and file discovery.",
      "links": {
        "fileDiscovery": "File discovery pipeline",
        "research": "Deep research stage"
      },
      "title": "Continue in the pipeline"
    },
    "faq": {
      "formats": {
        "answer": "MP4, WebM, MOV, and AVI are supported. Other formats may work but are not guaranteed.",
        "question": "Which video formats are supported?"
      },
      "fps": {
        "answer": "FPS is a sampling hint. Higher FPS can increase cost; for very large files the provider may sample at a fixed rate, and long recordings may be chunked.",
        "question": "What FPS settings should I use?"
      },
      "model": {
        "answer": "Video analysis uses Google Gemini video models. The default model is configured per project from the server allowlist.",
        "question": "Which model should I choose?"
      },
      "optimization": {
        "answer": "Trim to relevant segments, keep the focus prompt specific, and use lower FPS when high visual detail is not required.",
        "question": "How can I optimize analysis costs?"
      }
    },
    "hero": {
      "badge": "Stage 1 input: Screen recording analysis",
      "description": "Record or upload a screen recording, add a focus prompt, and let the video analysis system prompt guide a Gemini model to extract what matters. Results are stored as a job response you can attach to the task.",
      "title": "Multimodal video analysis for requirements capture"
    },
    "howItWorks": {
      "steps": [
        {
          "title": "Capture or upload video",
          "description": "Record your screen (with optional audio) or pick an existing file. Recordings stay local until analysis starts."
        },
        {
          "title": "Set a focus prompt",
          "description": "Your task description and optional focus prompt are wrapped in <description> and <video_attention_prompt> tags."
        },
        {
          "title": "Run adaptive analysis",
          "description": "The default video analysis system prompt tells the model to focus on what you show and say and to quote visible text when relevant."
        },
        {
          "title": "Attach to the task pipeline",
          "description": "The analysis summary is stored in the job record and can be appended to the task description."
        }
      ],
      "title": "How the pipeline runs"
    },
    "insights": {
      "actionItems": {
        "description": "Action items and suggested fixes based on what was shown and said.",
        "title": "Action items"
      },
      "decisions": {
        "description": "Decisions or open questions captured from the recording.",
        "title": "Decisions"
      },
      "description": "Analysis results are stored in the job response and can be applied to the task description for refinement and planning.",
      "discussionPoints": {
        "description": "UI issues, design tradeoffs, or bugs worth following up.",
        "title": "Discussion points"
      },
      "title": "Structured outputs"
    },
    "models": {
      "flash": {
        "description": "Lower cost and latency for straightforward UI flows and documentation.",
        "features": [
          "Fast turnaround",
          "Lower cost for straightforward recordings",
          "Good for simple flows"
        ],
        "title": "Fast analysis model"
      },
      "pro": {
        "description": "Deeper context for complex UI issues and nuanced workflows.",
        "features": [
          "Richer reasoning",
          "Better for complex flows",
          "Higher cost for complex recordings"
        ],
        "title": "Deep analysis model"
      },
      "title": "Model tradeoffs"
    },
    "multimodal": {
      "audioTranscript": {
        "description": "The model analyzes the audio track directly; the app does not generate a separate transcript.",
        "features": [
          "Narration guides what to focus on",
          "Spoken intent and errors inform the summary",
          "No standalone transcript file produced"
        ],
        "title": "Audio and narration context"
      },
      "title": "Audio and visual extraction",
      "visualContent": {
        "description": "The model analyzes what is visible in the video and can quote on-screen text when it is clear.",
        "features": [
          "UI flows and state changes from what is visible",
          "Best-effort quotes of logs, errors, and labels",
          "No local frame export or OCR pipeline"
        ],
        "title": "Visual context from the recording"
      }
    },
    "painPoints": {
      "incompleteNotes": {
        "description": "Screenshare changes and error dialogs are easy to miss in notes; recordings preserve that context.",
        "title": "Manual notes omit frame references"
      },
      "requirementsLost": {
        "description": "Text notes miss on-screen state and timing; recordings keep the visual context intact.",
        "title": "UI state lives in recordings"
      },
      "reviewTime": {
        "description": "Long recordings are hard to review; a focused summary highlights what matters.",
        "title": "Raw recordings are expensive to review"
      },
      "title": "Why multimodal ingestion exists"
    },
    "useCases": {
      "bugCapture": {
        "description": "Summarize reproduction steps and visible errors from a recording.",
        "title": "Bug timeline artifacts"
      },
      "onboarding": {
        "description": "Produce walkthrough notes from a screen recording.",
        "title": "Walkthrough summaries"
      },
      "title": "Example outputs",
      "uiDemo": {
        "description": "Capture UI states and flows shown in the recording.",
        "title": "UI state capture"
      }
    }
  },
  "copyButtons": {
    "concept": {
      "dragDrop": {
        "description": "Drag-and-drop ordering for button sets. Organize buttons by execution stage or priority.",
        "title": "Drag-and-drop ordering"
      },
      "serverConfigured": {
        "description": "Template prompts with placeholders: {{IMPLEMENTATION_PLAN}}, {{TASK_DESCRIPTION}}, {{STEP_CONTENT}}. Server defaults with project-level overrides.",
        "title": "Template Placeholders"
      },
      "terminal": {
        "description": "Send templated content to persistent terminal sessions (Stage 5). Large content is chunked when writing to the PTY.",
        "title": "Terminal integration (Stage 5)"
      }
    },
    "configuration": {
      "projectSettings": {
        "description": "Copy buttons are stored in per-project task settings in key_value_store and merged with server defaults.",
        "features": [
          "Key-value storage in SQLite",
          "Server-managed default configurations",
          "Project directory scoping",
          "Settings sync across desktop and mobile"
        ],
        "title": "Project-Specific Settings"
      },
      "title": "Configuration & Management",
      "visualUI": {
        "description": "Configuration editor with drag-drop reordering and debounced inputs for labels and templates.",
        "features": [
          "Drag handles for visual reordering",
          "300ms debounced input processing",
          "Read-only mode for system buttons",
          "Template ordering support"
        ],
        "title": "Visual Configuration UI"
      }
    },
    "cta": {
      "links": {
        "planMode": "See Stage 3 planning & Stage 4 merge",
        "terminal": "Explore Stage 5 terminal integration"
      },
      "title": "Template-driven execution handoff"
    },
    "exampleConfig": {
      "title": "Example button configuration:",
      "footer": "→ Button runs the configured template",
      "templateBody": "{{IMPLEMENTATION_PLAN}}\n\nReview the plan. Read the files mentioned, understand them and launch parallel coding agents that run at the same time..."
    },
    "exampleLabels": {
      "button": "Button:",
      "dynamic": "Dynamic:",
      "label": "Label:",
      "purpose": "Purpose:",
      "result": "Result:",
      "template": "Template:"
    },
    "exampleValues": {
      "investigationButton": "\"Investigate Results\"",
      "investigationPurpose": "Validation and review workflows",
      "parallelButton": "\"Parallel Claude Coding Agents\"",
      "parallelPurpose": "Parallel agent instruction templates",
      "projectContextTemplate": "{{TASK_DESCRIPTION}}",
      "projectDynamic": "Task-aware instructions",
      "stepResult": "Focused step execution",
      "stepTemplate": "{{STEP_CONTENT}}"
    },
    "hero": {
      "badge": "Template handoff",
      "description": "Copy buttons insert {{IMPLEMENTATION_PLAN}}, {{TASK_DESCRIPTION}}, and {{STEP_CONTENT}} into predefined templates.",
      "title": "Template prompts with plan substitution"
    },
    "technical": {
      "architecture": {
        "heading": "# Copy button system architecture",
        "note": "[Extend with new placeholders and templates as needed]",
        "sections": {
          "execution": "## 4. Execution flow",
          "processing": "## 2. Template processing",
          "storage": "## 1. Configuration storage",
          "ui": "## 3. UI integration"
        },
        "execution": "Button click triggers template processing -> clipboard copy or PTY write (chunked)",
        "processing": "Regex placeholder matching -> substitution with plan, step, and task text -> missing values become empty strings",
        "storage": "CopyButtonConfig[] stored in per-project task settings (key_value_store) plus server-side defaults",
        "ui": "Implementation plan cards → Content viewing modals → Terminal interface headers → Drag-drop configuration editor"
      },
      "title": "Technical Implementation"
    },
    "templateSystem": {
      "placeholders": {
        "description": "Template prompts with {{PLACEHOLDER}} substitution. Supported placeholders include plan content, step content, and task description.",
        "examples": [
          "{{IMPLEMENTATION_PLAN}} - Full plan content",
          "{{STEP_CONTENT}} - Selected step content",
          "{{TASK_DESCRIPTION}} - Task requirements"
        ],
        "title": "Placeholder Substitution"
      },
      "processor": {
        "description": "Template processor injects XML plans, task descriptions, and governance constraints into predefined prompts.",
        "features": [
          "Regex-based placeholder matching",
          "XML plan formatting and escaping",
          "Multi-line governance instruction support",
          "Graceful undefined handling"
        ],
        "title": "Unified Prompt Processing"
      },
      "title": "Template system"
    },
    "terminalIntegration": {
      "oneClick": {
        "description": "Copy buttons integrate with Stage 5 terminal sessions and insert plan context into the active PTY with logging.",
        "features": [
          "Automatic paste to active terminal session",
          "Chunked sending for large XML plans",
          "Session health monitoring",
          "Clipboard fallback for safety"
        ],
        "title": "Stage 5 execution handoff"
      },
      "title": "Stage 5 Terminal Execution"
    },
    "useCases": {
      "customTeam": {
        "description": "Team-specific governance constraints with {{PROJECT_CONTEXT}} and coding standards.",
        "title": "Team governance templates"
      },
      "investigation": {
        "description": "Standardized review prompts for Stage 3 implementation plan results.",
        "title": "Investigation and review"
      },
      "parallel": {
        "description": "Example button: \"Parallel agent template\" inserts the plan XML and governance instructions.",
        "title": "Parallel agent templates"
      },
      "stepByStep": {
        "description": "Extract individual implementation steps with {{STEP_CONTENT}}. Execute step-by-step with full plan context.",
        "title": "Step-by-step execution"
      },
      "title": "Example configurations"
    }
  },
  "deepResearch": {
    "advanced": {
      "features": [
        {
          "title": "Conception intelligente de requêtes",
          "description": "L'IA élabore des requêtes de recherche sophistiquées qui explorent plusieurs angles et perspectives pour une couverture complète."
        },
        {
          "title": "Analyse contextuelle",
          "description": "La recherche est adaptée au contexte spécifique de votre projet, à votre stack technologique et à vos exigences de développement."
        },
        {
          "title": "Traitement en arrière-plan",
          "description": "Les tâches de recherche de longue durée s'exécutent en arrière-plan avec des mises à jour de progression en temps réel et des notifications."
        },
        {
          "title": "Intégration des résultats",
          "description": "Les résultats de recherche sont automatiquement formatés et intégrés dans vos descriptions de tâches pour une utilisation immédiate."
        },
        {
          "title": "Optimisation des coûts",
          "description": "Sélection intelligente de modèle et optimisation des requêtes pour équilibrer la qualité de recherche et l'efficacité des coûts."
        },
        {
          "title": "Surveillance de la progression",
          "description": "Suivi en temps réel de la progression de la recherche avec des mises à jour d'état détaillées et des notifications d'achèvement."
        }
      ],
      "title": "Capacités de recherche avancées"
    },
    "aiCapabilities": {
      "multiModel": {
        "description": "Exploite plusieurs modèles d'IA pour exécuter des tâches de recherche avec différentes perspectives et domaines d'expertise.",
        "models": [
          "Modèles GPT d'OpenAI",
          "Anthropic Claude",
          "Google Gemini",
          "Modèles de recherche spécialisés"
        ],
        "title": "Recherche multi-modèles"
      },
      "parallel": {
        "description": "Exécutez plusieurs tâches de recherche simultanément avec agrégation et synthèse intelligentes des résultats.",
        "features": [
          "Exécution concurrente",
          "Suivi de progression",
          "Récupération d'erreur",
          "Synthèse des résultats"
        ],
        "title": "Traitement parallèle"
      },
      "projectContext": {
        "description": "L'IA analyse la structure de votre projet, votre stack technologique et votre base de code pour générer des recherches hautement pertinentes.",
        "features": [
          "Analyse de la structure des fichiers",
          "Détection du stack technologique",
          "Cartographie des dépendances",
          "Insights contextuels"
        ],
        "title": "Analyse du contexte du projet"
      },
      "title": "Capacités de recherche IA"
    },
    "cta": {
      "links": {
        "planMode": "Voir la planification d'implémentation",
        "textImprovement": "Explorer l'amélioration de texte"
      },
      "title": "Transformez votre workflow de recherche"
    },
    "developmentFocus": {
      "contextFiltering": {
        "description": "La portée de recherche est automatiquement ajustée en fonction du contexte de votre projet et de votre stack de développement.",
        "features": [
          "Conscience du stack technologique",
          "Vérification de la compatibilité des versions",
          "Filtrage des exigences du projet",
          "Priorisation de la scalabilité"
        ],
        "title": "Filtrage contextuel"
      },
      "implementationReady": {
        "description": "Résultats de recherche optimisés pour les workflows de développement. Exemples de code, documentation API et bonnes pratiques.",
        "features": [
          "Extraction d'extraits de code",
          "Compilation de référence API",
          "Analyse des patterns d'architecture",
          "Notes de considérations de performance"
        ],
        "title": "Insights prêts pour l'implémentation"
      },
      "title": "Recherche axée sur le développement"
    },
    "features": {
      "parallelExecution": {
        "description": "Exécutez plusieurs tâches de recherche sophistiquées simultanément. L'IA synthétise les résultats en insights de développement exploitables.",
        "title": "Exécution de recherche parallèle"
      },
      "projectIntegration": {
        "description": "La recherche est adaptée à la structure spécifique de votre projet, à votre stack technologique et à votre contexte de développement pour une pertinence maximale.",
        "title": "Intégration du contexte du projet"
      },
      "queryGeneration": {
        "description": "L'IA étend vos requêtes de recherche avec des variations contextuelles. Exploration multi-angle pour une couverture complète.",
        "title": "Génération intelligente de requêtes"
      }
    },
    "hero": {
      "badge": "Intelligence de recherche pilotée par l'IA",
      "description": "Générez des requêtes intelligentes, lancez des recherches et intégrez les résultats pertinents dans votre tâche - sans superflu.",
      "title": "Recherche approfondie - de la requête à l'insight"
    },
    "intelligence": {
      "contextIntegration": {
        "description": "Les résultats de recherche sont automatiquement intégrés à votre description de tâche, l'enrichissant avec des résultats et recommandations pertinents.",
        "features": [
          "Amélioration automatique des tâches",
          "Formatage structuré des résultats",
          "Intégration du plan d'implémentation",
          "Alignement du workflow de développement"
        ],
        "title": "Intégration contextuelle"
      },
      "execution": {
        "description": "Des modèles d'IA sophistiqués exécutent des tâches de recherche en parallèle, fournissant des analyses et insights complets.",
        "features": [
          "Exécution parallèle de tâches de recherche",
          "Résultats en streaming avec suivi de progression",
          "Analyse et synthèse contextuelles",
          "Insights axés sur le développement"
        ],
        "title": "Exécution de recherche IA"
      },
      "queryExpansion": {
        "description": "L'IA analyse votre requête initiale et génère des variations stratégiques pour une couverture de recherche complète.",
        "features": [
          "Variations de requête contextuelles",
          "Expansion de synonymes sémantiques",
          "Terminologie spécifique au domaine",
          "Angles de recherche multi-perspectives"
        ],
        "title": "Expansion intelligente de requêtes"
      },
      "synthesis": {
        "description": "Des modèles d'IA avancés analysent le contexte de votre projet et génèrent des insights de recherche ciblés adaptés à vos besoins de développement.",
        "features": [
          "Génération de recherche projet-aware",
          "Analyse sensible au contexte",
          "Insights axés sur le développement",
          "Recommandations prêtes pour l'implémentation"
        ],
        "title": "Synthèse de recherche IA"
      },
      "title": "Moteur d'intelligence de recherche"
    },
    "process": {
      "stage1": {
        "description": "L'IA analyse la description de votre tâche et le contexte du projet pour générer des requêtes de recherche sophistiquées. Crée plusieurs angles de recherche stratégiques pour une couverture complète.",
        "title": "Génération de requêtes de recherche"
      },
      "stage2": {
        "description": "Plusieurs modèles d'IA exécutent des tâches de recherche simultanément, chacun se concentrant sur différents aspects de vos exigences. Les résultats sont synthétisés en insights de développement exploitables.",
        "title": "Exécution de recherche parallèle"
      },
      "title": "Processus de recherche IA en deux étapes"
    }
  },
  "features": {
    "copyButtons": {
      "description": "Transformez n'importe quel prompt en bouton réutilisable avec placeholders intelligents et glisser-déposer",
      "slug": "/features/copy-buttons",
      "title": "Boutons de copie"
    },
    "deepResearch": {
      "description": "Recherche pilotée par l'IA avec requêtes sophistiquées et tâches de recherche parallèles",
      "slug": "/features/deep-research",
      "title": "Recherche approfondie"
    },
    "fileDiscovery": {
      "description": "Workflow intelligent multi-étapes qui découvre et sélectionne les fichiers pertinents de votre base de code",
      "slug": "/features/file-discovery",
      "title": "Découverte de fichiers IA",
      "meta": {
        "title": "AI file discovery - find impacted files",
        "description": "Multi-stage AI workflow that discovers and selects relevant files. Cost-effective at $0.10-0.15 per workflow with real-time progress tracking."
      }
    },
    "integratedTerminal": {
      "description": "Sessions de terminal persistantes avec surveillance de santé et révision de commandes",
      "slug": "/features/integrated-terminal",
      "title": "Terminal intégré"
    },
    "mergeInstructions": {
      "description": "L'IA analyse plusieurs plans d'implémentation, résout les conflits, crée des solutions émergentes",
      "slug": "/features/merge-instructions",
      "title": "Synthèse de plans architecturaux",
      "meta": {
        "title": "Plan Synthesis - Multi-Model Merging",
        "description": "Architectural synthesis beyond simple merging. AI analyzes plans, resolves conflicts with SOLID principles, and creates emergent solutions with traceability."
      }
    },
    "planMode": {
      "description": "Générez des plans d'implémentation fichier par fichier avec l'IA. Révisez et approuvez chaque modification avant l'exécution",
      "slug": "/features/plan-mode",
      "title": "Plans d'implémentation",
      "meta": {
        "title": "AI Implementation Plans - Human-in-Loop",
        "description": "Generate file-by-file AI plans. Review every change before execution. Prevent regressions in legacy code. Safe AI development."
      }
    },
    "textImprovement": {
      "description": "Affinez les spécifications avec amélioration de texte IA et prompts de raffinement de tâche",
      "slug": "/features/text-improvement",
      "title": "Mode de capture de spécifications",
      "meta": {
        "title": "Spec Capture Mode - AI Text Enhancement",
        "description": "Refine specifications with two AI prompts: Text Enhancement for clarity, Task Refinement for completeness. Create actionable specs for development teams."
      }
    },
    "videoAnalysis": {
      "description": "Multimodal ingestion of recordings with prompt-guided analysis summaries.",
      "slug": "/features/video-analysis",
      "title": "Analyse de réunions et enregistrements"
    },
    "voiceTranscription": {
      "description": "Capturez des spécifications mains libres avec transcription vocale en plusieurs langues",
      "slug": "/features/voice-transcription",
      "title": "Voix vers texte",
      "meta": {
        "title": "Voice to text for rapid specification capture",
        "description": "Hands-free specification capture with voice. Accurate transcription inserts text where you work. Configure per project, supports multiple languages."
      }
    }
  }
}
