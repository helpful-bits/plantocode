{
  "capture": {
    "cards": {
      "taskRefinement": {
        "description": "Développez les descriptions de tâches en identifiant les exigences implicites, en clarifiant le comportement attendu et les cas limites, et en ajoutant des considérations techniques.",
        "link": "En savoir plus →",
        "title": "Raffinement de tâche"
      },
      "textEnhancement": {
        "description": "Améliorez la grammaire, la structure des phrases, la clarté et la concision tout en préservant votre intention originale, votre ton et votre niveau de détail technique.",
        "link": "En savoir plus →",
        "title": "Amélioration de texte"
      },
      "voice": {
        "description": "Capturez les exigences initiales par saisie vocale, que vous pouvez ensuite affiner manuellement pour plus de précision et de clarté.",
        "link": "En savoir plus →",
        "title": "Dictée vocale"
      }
    },
    "subtitle": "Cristallisez rapidement vos idées en spécifications claires et actionnables avec dictée vocale et amélioration alimentée par l'IA.",
    "title": "Capture et raffinement de spécifications"
  },
  "cta": {
    "badge": "Planification IA avec humain dans la boucle",
    "buttons": {
      "download": "Télécharger gratuitement",
      "talk": "Parler à un expert"
    },
    "description": "Planifiez, examinez et exécutez des modifications assistées par l'IA depuis un seul espace de travail. Gardez les modèles, les invites, les fichiers et la sortie du terminal alignés.",
    "features": {
      "instant": "Commencez à travailler instantanément",
      "noCard": "Aucune carte de crédit requise"
    },
    "title": "Prêt à coordonner votre prochain plan de mise en œuvre ?"
  },
  "faq": {
    "items": {
      "q1": {
        "a": "Oui. PlanToCode fournit un workflow avec humain dans la boucle où les chefs d'équipe et les parties prenantes peuvent examiner les plans de mise en œuvre générés, modifier les détails, demander des modifications et approuver les changements avant leur exécution par des agents de codage ou des développeurs. Cela garantit la gouvernance d'entreprise et prévient les régressions.",
        "q": "Les parties prenantes peuvent-elles examiner et approuver les plans avant l'exécution ?"
      },
      "q10": {
        "a": "Absolument. Les plans s'ouvrent dans un éditeur Monaco avec coloration syntaxique, formatage compatible diff et assistants de presse-papiers. Vous pouvez modifier l'invite, copier des étapes individuelles et relancer la génération sans quitter l'espace de travail.",
        "q": "Puis-je modifier les plans générés par l'IA avant l'exécution ?"
      },
      "q11": {
        "a": "Sélectionnez deux plans ou plus, rédigez les instructions de fusion et soumettez. Le résultat fusionné est enregistré à côté des originaux pour que vous puissiez comparer les brouillons, garder des notes ou relancer la fusion avec des instructions différentes.",
        "q": "Comment fonctionnent les instructions de fusion ?"
      },
      "q12": {
        "a": "Prompt previews, model allowlists, token estimates, and terminal health checks surface issues before any command runs. Every job stores its inputs and outputs for review.",
        "q": "Pourquoi les ingénieurs seniors utilisent-ils cela ?"
      },
      "q13": {
        "a": "Décrivez la tâche (en tapant ou à la voix) → exécutez le workflow de recherche de fichiers → générez un ou plusieurs plans de mise en œuvre → modifiez ou fusionnez les plans dans l'éditeur Monaco → lancez le terminal intégré pour exécuter le plan et surveiller les logs. Les sessions et les logs restent disponibles la prochaine fois que vous ouvrez l'application.",
        "q": "À quoi ressemble un workflow typique ?"
      },
      "q14": {
        "a": "Oui. Le repo est source-available sous la Business Source License, et les system prompts par defaut sont dans le repo et modifiables dans l'app.",
        "q": "Le code source et les system prompts sont-ils disponibles ?"
      },
      "q2": {
        "a": "Téléchargez des enregistrements de réunions Microsoft Teams ou des captures d'écran vers PlanToCode. Des modèles multimodaux avancés analysent à la fois les transcriptions audio (y compris l'identification des locuteurs) et le contenu visuel (écrans partagés, documents) pour extraire les exigences de spécification. Vous examinez les informations extraites - décisions, éléments d'action, points de discussion - et les incorporez dans les plans de mise en œuvre.",
        "q": "Comment les réunions Teams deviennent-elles des spécifications ?"
      },
      "q3": {
        "a": "Oui. Les plans de mise en œuvre décomposent les changements fichier par fichier avec des chemins de référentiel exacts correspondant à votre structure de projet. Cette approche granulaire garantit que vous savez exactement ce qui sera modifié avant l'exécution, offrant une visibilité et un contrôle complets.",
        "q": "Les plans correspondent-ils aux fichiers exacts de notre dépôt ?"
      },
      "q4": {
        "a": "PlanToCode est un espace de travail de planification de bureau. Vous exécutez le workflow de découverte de fichiers, examinez les plans de mise en œuvre dans un éditeur Monaco, ajustez les invites, puis lancez le terminal depuis la même session. Les outils de chat vous donnent une seule réponse ; ici, vous préparez le travail avant l'exécution.",
        "q": "En quoi est-ce différent des agents de codage basés sur le chat ?"
      },
      "q5": {
        "a": "Oui. L'application suppose que vous travaillez déjà dans de grands référentiels et que vous êtes à l'aise avec les terminaux, les graphes de dépendances et les compromis architecturaux. Le logiciel garde le contexte organisé pour que vous puissiez appliquer votre jugement plus rapidement.",
        "q": "Dois-je savoir coder ?"
      },
      "q6": {
        "a": "La configuration par défaut est livrée avec Gemini 3 Pro, GPT-5.2, Claude 4.5 Sonnet, o3, Grok 4, DeepSeek R1 et Kimi K2. Vous pouvez changer de modèle par tâche depuis le panneau des paramètres avant de soumettre un travail.",
        "q": "Quels modèles d'IA peuvent générer des plans ?"
      },
      "q7": {
        "a": "L'état du projet, les logs du terminal et les brouillons de plans sont stockés localement dans SQLite. Seule l'invite que vous approuvez plus les fichiers que vous sélectionnez sont envoyés via votre serveur proxy configuré. Le serveur Rust dans ce dépôt peut être auto-hébergé lorsque vous devez garder le trafic sur votre propre infrastructure.",
        "q": "Qu'arrive-t-il à mon code source ?"
      },
      "q8": {
        "a": "Each tab is a PTY session managed by the Rust backend. Output is streamed to the UI and stored in SQLite so you can review or resume later.",
        "q": "Quels outils CLI fonctionnent à l'intérieur du terminal ?"
      },
      "q9": {
        "a": "Lancez le workflow de recherche de fichiers pour générer des modèles de recherche, un scoring de pertinence et des listes de fichiers priorisées. Chaque étape s'exécute comme son propre travail en arrière-plan pour que vous puissiez inspecter les résultats avant d'appliquer les sélections à votre session.",
        "q": "Comment gère-t-il les grandes bases de code ?"
      }
    },
    "subtitle": "Tout ce que vous devez savoir sur PlanToCode",
    "title": "Questions fréquemment posées"
  },
  "features": {
    "cards": {
      "fileDiscovery": {
        "description": "Lancez des travaux en arrière-plan échelonnés pour la génération de modèles regex, le scoring de pertinence et la correction de chemin. Examinez chaque étape avant d'appliquer les résultats à votre session.",
        "title": "Workflow de découverte de fichiers"
      },
      "implementation": {
        "description": "Générez des plans de mise en œuvre fichier par fichier avec des chemins de référentiel exacts. Examinez, modifiez et approuvez les changements avant l'exécution pour prévenir les régressions et garantir l'alignement avec les exigences.",
        "title": "Plans de mise en œuvre examinés par des humains"
      },
      "integratedTerminal": {
        "description": "Lancez claude, cursor, codex ou gemini directement dans le terminal intégré. La surveillance de l'état, la récupération automatique et la gestion du redimensionnement maintiennent les travaux de longue durée stables.",
        "title": "Terminal PTY intégré avec détection CLI"
      },
      "meeting": {
        "description": "Téléchargez des réunions Microsoft Teams ou des enregistrements d'écran. L'analyse multimodale extrait les spécifications des transcriptions audio et du contenu visuel pour examen et incorporation.",
        "title": "Ingestion d'enregistrements de réunions"
      },
      "mergePlans": {
        "description": "Sélectionnez plusieurs plans, rédigez des instructions de fusion et gardez la sortie fusionnée à côté des originaux. Itérez jusqu'à ce que l'approche corresponde à vos normes.",
        "title": "Fusionner les plans avec des instructions"
      },
      "modelConfiguration": {
        "description": "Choisissez parmi Gemini 3 Pro, GPT-5.2, Claude 4.5 Sonnet, Grok 4, DeepSeek R1 et Kimi K2 pour les plans de mise en œuvre. Les paramètres persistent par projet.",
        "title": "Configuration du modèle par tâche"
      },
      "monacoEditor": {
        "description": "Les plans s'ouvrent dans un éditeur Monaco avec coloration syntaxique, formatage compatible diff et assistants de presse-papiers. Modifiez les étapes, stockez les brouillons et gardez les modèles prêts pour la prochaine tâche.",
        "title": "Éditeur de plan de mise en œuvre Monaco"
      },
      "persistentSessions": {
        "description": "La sortie du terminal est stockée dans un tampon circulaire de 5 Mo et les sessions de projet se rechargent au démarrage. Reprenez le travail en cours sans reconstruire le contexte.",
        "title": "Sessions et logs persistants"
      },
      "specification": {
        "description": "Dictée vocale pour saisie rapide, amélioration de texte pour la clarté et raffinement de tâche pour identifier les exigences implicites et les cas limites.",
        "title": "Capture et raffinement de spécifications"
      },
      "textImprovement": {
        "description": "Surlignez n'importe quelle sélection pour exécuter le travail d'amélioration de texte avec Claude 4.5 Sonnet ou Gemini 3 Flash. La réécriture préserve le formatage et s'applique dans les éditeurs Monaco, les entrées de tâches et la dictée du terminal.",
        "title": "Popover d'amélioration de texte"
      },
      "tokenGuardrails": {
        "description": "Visualisez l'invite exacte, les estimations de jetons et les avertissements de fenêtre de contexte avant de soumettre un travail. Ajustez les instructions avec une visibilité complète.",
        "title": "Garde-fous de jetons et aperçu d'invite"
      },
      "voiceTranscription": {
        "description": "Enregistrez des descriptions de tâches ou des commandes de terminal et envoyez-les via le service de transcription. Configurez les paramètres par défaut de langue et de température pour chaque projet.",
        "title": "Pipeline de transcription vocale"
      }
    },
    "linkText": "En savoir plus",
    "subtitle": "Conçu pour les développeurs s'attaquant à des bases de code volumineuses et héritées. Si vous utilisez Claude Code, Cursor ou Aider - c'est votre couche de planification.",
    "title": "Mécanismes"
  },
  "governance": {
    "cards": {
      "filePlans": {
        "description": "Les plans d'implementation decrivent les changements par fichier et operation pour clarifier le perimetre.",
        "title": "Plans fichier par fichier avec chemins exacts"
      },
      "handoff": {
        "description": "Les plans approuves sont transmis aux terminaux ou aux CLI d'agents avec tout le contexte et les journaux d'audit.",
        "title": "Transfert d'execution"
      },
      "workflow": {
        "description": "Plans modifiables sur desktop ou mobile; chaque revision est conservee.",
        "title": "Revoir, modifier, approuver"
      }
    },
    "subtitle": "Plans are artifacts you can review, edit, and approve before any agent runs. Logs and history keep changes traceable.",
    "title": "Revue de plan avant execution"
  },
  "hero": {
    "cta": {
      "viewDemo": "Telecharger PlanToCode",
      "howItWorks": "Voir le format du plan"
    }
  },
  "integrations": {
    "cards": {
      "allIntegrations": {
        "description": "Hebergez le serveur vous-meme pour controler le routage des providers et fournir vos propres keys.",
        "link": "Guide de configuration serveur ->",
        "title": "Self-hosting et BYOK"
      },
      "claudeCode": {
        "description": "Les prompts par defaut sont dans le repo et la base serveur pour inspection et edition.",
        "link": "Docs des types de prompts ->",
        "title": "System prompts consultables"
      },
      "cursor": {
        "description": "Le systeme complet est sur GitHub sous la Business Source License pour audit de l'architecture.",
        "link": "Voir le repo GitHub ->",
        "title": "Source available (BSL 1.1)"
      }
    },
    "subtitle": "System prompts, code source et self-hosting sont visibles et documentes.",
    "title": "Transparence et controle"
  },
  "meetings": {
    "cards": {
      "insights": {
        "description": "Les informations extraites - décisions résumées, éléments d'action et points de discussion clés - sont présentées dans une interface intuitive où les chefs d'équipe peuvent examiner, sélectionner et les incorporer dans des plans de mise en œuvre actionnables.",
        "link": "En savoir plus →",
        "title": "Examiner et incorporer les informations"
      },
      "multimodal": {
        "description": "Téléchargez des réunions Microsoft Teams ou des enregistrements d'écran. Des modèles multimodaux avancés analysent à la fois les transcriptions audio (avec identification des locuteurs) et le contenu visuel pertinent (écrans partagés, documents présentés, moments clés) pour extraire les exigences de spécification.",
        "link": "En savoir plus →",
        "title": "Analyse multimodale"
      }
    },
    "subtitle": "Transformez les réunions Microsoft Teams et les enregistrements d'écran en exigences de mise en œuvre actionnables.",
    "title": "Ingestion de réunions et d'enregistrements"
  },
  "pricing": {
    "card": {
      "description": "Commencez avec une tarification basée sur l'utilisation pour valider les résultats. Pas d'abonnements. Juste des coûts API transparents.",
      "pricing": {
        "description": "Testez l'éditeur de plan, les instructions de fusion, l'intégration du terminal. Rechargement automatique quand vous êtes convaincu.",
        "subtitle": "Payez uniquement ce que vous utilisez.",
        "title": "Tarification basée sur l'utilisation"
      },
      "title": "Tarification transparente"
    },
    "subtitle": "Payez uniquement pour l'inférence IA avec des coûts de jetons transparents. Surveillez votre ROI en temps réel - un incident de production évité paie des mois d'utilisation.",
    "title": "Conçu pour le développement professionnel"
  },
  "problems": {
    "cards": {
      "browseAll": {
        "description": "Explorez les workflows pour les refactorisations, les migrations, la réponse aux incidents et plus encore",
        "link": "Voir tous les workflows →",
        "title": "Parcourir tous les workflows"
      },
      "hardBugs": {
        "description": "Déboguez avec un contexte préservé, des étapes reproductibles et un historique d'enquête complet",
        "link": "En savoir plus →",
        "title": "Bugs de production difficiles"
      },
      "largeFeatures": {
        "description": "Planifiez des mises en œuvre complexes avec conscience architecturale et analyse d'impact",
        "link": "En savoir plus →",
        "title": "Grandes fonctionnalités"
      },
      "legacyRefactoring": {
        "description": "Modernisez les bases de code héritées avec une refactorisation assistée par IA qui préserve les fonctionnalités tout en améliorant la structure",
        "link": "En savoir plus →",
        "title": "Refactorisation de Code Hérité"
      },
      "libraryUpgrades": {
        "description": "Mettez à jour les dépendances en toute sécurité avec détection de changements de rupture et planification de migration",
        "link": "En savoir plus →",
        "title": "Mises à jour de bibliothèques"
      },
      "preventDuplicates": {
        "description": "Détectez et prévenez le code en double, les composants et les implémentations dans votre base de code",
        "link": "En savoir plus →",
        "title": "Prévenir les Fichiers Dupliqués"
      },
      "safeRefactoring": {
        "description": "Refactorisez en toute confiance grâce à la conscience architecturale et à une analyse d'impact complète",
        "link": "En savoir plus →",
        "title": "Refactorisation Sécurisée"
      }
    },
    "subtitle": "Des solutions réelles pour les problèmes les plus difficiles du développement logiciel",
    "title": "Résolvez les défis de développement complexes"
  },
  "gallery": {
    "heading": "Workflow de revue de plans dans l'app",
    "intro": "See how file discovery, multi-model planning, merge instructions, and execution handoff keep agent work transparent and traceable.",
    "video": {
      "title": "Apercu du workflow plan-first",
      "description": "Un court walkthrough de la saisie de tache a la revue de plan, aux merge instructions et a l'execution handoff.",
      "bullets": [
        "Lancer plusieurs brouillons avec le meme contexte de fichiers",
        "Fusionner les meilleures idees avec des instructions explicites",
        "Revoir et modifier les plans sur desktop ou mobile",
        "Transmettre a Claude Code ou a un terminal local avec logs"
      ]
    },
    "cards": {
      "fileFinder": {
        "title": "Pipeline de découverte de fichiers",
        "description": "Un workflow Rust en quatre étapes : sélection de racine assistée par LLM, filtrage regex, scoring de pertinence et recherche de chemins étendue pour construire un ensemble de fichiers ciblé.",
        "features": [
          "La sélection du dossier racine utilise l'arborescence et la description de la tâche",
          "Le filtre regex génère des groupes de motifs et applique git ls-files",
          "Le scoring de pertinence découpe le contenu des fichiers avec des estimations de tokens",
          "Le chercheur de chemins étendu élargit le contexte avec les données de fichiers et d'arborescence"
        ]
      },
      "fileFinderWorkflow": {
        "title": "Plan history and logs",
        "description": "Chaque étape du workflow écrit les résultats dans background_jobs pour que les ensembles de fichiers puissent être réutilisés entre les sessions et inspectés ultérieurement.",
        "features": [
          "Étapes du workflow stockées comme enregistrements de jobs",
          "Listes de fichiers sélectionnés persistées en réponses JSON",
          "Les included_files de session réutilisés entre les jobs",
          "L'historique SQLite survit aux redémarrages"
        ]
      },
      "videoAnalysis": {
        "title": "Optional screen recording analysis",
        "description": "Screen recordings can be sent to the /api/llm/video/analyze endpoint with a focus prompt and FPS hint to generate analysis summaries.",
        "features": [
          "Multipart upload includes durationMs and framerate",
          "Model format is provider/model (google/* required)",
          "Usage and cost recorded per job",
          "Summary stored in background_jobs response and can be applied to the task description"
        ]
      },
      "implementationPlans": {
        "title": "Génération de plans multi-modèles",
        "description": "ImplementationPlanProcessor diffuse des brouillons de plans à partir du contenu complet des fichiers ; les jobs de fusion consolident plusieurs brouillons en un seul plan.",
        "features": [
          "Les jobs de plan incluent le contenu des fichiers sélectionnés + l'arborescence",
          "Métadonnées de plan structurées capturées par job",
          "Le prompt de fusion utilise <source_plans> et <user_instructions>",
          "Le plan final est stocké avec les brouillons sources"
        ]
      },
      "backgroundTasks": {
        "title": "Surveillance des jobs en arrière-plan",
        "description": "Les processeurs de jobs Rust diffusent la progression et les transitions d'état vers l'interface tout en persistant l'historique des jobs dans SQLite.",
        "features": [
          "Created, queued, preparing, running, completed/failed/canceled",
          "Mises à jour en streaming via les événements Tauri",
          "Utilisation des tokens capturée par exécution",
          "Annuler les jobs de longue durée"
        ]
      },
      "settingsPrompts": {
        "title": "Configuration des prompts et modèles",
        "description": "Les paramètres de modèle runtime sont récupérés depuis `/api/config/desktop-runtime-config` ; les substitutions de prompts sont stockées dans SQLite.",
        "features": [
          "Modèles autorisés et valeurs par défaut par tâche",
          "Prompts système servis par l'API du serveur",
          "Substitutions de prompts au niveau projet dans project_system_prompts",
          "key_value_store local pour les préférences runtime"
        ]
      },
      "terminalVoiceRecording": {
        "title": "Boutons d'automatisation de workflow",
        "description": "Les boutons de copie insèrent des prompts basés sur des modèles avec le contexte de la tâche pour le transfert vers des terminaux ou des outils externes.",
        "features": [
          "Modèles provenant de la configuration du modèle de tâche",
          "Placeholders résolus contre le plan actif",
          "Transfert vers des sessions PTY ou le presse-papiers",
          "Actions liées aux métadonnées de job pour l'audit"
        ]
      },
      "mergeInstructionsWorkflow": {
        "title": "Instructions de fusion de plans",
        "description": "ImplementationPlanMergeProcessor fusionne plusieurs brouillons de plans en utilisant des plans sources balisés XML et des instructions optionnelles.",
        "features": [
          "Plans sources récupérés par ID de job",
          "Instructions de fusion stockées dans les métadonnées",
          "Le contenu des fichiers + l'arborescence ajoutent du contexte",
          "Le plan fusionné est stocké avec les entrées"
        ]
      },
      "billingTransactions": {
        "title": "Registre d'utilisation et de coûts",
        "description": "Les entrées d'utilisation côté serveur et les métadonnées de job capturent l'utilisation des modèles à travers les fournisseurs.",
        "features": [
          "Métadonnées de tokens et de coûts par job",
          "Entrées d'utilisation conscientes du fournisseur",
          "Les endpoints de facturation exposent des résumés d'utilisation",
          "Usage history for model spend"
        ]
      }
    },
    "viewFullSize": "Voir en taille réelle",
    "cta": {
      "title": "Pret a revoir les plans avant l'execution des agents ?",
      "description": "Telechargez l'app desktop pour tester la planification multi-modele, la fusion de plans et l'execution handoff.",
      "primary": "Telecharger PlanToCode",
      "secondary": "Voir le format du plan"
    }
  },
  "technicalLanding": {
    "title": "PlanToCode : Revoir et fusionner des plans d'implementation",
    "description": "PlanToCode transforme les taches en plans d'implementation structures que vous pouvez lire, comparer et modifier avant qu'un agent n'agisse. Generez plusieurs brouillons, fusionnez la meilleure approche et transferez vers Claude Code ou votre terminal avec tout le contexte.",
    "note": "L'hebergement utilise un acces modele gere; BYOK est disponible uniquement en self-hosting.",
    "noteLink": "Guide de self-hosting",
    "repo": {
      "title": "Code source sur GitHub",
      "description": "Ce site est la page d'accueil du dépôt PlanToCode. Consultez le code, la documentation et l'architecture ici.",
      "starsLabel": "étoiles GitHub",
      "licenseLabel": "BSL 1.1"
    },
    "walkthroughTitle": "Étape par étape : comment les composants fonctionnent ensemble",
    "walkthroughDescription": "Suivez une présentation complète de la façon dont l'application de bureau, le backend Rust/Tauri, la base de données SQLite et le pipeline d'orchestration LLM coordonnent les tâches et renvoient les résultats à l'interface.",
    "tags": [
      "Revue de plan",
      "Planification multi-modele",
      "Fusion de plans",
      "Lecteur de plans mobile",
      "Source available (BSL)"
    ]
  }
}
